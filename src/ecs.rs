#[derive(Clone, Copy)]
pub enum Endpoint {
    CnQingdao,
    CnBeijing,
    CnZhangjiakou,
    CnZhengzhouJva,
    CnHuhehaote,
    CnWulanchabu,
    CnHangzhou,
    CnShanghai,
    CnNanjing,
    CnFuzhou,
    CnShenzhen,
    CnHeyuan,
    CnGuangzhou,
    CnChengdu,
    CnWuhanLr,
    CnHongkong,
    ApNortheast1,
    ApNortheast2,
    ApSoutheast1,
    ApSoutheast2,
    ApSoutheast3,
    ApSoutheast5,
    ApSoutheast6,
    UsEast1,
    UsWest1,
    EuWest1,
    EuCentral1,
    ApSouth1,
    MeEast1,
    CnHangzhouFinance,
    CnShanghaiFinance1,
    CnShenzhenFinance1,
    ApSoutheast7,
    CnBeijingFinance1,
    MeCentral1,
    CnHeyuanAcdr1,
    NaSouth1,
    UsSoutheast1,
}

impl From<Endpoint> for &'static str {
    fn from(ep: Endpoint) -> Self {
        match ep {
            Endpoint::CnQingdao => "ecs.cn-qingdao.aliyuncs.com",
            Endpoint::CnBeijing => "ecs.cn-beijing.aliyuncs.com",
            Endpoint::CnZhangjiakou => "ecs.cn-zhangjiakou.aliyuncs.com",
            Endpoint::CnZhengzhouJva => "ecs.cn-zhengzhou-jva.aliyuncs.com",
            Endpoint::CnHuhehaote => "ecs.cn-huhehaote.aliyuncs.com",
            Endpoint::CnWulanchabu => "ecs.cn-wulanchabu.aliyuncs.com",
            Endpoint::CnHangzhou => "ecs.cn-hangzhou.aliyuncs.com",
            Endpoint::CnShanghai => "ecs.cn-shanghai.aliyuncs.com",
            Endpoint::CnNanjing => "ecs.cn-nanjing.aliyuncs.com",
            Endpoint::CnFuzhou => "ecs.cn-fuzhou.aliyuncs.com",
            Endpoint::CnShenzhen => "ecs.cn-shenzhen.aliyuncs.com",
            Endpoint::CnHeyuan => "ecs.cn-heyuan.aliyuncs.com",
            Endpoint::CnGuangzhou => "ecs.cn-guangzhou.aliyuncs.com",
            Endpoint::CnChengdu => "ecs.cn-chengdu.aliyuncs.com",
            Endpoint::CnWuhanLr => "ecs.cn-wuhan-lr.aliyuncs.com",
            Endpoint::CnHongkong => "ecs.cn-hongkong.aliyuncs.com",
            Endpoint::ApNortheast1 => "ecs.ap-northeast-1.aliyuncs.com",
            Endpoint::ApNortheast2 => "ecs.ap-northeast-2.aliyuncs.com",
            Endpoint::ApSoutheast1 => "ecs.ap-southeast-1.aliyuncs.com",
            Endpoint::ApSoutheast2 => "ecs.ap-southeast-2.aliyuncs.com",
            Endpoint::ApSoutheast3 => "ecs.ap-southeast-3.aliyuncs.com",
            Endpoint::ApSoutheast5 => "ecs.ap-southeast-5.aliyuncs.com",
            Endpoint::ApSoutheast6 => "ecs.ap-southeast-6.aliyuncs.com",
            Endpoint::UsEast1 => "ecs.us-east-1.aliyuncs.com",
            Endpoint::UsWest1 => "ecs.us-west-1.aliyuncs.com",
            Endpoint::EuWest1 => "ecs.eu-west-1.aliyuncs.com",
            Endpoint::EuCentral1 => "ecs.eu-central-1.aliyuncs.com",
            Endpoint::ApSouth1 => "ecs.ap-south-1.aliyuncs.com",
            Endpoint::MeEast1 => "ecs.me-east-1.aliyuncs.com",
            Endpoint::CnHangzhouFinance => "ecs.aliyuncs.com",
            Endpoint::CnShanghaiFinance1 => "ecs.cn-shanghai-finance-1.aliyuncs.com",
            Endpoint::CnShenzhenFinance1 => "ecs-cn-hangzhou.aliyuncs.com",
            Endpoint::ApSoutheast7 => "ecs.ap-southeast-7.aliyuncs.com",
            Endpoint::CnBeijingFinance1 => "ecs.cn-beijing-finance-1.aliyuncs.com",
            Endpoint::MeCentral1 => "ecs.me-central-1.aliyuncs.com",
            Endpoint::CnHeyuanAcdr1 => "ecs.cn-heyuan-acdr-1.aliyuncs.com",
            Endpoint::NaSouth1 => "ecs.na-south-1.aliyuncs.com",
            Endpoint::UsSoutheast1 => "ecs.us-southeast-1.aliyuncs.com",
        }
    }
}

mod sealed {
    /// prevent Request type used with Connection of other mod.
    pub trait Bound {}
}

#[derive(Clone)]
pub struct Connection(crate::common::Connection);

impl Connection {
    pub fn new(endpoint: Endpoint, app_key_secret: crate::v3::AccessKeySecret) -> Self {
        Self(crate::common::Connection::new(
            app_key_secret,
            "2014-05-26",
            endpoint.into(),
        ))
    }

    pub fn with_client(
        endpoint: Endpoint,
        app_key_secret: crate::v3::AccessKeySecret,
        client: reqwest::Client,
    ) -> Self {
        Self(crate::common::Connection::with_client(
            app_key_secret,
            "2014-05-26",
            endpoint.into(),
            client,
        ))
    }

    fn call<R: crate::Request + sealed::Bound>(
        &self,
        req: R,
    ) -> impl std::future::Future<
        Output = crate::Result<<R::ResponseWrap as crate::IntoResponse>::Response>,
    > + Send {
        self.0.call(req)
    }

    /// # 查询地域列表
    ///
    /// 根据计费方式、资源类型等参数查询地域信息列表。
    ///
    /// # Error Codes
    /// - `Unauthorized.EmptyRegion`: The specified account has no access authority to any region.
    /// - `Invalid.InstanceChargeType`: The specified instanceChargeType is not valid.
    /// - `InvalidAcceptLanguage.NotFound`: Only Chinese (zh-CN), English (en-US), and Japanese (ja) are allowed.
    /// - `InvalidResourceType.NotFound`: The ResourceType provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_regions(
        &self,
        req: DescribeRegions,
    ) -> impl std::future::Future<Output = crate::Result<DescribeRegionsResponse>> + Send {
        self.call(req)
    }

    /// # 查询可用区列表
    ///
    /// 根据地域ID、计费方式等参数查询可用区信息列表。
    ///
    /// ## 接口说明
    ///
    /// DescribeZones仅查询阿里云提供的可用区列表并返回少量库存信息。如果您需要查询具体可用区下可购买的实例规格和云盘规格，推荐您使用[DescribeAvailableResource](~~66186~~)。
    ///
    /// # Error Codes
    /// - `InvalidSpotStrategy`: The specified SpotStrategy is not valid.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidRegion.NotFound`: The specified parameter RegionId is not valid.
    /// - `InvalidInstanceChargeType.NotFound`: The InstanceChargeType does not exist in our records.
    /// - `InvalidAcceptLanguage.NotFound`: Only Chinese (zh-CN), English (en-US), and Japanese (ja) are allowed.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_zones(
        &self,
        req: DescribeZones,
    ) -> impl std::future::Future<Output = crate::Result<DescribeZonesResponse>> + Send {
        self.call(req)
    }

    /// # 查询可用区的资源库存
    ///
    /// 查询指定可用区的资源库存状态。该接口主要用于在创建实例（RunInstances）或修改实例规格（ModifyInstanceSpec）前，确认目标资源（如实例规格、系统盘类型）在特定可用区是否库存充足。
    ///
    /// 参数`DestinationResource`的取值有不同的逻辑与要求。在下列的顺序列表中，顺序越低的取值需要设置更多的参数，不支持通过低顺序的取值筛选高顺序的资源类别。
    ///
    /// - 取值顺序：`Zone > IoOptimized > InstanceType = Network = ddh > SystemDisk > DataDisk`
    ///
    /// - 取值示例：
    ///
    ///     - 若参数`DestinationResource`取值为`DataDisk`：
    ///
    ///          - `ResourceType`取值为`disk`表示查询与ECS实例规格无关的数据盘类型，可以不传入参数`InstanceType`。
    ///
    ///         - `ResourceType`取值为`instance`表示查询待挂载至ECS实例的数据盘类型，由于实例规格对数据盘有限制，所以需要同时指定`InstanceType`与参数`DataDiskCategory	`。
    ///
    ///     - 若参数`DestinationResource`取值为`SystemDisk`，`ResourceType`取值为`instance`，由于ECS实例规格对系统盘存在限制，则必须要传入参数`InstanceType`。
    ///
    ///     - 若参数`DestinationResource`取值为`InstanceType`，建议传入参数`IoOptimized`和`InstanceType`。
    ///
    ///     - 查询指定地域下所有可用区的ecs.g5.large库存供应情况：`RegionId=cn-hangzhou &DestinationResource=InstanceType &IoOptimized=optimized &InstanceType=ecs.g5.large`。
    ///
    ///     - 查询指定地域下有ecs.g5.large库存供应的可用区列表：`RegionId=cn-hangzhou &DestinationResource=Zone &IoOptimized=optimized &InstanceType=ecs.g5.large`。
    ///
    /// <details>
    /// <summary>查询杭州地域供应实例规格为ecs.g5.large的可用区列表。</summary>
    ///
    /// ```ignore
    /// "RegionId": "cn-hangzhou",
    /// "DestinationResource": "Zone"，
    /// "InstanceType": "ecs.g5.large"
    /// ```
    /// </details>
    ///
    /// <details>
    /// <summary>查询杭州地域、所有可用区下的实例类型为ecs.g5.large的库存。</summary>
    ///
    /// ```ignore
    /// "RegionId": "cn-hangzhou",
    /// "DestinationResource": "InstanceType"，
    /// "InstanceType": "ecs.g5.large"
    /// ```
    /// </details>
    ///
    /// <details>
    /// <summary>【只购买数据盘】查询杭州地域、可用区b下的数据盘类型为cloud_efficiency的库存。</summary>
    ///
    /// ```ignore
    /// "RegionId": "cn-hangzhou",
    /// "ZoneId": "cn-hangzhou-b",
    /// "ResourceType": "disk",
    /// "DestinationResource": "DataDisk"
    /// ```
    /// </details>
    ///
    /// <details>
    /// <summary>【购买ECS实例和系统盘】查询杭州地域、可用区b下的实例类型为ecs.g7.large、系统盘类型为cloud_essd的库存。</summary>
    ///
    /// ```ignore
    /// "RegionId": "cn-hangzhou",
    /// "ZoneId": "cn-hangzhou-b",
    /// "ResourceType": "instance",
    /// "InstanceType": "ecs.g7.large",
    /// "DestinationResource": "SystemDisk",
    /// "SystemDiskCategory": "cloud_essd"
    /// ```
    /// </details>
    ///
    /// # Error Codes
    /// - `Invalid.InstanceChargeType`: The specified InstanceChargeType is not valid.
    /// - `Invalid.Param`: The input parameter DestinationResource that is mandatory for processing this request is not supplied.
    /// - `InvalidRegionId.MalFormed`: The specified parameter RegionId is not valid.
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist.
    /// - `InvalidParam.TypeAndCpuMem.Conflict`: The specified 'InstanceType' and 'Cores','Memory' are not blank at the same time.
    /// - `InvalidParam.Cores`: The specified parameter 'Cores' should be empty.
    /// - `InvalidParam.Memory`: The specified parameter 'Memory' should be empty.
    /// - `InvalidParameter.Scope`: The specified parameter Scope is invalid.
    /// - `OperationDenied.RegionIdNotSupported`: The region does not support preemptible instances.
    /// - `OperationDenied.FlavorNotSupported`: The flavor does not support preemptible instances.
    /// - `OperationDenied.TimestampNotSupported`: Preemptible instances are not for sale for current time.
    /// - `InvalidParameter.ResourceOwnerId`: The specified parameter ResourceOwnerId is not available anymore.
    /// - `Invalid.RegionId`: The specified RegionId does not exist.
    /// - `Unavailable.Regions`: The available region does not exist.
    /// - `Invalid.ResourceType`: The ResourceType provided does not exist in our records.
    /// - `Invalid.DestinationResource`: The specified DestinationResource is not valid.
    /// - `Invalid.IoOptimized`: The specified IoOptimized is not valid.
    /// - `Invalid.NetworkCategory`: The specified NetworkCategory is not valid.
    /// - `Invalid.SpotStrategy`: The specified SpotStrategy is not valid.
    /// - `Invalid.NetworkType`: The specified NetworkType is not valid.
    /// - `InvalidResourceId.NotFound`: The specified ResourceId is not found in our records.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidDedicatedHostId.NotFound`: The specified Dedicated Host does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_available_resource(
        &self,
        req: DescribeAvailableResource,
    ) -> impl std::future::Future<Output = crate::Result<DescribeAvailableResourceResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询资源配额
    ///
    /// 查询您在一个阿里云地域下能创建的ECS资源配额。包括您能创建的安全组数量、弹性网卡数量、按量付费vCPU核数、抢占式实例vCPU核数、按量付费云盘总容量配额、专用宿主机数量、网络类型以及账号是否已完成实名认证。
    ///
    /// <props="china">[注册](https://account.aliyun.com/register/register.htm)了阿里云账号后，您可以在不同的阿里云地域中创建一定数量的ECS资源，更多信息，请参见[使用限制](~~25412~~)。</props>
    ///
    /// <props="intl">[注册](https://account.alibabacloud.com/register/intl_register.htm)了阿里云账号后，您可以在不同的阿里云地域中创建一定数量的ECS资源，更多信息，请参见[使用限制](~~25412~~)。</props>
    ///
    /// 您也可以根据自己的需求，在[配额中心](https://quotas.console.aliyun.com/products)申请提高资源使用配额。
    ///
    /// # Error Codes
    /// - `Invalid.Parameter`: The required parameter regionId must be not null.
    /// - `InternalError`: The process of creating snapshot has failed due to some unknown error.
    /// - `ServiceUnavailable`: The service is unavailable, please try again later.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_account_attributes(
        &self,
        req: DescribeAccountAttributes,
    ) -> impl std::future::Future<Output = crate::Result<DescribeAccountAttributesResponse>> + Send
    {
        self.call(req)
    }

    /// # 变更实例规格或系统盘类型之前，查询某一可用区下实例规格或系统盘的库存情况
    ///
    /// 变更实例规格或系统盘类型之前，查询某一可用区下实例规格或系统盘的库存情况。
    ///
    /// 常见变更场景示例如下：
    /// ### 示例1：查询当前实例支持变配的规格
    /// 查询实例i-bp67acfmxazb4p****支持变配到的规格，以及相应规格在实例所属可用区下的库存情况。
    /// ```ignore
    /// http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
    /// &RegionId=cn-hangzhou
    /// &ResourceId=i-bp67acfmxazb4p****
    /// &DestinationResource=InstanceType
    /// &OperationType=Upgrade
    /// &公共请求参数
    /// ```
    /// ### 示例2：查询当前实例变更云盘类型后支持变配到的规格
    /// 查询实例i-bp67acfmxazb4p****变更云盘类型后，可以变配到的规格，以及相应规格在实例所属可用区下的库存情况。
    /// ```ignore
    /// http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
    /// &RegionId=cn-hangzhou
    /// &ResourceId=i-bp67acfmxazb4p****
    /// &DestinationResource=InstanceType
    /// &OperationType=Upgrade
    /// &Conditions.0=DiskCategory
    /// &公共请求参数
    /// ```
    ///
    /// ### 示例3：查询目标规格要求的云盘类型
    /// 查询目标规格（例如ecs.g7.large）要求的云盘类型（即当前实例i-bp67acfmxazb4p****变更到该云盘类型后才支持变配到目标规格），以及云盘类型在实例所属可用区下的库存情况。
    /// > 目标规格需通过示例2查询。
    /// ```ignore
    /// http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
    /// &RegionId=cn-hangzhou
    /// &ResourceId=i-bp67acfmxazb4p****
    /// &DestinationResource=SystemDisk
    /// &OperationType=Upgrade
    /// &InstanceType=ecs.g7.large
    /// &公共请求参数
    /// ```
    ///
    /// # Error Codes
    /// - `Invalid.OperationType`: The specified operationType is not valid.
    /// - `Invalid.Param`: The input parameter DestinationResource that is mandatory for processing this request is not supplied.
    /// - `Invalid.InstanceChargeType`: The specified InstanceChargeType is not valid.
    /// - `InvalidCondition.Malformed`: The specified Condition is not valid.
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist in our records.
    /// - `InvalidParam.TypeAndCpuMem.Conflict`: The specified 'InstanceType' and 'Cores','Memory' are not blank at the same time.
    /// - `InvalidParam.Cores`: The specified parameter 'Cores' should be empty.
    /// - `InvalidParam.Memory`: The specified parameter 'Memory' should be empty.
    /// - `InvalidParameter.ResourceOwnerId`: The specified parameter ResourceOwnerId is not available anymore.
    /// - `Invalid.RegionId`: The specified RegionId does not exist.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `Unavailable.Regions`: The available regions does not exists.
    /// - `Invalid.ResourceType`: The ResourceType provided does not exist in our records.
    /// - `Invalid.DestinationResource`: The specified DestinationResource is not valid.
    /// - `Invalid.IoOptimized`: The specified IoOptimized is not valid.
    /// - `Invalid.NetworkCategory`: The specified NetworkCategory is not valid.
    /// - `Invalid.SpotStrategy`: The specified SpotStrategy is not valid.
    /// - `Invalid.ResourceId`: The specified ResourceId is not valid.
    /// - `Invalid.InstancePayType`: The specified InstancePayType is not valid.
    /// - `Invalid.OperationType`: The specified OperationType is not valid.
    /// - `OperationDenied`: The specified operation is denied as this instanceType is not support.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId provided does not exist in our records.
    /// - `InvalidResourceId.NotFound`: The specified ResourceId is not found in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_resources_modification(
        &self,
        req: DescribeResourcesModification,
    ) -> impl std::future::Future<Output = crate::Result<DescribeResourcesModificationResponse>> + Send
    {
        self.call(req)
    }

    /// # 查找备选实例规格
    ///
    /// （Beta）调用DescribeRecommendInstanceType根据一个指定的实例规格，查找一个或多个备选的实例规格。针对已经或者即将停售的实例规格，DescribeRecommendInstanceType会罗列出作为替补的所有实例规格。
    ///
    /// # Error Codes
    /// - `RecommendEmpty.InstanceTypeNotAuthorized`: The recommend instanceTypes are not authorized.
    /// - `RecommendEmpty.InstanceTypeSoldOut`: The recommend instanceTypes are out of usage.
    /// - `RecommendEmpty.DiskCategoryNotRecommended`: The specified disk category is not available for recommended.
    /// - `InvalidNetworkType.ValueNotSupported`: The specified parameter NetworkType is not valid.
    /// - `InvalidSpotStrategy.ValueNotSupported`: The specified parameter SpotStrategy is not valid.
    /// - `InvalidInstanceChargeType.NotFound`: The specified parameter InstanceChargeType is not valid.
    /// - `InvalidPriorityStrategy.ValueNotSupported`: The specified parameter PriorityStrategy is not supported.
    /// - `InvalidParam.TypeAndCpuMem.Conflict`: The specified parameters InstanceType and Cores,Memory should not be blank at the same time.
    /// - `InvalidIoOptimized.NotFound`: The specified parameter IoOptimized is not valid.
    /// - `InvalidRegionId.MalFormed`: The specified parameter RegionId is not valid.
    /// - `InvalidDiskCategory.NotFound`: The specified parameter SystemDiskCategory is not supported.
    /// - `InvalidInstanceTypeFamily.NotFound`: The specified InstanceTypeFamily is not valid.
    /// - `InvalidMaxPrice.NotSupported`: The specified MaxPrice is not valid.
    /// - `InvalidZoneId.MalFormed`: The specified ZoneId is not valid when Cores and Memory is not null.
    /// - `InvalidInstanceType.NotSupported`: The specified InstanceType is not valid.
    /// - `InvalidZoneId.ValueNotSupported`: The specified ZoneId is not valid.
    /// - `InvalidCoreAndMemory.ValueNotSupported`: The specified Cores/Memory does not match instance type.
    /// - `QuotaExceed.AfterpayInstance`: Living afterpay instances quota exceeded.
    /// - `RecommendEmpty.PerformanceNotSatisfied`: The performance of recommend instanceType is not satisfied.
    /// - `RecommendEmpty.PriceNotSatisfied`: The current price of recommend instanceTypes above user max price.
    /// - `RecommendEmpty.QuotaNotSatisfied`: The quota of recommend instanceTypes are out of usage.
    /// - `RecommendEmpty.IzNotMatched`: The iz of recommend instanceTypes are not match.
    /// - `RecommendEmpty.InstanceTypeNotMatched`: The recommend instanceTypes are not match.
    /// - `InvalidScene.ValueNotSupported`: The specified Scene is invalid.
    /// - `RecommendEmpty.InstanceTypeFamilyNotMatched`: The recommend instanceTypeFamily are not match.
    /// - `RecommendEmpty.GenerationNotMatch`: The recommend instanceType generation are not match.
    /// - `RecommendEmpty.NetworkTypeNotSupported`: The recommend instanceType networkType are not match.
    /// - `InvalidInstanceFamilyLevel.NotSupported`: The specified InstanceFamilyLevel is not valid.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_recommend_instance_type(
        &self,
        req: DescribeRecommendInstanceType,
    ) -> impl std::future::Future<Output = crate::Result<DescribeRecommendInstanceTypeResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询价格
    ///
    /// 本接口用于查询指定资源的最新价格，支持根据资源类型查询ECS实例、云盘、专有宿主机、弹性保障服务、容量预定服务的最新价格，包括活动规则、价格、折扣等信息。
    ///
    /// 查询不同类型资源的价格时，参数设置也有所不同：
    ///   - `ResourceType=instance`时，必须同时指定参数`InstanceType`。
    ///     默认查询付费方式（`ChargeType`）为按量付费（`PostPaid`）的价格，您可以通过指定`PriceUnit`参数查询云服务器ECS不同计费周期的价格。
    ///  - `ResourceType=disk`时，必须同时指定参数`DataDisk.1.Category`和`DataDisk.1.Size`。查询`disk`资源的价格时，只返回云盘按量付费的价格，即参数`PriceUnit`只能取值为`Hour`。
    /// - `ResourceType=diskperformance`时，必须同时指定参数`DataDisk.1.Category`和`DataDisk.1.ProvisionedIops`。
    ///  - `ResourceType=ddh`时，您必须同时指定参数`DedicatedHostType`。
    ///  - `ResourceType=ElasticityAssurance`时，必须同时指定参数`InstanceType`。
    ///  - `ResourceType=CapacityReservation`时，必须同时指定参数`InstanceType`。
    /// - `ResourceType=bandwidth`时，只返回按流量计费（`PayByTraffic`）的价格。
    ///
    /// # Error Codes
    /// - `InvalidParameter.RecurrenceRules`: The specified parameter RecurrenceRules is invalid.
    /// - `InvalidRecurrenceRules.CountLimitExceeded`: The count of RecurrenceRules exceeds the limit.
    /// - `InvalidRecurrenceRulesStartHourEndHour.TooShort`: The recurrence hour between RecurrenceRules.StartHour and RecurrenceRules.EndHour is too short.
    /// - `InvalidParameter.RecurrenceRulesStartHourEndHour`: The specified parameter RecurrenceRules.StartHour or RecurrenceRules.EndHour is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceValueMonthly`: The specified parameter RecurrenceRules.RecurrenceValue for Monthly is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceValueWeekly`: The specified parameter RecurrenceRules.RecurrenceValue for Weekly is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceValueDaily`: The specified parameter RecurrenceRules.RecurrenceValue for Daily is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceType`: The specified parameter RecurrenceRules.RecurrenceType is invalid.
    /// - `InvalidStartTime.NotSupported`: The StartTime of TimeDivisionElasticityAssurance cannot between any of active time ranges.
    /// - `InvalidSpotAuthorized`: The specified Spot param is unauthorized.
    /// - `Invalid.ZoneId`: The specified ZoneId is not valid.
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType is not authorized.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidInternetChargeType.ValueNotSupported`: The specified InternetChargeType is not valid.
    /// - `InvalidInternetMaxBandwidthOut.ValueNotSupported`: The specified parameter "InternetMaxBandwidthOut" is not valid.
    /// - `AccountForbidden.ProductCreationLimited`: The commodity must be officially operated by Aliyun and in pay-as-you-go billing method.
    /// - `InvalidSystemDiskCategory.ValueNotSupported`: The specified parameter "SystemDisk.Category" is not valid.
    /// - `InvalidDataDiskSize.ValueNotSupported`: The specified DataDisk.n.Size beyond the permitted range, or the capacity of snapshot exceeds the size limit of the specified disk category.
    /// - `InvalidDataDiskCategory.ValueNotSupported`: The specified parameter "DataDisk.n.Category" is not valid.
    /// - `InvalidParameter.Conflict`: The specified image does not support the specified instance type.
    /// - `InvalidNetworkType.Mismatch`: Specified parameter "InternetChargeType" conflict with instance network type.
    /// - `InvalidDiskCategory.Mismatch`: The specified disk categories' combination is not supported.
    /// - `InvalidIoOptimizedValue.ValueNotSupported`: IoOptimized value not supported.
    /// - `InvalidPeriod`: The specified period is not valid.
    /// - `InstanceDiskCategoryLimitExceed`: The specified DataDisk.n.Size beyond the permitted range, or the capacity of snapshot exceeds the size limit of the specified disk category.
    /// - `InstanceDiskNumber.LimitExceed`: The total number of specified disk in an instance exceeds.
    /// - `InvalidSystemDiskSize.LessThanImageSize`: The specified parameter "SystemDisk.Size" is less than the image size.
    /// - `Throttling`: Request was denied due to request throttling.
    /// - `Throttling.User`: Request was denied due to user flow control.
    /// - `PriceNotFound`: The price of your queried resource is not available now, please try other resources.
    /// - `InvalidResourceType.ValueNotSupported`: The specified parameter ResourceType is not valid.
    /// - `InvalidPriceUnit.ValueNotSupported`: The specified parameter PriceUnit is not valid.
    /// - `IncorrectImageStatus`: The specified image is an Alibaba Cloud Marketplace image. The sale of this image has ended. For more information, contact the image service provider.
    /// - `OperationDenied`: The current operation is not supported due to unfinished Temporary Upgrade.
    /// - `InvalidPerformanceLevel.Malformed`: The specified parameter DataDisk.n.PerformanceLevel is not valid.
    /// - `InvalidCapacity.ValueNotSupported`: The specified parameter Capacity is not valid.
    /// - `InvalidActivity.NotSupported`: The specified discount activity is not supported.
    /// - `InvalidEncrypted.NotMatchEncryptAlgorithm`: The specified parameter Encrypted must be true when EncryptAlgorithm is not empty.
    /// - `InvalidEncrypted.NotMatchKmsKeyId`: The specified parameter Encrypted must be true when KmsKeyId is not empty.
    /// - `InvalidEncrypted.NotMatchSnapshot`: The specified parameter Encrypted is different from the Encrypted of the snapshot.
    /// - `InvalidEncryptAlgorithm.NotMatchSnapshot`: The specified parameter EncryptAlgorithm is different from the encrypt algorithm of the snapshot.
    /// - `InvalidKmsKeyId.NotMatchSnapshot`: The specified parameter KmsKeyId is different from the KmsKeyId of the snapshot.
    /// - `InvalidEncryptAlgorithm`: The specified parameter EncryptAlgorithm is not valid.
    /// - `InvalidAssuranceTimes.NotSupported`: The value of AssuranceTimes is not supported.
    /// - `InvalidParameter.Platform`: The specified parameter Platform is invalid.
    /// - `InvalidOperation.InstanceRenewWithDowngradeInPlan`: The operation is denied due to the specified instance has renew with downgrade record in plan.
    /// - `OperationDenied.TestAccountRetricted`: Test-account for testing has been prohibited from creating instance in this region. Please contact 400181.
    /// - `UnsupportedIspNetworkChargeType`: The network charge type is not supported when specifying ISP.
    /// - `EncryptedOption.Conflict`: Disk encryption attributes conflict.
    /// - `InvalidSystemDiskSize.ValueNotSupported`: The specified parameter SystemDisk.Size is invalid
    /// - `UnsupportedIspChargeType`: The specified Isp does not support the charge type.
    /// - `InvalidInstanceType.NotSupported`: The specified instanceType is not supported by the image architecture.
    /// - `InvalidDiskCategory.ValueNotSupported`: The specified parameter "DiskCategory" is not valid.
    /// - `InvalidMarketImage.NotAuthorized`: The specified marketplace image is not authorized for your channel, please use other image.
    /// - `ImageNotSubscribed`: The specified image has not be subscribed.
    /// - `OperationDenied`: The specified Image is disabled or is deleted.
    /// - `InvalidSystemDiskCategory.ValueUnauthorized`: The disk category is not authorized.
    /// - `InstanceDiskCategoryLimitExceed`: The total size of specified disk category in an instance exceeds.
    /// - `ImageRemovedInMarket`: The specified market image is not available, Or the specified user defined image includes product code because it is based on an image subscribed from marketplace, and that image in marketplace includeing exact the same product code has been removed.
    /// - `QuotaExceed.PortableCloudDisk`: The quota of portable cloud disk exceeds.
    /// - `Forbbiden`: User not authorized to operate on the specified resource.
    /// - `InstanceDiskNumLimitExceed`: The number of specified disk in an instance exceeds.
    /// - `IoOptimized.NotSupported`: The specified image is not support IoOptimized Instance.
    /// - `ImageNotSupportInstanceType`: The specified image don't support the InstanceType instance.
    /// - `InvalidDiskSize.TooSmall`: Specified disk size is less than the size of snapshot.
    /// - `InvalidDiskCategory.Mismatch`: The specified disk categories combination is not supported.
    /// - `InvalidDiskCategory.NotSupported`: The specified disk category is not support the specified instance type.
    /// - `QuotaExceed.BuyImage`: The specified image is from the image market, you have not bought it or your quota has been exceeded.
    /// - `InvalidParameter.ResourceOwnerAccount`: ResourceOwnerAccount is Invalid.
    /// - `RegionUnauthorized`: There is no authority to create instance in the specified region.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidAmount.Malformed`: The specified parameter Amount is not valid.
    /// - `InvalidChargeType.MarketImage`: The specified chargeType of marketplace image is invalid.
    /// - `InvalidDiskIds.NotFound`: Some of the specified disks do not exist.
    /// - `PrePaidInstance.Expired`: The prePaid instance has expired.
    /// - `OperationDenied.PerformanceLevelNotMatch`: The specified DataDisk.n.PerformanceLevel and DataDisk.n.Size do not match.
    /// - `InvalidAction.Unauthorized`: The specified action is not valid.
    /// - `InvalidRegionId.NotSupportEncryptAlgorithm`: The current region does not support creating encrypted disks with EncryptAlgorithm.
    /// - `InvalidInstanceType.NotSupportDiskCategory`: The instanceType of the specified instance does not support this disk category.
    /// - `InvalidOperation.PublicIpAddressNoStock`: The public IP address for the specified Region or ChargeType of the instance is out of stock. Please try another Region or ChargeType.
    /// - `UnsupportedIspRegion`: The specified region does not support Isp.
    /// - `InvalidIspBandwidthOut`: The specified parameter InternetMaxBandwidthOut should  be larger than 0 when specifying parameter Isp.
    /// - `InstanceType.Offline`: The specified InstanceType has been offline
    /// - `InvalidIspUID`: The current account does not have permission to specify the Isp parameter.
    /// - `UnsupportedIspClassicNetwork`: The Isp parameter is not supported in the classic network.
    /// - `InvalidIspType.ValueNotSupported`: The specified parameter Isp is invalid.
    /// - `InvalidSystemDiskCategory.ValueNotSupported`: The specified parameter  SystemDisk.Category is not valid.
    /// - `InvalidDataDiskCategory.ValueNotSupported`: The specified Category of Data Disk is not valid.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `OperationDenied`: The specified Image is disabled or is deleted.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.
    /// - `IoOptimized.NotSupported`: The specified instancetype is not support IoOptimized instance.
    /// - `InvalidInstanceChargeType.NotFound`: The InstanceChargeType does not exist in our records.
    /// - `DependencyViolation.IoOptimized`: The specified instancetype must be IoOptimized instance.
    /// - `InvalidSystemDiskSize.LessThanImageSize`: The specified parameter SystemDisk.Size is less than the image size.
    /// - `InvalidSystemDiskSize.LessThanMinSize`: The specified parameter SystemDisk.Size is less than the minimum size.
    /// - `InvalidSystemDiskSize.MoreThanMaxSize`: The specified parameter SystemDisk.Size is more than the maximum size.
    /// - `InvalidInternetMaxBandwidthOut.ValueNotSupported`: The specified vm bandwidth is not valid.
    /// - `InvalidSystemDiskSize.ValueNotSupported`: The specified parameter SystemDisk.Size is invalid.
    /// - `InvalidInstanceType.Missing`: The InstanceType parameter that is mandatory for processing the request is not provided.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidNetworkType.ValueNotSupported`: The specified parameter NetworkType is not valid.
    /// - `InvalidDiskCategory.Missing`: The DataDisk.1.Category parameter that is mandatory for processing the request is not provided.
    /// - `Invalid.InstanceId.NotFound`: The Instance provided does not exist.
    /// - `InvalidMarketImage.NotFound`: The specified marketplace image does not exist, please change the imageId and try again.
    /// - `InvalidDiskIds.NotPortable`: The specified DiskId is not portable.
    /// - `InvalidSystemDisk.NotFound`: The specified system disk does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InvalidDedicatedHostType.Missing`: The dedicatedHostType parameter that is mandatory for processing the request is not provided.
    /// - `InvalidDedicatedHostId.NotFound`: The specified SchedulerOptions.DedicatedHostId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_price(
        &self,
        req: DescribePrice,
    ) -> impl std::future::Future<Output = crate::Result<DescribePriceResponse>> + Send {
        self.call(req)
    }

    /// # 查询资源续费价格
    ///
    /// 查询云服务器ECS资源的续费价格。仅支持查询包年包月资源的续费价格。
    ///
    /// - 仅支持查询包年包月ECS实例续费时长的价格或者续费至统一到期日的价格。
    /// - 参数设置的注意事项如下：
    ///     - 只设置必选参数时，默认查询实例续费时长1个月的价格信息。
    ///     - 不支持同时查询续费时长价格和续费至统一到期日的价格，即续费时长参数（`Period`、`PeriodUnit`）与续费至统一到期日参数（`ExpectedRenewDay`）不能同时设置。
    ///
    /// # Error Codes
    /// - `InvalidResourceType.ValueNotSupported`: The specified parameter ResourceType is not valid.
    /// - `InvalidPeriod`: The specified period is not valid.
    /// - `InvalidPriceUnit.ValueNotSupported`: The specified parameter PriceUnit is not valid.
    /// - `Throttling`: Request was denied due to request throttling.
    /// - `Throttling.User`: Request was denied due to user flow control.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `InvalidPeriod.ExceededMaximumExpirationDate`: The specified renewal period cannot exceed the maximum expiration date. We recommend you try shortening the renewal period at next attempt.
    /// - `InvalidExpectedRenewDay.Conflict`: The specified expectedRenewDay is in conflict with period.
    /// - `InvalidExpectedRenewDay.ValueNotSupported`: The specified parameter ExpectedRenewDay is not valid.
    /// - `InvalidPeriod.ExceededDedicatedHost`: Instance expired date can not exceed dedicated host expired date.
    /// - `OperationRestricted.Renewal`: The renewal operation has been restricted because the zone is closed. %s
    /// - `ChargeTypeViolation`: The operation is not permitted due to charge type of the instance.
    /// - `InvalidAction.Unauthorized`: The specified action is not valid.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_renewal_price(
        &self,
        req: DescribeRenewalPrice,
    ) -> impl std::future::Future<Output = crate::Result<DescribeRenewalPriceResponse>> + Send {
        self.call(req)
    }

    /// # 查询未到期的包年包月ECS实例升配时目标实例规格的价格信息、新增包年包月数据盘的价格信息
    ///
    /// 查询未到期的包年包月ECS实例升配时目标实例规格的价格信息、新增包年包月数据盘的价格信息。
    ///
    /// - 仅支持查询未到期的包年包月ECS实例升配的价格信息，暂不支持查询实例降配的价格信息。
    /// - 不支持查询按量付费ECS实例变配时的价格信息。由于按量付费ECS实例变配后的价格与新购实例的价格一致，因此您可以直接调用[DescribePrice](~~107829~~)查询ECS实例的最新价格。
    /// - 实例升配前，建议您先调用[DescribeResourcesModification](~~66187~~)查询指定可用区内可升配的实例规格信息。
    ///
    /// # Error Codes
    /// - `MissingParameter.InstanceTypeOrDataDisk`: You must specify the parameter InstanceType or DataDisk.
    /// - `InvalidSystemDiskCategory.ValueNotSupported`: The specified parameter "SystemDisk.Category" is not valid.
    /// - `InvalidDiskCategory.Missing`: The DataDisk.1.Category parameter that is mandatory for processing the request is not provided.
    /// - `InvalidDataDiskCategory.ValueNotSupported`: The specified parameter "DataDisk.n.Category" is not valid.
    /// - `InvalidDiskCategory.ValueNotSupported`: The specified parameter "DiskCategory" is not valid.
    /// - `InvalidDataDiskSize.ValueNotSupported`: The specified DataDisk.n.Size beyond the permitted range.
    /// - `InvalidPerformanceLevel.Malformed`: The specified parameter DataDisk.n.PerformanceLevel is not valid.
    /// - `InvalidDiskSize.TooSmall`: Specified disk size is too small when choose PL0 of cloud_essd.
    /// - `OperationDenied.PerformanceLevelNotMatch`: The specified DataDisk.n.PerformanceLevel and DataDisk.n.Size do not match.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidAction.WithActiveElasticUpgrade`: The instance has active Elastic Upgrade.
    /// - `PriceNotFound`: The price of your queried resource is not available now, please try other resources.
    /// - `InvalidParameter.ResourceOwnerAccount`: ResourceOwnerAccount is Invalid.
    /// - `ChargeTypeViolation`: PostPaid instance do not support this operation.
    /// - `InvalidInstanceType.NotSupportUpgrade`: The specified InstanceType can only be downgraded. This API supports querying prices only of InstanceType that can be upgraded.
    /// - `InstanceExpired`: The PrePaid instance has been expired.
    /// - `Throttling.User`: Request was denied due to user flow control.
    /// - `Throttling`: Request was denied due to request throttling.
    /// - `InstanceType.Offline`: The specified InstanceType has been offline
    /// - `RegionUnauthorized`: There is no authority to create instance in the specified region.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_modification_price(
        &self,
        req: DescribeInstanceModificationPrice,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstanceModificationPriceResponse>> + Send
    {
        self.call(req)
    }

    /// # 批量创建实例
    ///
    /// 本接口用于批量创建ECS实例，支持自动启动、分配公网IP及设置自动释放时间。
    ///
    /// <props="china">
    /// 创建实例会产生计费，计费项包括[实例规格](~~25398~~)、[镜像](~~179021~~)、[块存储](~~179022~~)和[公网带宽](~~25411~~)。请确保在使用该接口前，已充分了解ECS产品的收费方式和[价格](https://www.aliyun.com/price/product#/ecs/detail)。
    /// </props>
    /// <props="intl">请确保在使用该接口前，已充分了解ECS产品的收费方式和[价格](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl)。
    /// </props>
    ///
    /// 本接口为异步接口，当前创建实例请求发送成功后会返回实例ID，实例的创建和启动不是立即完成的，您可以调用[DescribeInstanceStatus](~~2679688~~)查看实例信息，当返回信息中的状态为`Running`时代表创建并启动成功。
    ///
    /// ### 使用须知
    ///
    /// <props="china">
    ///
    /// - 请确保您的账号已通过实名认证。更多信息，请参见[账号实名认证相关文档](~~48263~~)。
    ///
    /// </props>
    ///
    /// - 当资源库存不足以完成当前实例创建时，阿里云会立即发送一个实例创建失败事件（SystemFailure.Delete），您可以通过[DescribeInstanceHistoryEvents](~~2679897~~)查看是否存在实例创建失败事件。更多信息，请参见[实例创建失败事件](~~2545990~~)。
    /// - 请确保您创建的实例总数或者全实例规格 vCPU 不会超出系统配额。更多信息，请参见[配额中心](https://quotas.console.aliyun.com/products/ecs/quotas)。
    /// - 创建专有网络VPC类型实例前，请预先在相应的阿里云地域[创建VPC](~~65430~~)。
    ///
    /// ### 注意事项
    /// - 若实例计费方式为包年包月（`PrePaid`），在付款时默认会使用您可用的优惠券。
    /// - 单个请求最多能创建100台实例，超出100台，建议您分批或并发调用。
    /// - 如果参数`InternetMaxBandwidthOut`的值大于0，则自动为实例分配公网IP。
    /// > 单个地域下，单个阿里云账号按固定带宽计费的公网带宽峰值总和存在限制，请参见[公网带宽限制](~~25412#BandwidthQuota~~)。
    ///
    ///
    /// ### 使用建议
    ///
    /// - **测试场景**：可以通过设置`DryRun=true`发送预检请求。
    /// - **释放实例**：您可以通过参数`AutoReleaseTime`设置实例自动释放时间，或者调用[DeleteInstances](~~2679710~~)进行手动释放。
    /// - **管理与检索**：建议您为每批次启动的实例指定标签（`Tag.N.Key`和`Tag.N.Value`），并且为主机名（`HostName`）和实例名称（`InstanceName`）添加有序后缀（`UniqueSuffix`）。具体操作，请参见[批量设置有序的实例名称或主机名称](~~196048~~)。
    /// - **启动模板**：利用实例启动模板能为您免除每次创建实例时都需要填入大量配置参数的麻烦，您可以通过[CreateLaunchTemplate](~~2679729~~)创建实例启动模板后，在`RunInstances`请求中指定`LaunchTemplateId`和`LaunchTemplateVersion`使用启动模板。
    /// - **关闭超线程**：在内存密集型业务场景，可以通过设置`CpuOptions.ThreadsPerCore=1`关闭超线程来提高内存配比。
    /// - **开启巨型帧**：可以指定 `NetworkOptions.EnableJumboFrame=true`在创建时开启`Jumbo frame`特性。 更多信息，请参见 [ECS实例MTU](~~200512~~)。
    ///
    /// ## 请求示例
    /// 假设您需要在华东 1（杭州）地域创建一些 ECS 实例。期望使用特定的镜像、实例规格、安全组和虚拟交换机，同时配置一定容量的系统盘和数据盘，并分配公网 IP 和设定实例名称与密码。相关配置请求参数如下：
    /// ```ignore
    /// RegionId:"cn-hangzhou", //设置华东 1（杭州）地域
    /// ImageId:"aliyun_3_x64_20G_alibase_20221102.vhd", //设置镜像ID
    /// InstanceType:"ecs.g7.large", //设置实例规格
    /// SecurityGroupId:"sg-bp150uqocpf9jj70****", //设置安全组 ID
    /// VSwitchId:"vsw-bp1qo7s91cbch5i4l****", //设置虚拟交换机 ID
    /// SystemDisk:{
    ///   Category:"cloud_essd", //设置系统盘类别为ESSD云盘
    ///   Size:40, //设置系统盘大小为40GiB
    /// },
    /// DataDisk:[
    ///   {
    ///     Category:"cloud_essd", //设置数据盘类别为ESSD云盘
    ///     Size:100, //设置数据盘大小为100GiB
    ///   }
    /// ],
    /// HostName:"ECS-test", //设置实例主机名称
    /// Password:"ECS@test1234", //设置实例登录密码
    /// InternetMaxBandwidthOut:10 //设置公网出带宽为10Mbit/s
    /// ```
    /// 在上述配置的基础上，创建不同类型实例：
    /// <details>
    /// <summary>示例：创建5台自动续费的包年包月实例</summary>
    ///
    /// ```ignore
    /// Amount:5, //创建数量为5台
    /// InstanceChargeType:"PrePaid", //表示包年包月
    /// PeriodUnit:"Month", //设置时长单位为"月"
    /// Period:1, //设置时长为1个月
    /// AutoRenew:true, //表示自动续费
    /// AutoRenewPeriod:1 //续费时长为1个月
    /// ```
    /// </details>
    ///
    /// <details>
    /// <summary>示例：创建10台按量付费实例</summary>
    ///
    /// ```ignore
    /// Amount:10, //创建数量为10台
    /// InstanceChargeType:"PostPaid", //表示按量付费
    /// SpotStrategy:"NoSpot" //默认值，表示正常按量付费
    /// ```
    /// </details>
    ///
    /// <details>
    /// <summary>示例：创建20台抢占式实例，并设置竞价策略和保留时长</summary>
    ///
    /// ```ignore
    /// Amount:20, //创建数量为20台
    /// InstanceChargeType:"PostPaid",
    /// SpotStrategy:"SpotAsPriceGo", //表示抢占式实例的竞价策略为根据市场价格自动出价
    /// SpotDuration:1 //设置抢占式实例的保留时长为1小时
    /// ```
    /// </details>
    ///
    /// 假设您已通过[CreateLaunchTemplate](~~2679729~~)创建了一个实例启动模版，现在需要使用该模版在华东 1（杭州）地域创建一些 ECS 实例。示例如下：
    ///
    /// <details>
    /// <summary>示例：根据实例启动模版创建10台ECS实例</summary>
    ///
    /// ```ignore
    /// RegionId:"cn-hangzhou", //设置华东 1（杭州）地域
    /// Amount:10, //创建数量为10台
    /// LaunchTemplateId:"lt-bp14xczpoxvb6rre****" //设置实例启动模版ID
    /// ```
    ///
    /// </details>
    ///
    /// ><notice>实例的参数和模版内的参数同时指定时，优先以实例参数创建。例如：模版内的付费方式是包年包月，同时`InstanceChargeType`设定为`PostPaid`，创建的即为按量付费类型实例。></notice>
    ///
    /// <details>
    /// <summary>示例：使用全镜像（包含系统盘和数据盘的整机镜像）创建1台实例</summary>
    ///
    /// ```ignore
    /// RegionId:"cn-hangzhou", //设置华东 1（杭州）地域
    /// ImageId = m-bp13ohd32cvzpq9e****，//自定义镜像ID
    /// InstanceType = ecs.u1-c1m1.large，//实例类型
    /// SecurityGroupId = sg-bp10jztp6b0sdsyl****，//安全组ID
    /// VSwitchId = vsw-bp19wo63nleroq22g****，//交换机ID
    /// SystemDisk.Size = 50，//设置全镜像自带的系统盘大小
    /// SystemDisk.Category = cloud_auto，//设置全镜像自带的系统盘的云盘种类
    /// DataDisk.0.Device = /dev/xvdb，//设置全镜像自带的数据盘的挂载点
    /// DataDisk.0.Size = 50，//设置全镜像自带的数据盘的容量大小
    /// DataDisk.0.Category = cloud_essd，//设置全镜像自带的数据盘的云盘种类
    /// DataDisk.1.Device = /dev/xvdc，//新增数据盘的挂载点，如果您需要使用新增的数据盘替换全镜像自带的数据盘，可设置DataDisk.1.Device = /dev/xvdb（全镜像中数据盘的默认挂载点）。
    /// DataDisk.1.Size = 70，//新增数据盘的容量大小
    /// DataDisk.1.Category = cloud_auto，//新增数据盘的云盘种类
    /// ```
    ///
    /// </details>
    ///
    /// # Error Codes
    /// - `LoginAsNonRoot.ImageNotSupport`: The specified image does not support login as non-root.
    /// - `InvalidParam.NotSupportJumboFrame`: Not support jumbo frame.
    /// - `InsufficientBalance.AgentCredit`: Insufficient agent credit. Please contact your agent.
    /// - `QuotaExceed.DiskCapacity`: The used capacity of disk type has exceeded the quota in the zone,  %s.
    /// - `InvalidPeriod.ExceededDedicatedHost`: Instance expired date can not exceed dedicated host expired date.
    /// - `InvalidParam.SecondaryNetworkInterface`: When min amount greater than 1 and the PrivateIpAddress or Primary NetworkInterface is specified,the Secondary NetworkInterface IP parameter cannot be specified.
    /// - `InvalidPrimaryIpAddress.SizeInvalid`: The NetworkInterface PrimaryIpAddress is used to create only one instance.
    /// - `InvalidStorageClusterId.CapacityNotEnough`: The remaining capacity of the current dedicated storage cluster is less than the size of disk.
    /// - `InvalidStorageClusterId.StatusNotSupport`: The current status of the dedicated storage cluster cannot create a cloud disk yet.
    /// - `InvalidStorageClusterId.ZoneIdEmpty`: The specified param ZoneId cannot be empty when StorageClusterId given.
    /// - `InvalidStorageClusterId.PerformanceLevelNotMatch`: The current dedicated storage cluster cannot create this performance level of disk.
    /// - `InvalidStorageClusterId.CategoryNotMatch`: The current dedicated storage cluster cannot create this category of disk.
    /// - `InvalidStorageClusterId.DiskSizeEmpty`: The specified param DiskSize cannot be empty when StorageClusterId given.
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType is not authorized.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType beyond the permitted range.
    /// - `InvalidDescription.Malformed`: The specified parameter "Description" is not valid.
    /// - `InvalidInternetChargeType.ValueNotSupported`: The specified InternetChargeType is not valid.
    /// - `InvalidParameter`: The specified parameter "InternetMaxBandwidthOut" is not valid.
    /// - `InvalidHostName.Malformed`: The specified parameter "HostName" is not valid.
    /// - `InvalidPassword.Malformed`: The specified parameter "Password" is not valid.
    /// - `InvalidPasswordParam.Mismatch`: The input password should be null when passwdInherit is true.
    /// - `InvalidSystemDiskCategory.ValueNotSupported`: The specified parameter "SystemDisk.Category" is not valid.
    /// - `InvalidDiskName.Malformed`: The specified parameter "SyatemDisk.DiskName or DataDisk.n.DiskName" is not valid.
    /// - `InvalidDiskDescription.Malformed`: The specified parameter "SyatemDisk.DiskDescription" or "DataDisk.n.Description" is not valid.
    /// - `InvalidDataDiskSize.ValueNotSupported`: The specified DataDisk.n.Size beyond the permitted range, or the capacity of snapshot exceeds the size limit of the specified disk category.
    /// - `InvalidDataDiskCategory.ValueNotSupported`: The specified parameter "DataDisk.n.Category" is not valid.
    /// - `InvalidDataDevice.Malformed`: The specified parameter "DataDisk.n.Device" is not valid.
    /// - `InvalidNodeControllerId.Malformed`: The specified parameter "NodeControllerId" is not valid.
    /// - `InvalidInnerIpAddress.Malformed`: The specified parameter "InnerIpAddress" is not valid.
    /// - `InvalidInnerIpAddress.Unusable`: The specified InnerIpAddress is already used or not found in usable ip range.
    /// - `InvalidParameter.Conflict`: The specified image does not support the specified instance type.
    /// - `ImageNotSupportCloudInit`: The specified image does not support cloud-init.
    /// - `InvalidSnapshotId.BasedSnapshotTooOld`: The specified snapshot is created before 2013-07-15.
    /// - `QuotaExceed.AfterpayInstance`: Living afterpay instances quota exceeded.
    /// - `InvalidInstanceName.Malformed`: The specified parameter "InstanceName" is not valid.
    /// - `InvalidInstanceName.CustomMalformed`: Customized section of instance or host name is invalid, please use valid format: [], [,], [m,], [,n], [m,n].
    /// - `InvalidParameter.Mismatch`: Specified security group and virtual switch are not in the same VPC.
    /// - `InvalidNetworkType.Mismatch`: Specified parameter "InternetMaxBandwidthIn" or "InternetMaxBandwidthOut" conflict with instance network type.
    /// - `InvalidPrivateIpAddress`: Specified private IP address is not in the CIDR block of virtual switch.
    /// - `InvalidPrivateIpAddress.Malformed`: Specified private IP address is malformed.
    /// - `QuotaExceeded.PrivateIpAddress`: Don't have enough private IPs in this switch.
    /// - `QuotaExceeded`: Living instances quota exceeded in this VPC.
    /// - `IncorrectVSwitchStatus`: The current status of virtual switch does not support this operation.
    /// - `ResourceNotAvailable`: Resource you requested is not available in this region or zone.
    /// - `MissingParameter`: The input parameter "VSwitchId" that is mandatory for processing this request is not supplied.
    /// - `InvalidDiskCategory.Mismatch`: The specified disk categories' combination is not supported.
    /// - `MissingParamter`: The specified parameter "Period" is not null.
    /// - `InvalidPeriod`: The specified period is not valid.
    /// - `InstanceDiskCategoryLimitExceed`: The specified DataDisk.n.Size beyond the permitted range, or the capacity of snapshot exceeds the size limit of the specified disk category.
    /// - `InvalidClientToken.ValueNotSupported`: The ClientToken provided is invalid.
    /// - `InvalidIoOptimize.ValueNotSupported`: The specified IoOptimize is not valid.
    /// - `InvalidSecurityGroupId.NotFound`: The SecurityGroupId provided does not exist in our records.
    /// - `InvalidInternetMaxBandwidthOut.Malformed`: The specified parameter internetMaxBandwidthOut is not valid.
    /// - `InvalidInternetMaxBandwidthIn.Malformed`: The specified parameter internetMaxBandwidthIn is not valid.
    /// - `InvalidSnapshotId.NotFound`: The specified parameter SnapshotId is not exist.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidTag.Mismatch`: The specified Tag.n.Key and Tag.n.Value are not match.
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `InvalidMinAmount.Malformed`: The specified parameter MinAmount is not valid.
    /// - `InvalidMaxAmount.Malformed`: The specified parameter MaxAmount is not valid.
    /// - `InvalidAutoReleaseTime.Malformed`: The specified parameter AutoReleaseTime is not valid.
    /// - `OperationDenied.NoVlan`: The specified parameter "VlanId" is not valid or vlan has not enough IP address.
    /// - `OperationDenied.QuotaExceed`: The quota of tags on resource is beyond permitted range.
    /// - `Account.Arrearage`: Your account has been in arrears.
    /// - `InvalidUserData.SizeExceeded`: The specified parameter "UserData" exceeds the size.
    /// - `InvalidUserData.NotSupported`: TThe specified parameter "UserData" only support the vpc and IoOptimized Instance.
    /// - `InvalidUserData.Base64FormatInvalid`: The specified UserData is not valid.
    /// - `InstanceDiskNumber.LimitExceed`: The total number of specified disk in an instance exceeds.
    /// - `InvalidDiskCategory.ValueNotSupported`: The specified parameter "DiskCategory" is not valid.
    /// - `InvalidSpotStrategy`: The specified SpotStrategy is not valid.
    /// - `InvalidSpotParam.EmptyZoneID`: The specified zoneid is empty when SpotStrategy is set.
    /// - `InvalidSpotPriceLimit`: The specified SpotPriceLimitis not valid.
    /// - `InvalidSpotDuration`: The specified SpotDuration is not valid.
    /// - `InvalidSpotAuthorized`: The specified Spot param is unauthorized.
    /// - `InvalidSpotPrepaid`: The specified Spot type is not support PrePay Instance.
    /// - `InvalidSpotAliUid`: The specified UID is not authorized to use SPOT instance.
    /// - `InvalidParameter.Bandwidth`: %s
    /// - `RegionUnauthorized`: %s
    /// - `Zone.NotOnSale`: %s
    /// - `InvalidSystemDiskSize.ValueNotSupported`: %s
    /// - `InvalidInstanceType.ElasticNetworkInterfaceNotSupported`: The specified instance type does not support Elastic Network Interface, you can not attach Elastic Network Interface to generation I instances.
    /// - `InvalidParameter.EncryptedIllegal`: %s
    /// - `InvalidParameter.EncryptedNotSupported`: %s
    /// - `InvalidSpotPriceLimit.LowerThanPublicPrice`: The specified parameter "spotPriceLimit" can't be lower than current public price.
    /// - `InvalidRelationResource.NotFound`: The relation resource has been deleted.
    /// - `IncorrectRecycleBinStatus`: The operation is not permitted due to resource status.
    /// - `InvalidHpcClusterId.Unnecessary`: The specified HpcClusterId is unnecessary.
    /// - `InvalidVSwitchId.Necessary`: The VSwitchId is necessary.
    /// - `InvalidHpcClusterId.Necessary`: The HpcClusterId is necessary.
    /// - `InvalidHpcClusterId.NotFound`: The specified HpcClusterId is not found.
    /// - `InvalidHpcClusterId.Creating`: The specified HpcClusterId is creating.
    /// - `InvalidParameter.VSwitchId`: %s
    /// - `InvalidSecurityGroup.NotInDefaultVpc`: %s
    /// - `VpcNotFound`: Vpc is not found according to the specified VSwitch or the vpc does not belong to you.
    /// - `InvalidSystemDiskSize.ImageNotSupportResize`: The specified image does not support resize.
    /// - `InvalidSpotInterruptionBehavior`: %s
    /// - `InvalidDeploymentOnHost`: %s
    /// - `InvalidInstanceChargeType.NotSupport`: The Dedicated host not support the specified Instance charge type.
    /// - `InvalidNetworkType.NotSupported`: The classic networkType not support create ECS on dedicatedHost.
    /// - `NoAvaliableDedicatedHost`: No available dedicated host or not enough resource on dedicated host.
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist.
    /// - `InvalidDedicatedHostStatus.NotSupport`: Operation denied due to dedicated host status.
    /// - `IncorrectDedicatedHostStatus`: The current status of the resource does not support this operation.
    /// - `ChargeTypeViolation.PostPaidDedicatedHost`: Prepaid instance onto postpaid dedicated host is not allowed.
    /// - `DedicatedHostType.Unmatched`: The specified DedicatedHostType doesn?t match the instance type.
    /// - `InvalidParam.NetworkInterface`: %s
    /// - `InvalidParams.CreateEniParams`: %s
    /// - `InvalidParameter.CreditSpecification`: The specified CreditSpecification is not supported in this region.
    /// - `IncorrectVpcStatus`: Current VPC status does not support this operation.
    /// - `InvalidInstanceType.NotSupported`: The specified instanceType is not supported by the deployment set.
    /// - `InvalidVpcZone.NotSupported`: The specified operation is not allowed in the zone to which your VPC belongs, please try in other zones.
    /// - `IncorrectDefaultVpcStatus`: The status of the default VPC is invalid.
    /// - `InvalidAutoRenewPeriod.ValueNotSupported`: The specified autoRenewPeriod is invalid.
    /// - `InvalidMarketImageChargeType.NotSupport`: The specified chargeType of marketImage is unsupported.
    /// - `OperationDenied`: The specified instanceType or zone is not available or not authorized.
    /// - `InvalidPeriodType.ValueNotSupported`: The specified parameter PeriodType is invalid.
    /// - `IncorrectImageStatus`: The specified image is an Alibaba Cloud Marketplace image. The sale of this image has ended. For more information, contact the image service provider.
    /// - `InvalidParam.Tenancy`: The specified Tenancy is invalid.
    /// - `InvalidParameter.Affinity`: The specified Affinity is invalid.
    /// - `InvalidCustomInstanceType.NotSupported`: The specified custom instance type is invalid.
    /// - `IoOptimized.NotSupported`: The specified instance must be IoOptimized instance when kmsKeyId is not empty.
    /// - `InvalidSnapshotId.Malformed`: The specified SnapshotId is not valid.
    /// - `InvalidCapacityReservationId.NotFound`: The specified CapacityReservationId does not exist.
    /// - `LackResource`: There's no enough resource on the specified capacity reservation.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidSecurityGroup.NetworkType`: %s
    /// - `InvalidSecurityGroup.VpcMismatch`: %s
    /// - `InvalidParameter.SecurityGroupIdRepeated`: %s
    /// - `InvalidSecurityGroupId.SingleIdAndMultiIdConflict`: %s
    /// - `InvalidSecurityGroupId.MultiGroupIdNetworkTypeConflict`: %s
    /// - `JoinedGroupLimitExceed`: %s
    /// - `InvalidAccountStatus.PayAmountLimitExceeded`: Your account is being restricted, because you have no default payment method or you are not authorized.
    /// - `InvalidPerformanceLevel.Malformed`: The specified parameter DataDisk.n.PerformanceLevel is not valid.
    /// - `InvalidOperation.EniCountExceeded`: The maximum number of eni in a enterprise security group is exceeded.
    /// - `QuotaExceeded.PrepayDataDiskCapacity`: The quota of prepay data disk capacity exceeds.
    /// - `InvalidDiskCategory.ConflictSnapshotCategory`: The specified disk category conflict with snapshot category.
    /// - `AccountForbidden.ProductCreationLimited`: The commodity must be officially operated by Aliyun and in pay-as-you-go billing method.
    /// - `UnexpectedImageFamily.ImageIdSupplied`: The input parameter ImageFamily must be null when image id is set.
    /// - `InvalidEncrypted.NotMatchEncryptAlgorithm`: The specified parameter Encrypted must be true when EncryptAlgorithm is not empty.
    /// - `InvalidEncrypted.NotMatchKmsKeyId`: The specified parameter Encrypted must be true when KmsKeyId is not empty.
    /// - `InvalidEncryptAlgorithm.NotMatchSnapshot`: The specified parameter EncryptAlgorithm is different from the encrypt algorithm of the snapshot.
    /// - `InvalidKmsKeyId.NotMatchSnapshot`: The specified parameter KmsKeyId is different from the KmsKeyId of the snapshot.
    /// - `InvalidEncryptAlgorithm`: The specified parameter EncryptAlgorithm is not valid.
    /// - `InvalidHttpEndpoint.NotSupported`: The specified HttpEndpoint not supported, you can use enabled(default) or disabled.
    /// - `InvalidHttpTokens.NotSupported`: The specified HttpTokens not supported, you can use optional(default) or required.
    /// - `InvalidHttpPutResponseHopLimit.NotSupported`: The specified HttpPutResponseHopLimit not supported, more than 1 and less than 64 is reasonable.
    /// - `InvalidOperation.VpcHasEnabledAdvancedNetworkFeature`: The specified vpc has enabled advanced network feature.
    /// - `InvalidChargeType.CapacityReservationNotSupported`: %s
    /// - `InvalidPerformanceLevel.ValueNotSupported`: The current ZoneId or InstanceType does not support PL0 of cloud_essd.
    /// - `InvalidKMSKeyId.NotSymmetric`: The specified parameter KmsKeyId must be symmetric.
    /// - `InvalidParameter.Arns`: The specified Arns is not valid.
    /// - `InvalidDedicatedHostClusterId.NotFound`: The specified DedicatedHostClusterId does not exist.
    /// - `InvalidDedicatedHostClusterId.InValid`: The specified Dedicated Host Cluster is invalid.
    /// - `InvalidDeploymentSetId.NotFound`: The parameter DeploymentSetId is invalid.
    /// - `InvalidOperation.UserNotSupported`: Reseller user do not support purchase at the moment.
    /// - `InvalidManagedPrivateSpaceId.NotFound`: %s
    /// - `InvalidSchedulerOptions`: The specified parameter SchedulerOptions is not valid.
    /// - `MissingParameter.PrivatePoolOptionsId`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptionsId`: The specified PrivatePoolOptions.Id is invalid.
    /// - `DedicatedHostNotSupported`: DedicatedHost is not supported for PrivatePool.
    /// - `SpotNotSupported`: Spot is not supported for PrivatePool.
    /// - `ClassicNetworkNotSupported`: Classic network is not supported for PrivatePool.
    /// - `Invalid.InstanceId`: Instance does not exist.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `Invalid.InstanceType`: The InstanceType does not match the PrivatePool.
    /// - `Invalid.InstanceChargeType`: The InstanceChargeType does not match the PrivatePool.
    /// - `Invalid.ZoneId`: The ZoneId does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.NoStock`: The PrivatePool has been used up.
    /// - `InvalidPlatform.ValueNotSupported`: The Platform does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.status`: The PrivatePool is expired or inactive.
    /// - `InvalidAliUid`: The PrivatePool does not belong to the user of the Instance.
    /// - `InvalidBandwidthOut.LessThanZero`: The bandwidth must be larger than 0 when specifying isp.
    /// - `HibernationConfigured.InstanceTypeNotSupport`: The specified instance type is not support.
    /// - `HibernationConfigured.ImageNotEncrypted`: The hibernation configured instance only support encrypted image.
    /// - `HibernationConfigured.MemorySizeTooBig`: The hibernation configured instance memory size is too big.
    /// - `InvalidSystemDiskSize.LessThanMemSize`: The specified parameter SystemDisk.Size is less than the memory size.
    /// - `InvalidCloudBoxZone.OperationNotSupported`: The cloud box zone does not support creating prepaid or encrypted resources.
    /// - `ProvisionedIopsForDiskCategoryUnsupported`: The specified disk category does not support provisioned iops.
    /// - `InvalidProvisionedIops.LimitExceed`: The provisioned iops exceeds the limit.
    /// - `BurstingEnabledForDiskCategoryUnsupported`: The specified disk category does not support bursting enabled.
    /// - `BurstingEnabledForMultiAttachDiskUnsupported`: The multi attach disk does not support bursting enabled.
    /// - `ProvisionedIopsForDiskCategoryRequired`: The provisioned iops is required for this disk category.
    /// - `NotSupportSnapshotEncrypted.InstanceType`: The specified instance type does not support creating encrypted disks with native snapshot encrypt.
    /// - `NotSupportSnapshotEncrypted.RegionId`: The specified region does not support creating encrypted disks with native snapshot encrypt.
    /// - `NotSupportSnapshotEncrypted.ZoneId`: The specified zone does not support creating encrypted disks with native snapshot encrypt.
    /// - `NotSupportSnapshotEncrypted.ShareImage`: Shared snapshot creating encrypted disks with native snapshot encrypt is not supported.
    /// - `NotSupportSnapshotEncrypted.ImageOwnerAlias`: The specified image category does not support creating encrypted disks with native snapshot encrypt.
    /// - `NotSupportSnapshotEncrypted.DiskCategory`: The specified disk category does not support creating encrypted disks with native snapshot encrypt.
    /// - `NotSupport.SnapshotEncryptedAlgorithmConflict`: Changing encrypt algorithm with encrypted snapshot is not supported.
    /// - `NoPermission.SystemTag`: The operator is not permission for the system tag.
    /// - `NumberExceed.Tags`: The Tags parameter's number is exceed , Valid : 20.
    /// - `InvalidZoneId.NotSupportShareEncryptedImage`: Creating instances by shared encrypted images is not supported in this zone.
    /// - `InvalidDiskCategory.NotSupported`: The specified disk category is not supported.
    /// - `InvalidParameter.CloudboxNotSupported`: %s
    /// - `InvalidZoneId.NotSupportCreateWithShareEncryptedImage`: You cannot use shared encrypted images to create instances in this zone.
    /// - `InvalidParameter.NetworkCardIndexInvalid`: Invalid network card index, please check your instance type.
    /// - `InvalidOperation.UserNotSupportNetworkCard`: User not support network card.
    /// - `InvalidAccount.NotSupportSpot`: According to business rules, this account cannot purchase ECS Spot instances.
    /// - `AccountForbidden.AssociatedWithResellerPartner`: Your account is associated with your reseller partner. Your account or your reseller partner's account has been forbidden to create orders, please contact your reseller partner.
    /// - `InvalidDestinationZone.DeploymentSetMismatch`: Error happened, %s.
    /// - `NoPermission.Price`: The operation requires price permission. Please either apply for permission from your main account, or set the parameter AutoPay as true.
    /// - `InvalidAutoPay.PostPaidUnsupported`: The specified parameter AutoPay must be set as true for postpaid instance.
    /// - `InvalidParam.EncryptedMismatch`: Creating encrypted disks with shared encrypted snapshots requires replacing encryption keys.
    /// - `InvalidParameter.DedicatedRegionNotSupported`: The specified action is rejected  because the specified ECS instance in the dedicated region does not support public IP.
    /// - `InvalidParameter.CpuOptionsTopologyType`: The specified parameter CpuOptions.TopologyType: %s is not valid.
    /// - `InvalidInstanceType.NotSupportCpuOptionsTopologyType`: The specified instance type does not support CpuOptions.TopologyType: %s.
    /// - `InvalidEniQueueSize.RegionOrUserNotSupported`: The specified parameter RxQueueSize or TxQueueSize is not supported in this region, or this account is not in the whitelist of using eni QueueSize.
    /// - `InvalidParameter.EniQueueSize`: The specified parameter TxQueueSize and RxQueueSize are not equal or exceed limit.
    /// - `InvalidParameter.KmsNotEnabled`: Failed to perform this operation because KMS is not activated.
    /// - `InvalidParameter.Encrypted.KmsNotEnable`: Failed to perform this operation because KMS is not activated.
    /// - `InvalidPrivateIpAddress.Duplicated`: The specified private IP address is already in use.
    /// - `InvalidAdditionalInfoPvdConfig.SizeExceeded`: The specified parameter AdditionalInfo.PvdConfig exceeds the size.
    /// - `InvalidParameter.Encrypted`: Creating non-encrypted disks with encrypted snapshots is not supported.
    /// - `InvalidInstanceType.NotSupportHighDensityMode`: The specified instance type does not support the use of the high density mode.
    /// - `QuotaExceeded.InternetBandwidth`: %s.
    /// - `InvalidParameter.CpuOptionsAccelerators`: The specified parameter CpuOptionsAccelerators is not valid.
    /// - `InvalidInstanceType.NotSupportCpuOptionsAccelerators`: The specified instance type does not support attach accelerator.
    /// - `OperationDenied.TestAccountRetricted`: Test-account for testing has been prohibited from creating instance in this region. Please contact 400181.
    /// - `InvalidBurstingEnabled.DiskSizeTooSmall`: The disk size must be greater than 3 GiB to enable burst.
    /// - `InvalidImage.WindowsUnsupported`: The specified InstanceType does not support the specified Windows image.
    /// - `InvalidParameter.CpuOptionsTurboMode`: The specified parameter TurboMode is not valid.
    /// - `InvalidInstanceType.EnableNVSUnsupported`: The specified instance type does not support EnableNVS.
    /// - `InvalidInstanceType.EnableVISSTUnsupported`: The specified instance type does not support EnableVISST.
    /// - `InvalidInstanceType.EnableVRDTUnsupported`: The specified instance type does not support EnableVRDT.
    /// - `InvalidInstanceType.SingleCoreMaxModeUnsupported`: The specified instance type does not support TurboMode: "SINGLE CORE MAX".
    /// - `InvalidParameter.PtpStatus`: The specified parameter PtpStatus: %s is not valid.
    /// - `InvalidInstanceType.NotSupportEnablePtp`: The specified instance type does not support enable PTP.
    /// - `InvalidInstanceType.NetworkOptionsBandwidthWeightingUnsupported`: The current instance type does not support setting or modifying the BandwidthWeighting parameter.
    /// - `InvalidParameter.NetworkOptionsBandwidthWeighting`: The specified parameter BandwidthWeighting is not valid.The correct value should be in [%s].
    /// - `InvalidMarketImage.NotAuthorized`: The specified marketplace image is not authorized for your channel, please use other image.
    /// - `InvalidRamRole.NotEcsRole`: The specified ram role is not authorized for ecs, please check your role policy.
    /// - `OperationDenied.CashCouponsInsufficientOrExpired`: Cash coupon balance is insufficient or has expired, please retry.
    /// - `InvalidParameter.PrivateIpAddressRepeated`: %s
    /// - `InvalidOperation.HighPerformanceEniPerInstanceLimitExceeded`: %s
    /// - `InvalidParameter.EniNumExceededWithLaunchEcs`: %s
    /// - `InvalidOperation.InstanceTypeNotSupportHighPerformanceTrafficMode`: %s
    /// - `InvalidParameter.QueuePairNumberMustEmpty`: %s
    /// - `InvalidParameter.EniTrafficMode`: %s
    /// - `InvalidParameter.InvalidQueuePairNumber`: The parameter of QueuePairNumber is invalid.
    /// - `InvalidParam.IpCount`: The parameter of ip count is invalid.
    /// - `InvalidParameter.EniType`: %s
    /// - `InvalidOperation.HighPerformanceTrafficModeIsNotAllowed`: %s
    /// - `InvalidParameter.NetworkInterface`: %s
    /// - `InvalidParameter.Combination`: %s
    /// - `InvalidHostname.SingleAndMultiConflict`: %s
    /// - `InvalidHostname.SizeInvalid`: %s
    /// - `InvalidParams.InstanceNameExceed`: The uniqueSuffix takes three naming places, please shorten your InstanceName.
    /// - `InvalidParams.HostnameExceed`: The uniqueSuffix takes three naming places, please shorten your Hostname.
    /// - `ImageNotSubscribed`: The specified image has not be subscribed.
    /// - `InvalidSystemDiskCategory.ValueUnauthorized`: The disk category is not authorized.
    /// - `InvalidSnapshotId.NotReady`: The specified snapshot has not completed yet.
    /// - `InstanceDiskCategoryLimitExceed`: The total size of specified disk category in an instance exceeds.
    /// - `InvalidDevice.InUse`: The specified device has been occupied.
    /// - `ImageRemovedInMarket`: The specified market image is not available, Or the specified user defined image includes product code because it is based on an image subscribed from marketplace, and that image in marketplace includeing exact the same product code has been removed.
    /// - `CategoryNotSupported`: The specified zone does not offer the specified disk category.
    /// - `QuotaExceed.PortableCloudDisk`: The quota of portable cloud disk exceeds.
    /// - `SecurityGroupInstanceLimitExceed`: Exceeding the allowed amount of instances of a security group.
    /// - `NodeControllerUnavailable`: The Node Controller is temporarily unavailable.
    /// - `RegionUnauthorized`: There is no authority to create instance in the specified region.
    /// - `InvalidSnapshotId.NotDataDiskSnapshot`: The specified snapshot is system disk snapshot.
    /// - `Forbbiden`: User not authorized to operate on the specified resource.
    /// - `DeleteWithInstance.Conflict`: The specified disk is not a portable disk and cannot be set to DeleteWithInstance attribute.
    /// - `InstanceDiskNumLimitExceed`: The number of specified disk in an instance exceeds.
    /// - `IoOptimized.NotSupported`: The specified image is not support IoOptimized Instance.
    /// - `InvalidDiskSize.TooSmall`: Specified disk size is less than the size of snapshot.
    /// - `InvalidDiskCategory.Mismatch`: The specified disk categories combination is not supported.
    /// - `InvalidDiskCategory.NotSupported`: The specified disk category is not support the specified instance type.
    /// - `QuotaExceed.BuyImage`: The specified image is from the image market?You have not bought it or your quota has been exceeded.
    /// - `InvalidResourceId.NotSupported`: The specified ResourceId does not support tagging.
    /// - `OperationDenied`: The specified RegionId does not support the creation of the network type ECS instance.
    /// - `OperationDenied.ImageNotValid`: The specified Image is disabled or is deleted.
    /// - `OperationDenied.SnapshotNotValid`: The specified snapshot is not allowed to create disk.
    /// - `OperationDenied.SnapshotNotAllowed`: The specified snapshot is not allowed to create disk.
    /// - `OperationDenied.ZoneNotAllowed`: The creation of Instance to the specified Zone is not allowed.
    /// - `OperationDenied.ZoneSystemCategoryNotMatch`: The specified Zone or cluster does not offer the specified disk category or the speicified zone and cluster do not match.
    /// - `OperationDenied.ResourceControl`: The specified region is in resource control, please try later.
    /// - `OperationDenied.NoStock`: The resource is out of usage.
    /// - `OperationDenied.SnapshotParamsNotValid`: The capacity of snapshot exceeds the size limit of the specified disk category or the specified category is not authorizied.
    /// - `OperationDenied.DiskTypeNotSupport`: The type of the disk does not support the operation.
    /// - `InvalidUserData.Forbidden`: User not authorized to input the parameter "UserData", please apply for permission "UserData".
    /// - `Zone.NotOpen`: The specified zone is not granted to you to buy resources yet.
    /// - `Zone.NotOnSale`: The resource in the specified zone is no longer available for sale. Please try other regions and zones.
    /// - `InvalidClusterId.NotFound`: The specified clusterId does not exist.
    /// - `InvalidResourceType.NotSupported`: %s
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType beyond the permitted range.
    /// - `InvalidInstanceType.ZoneNotSupported`: The specified zone does not support this instancetype.
    /// - `InstanceType.Offline`: %s
    /// - `DependencyViolation.WindowsInstance`: The instance creating is window, cannot use ssh key pair to login.
    /// - `InvalidNetworkType.MismatchRamRole`: A RAM role can?t be used for classic instance.
    /// - `InvalidUser.PassRoleForbidden`: The RAM user does not have the privilege to pass a RAM role.
    /// - `InvalidParam.TrustedSystemMode`: The specified TrustedSystemMode is invalid.
    /// - `InvalidParam.ConfidentialComputingMode`: The specified ConfidentialComputingMode is invalid.
    /// - `InvalidInstanceType.NotSupported`: The specified instance type does not support trusted system.
    /// - `InvalidSecurityOptions.NotSupported`: SecurityOptions for vTPM and Enclave can not both be set.
    /// - `InvalidImage.NotSupported`: The specified vTPM instance need UEFI image.
    /// - `Forbidden.RiskControl`: This operation is forbidden by Aliyun RiskControl system.
    /// - `InvalidInstance.UnPaidOrder`: The specified Instance has unpaid order.
    /// - `Account.Arrearage`: Your account has been in arrears.
    /// - `RealNameAuthenticationError`: Your account has not passed the real-name authentication yet.
    /// - `InvalidPayMethod`: The specified pay method is not valid.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `ImageNotSupportInstanceType`: The specified image does not support the specified InstanceType.
    /// - `DryRun.InvalidAmount`: %s
    /// - `OperationDenied.InvalidNetworkType`: %s
    /// - `InvalidSpotInterruptionBehavior.ClassicNetworkNotSupport`: The specified SpotInterruptionBehavior does not support Classic network Instance.
    /// - `InvalidSpotInterruptionBehavior.LocalDiskNotSupport`: The specified SpotInterruptionBehavior does not support local disk instance.
    /// - `QuotaExceed.PostPaidDisk`: Living postPaid disks quota exceeded.
    /// - `InvalidParameter.NotMatch`: %s
    /// - `InvalidVSwitch.DefaultVSwitchNotSupport`: The specified zone in vpc can't support create default vSwitch.
    /// - `OperationDenied.LocalDiskUnsupported`: The configuration change is not allowed when the specified instance has local disks mounted.
    /// - `OperationDenied.InconsistentNetwork`: The specified security group and vswitch are not in the same vpc.
    /// - `DefaultVswitch.Existed`: The default vswitch for VPC already exists.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `CategoryViolation`: The specified instance does not support this operation because of its disk category.
    /// - `ResourcesNotInSameZone`: The specified instance and dedicated host are not in the same zone.
    /// - `InvalidDisk.SystemDiskSize`: The specified SystemDiskSize beyond the permitted range.
    /// - `InsufficientBalance`: Your account does not have enough balance.
    /// - `InvalidOperation.NetworkInterface`: %s
    /// - `MaxEniIpv6IpsCountExceeded`: %s
    /// - `InvalidIp.IpRepeated`: %s
    /// - `InvalidIp.IpAssigned`: %s
    /// - `InvalidIp.Address`: %s
    /// - `InvalidOperation.EniCountExceeded`: %s
    /// - `InvalidOperation.Ipv4CountExceeded`: %s
    /// - `InvalidOperation.Ipv6CountExceeded`: %s
    /// - `InvalidOperation.Ipv6NotSupport`: %s
    /// - `InvalidOperation.Ipv4NotSupport`: %s
    /// - `InvalidParam.SecondaryIp`: %s
    /// - `InvalidVSwitch.Ipv6NotTurnOn`: %s
    /// - `InvalidParam.IpAssign`: %s
    /// - `InvalidParam.Amount`: %s
    /// - `InvalidParam.CpuOptionsCore`: %s
    /// - `InvalidParam.CpuOptionsNuma`: %s
    /// - `InvalidVSwitchId.IpInvalid`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `QuotaExceed.DeploymentSetInstanceQuotaFull`: The instance quota in one deployment set exceeded.
    /// - `InvalidChargeType.ValueNotSupported`: Deletion protection is only valid for postPaid instance, not for prePaid or spot instance.
    /// - `InvalidRegion.NotSupport`: The specified region does not support byok.
    /// - `UserNotInTheWhiteList`: The user is not in byok white list.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `SecurityRisk.3DVerification`: We have detected a security risk with your default credit or debit card. Please proceed with verification via the link in your email.
    /// - `Mayi.InternalError`: The request processing has failed due to some unknown error.
    /// - `InvalidNetworkType`: The network type is not support in this region.
    /// - `InvalidAccountStatus`: Your account status is invalid, please contact customer service.
    /// - `QuotaExceeded.PrivateIpAddress`: %s
    /// - `OperationDenied.PerformanceLevelNotMatch`: The specified DataDisk.n.PerformanceLevel and DataDisk.n.Size do not match.
    /// - `InvalidStorageSetName.Malformed`: Specified parameter StorageSetName is not valid.
    /// - `InvalidDescription.Malformed`: Specified parameter Description is not valid.
    /// - `InvalidMaxPartitionNumber.Malformed`: Specified parameter MaxPartitionNumber is not valid.
    /// - `InvalidParameter.StorageSetPartitionNumber`: Specified parameter StorageSetPartitionNumber is not valid.
    /// - `InvalidParameter.StorageSetId`: Specified parameter StorageSetId is not valid.
    /// - `InvalidParameter.StorageSetZoneId`: Specified parameter StorageSetZoneId is not valid.
    /// - `EnterpriseGroupLimited.MutliGroupType`: The specified instance can't join multi SecurityGroup types.
    /// - `EnterpriseGroupLimited.InstanceType`: The specified instance type doesn't support Enterprise SecurityGroup.
    /// - `QuotaExceed.Tags`: %s
    /// - `OperationDenied.RegionIdNotSupported`: The specified region does not support spot duration instance.
    /// - `OperationDenied.FlavorNotSupported`: Flavor not support spot duration instance.
    /// - `OperationDenied.TimestampNotSupported`: Timestamp not support spot duration instance.
    /// - `OperationDenied.PaygNotAvailable`: Pay-as-you-go instance is not available now.
    /// - `OperationDenied.PrepayNotAvailable`: Prepay instance is not available now.
    /// - `OperationDenied.BidOwnResource`: Bid user can not own resource.
    /// - `OperationDenied.CloudSSDNotSupported`: The specified available zone does not offer the cloud_ssd disk, use cloud_essd instead.
    /// - `QuotaExceed.ElasticQuota`: No additional quota is available for the specified ECS instance type.
    /// - `QuotaExceeded.PostpaidDataDiskCapacity`: The quota of postpaid data disk capacity exceeds.
    /// - `InvalidImageFamily.MissingAvailableImage`: There is no available image related to the specified image family.
    /// - `InvalidRegionId.NotSupportEncryptAlgorithm`: The current region does not support creating encrypted disks with EncryptAlgorithm.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidManagedPrivateSpaceId.DedicatedHostIdConflict`: ManagedPrivateSpaceId and DedicatedHostId cannot be specified at the same time.
    /// - `InvalidManagedPrivateSpaceId.TenancyConflict`: ManagedPrivateSpaceId and Tenancy cannot be specified at the same time.
    /// - `InvalidParameter.InvalidEniQueueNumber`: %s
    /// - `InvalidOperation.MaxEniQueueNumberExceeded`: %s
    /// - `InvalidOperation.ExceedInstanceTypeQueueNumber`: %s
    /// - `InvalidIspType.ValueNotSupported`: %s
    /// - `UnsupportedIspChargeType`: %s
    /// - `UnsupportedIspClassicNetwork`: %s
    /// - `InvalidIspBandwidthOut`: %s
    /// - `UnsupportedIspNetworkChargeType`: %s
    /// - `InvalidIspUID`: %s
    /// - `UnsupportedIspRegion`: %s
    /// - `Forbidden.OnlySupportEnterpriseGroup`: %s
    /// - `HibernationConfigured.InstanceOperationForbidden`: The operation is not permitted due to limit of the hibernation configured instance.
    /// - `InstanceDiskLimitExceeded`: The amount of the disk on instance reach its limits.
    /// - `InvalidInstanceType.NotSupportDiskCategory`: The instanceType of the specified instance does not support this disk category.
    /// - `InvalidOperation.ConfidentialComputingModeInInviteOnlyTesting`: The specified confidential computing mode is in invite only testing: %s.
    /// - `InvalidOperation.InvalidNetworkInterfaceId`: %s
    /// - `InvalidOperation.RegionNotSupportNetworkInterfaceId`: The specific region does not support network interface id.
    /// - `InvalidEniId.NotFound`: %s
    /// - `NotSupportSnapshotEncrypted.DiskCategory`: The specified disk category does not support creating encrypted system disks or creating encrypted data disks from snapshots. Check the DiskCategory or Encrypted parameter, or check your account for default encryption settings.
    /// - `InvalidOperation.PublicIpAddressNoStock`: The public IP address for the specified Region or ChargeType of the instance is out of stock. Please try another Region or ChargeType.
    /// - `AclLimitExceed`: %s
    /// - `InvalidParameter.DataEncryptedKeyCreateFailed`: Create kms data encrypted key fail. If you need further assistance, you can contact the KMS Technical Support.
    /// - `InvalidParameter.CpuOptionsThreadsPerCore`: The specified parameter CpuOptions.ThreadsPerCore is not valid.
    /// - `InvalidParameter.CpuOptionsCore`: The specified parameter CpuOptions.Core is not valid.
    /// - `InvalidInstanceType.CpuOptionsThreadsPerCoreUnsupported`: The current instance type does not support setting or modifying the CpuOptions.ThreadsPerCore parameter.
    /// - `InvalidParameter.CpuOptionsNuma`: The specified parameter CpuOptions.Numa is not valid.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidEncrypted.NotMatchSnapshot`: The specified parameter Encrypted must be set to true when creating disks with encrypted snapshots.
    /// - `InvalidEncrypted.NotMatchDiskDefaultEncryption`: Enabling disk default encryption prevents the creation of non-encrypted disks.
    /// - `InvalidOperation.InstanceTypeNotSupportNetworkEncryption`: The specified instance type does not support network encryption.
    /// - `InvalidOperation.UserNotSupportNetworkEncryption`: User not support network encryption.
    /// - `InvalidOperation.InstanceTypeNotSupportEniTrunking`: The current instance type does not support ENI trunking operation.
    /// - `InvalidStorageClusterId.NotExist`: The specified StorageClusterId does not exist in current region.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidZoneId.NotFound`: The ZoneId provided does not exist in our records.
    /// - `InvalidSecurityGroupId`: The specified SecurityGroupId is invalid or does not exist.
    /// - `InvalidSecurityGroupId.NotFound`: The SecurityGroupId provided does not exist in our records.
    /// - `InvalidDataDiskSnapshotId.NotFound`: The specified parameter "DataDisk.n.SnapshotId" is not valid.
    /// - `InvalidClusterId.NotFound`: The ClusterId provided does not exist in our records.
    /// - `InvalidVSwitchId.NotFound`: Specified virtual switch does not exist.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.
    /// - `IoOptimized.NotSupported`: The specified instancetype is not support IoOptimized instance.
    /// - `InvalidInstanceChargeType.NotFound`: The InstanceChargeType does not exist in our records.
    /// - `DependencyViolation.IoOptimized`: The specified instancetype must be IoOptimized instance.
    /// - `PaymentMethodNotFound`: No payment method has been registered on the account.
    /// - `HOSTNAME_ILLEGAL`: The specified parameter HostName is not valid.
    /// - `InvalidSystemDiskSize.LessThanImageSize`: The specified parameter SystemDisk.Size is less than the image size.
    /// - `InvalidSystemDiskSize.LessThanMinSize`: The specified parameter SystemDisk.Size is less than the min size.
    /// - `InvalidSystemDiskSize.MoreThanMaxSize`: The specified parameter SystemDisk.Size is more than the max size.
    /// - `OperationDenied.ImageNotValid`: The specified Image is disabled or is deleted.
    /// - `OperationDenied.CreatingConflict`: Another Instance has been creating.
    /// - `InvalidKeyPairName.NotFound`: The specified parameter KeyPairName does not exist in our records.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InvalidRamRole.NotFound`: The specified parameter "RAMRoleName" does not exist.
    /// - `InvalidLaunchTemplate.NotFound`: %s
    /// - `InvalidLaunchTemplateVersion.NotFound`: %s
    /// - `InvalidVSwitchId.NotExist`: %s
    /// - `InvalidMarketImage.NotFound`: The specified marketplace image does not exist, please change the imageId and try again.
    /// - `DeploymentSet.NotFound`: The specified deployment set does not exist.
    /// - `InvalidParameter.DeploymentSetGroupNo`: Parameter DeploymentSetGroupNo is invalid.
    /// - `InvalidParameter.KMSKeyId.NotFound`: The specified KMSKeyId does not exist.
    /// - `InvalidDiskIds.NotPortable`: The specified DiskId is not portable.
    /// - `InvalidAutoSnapshotPolicyId.NotFound`: Specified parameter AutoSnapshotPolicyId not found.
    /// - `Throttling.Resource`: The request throttle by resource operation.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn run_instances(
        &self,
        req: RunInstances,
    ) -> impl std::future::Future<Output = crate::Result<RunInstancesResponse>> + Send {
        self.call(req)
    }

    /// # 创建实例
    ///
    /// 本接口是阿里云 ECS 中用于创建实例的接口，支持创建一台包年包月或按量付费的 ECS 实例。您可通过此接口，依据自身需求灵活配置各类参数，实现实例的个性化创建。
    ///
    /// > 本接口已停止迭代更新，建议您使用[RunInstances](~~2679677~~)接口。
    ///
    /// <props="china">
    ///
    /// **请确保在使用该接口前，已充分了解ECS产品的收费方式和[价格](https://www.aliyun.com/price/product#/ecs/detail)。**
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// **请确保在使用该接口前，已充分了解ECS产品的收费方式和[价格](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl)。**
    ///
    /// </props>
    ///
    ///
    ///
    ///
    /// 本接口为异步接口，当前创建实例请求发送成功后会返回实例ID，实例的创建不是立即完成的，需要调用[DescribeInstanceStatus](~~2679688~~)查看实例信息，当返回信息中的状态为`Stopped`时代表创建成功，之后您可以通过[StartInstance](~~2679679~~)启动实例。
    ///
    ///
    /// ### 使用须知
    ///
    /// <props="china">
    ///
    /// - 请确保您的账号已通过实名认证。更多信息，请参见[账号实名认证相关文档](~~48263~~)。
    ///
    /// </props>
    ///
    ///
    /// - 创建实例会涉及资源计费，请确保您已了解云服务器ECS的计费方式。更多信息，请参见[计费概述](~~25398~~)。
    ///     
    /// - 请确保您创建的实例总数或者全实例规格 vCPU 不会超出系统配额。更多信息，请参见[配额中心](https://quotas.console.aliyun.com/products/ecs/quotas)。
    /// - 创建专有网络VPC类型实例前，请预先在相应的阿里云地域[创建VPC](~~65430~~)。
    ///
    /// ### 注意事项
    /// - 若实例计费方式为包年包月（`PrePaid`），在付款时默认会使用您可用的优惠券。
    /// - 实例内存为512 MiB时，不能使用除半年渠道之外的Windows Server镜像；实例内存为4 GiB以上时，不能使用32位操作系统的镜像。
    /// - 使用该接口创建的实例将不会分配公网IP地址，若公网带宽大于0，您可以调用[AllocatePublicIpAddress](~~25544~~)分配；若公网带宽为0，您需要调用[ModifyInstanceNetworkSpec](~~2679879~~)调整带宽之后再调用[AllocatePublicIpAddress](~~25544~~)分配。
    ///
    /// > 单个地域下，单个阿里云账号按固定带宽计费的公网带宽峰值总和存在限制，请参见[公网带宽限制](~~25412#BandwidthQuota~~)。
    ///
    /// ### 使用建议
    /// - **产品选型**：参见[实例规格族](~~25378~~)或调用[DescribeInstanceTypes](~~25620~~)查看目标实例规格的性能数据，或者参见[选型配置](~~58291~~)了解如何选择实例规格。
    /// - **查询库存**：调用[DescribeAvailableResource](~~66186~~)查看指定地域或者可用区内的资源供给情况。
    /// - **自定义数据**：若实例满足使用[实例自定义数据](~~49121~~)的限制，您可传入UserData信息。发送API请求时，不会加密您设置的`UserData`数据，建议您不要以明文方式传入机密的信息，例如密码和私钥等。如果必须传入，建议加密后以Base64的方式编码后再传入，在实例内部解密后使用。
    ///
    /// # Error Codes
    /// - `InvalidStorageClusterId.CapacityNotEnough`: The remaining capacity of the current dedicated storage cluster is less than the size of disk.
    /// - `InvalidStorageClusterId.StatusNotSupport`: The current status of the dedicated storage cluster cannot create a cloud disk yet.
    /// - `InvalidStorageClusterId.ZoneIdEmpty`: The specified param ZoneId cannot be empty when StorageClusterId given.
    /// - `InvalidStorageClusterId.PerformanceLevelNotMatch`: The current dedicated storage cluster cannot create this performance level of disk.
    /// - `InvalidStorageClusterId.CategoryNotMatch`: The current dedicated storage cluster cannot create this category of disk.
    /// - `InvalidStorageClusterId.DiskSizeEmpty`: The specified param DiskSize cannot be empty when StorageClusterId given.
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType is not authorized.
    /// - `InvalidInternetChargeType.ValueNotSupported`: The specified InternetChargeType is not valid.
    /// - `InvalidParameter`: The specified parameter "InternetMaxBandwidthOut" is not valid.
    /// - `InvalidSystemDiskCategory.ValueNotSupported`: The specified parameter " SystemDisk.Category " is not valid.
    /// - `InvalidDataDiskSize.ValueNotSupported`: The specified DataDisk.n.Size beyond the permitted range, or the capacity of snapshot exceeds the size limit of the specified disk category.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidDescription.Malformed`: The specified parameter "Description" is not valid.
    /// - `InvalidHostName.Malformed`: The specified parameter "HostName" is not valid.
    /// - `InvalidPassword.Malformed`: The specified parameter "Password" is not valid.
    /// - `InvalidPasswordParam.Mismatch`: The input password should be null when passwdInherit is true.
    /// - `InvalidDiskName.Malformed`: The specified parameter "SystemDisk.DiskName or DataDisk.n.DiskName" is not valid.
    /// - `InvalidDiskDescription.Malformed`: The specified parameter "SystemDisk.DiskDescription" or "DataDisk.n.Description" is not valid.
    /// - `InvalidDataDiskCategory.ValueNotSupported`: The specified parameter "DataDisk.n.Category" is not valid.
    /// - `InvalidDataDevice.Malformed`: The specified parameter "DataDisk.n.Device" is not valid.
    /// - `InvalidNodeControllerId.Malformed`: The specified parameter "NodeControllerId" is not valid.
    /// - `InvalidInnerIpAddress.Malformed`: The specified parameter "InnerIpAddress" is not valid.
    /// - `InvalidInnerIpAddress.Unusable`: The specified InnerIpAddress is already used or not found in usable ip range.
    /// - `OperationDenied`: The specified parameter "VlanId" is not valid or vlan has not enough IP address.
    /// - `InvalidParameter.Conflict`: The specified image does not support the specified instance type.
    /// - `ImageNotSupportCloudInit`: The specified image does not support cloud-init.
    /// - `InvalidSnapshotId.BasedSnapshotTooOld`: The specified snapshot is created before 2013-07-15.
    /// - `QuotaExceed.AfterpayInstance`: The maximum number of Pay-As-You-Go instances is exceeded: %s.
    /// - `InvalidMarketImageChargeType.NotSupport`: The specified chargeType of marketImage is unsupported.
    /// - `InvalidInstanceName.Malformed`: The specified parameter "InstanceName" is not valid.
    /// - `InvalidParameter.Mismatch`: Specified security group and virtual switch are not in the same VPC.
    /// - `InvalidNetworkType.Mismatch`: Specified parameter InternetMaxBandwidthIn or InternetMaxBandwidthOut conflict with instance network type.
    /// - `InvalidPrivateIpAddress`: Specified private IP address is not in the CIDR block of virtual switch.
    /// - `InvalidPrivateIpAddress.Malformed`: Specified private IP address is invalid.
    /// - `InvalidPrivateIpAddress.Duplicated`: Specified private IP address is duplicated.
    /// - `QuotaExceeded.PrivateIpAddress`: Don't have enough private IPs in this switch.
    /// - `QuotaExceeded`: Living instances quota exceeded in this VPC.
    /// - `IncorrectVSwitchStatus`: The current status of virtual switch does not support this operation.
    /// - `ResourceNotAvailable`: Resource you requested is not available in this region or zone.
    /// - `MissingParameter`: The input parameter "VSwitchId" that is mandatory for processing this request is not supplied.
    /// - `InvalidDiskCategory.Mismatch`: The specified disk categories' combination is not supported.
    /// - `InvalidIoOptimizedValue.ValueNotSupported`: IoOptimized value not supported.
    /// - `MissingParamter`: The specified parameter "Period" is not null.
    /// - `InvalidPeriod`: The specified period is not valid.
    /// - `InstanceDiskCategoryLimitExceed`: The specified DataDisk.n.Size beyond the permitted range, or the capacity of snapshot exceeds the size limit of the specified disk category.
    /// - `InvalidParameter.Bandwidth`: The specified parameter Bandwidth is not valid.
    /// - `InvalidIPAddress.AlreadyUsed`: The specified IPAddress is already used by other resource.
    /// - `InvalidUserData.SizeExceeded`: The specified parameter "UserData" exceeds the size.
    /// - `InvalidUserData.NotSupported`: The specified parameter "UserData" only support the vpc and IoOptimized Instance.
    /// - `InstanceDiskNumber.LimitExceed`: The total number of specified disk in an instance exceeds.
    /// - `Account.Arrearage`: Your account has an outstanding payment.
    /// - `InvalidDiskCategory.ValueNotSupported`: The specified parameter "DiskCategory" is not valid.
    /// - `InvalidAutoRenewPeriod.ValueNotSupported`: The specified autoRenewPeriod is not valid.
    /// - `InvalidSpotStrategy`: The specified SpotStrategy is not valid.
    /// - `InvalidSpotParam.EmptyZoneID`: The specified ZoneId is empty when SpotStrategy is set.
    /// - `InvalidSpotPriceLimit`: The specified SpotPriceLimitis not valid.
    /// - `InvalidSpotDuration`: The specified SpotDuration is not valid.
    /// - `InvalidSpotAuthorized`: The specified Spot param is unauthorized.
    /// - `InvalidSpotPrepaid`: The specified Spot type is not support PrePay Instance.
    /// - `InvalidSpotAliUid`: The specified UID is not authorized to use SPOT instance.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `RegionUnauthorized`: %s
    /// - `Zone.NotOnSale`: %s
    /// - `InvalidSystemDiskSize.ValueNotSupported`: %s
    /// - `InvalidParameter.EncryptedIllegal`: %s
    /// - `InvalidParameter.EncryptedNotSupported`: %s
    /// - `EncryptedOption.Conflict`: %s
    /// - `InvalidSpotPriceLimit.LowerThanPublicPrice`: The specified parameter "soptPriceLimit" can't be lower than current public price.
    /// - `InvalidHpcClusterId.Unnecessary`: The specified HpcClusterId is unnecessary.
    /// - `InvalidVSwitchId.Necessary`: The VSwitchId is necessary.
    /// - `InvalidHpcClusterId.Necessary`: The HpcClusterId is necessary.
    /// - `InvalidHpcClusterId.NotFound`: The specified HpcClusterId is not found.
    /// - `InvalidHpcClusterId.Creating`: The specified HpcClusterId is creating.
    /// - `InvalidPeriodUnit.ValueNotSupported`: The specified parameter PeriodUnit is not valid.
    /// - `IncorrectImageStatus`: Encrypted snapshots do not support this operation.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidSecurityGroup.NotInDefaultVpc`: %s
    /// - `VpcNotFound`: Vpc is not found according to the specified VSwitch or the vpc does not belong to you.
    /// - `InvalidSpotInterruptionBehavior`: %s
    /// - `OperationDenied.IllegalPaymentPolicy`: The current payment policy is illegal, please connect your service provider to authenticate relative agreement.
    /// - `InvalidDeploymentOnHost`: %s
    /// - `InvalidInstanceChargeType.NotSupport`: The Dedicated host not support the specified Instance charge type.
    /// - `InvalidNetworkType.NotSupported`: The classic networkType not support create ECS on dedicatedHost.
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist.
    /// - `InvalidDedicatedHostStatus.NotSupport`: Operation denied due to dedicated host status.
    /// - `IncorrectDedicatedHostStatus`: The current status of the resource does not support this operation.
    /// - `ChargeTypeViolation.PostPaidDedicatedHost`: Prepaid instance onto postpaid dedicated host is not allowed.
    /// - `InvalidPeriod.ExceededDedicatedHost`: Instance expired date can't exceed dedicated host expired date.
    /// - `DedicatedHostType.Unmatched`: The specified DedicatedHostType doesn?t match the instance type.
    /// - `NoAvaliableDedicatedHost`: There's no enough resource on the specified dedicated host.
    /// - `InvalidParameter.Affinity`: The specified Affinity is invalid.
    /// - `InvalidParameter.Tenancy`: The specified Tenancy is invalid.
    /// - `InvalidParam.Tenancy`: The specified Tenancy is invalid.
    /// - `InvalidParameter.CreditSpecification`: The specified CreditSpecification is not supported in this region.
    /// - `InvalidInstanceType.NotSupported`: The specified instanceType is not supported by the deployment set.
    /// - `InvalidVpcZone.NotSupported`: Zone of the specified VSwitch is not available for creating, please try in other zones.
    /// - `IncorrectDefaultVpcStatus`: The status of the default VPC is invalid.
    /// - `IoOptimized.NotSupported`: The specified instance must be IoOptimized instance when kmsKeyId is not empty.
    /// - `InvalidClientToken.ValueNotSupported`: The ClientToken provided is invalid.
    /// - `InvalidCapacityReservationId.NotFound`: The specified CapacityReservationId does not exist.
    /// - `LackResource`: There's no enough resource on the specified capacity reservation.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidParameter.Arns`: The specified Arns is not valid.
    /// - `InvalidOperation.NotSupportEnterpriseGroup`: The specified instance type doesn't support enterprise level security group.
    /// - `InvalidOperation.MultiGroupType`: The specified instance can't join different types of security group.
    /// - `InvalidAccountStatus.PayAmountLimitExceeded`: Your account is being restricted, because you have no default payment method or you are not authorized.
    /// - `InvalidPerformanceLevel.Malformed`: The specified parameter DataDisk.n.PerformanceLevel is not valid.
    /// - `InvalidSecurityGroup.NetworkType`: %s
    /// - `QuotaExceeded.PrepayDataDiskCapacity`: The quota of prepay data disk capacity exceeds.
    /// - `InvalidCustomInstanceType.NotSupported`: The specified custom instance type is invalid.
    /// - `InvalidOperation.EniCountExceeded`: The maximum number of eni in a enterprise security group is exceeded.
    /// - `AccountForbidden.ProductCreationLimited`: The commodity must be officially operated by Aliyun and in pay-as-you-go billing method.
    /// - `UnexpectedImageFamily.ImageIdSupplied`: The input parameter ImageFamily must be null when image id is set.
    /// - `InvalidEncrypted.NotMatchEncryptAlgorithm`: The specified parameter Encrypted must be true when EncryptAlgorithm is not empty.
    /// - `InvalidEncrypted.NotMatchKmsKeyId`: The specified parameter Encrypted must be true when KmsKeyId is not empty.
    /// - `InvalidEncryptAlgorithm.NotMatchSnapshot`: The specified parameter EncryptAlgorithm is different from the encrypt algorithm of the snapshot.
    /// - `InvalidKmsKeyId.NotMatchSnapshot`: The specified parameter KmsKeyId is different from the KmsKeyId of the snapshot.
    /// - `InvalidEncryptAlgorithm`: The specified parameter EncryptAlgorithm is not valid.
    /// - `InvalidHttpEndpoint.NotSupported`: The specified HttpEndpoint not supported, you can use enabled(default) or disabled.
    /// - `InvalidHttpTokens.NotSupported`: The specified HttpTokens not supported, you can use optional(default) or required.
    /// - `InvalidHttpPutResponseHopLimit.NotSupported`: The specified HttpPutResponseHopLimit not supported, more than 1 and less than 64 is reasonable.
    /// - `InvalidOperation.VpcHasEnabledAdvancedNetworkFeature`: The specified vpc has enabled advanced network feature.
    /// - `InvalidChargeType.CapacityReservationNotSupported`: %s
    /// - `InvalidPerformanceLevel.ValueNotSupported`: The current ZoneId or InstanceType does not support PL0 of cloud_essd.
    /// - `InvalidKMSKeyId.NotSymmetric`: The specified parameter KmsKeyId must be symmetric.
    /// - `InvalidDedicatedHostClusterId.NotFound`: The specified DedicatedHostClusterId does not exist.
    /// - `InvalidDedicatedHostClusterId.InValid`: The specified Dedicated Host Cluster is invalid.
    /// - `InvalidOperation.UserNotSupported`: Reseller user do not support purchase at the moment.
    /// - `InvalidDeploymentSetId.NotFound`: The parameter DeploymentSetId is invalid.
    /// - `MissingParameter.PrivatePoolOptionsId`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptionsId`: The specified PrivatePoolOptions.Id is invalid.
    /// - `DedicatedHostNotSupported`: DedicatedHost is not supported for PrivatePool.
    /// - `SpotNotSupported`: Spot is not supported for PrivatePool.
    /// - `ClassicNetworkNotSupported`: Classic network is not supported for PrivatePool.
    /// - `Invalid.InstanceId`: Instance does not exist.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `Invalid.InstanceType`: The InstanceType does not match the PrivatePool.
    /// - `Invalid.InstanceChargeType`: The InstanceChargeType does not match the PrivatePool.
    /// - `Invalid.ZoneId`: The ZoneId does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.NoStock`: The PrivatePool has been used up.
    /// - `InvalidPlatform.ValueNotSupported`: The Platform does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.status`: The PrivatePool is expired or inactive.
    /// - `InvalidAliUid`: The PrivatePool does not belong to the user of the Instance.
    /// - `HibernationConfigured.InstanceTypeNotSupport`: The specified instance type is not support.
    /// - `HibernationConfigured.ImageNotEncrypted`: The hibernation configured instance only support encrypted image.
    /// - `HibernationConfigured.MemorySizeTooBig`: The hibernation configured instance memory size is too big.
    /// - `InvalidSystemDiskSize.LessThanMemSize`: The specified parameter SystemDisk.Size is less than the memory size.
    /// - `InvalidCloudBoxZone.OperationNotSupported`: The cloud box zone does not support creating prepaid or encrypted resources.
    /// - `InvalidInternetMaxBandwidthOut.Malformed`: The specified parameter InternetMaxBandwidthOut is not valid.
    /// - `InvalidInternetMaxBandwidthIn.Malformed`: The specified parameter InternetMaxBandwidthIn is not valid.
    /// - `InvalidParameter.CloudboxNotSupported`: %s
    /// - `NotSupportSnapshotEncrypted.ShareImage	`: Shared snapshot creating encrypted disks with native snapshot encrypt is not supported.
    /// - `QuotaExceed.DiskCapacity`: The used capacity of disk type has exceeded the quota in the zone,  %s.
    /// - `InvalidParameter.DataEncryptedKeyCreateFailed`: Create kms data encrypted key fail. If you need further assistance, you can contact the KMS Technical Support.
    /// - `InvalidDiskCategory.NotSupported`: The specified disk category is not supported.
    /// - `InvalidDestinationZone.DeploymentSetMismatch`: Error happened, %s.
    /// - `NoPermission.Price`: The operation requires price permission. Please either apply for permission from your main account, or set the parameter AutoPay as true.
    /// - `InvalidParameter.DedicatedRegionNotSupported`: The specified action is rejected  because the specified ECS instance in the dedicated region does not support public IP.
    /// - `InvalidParameter.KmsNotEnabled`: Failed to perform this operation because KMS is not activated.
    /// - `InvalidParameter.Encrypted.KmsNotEnable`: Failed to perform this operation because KMS is not activated.
    /// - `InvalidParam.EncryptedMismatch`: Creating encrypted disks with shared encrypted image requires replacing encryption keys.
    /// - `InvalidParameter.Encrypted`: Creating non-encrypted disks with encrypted snapshots is not supported.
    /// - `QuotaExceeded.InternetBandwidth`: %s.
    /// - `InvalidVSwitchId.NotFound`: The specified VSwitch does not exist in the specified region.
    /// - `OperationDenied.TestAccountRetricted`: Test-account for testing has been prohibited from creating instance in this region. Please contact 400181.
    /// - `InvalidRamRole.NotEcsRole`: The specified ram role is not authorized for ecs, please check your role policy.
    /// - `InvalidDiskCategory.NotSupported`: The specified disk category is not support the specified instance type.
    /// - `ImageNotSubscribed`: The specified image has not be subscribed.
    /// - `OperationDenied`: The specified Image is disabled or is deleted.
    /// - `InvalidSystemDiskCategory.ValueUnauthorized`: The disk category is not authorized.
    /// - `InvalidSnapshotId.NotReady`: The specified snapshot has not completed yet.
    /// - `InstanceDiskCategoryLimitExceed`: The total size of specified disk category in an instance exceeds.
    /// - `InvalidDevice.InUse`: The specified device has been occupied.
    /// - `ImageRemovedInMarket`: The specified market image is not available, Or the specified user defined image includes product code because it is based on an image subscribed from marketplace, and that image in marketplace includeing exact the same product code has been removed.
    /// - `CategoryNotSupported`: The specified zone does not offer the specified disk category.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone; try other types of resources or other regions and zones.
    /// - `QuotaExceed.PortableCloudDisk`: The quota of portable cloud disk exceeds.
    /// - `SecurityGroupInstanceLimitExceed`: The maximum number of instances in a security group is exceeded.
    /// - `NodeControllerUnavailable`: The Node Controller is temporarily unavailable.
    /// - `RegionUnauthorized`: There is no authority to create instance in the specified region.
    /// - `InvalidSnapshotId.NotDataDiskSnapshot`: The specified snapshot is system disk snapshot.
    /// - `DeleteWithInstance.Conflict`: The specified disk is not a portable disk and cannot be set to DeleteWithInstance attribute.
    /// - `InstanceDiskNumLimitExceed`: The number of specified disk in an instance exceeds.
    /// - `IoOptimized.NotSupported`: The specified image is not support IoOptimized Instance.
    /// - `ImageNotSupportInstanceType`: The specified image don't support the InstanceType instance.
    /// - `InvalidDiskSize.TooSmall`: Specified disk size is less than the size of snapshot.
    /// - `InvalidDiskCategory.Mismatch`: The specified disk categories combination is not supported.
    /// - `QuotaExceed.BuyImage`: The specified image is from the image market, You have not bought it or your quota has been exceeded.
    /// - `InvalidVSwitchId.NotFound`: The VSwitchId provided does not exist in our records.
    /// - `InvalidParameter.ResourceOwnerAccount`: ResourceOwnerAccount is Invalid.
    /// - `InvalidUserData.Forbidden`: User not authorized to input the parameter "UserData", please apply for permission "UserData".
    /// - `Zone.NotOpen`: The specified zone is not granted to you to buy resources yet.
    /// - `Zone.NotOnSale`: The specified zone is not available for purchase.
    /// - `InvalidClusterId.NotFound`: The specified clusterId does not exist.
    /// - `InvalidResourceType.NotSupported`: %s
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidInstanceType.ZoneNotSupported`: The specified zone does not support this instancetype.
    /// - `InvalidPayMethod`: The specified pay method is not valid.
    /// - `OperationDenied.ImageNotValid`: The specified Image is disabled or is deleted.
    /// - `InvalidUserData.Base64FormatInvalid`: The specified UserData is not valid.
    /// - `InstanceType.Offline`: %s
    /// - `DependencyViolation.WindowsInstance`: The instance creating is window, cannot use ssh key pair to login.
    /// - `RealNameAuthenticationError`: Your account has not passed the real-name authentication yet.
    /// - `InvalidNetworkType.MismatchRamRole`: Ram role cannot be applied to instances of Classic network type.
    /// - `InvalidUser.PassRoleForbidden`: The RAM user does not have the privilege to pass a RAM role.
    /// - `InvalidImage.NotSupported`: The specified image does not support vSGX instance.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `IncorrectVpcStatus`: Current VPC status does not support this operation.
    /// - `InvalidParameter.NotMatch`: %s
    /// - `OperationDenied.InvalidNetworkType`: %s
    /// - `InvalidSpotInterruptionBehavior.ClassicNetworkNotSupport`: The specified SpotInterruptionBehavior does not support Classic network Instance.
    /// - `InvalidSpotInterruptionBehavior.LocalDiskNotSupport`: The specified SpotInterruptionBehavior does not support local disk instance.
    /// - `QuotaExceed.PostPaidDisk`: Living postPaid disks quota exceeded.
    /// - `QuotaExceed.DeploymentSetInstanceQuotaFull`: Instance quota in one deployment set exceeded.
    /// - `InvalidVSwitch.DefaultVSwitchNotSupport`: The specified zone in vpc can't support create default vSwitch.
    /// - `OperationDenied.LocalDiskUnsupported`: The configuration change is not allowed when the specified instance has local disks mounted.
    /// - `OperationDenied.InconsistentNetwork`: The specified security group and vswitch are not in the same vpc.
    /// - `DefaultVswitch.Existed`: The default vswitch for VPC already exists.
    /// - `InvalidChargeType.ValueNotSupported`: Deletion protection is only valid for postPaid instance, not for prePaid or spot instance.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `CategoryViolation`: The specified instance does not support this operation because of its disk category.
    /// - `ResourcesNotInSameZone`: The specified instance and dedicated host are not in the same zone.
    /// - `InvalidRegion.NotSupport`: The specified region does not support byok.
    /// - `UserNotInTheWhiteList`: The user is not in byok white list.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `SecurityRisk.3DVerification`: We have detected a security risk with your default credit or debit card. Please proceed with verification via the link in your email.
    /// - `InvalidDisk.SystemDiskSize`: The specified SystemDiskSize beyond the permitted range.
    /// - `InsufficientBalance`: Your account does not have enough balance.
    /// - `Mayi.InternalError`: The request processing has failed due to some unknown error.
    /// - `InvalidNetworkType`: The network type is not support in this region.
    /// - `InvalidAccountStatus`: Your account status is invalid, please contact customer service.
    /// - `QuotaExceeded.PrivateIpAddress`: %s
    /// - `InvalidVSwitchId.IpInvalid`: %s
    /// - `OperationDenied.PerformanceLevelNotMatch`: The specified DataDisk.n.PerformanceLevel and DataDisk.n.Size do not match.
    /// - `InvalidStorageSetName.Malformed`: Specified parameter StorageSetName is not valid.
    /// - `InvalidDescription.Malformed`: Specified parameter Description is not valid.
    /// - `InvalidMaxPartitionNumber.Malformed`: Specified parameter MaxPartitionNumber is not valid.
    /// - `InvalidParameter.StorageSetPartitionNumber`: Specified parameter StorageSetPartitionNumber is not valid.
    /// - `InvalidParameter.StorageSetId`: Specified parameter StorageSetId is not valid.
    /// - `InvalidParameter.StorageSetZoneId`: Specified parameter StorageSetZoneId is not valid.
    /// - `QuotaExceed.Tags`: %s
    /// - `OperationDenied.RegionIdNotSupported`: Region not support spot duration instance.
    /// - `OperationDenied.FlavorNotSupported`: Flavor not support spot duration instance.
    /// - `OperationDenied.TimestampNotSupported`: Timestamp not support spot duration instance.
    /// - `OperationDenied.PrepayNotAvailable`: Prepay instance is not available now.
    /// - `OperationDenied.PaygNotAvailable`: Pay-as-you-go instance is not available now.
    /// - `EnterpriseGroupLimited.MutliGroupType`: The specified instance can not join multi SecurityGroup types.
    /// - `EnterpriseGroupLimited.InstanceType`: The specified instance type does not support Enterprise SecurityGroup.
    /// - `InternalError.AllocateUnderlayIp`: Allocate underlay ip for the instance error.
    /// - `OperationDenied.BidOwnResource`: Bid user can not own resource.
    /// - `OperationDenied.CloudSSDNotSupported`: The specified available zone does not offer the cloud_ssd disk, use cloud_essd instead.
    /// - `InvalidVPCStatus.NotWorking`: The specified VPC subnet status is not working.
    /// - `QuotaExceed.ElasticQuota`: No additional quota is available for the specified ECS instance type.
    /// - `QuotaExceeded.PostpaidDataDiskCapacity`: The quota of postpaid data disk capacity exceeds.
    /// - `InvalidImageFamily.MissingAvailableImage`: There is no available image related to the specified image family.
    /// - `InvalidRegionId.NotSupportEncryptAlgorithm`: The current region does not support creating encrypted disks with EncryptAlgorithm.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `Forbidden.OnlySupportEnterpriseGroup`: %s
    /// - `HibernationConfigured.InstanceOperationForbidden`: The operation is not permitted due to limit of the hibernation configured instance.
    /// - `InstanceDiskLimitExceeded`: The amount of the disk on instance reach its limits.
    /// - `InvalidInstanceType.NotSupportDiskCategory`: The instanceType of the specified instance does not support this disk category.
    /// - `NotSupportSnapshotEncrypted.DiskCategory`: The specified disk category does not support creating encrypted system disks or creating encrypted data disks from snapshots. Check the DiskCategory or Encrypted parameter, or check your account for default encryption settings.
    /// - `InvalidOperation.PublicIpAddressNoStock`: The public IP address for the specified Region or ChargeType of the instance is out of stock. Please try another Region or ChargeType.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.
    /// - `InvalidEncrypted.NotMatchDiskDefaultEncryption`: Enabling disk default encryption prevents the creation of non-encrypted disks.
    /// - `InvalidEncrypted.NotMatchSnapshot`: The specified parameter Encrypted must be set to true when creating disks with encrypted snapshots.
    /// - `InvalidStorageClusterId.NotExist`: The specified StorageClusterId does not exist in current region.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `IoOptimized.NotSupported`: The specified instancetype is not support IoOptimized instance.
    /// - `InvalidZoneId.NotFound`: The ZoneId provided does not exist in our records.
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `InvalidDataDiskSnapshotId.NotFound`: The specified parameter "DataDisk.n.SnapshotId" is not valid.
    /// - `InvalidClusterId.NotFound`: The ClusterId provided does not exist in our records.
    /// - `OperationDenied`: The specified Image is disabled or is deleted.
    /// - `InvalidVSwitchId.NotFound`: Specified virtual switch does not exist.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.
    /// - `InvalidInstanceChargeType.NotFound`: The InstanceChargeType does not exist in our records.
    /// - `DependencyViolation.IoOptimized`: The specified instancetype must be IoOptimized instance.
    /// - `PaymentMethodNotFound`: No payment method has been registered on the account.
    /// - `HOSTNAME_ILLEGAL`: The specified parameter Hostname is not valid.
    /// - `InvalidSystemDiskSize.LessThanImageSize`: The specified parameter SystemDisk.Size is less than the image size.
    /// - `InvalidSystemDiskSize.LessThanMinSize`: The specified parameter SystemDisk.Size is less than the min size.
    /// - `InvalidSystemDiskSize.MoreThanMaxSize`: The specified SystemDisk.Size parameter exceeds the maximum size.
    /// - `InvalidParameter`: The specified vm bandwidth is not valid.
    /// - `InvalidSystemDiskSize`: The specified parameter SystemDisk.Size is invalid.
    /// - `InvalidKeyPairName.NotFound`: The specified parameter KeyPairName does not exist in our records.
    /// - `InvalidRamRole.NotFound`: The specified RAMRoleName does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InvalidMarketImage.NotFound`: The specified marketplace image does not exist, please change the imageId and try again.
    /// - `DeploymentSet.NotFound`: The specified deployment set does not exist.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidParameter.KMSKeyId.NotFound`: The specified KMSKeyId does not exist.
    /// - `InvalidDiskIds.NotPortable`: The specified DiskId is not portable.
    /// - `OperationConflict`: Request was denied due to conflict with a previous request,please try again later.
    /// - `Throttling.Resource`: The request throttle by resource operation.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `InvalidImage.OSType`: The image OSType does not support this instance type.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_instance(
        &self,
        req: CreateInstance,
    ) -> impl std::future::Future<Output = crate::Result<CreateInstanceResponse>> + Send {
        self.call(req)
    }

    /// # 启动实例
    ///
    /// 本接口用于启动一台ECS实例，您可以通过指定实例ID以及按需设置 InitLocalDisk 等参数启动实例。
    ///
    /// 该接口为异步接口，实例的启动不是立即完成的，成功调用后，实例会先进入启动中（Starting）状态，你可以调用[DescribeInstanceStatus](~~2679688~~)查看实例状态，当返回的状态为`Running`时代表启动成功。
    ///
    /// ### 使用须知
    /// - 被安全锁定的实例不能通过调用该接口启动。更多信息，请参见[资源安全锁定对调用API的影响](~~25695~~)。
    /// - ECS实例状态必须为**已停止**（`Stopped`）。
    /// - 节省停机模式下可能会因为库存不足导致启动失败。
    ///
    /// # Error Codes
    /// - `LackResource`: There's no enough resource on the specified capacity reservation.
    /// - `InvalidDedicatedHost.NotEnoughResource`: The specified dedicated host has not enough resource due to host affinity.
    /// - `InvalidInstance.NotFoundSystemDisk`: The specified instance does not have system disk.
    /// - `Invalid.PrivatePoolOptions.NoStock`: The PrivatePool has been used up.
    /// - `InvalidParameter.KMSKeyId.NotFound`: The specified KMSKeyId does not exist.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `InsufficientBalance`: Your account does not have enough balance.
    /// - `DiskError`: IncorrectDiskStatus.
    /// - `InstanceExpired`: The postPaid instance has been expired.Please ensure your account have enough balance.
    /// - `InstanceNotReady`: The specified instance is not ready for use.
    /// - `DiskInArrears`: The specified operation is denied as your disk has expired.
    /// - `OperationDenied.SpotPriceLowerThanPublicPrice`: The spot instance price is lower than public price.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK needs to be added ECS tag.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be enabled.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `QuotaExceed.ElasticQuota`: No additional quota is available for the specified ECS instance type.
    /// - `OperationDenied.HostRepairing`: The specified operation is denied as the host of ECS instance is being repaired.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone, try other types of resources or other regions and zones.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidCapacityReservationId.NotFound`: The specified capacity reservation does not exist.
    /// - `InstanceNotReady`: The specified instance is not ready for use.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `ServiceUnavailable`: The request has failed due to a temporary failure of the server.
    /// - `LimitedOperation.ServiceUnavailable`: The service is currently unavailable. Please try again later.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn start_instance(
        &self,
        req: StartInstance,
    ) -> impl std::future::Future<Output = crate::Result<StartInstanceResponse>> + Send {
        self.call(req)
    }

    /// # 批量启动实例
    ///
    /// 本接口用于批量启动 ECS 实例，支持通过设置参数来选择不同的批量操作模式，为您提供灵活的启动方式。
    ///
    /// 该接口为异步接口，实例的启动不是立即完成的，成功调用后，实例会先进入启动中（Starting）状态，你可以调用[DescribeInstanceStatus](~~2679688~~)查看实例状态，当返回的状态为`Running`时代表启动成功。
    ///
    /// ### 使用须知
    /// - 被安全锁定的实例不能通过调用该接口启动。更多信息，请参见[资源安全锁定对调用API的影响](~~25695~~)。
    /// - ECS实例状态必须为**已停止**（`Stopped`）。
    /// - 节省停机模式下可能会因为库存不足导致启动失败。
    ///
    /// # Error Codes
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be added ECS tag
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service account have no right to access your KMS.
    /// - `DRYRUN.SUCCESS`: This request is a dryrun request with successful result.
    /// - `Invalid.PrivatePoolOptions.NoStock`: The PrivatePool has been used up.
    /// - `InvalidInstanceId.NotFound`: InstanceId should not be null.
    /// - `InvalidParameter.TooManyInstanceIds`: Instance ids cannot be more than 100.
    /// - `Abs.InvalidInstanceIds.MalFormed`: The specified instanceIds is not valid.
    /// - `InstanceExpired`: %s
    /// - `InstanceLockedForSecurity`: %s
    /// - `InstanceExpiredOrInArrears`: %s
    /// - `IncorrectInstanceStatus`: %s
    /// - `InvalidInstance.NotFoundSystemDisk`: %s
    /// - `OperationDenied.SpotPriceLowerThanPublicPrice`: The spot instance price is lower than public price.
    /// - `InsufficientBalance`: Your account does not have enough balance.
    /// - `InstanceNotReady`: The specified instance is not ready for use.
    /// - `OperationDenied.HostRepairing`: %s
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone, try other types of resources or other regions and zones.
    /// - `InvalidInstanceId.NotFound`: %s
    /// - `InvalidInstanceIds.NotFound`: The specified InstanceIds does not exist.
    /// - `InvalidOperation.Conflict`: Request was denied due to conflict with a previous request, please try again later.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `LimitedOperation.ServiceUnavailable`: The service is currently unavailable. Please try again later.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn start_instances(
        &self,
        req: StartInstances,
    ) -> impl std::future::Future<Output = crate::Result<StartInstancesResponse>> + Send {
        self.call(req)
    }

    /// # 停止实例
    ///
    /// 本接口用于停止一台ECS实例，支持选择不同的停机方式、停机模式以及批量操作模式停止实例。
    ///
    /// 该接口为异步接口，实例的停止不是立即完成的，成功调用后，实例会先进入停止中（Stoping）状态，你可以调用[DescribeInstanceStatus](~~2679688~~)查看实例状态，当返回的状态为`Stopped `时代表启动成功。
    ///
    /// ### 使用须知
    /// - 被安全锁定的实例不能通过调用该接口停止。更多信息，请参见[资源安全锁定对调用API的影响](~~25695~~)。
    /// - 开启VPC内实例节省停机模式后，您可以通过设置`StoppedMode=KeepCharging`开启普通停机模式，ECS实例停止后会继续计费，并为您保留ECS实例规格库存和公网IP地址。
    ///
    /// # Error Codes
    /// - `InvalidParameter.Encrypted.KmsNotEnable`: Failed to perform this operation because KMS is not activated.
    /// - `DiskError`: IncorrectDiskStatus.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `InstanceType.ParameterMismatch`: The input parameter ConfirmStop must be true when an instance have localstorage.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `InvalidInstanceId.NotSupport`: Classic network Instance  does not support this operation.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK needs to be added ECS tag
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be enabled.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `HibernationConfigured.InstanceOperationForbidden`: The operation is not permitted due to limit of the hibernation configured instance.
    /// - `HibernationConfigured.NotEnabled`: The instance hibernation configured option is not enabled.
    /// - `InvalidOperation.KMSKeyIdNotFound`: The specified KMSKeyId not found, %s.
    /// - `InvalidOperation.KMSServiceNotOpen`: KMS service is currently not open.
    /// - `OperationDenied.SystemInstanceNotSupport`: The system instance does not support the %s operation because %s.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `LimitedOperation.ServiceUnavailable`: The service is currently unavailable. Please try again later.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn stop_instance(
        &self,
        req: StopInstance,
    ) -> impl std::future::Future<Output = crate::Result<StopInstanceResponse>> + Send {
        self.call(req)
    }

    /// # 批量停止实例
    ///
    /// 本接口用于停止一台或多台 ECS 实例，支持选择不同的停机方式、停机模式以及批量操作模式停止实例。
    ///
    /// 该接口为异步接口，实例的停止不是立即完成的，成功调用后，实例会先进入停止中（Stoping）状态，你可以调用[DescribeInstanceStatus](~~2679688~~)查看实例状态，当返回的状态为`Stopped `时代表停止成功。
    /// ### 使用须知
    /// - 停止实例后实例不可用，请确认停止实例不会对您的业务造成影响。您可以调用[StartInstance](~~2679679~~)或 [StartInstances](~~2679680~~)接口启动实例。
    /// - 被安全锁定的实例不能通过调用该接口停止。更多信息，请参见[资源安全锁定对调用API的影响](~~25695~~)。
    ///
    /// # Error Codes
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be added ECS tag
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service account have no right to access your KMS.
    /// - `DRYRUN.SUCCESS`: This request is a dryrun request with successful result.
    /// - `InvalidParameter.Encrypted.KmsNotEnable`: Failed to perform this operation because KMS is not activated.
    /// - `InvalidInstanceId.NotFound`: InstanceId should not be null.
    /// - `InvalidParameter.TooManyInstanceIds`: Instance ids cannot be more than 100.
    /// - `Abs.InvalidInstanceIds.MalFormed`: The specified instanceIds is not valid.
    /// - `InstanceLockedForSecurity`: %s
    /// - `InstanceExpiredOrInArrears`: %s
    /// - `IncorrectInstanceStatus`: %s
    /// - `InvalidInstanceId.NotSupport`: %s
    /// - `InsufficientBalance`: Your account does not have enough balance.
    /// - `InstanceNotReady`: The specified instance is not ready for use.
    /// - `InvalidOperation.KMSKeyIdNotFound`: The specified KMSKeyId not found, %s.
    /// - `InvalidOperation.KMSServiceNotOpen`: KMS service is currently not open.
    /// - `OperationDenied.SystemInstanceNotSupport`: The system instance does not support the %s operation because %s.
    /// - `InvalidInstanceId.NotFound`: %s
    /// - `InvalidInstanceIds.NotFound`: The specified InstanceIds does not exist.
    /// - `InvalidOperation.Conflict`: Request was denied due to conflict with a previous request, please try again later.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `LimitedOperation.ServiceUnavailable`: The service is currently unavailable. Please try again later.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn stop_instances(
        &self,
        req: StopInstances,
    ) -> impl std::future::Future<Output = crate::Result<StopInstancesResponse>> + Send {
        self.call(req)
    }

    /// # 重启实例
    ///
    /// 本接口用于重启一台ECS实例。
    ///
    /// 该接口为异步接口，实例的重启不是立即完成的，成功调用后，实例会先进入启动中（`Starting`）状态，你可以调用[DescribeInstanceStatus](~~2679688~~)查看实例状态，当返回的状态为`Running`时代表重启成功。
    ///
    /// ### 使用须知
    /// - 被安全锁定的实例不能通过调用该接口重启。更多信息，请参见[资源安全锁定对调用API的影响](~~25695~~)。
    /// - 您只能重启状态为**运行中**（`Running`）的ECS实例。
    ///
    /// # Error Codes
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `DiskError`: IncorrectDiskStatus.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: %s
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: %s
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: %s
    /// - `InvalidParameter.KMSKeyId.NotFound`: %s
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `LimitedOperation.ServiceUnavailable`: The service is currently unavailable. Please try again later.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn reboot_instance(
        &self,
        req: RebootInstance,
    ) -> impl std::future::Future<Output = crate::Result<RebootInstanceResponse>> + Send {
        self.call(req)
    }

    /// # 批量重启实例
    ///
    /// 本接口用于重启一台或多台ECS实例，支持您通过参数来选择是否强制重启和设置不同的批量操作模式。
    ///
    /// 该接口为异步接口，实例的重启不是立即完成的，成功调用后，实例会先进入启动中（`Starting`）状态，你可以调用[DescribeInstanceStatus](~~2679688~~)查看实例状态，当返回的状态为`Running`时代表重启成功。
    ///
    /// ### 使用须知
    /// - 被安全锁定的实例不能通过调用该接口重启。更多信息，请参见[资源安全锁定对调用API的影响](~~25695~~)。
    /// - ECS实例的状态必须为**运行中**（`Running`）。
    ///
    /// # Error Codes
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be added ECS tag
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service account have no right to access your KMS.
    /// - `DRYRUN.SUCCESS`: This request is a dryrun request with successful result.
    /// - `InvalidInstanceId.NotFound`: InstanceId should not be null.
    /// - `InvalidParameter.TooManyInstanceIds`: Instance ids cannot be more than 100.
    /// - `Abs.InvalidInstanceIds.MalFormed`: The specified instanceIds is not valid.
    /// - `InstanceLockedForSecurity`: %s
    /// - `InstanceExpiredOrInArrears`: %s
    /// - `IncorrectInstanceStatus`: %s
    /// - `InvalidInstance.NotFoundSystemDisk`: %s
    /// - `InsufficientBalance`: Your account does not have enough balance.
    /// - `InstanceNotReady`: The specified instance is not ready for use.
    /// - `InvalidInstanceId.NotFound`: %s
    /// - `InvalidInstanceIds.NotFound`: The specified InstanceIds does not exist.
    /// - `InvalidOperation.Conflict`: Request was denied due to conflict with a previous request, please try again later.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `LimitedOperation.ServiceUnavailable`: The service is currently unavailable. Please try again later.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn reboot_instances(
        &self,
        req: RebootInstances,
    ) -> impl std::future::Future<Output = crate::Result<RebootInstancesResponse>> + Send {
        self.call(req)
    }

    /// # 删除实例
    ///
    /// 删除或者释放一台指定的ECS实例。
    ///
    /// ><warning>
    /// 释放实例后，实例所使用的物理资源会被回收，相关数据全部丢失且不可恢复。
    /// ></warning>
    ///
    /// - 云盘的手动快照会被保留并继续计费，您可以通过[DeleteSnapshot](~~2679824~~)删除。
    /// - 实例上挂载的云盘和自动快照是否被释放取决于创建时的参数设置。释放实例之前，您可以通过[DescribeDisks](~~2679767~~)、[ModifyDiskAttribute](~~2679770~~)查询和修改相关参数设置：
    ///   - `DeleteWithInstance=false`，云盘会被转换成按量付费云盘而保留下来，否则会随实例被释放。
    ///   - `DeleteAutoSnapshot=false`，自动快照被保留，否则会随实例被释放。
    /// - 弹性公网IP（EIP）不会随实例被释放，您可以通过[ReleaseEipAddress](~~448702~~)释放。
    /// ><notice>被安全锁定的实例，即使云盘的`DeleteWithInstance`参数设置为`false`，释放实例时也会忽略这个属性而释放云盘。></notice>
    ///
    /// # Error Codes
    /// - `DependencyViolation.SLBConfiguring`: Specified operation is denied as your instance is using by another product.
    /// - `DependencyViolation.RouteEntry`: Specified instance is used by route entry.
    /// - `InvalidParameter`: The input parameter InstanceId is invalid.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `ChargeTypeViolation`: The operation is not permitted due to charge type of the instance.
    /// - `IncorrectInstanceStatus.Initializing`: The specified instance status does not support this operation.
    /// - `InvalidOperation.DeletionProtection`: %s
    /// - `InvalidOperation.EniLinked`: %s
    /// - `OperationDenied.SystemInstanceNotSupport`: The system instance does not support the %s operation because %s.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_instance(
        &self,
        req: DeleteInstance,
    ) -> impl std::future::Future<Output = crate::Result<DeleteInstanceResponse>> + Send {
        self.call(req)
    }

    /// # 批量删除实例
    ///
    /// 本接口用于批量删除或者释放按量付费实例或者到期的包年包月实例，支持通过参数设置决定云盘是否释放或转换为按量付费保留。
    ///
    /// ><warning>
    /// 释放实例后，实例所使用的物理资源会被回收，相关数据全部丢失且不可恢复。
    /// ></warning>
    ///
    /// - 云盘的手动快照会被保留并继续计费，您可以通过[DeleteSnapshot](~~2679824~~)删除。
    /// - 实例上挂载的云盘和自动快照是否被释放取决于创建时的参数设置。释放实例之前，您可以通过[DescribeDisks](~~2679767~~)、[ModifyDiskAttribute](~~2679770~~)查询和修改相关参数设置：
    ///   - `DeleteWithInstance=false`，云盘会被转换成按量付费云盘而保留下来，否则会随实例被释放。
    ///   - `DeleteAutoSnapshot=false`，自动快照被保留，否则会随实例被释放。
    /// - 弹性公网IP（EIP）不会随实例被释放，您可以通过[ReleaseEipAddress](~~448702~~)释放。
    /// ><notice>被安全锁定的实例，即使云盘的`DeleteWithInstance`参数设置为`false`，释放实例时也会忽略这个属性而释放云盘。></notice>
    ///
    /// # Error Codes
    /// - `InvalidParameter.CrossRegionNotSupport`: Instances of multiple regions not support.
    /// - `DRYRUN.SUCCESS`: This request is a dryrun request with successful result.
    /// - `DependencyViolation.SLBConfiguring`: Specified operation is denied as your instance is using by another product.
    /// - `DependencyViolation.RouteEntry`: Specified instance is used by route entry.
    /// - `InvalidParameter.TooManyInstanceIds`: Instance ids cannot be more than 100.
    /// - `InvalidInstanceIds.ValueNotSupported`: The specified instanceIds is not valid.
    /// - `InvalidOperation.DeletionProtection`: The operation is not allowed due to deletion protection.
    /// - `ChargeTypeViolation`: %s
    /// - `IncorrectInstanceStatus.Initializing`: %s
    /// - `InvalidOperation.EniLinked`: %s
    /// - `IncorrectInstanceStatus`: %s
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `OperationDenied.SystemInstanceNotSupport`: The system instance does not support the %s operation because %s.
    /// - `InvalidInstanceIds.NotFound`: The specified InstanceIds does not exist.
    /// - `InvalidInstanceId.NotFound`: %s
    /// - `InvalidParameter`: Invalid parameters.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_instances(
        &self,
        req: DeleteInstances,
    ) -> impl std::future::Future<Output = crate::Result<DeleteInstancesResponse>> + Send {
        self.call(req)
    }

    /// # 查询实例的状态信息列表
    ///
    /// 本接口主要用于查询一台或多台指定ECS实例的状态信息，同时支持查询指定条件下的实例列表。
    ///
    /// ECS实例的生命周期状态请参见[实例状态表](~~25687~~)。
    ///
    /// ## 请求示例
    /// - 根据**指定地域**查询实例以及状态信息，入参示例：
    /// ```ignore
    /// "RegionID": "cn-hangzhou"
    /// ```
    ///
    /// - 根据**指定地域**下的**某个可用区**查询实例以及状态信息，入参示例：
    /// ```ignore
    /// "RegionID": "cn-hangzhou",
    /// "ZoneID": "cn-hangzhou-a"
    /// ```
    ///
    /// - 根据**指定地域**和**实例ID**查询实例对应状态信息，入参示例：
    /// ```ignore
    /// "RegionID": "cn-hangzhou",
    /// "InstancesID": ["i-bp1f7c1zqp999zvp****", "i-bp1dqjv36biueg61****"]
    /// ```
    ///
    /// # Error Codes
    /// - `InvalidParameter.TooManyInstanceIds`: Instance ids cannot be more than 100.
    /// - `Abs.InvalidInstanceIds.MalFormed`: The specified instanceIds is not valid.
    /// - `InvalidZoneId.NotFound`: The ZoneId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_status(
        &self,
        req: DescribeInstanceStatus,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstanceStatusResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询实例的详细信息列表
    ///
    /// 本接口支持根据不同请求条件查询实例列表，并关联查询实例的详细信息。
    ///
    /// ### 使用须知
    /// - 通过阿里云CLI调用API时，不同数据类型的请求参数取值必须遵循格式要求。更多信息，请参见[CLI参数格式说明](~~110340~~)。
    /// - 如果您使用的是RAM用户账号或者RAM角色，当用户或者角色缺乏接口权限时，将会返回空列表。
    ///
    /// ### 使用建议
    /// - 通过请求参数DryRun发送预检请求，可以检查参数有效性和授权情况。
    /// - 分页查询首页时，仅需设置`MaxResults`以限制返回信息的条目数，返回结果中的`NextToken`值将作为查询后续页的凭证。查询后续页时，将`NextToken`参数设置为上一次返回结果中获取到的`NextToken`值作为查询凭证，并设置`MaxResults`限制返回条目数。
    ///
    /// # Error Codes
    /// - `InvalidTag.Mismatch`: The specified Tag.n.Key and Tag.n.Value are not match.
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `InvalidHpcClusterId.NotFound`: The specified HpcClusterId is not found.
    /// - `InvalidHpcClusterId.Creating`: The specified HpcClusterId is creating.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.
    /// - `InvalidInstanceChargeType.NotFound`: The InstanceChargeType does not exist in our records.
    /// - `InvalidInternetChargeType.ValueNotSupported`: The specified InternetChargeType is not valid.
    /// - `InvalidLockReason.NotFound`: The specified LockReason is not found.
    /// - `InvalidFilterKey.NotFound`: Invalid filter.%s.
    /// - `InvalidFilterValue`: Invalid filter.%s.
    /// - `InvalidNetworkType.NotFound`: The specified InstanceNetworkType is not found.
    /// - `InvalidStatus.NotFound`: The specified Status is not found.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instances(
        &self,
        req: DescribeInstances,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstancesResponse>> + Send {
        self.call(req)
    }

    /// # 查询实例规格族列表
    ///
    /// 本接口用于查询阿里云 ECS提供的实例规格族列表。通过该接口获取不同系列的实例规格族信息，从而更好地帮助您了解可用的实例规格资源，为您选择合适的实例规格创建 ECS 实例提供参考。
    ///
    /// # Error Codes
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_type_families(
        &self,
        req: DescribeInstanceTypeFamilies,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstanceTypeFamiliesResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询实例规格信息列表
    ///
    /// 本接口主要用于查询云服务器ECS提供的所有实例规格的信息列表并关联获取实例规格的详细信息，也可根据特定条件查询指定实例规格的信息，帮助您了解不同实例规格的配置和性能，以便选择适合自己业务需求的实例。
    ///
    /// - **分页查询**：您可以设置MaxResults参数以限制返回值中实例规格的条目数，如果只返回了部分被查询到的实例规格的条目数，则会同步返回NextToken参数值。再次调用该接口，设置上次调用该接口返回的NextToken参数值以及MaxResults参数，以实现分页查询实例规格信息。
    ///
    /// - 若您调用该API时未传入NextToken参数进行分页获取，默认只返回第一页（不超过100条）数据，若需要更多数据，请您传入NextToken进行分页获取或传入过滤条件来限制返回的数据范围。
    ///
    /// >  MaxResults（每页最大条目数）参数的最大值为100，对于在2022年调用过本API的用户，MaxResults参数的最大值仍为1600，在2023年11月15日及之后，我们将对所有用户的MaxResults参数的最大值缩小到100，不再支持1600。
    ///
    /// - DescribeInstanceTypes仅查询实例规格的配置和性能信息。如果您需要查询具体地域下可购买的实例规格，请使用[DescribeAvailableResource](~~66186~~)。
    ///
    /// <props="china">
    /// - 如果您需要使用非售卖可见的实例规格或特别的规格需求，请[提交工单](https://selfservice.console.aliyun.com/ticket/createIndex)。
    ///   </props>
    ///
    /// <props="intl">
    /// - 如果您需要使用非售卖可见的实例规格或特别的规格需求，请[提交工单](https://smartservice.console.aliyun.com/service/create-ticket-intl)。
    /// </props>
    ///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_types(
        &self,
        req: DescribeInstanceTypes,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstanceTypesResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询实例属性信息
    ///
    /// 本接口用于查询一台指定ECS实例的属性信息。
    ///
    /// # Error Codes
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_attribute(
        &self,
        req: DescribeInstanceAttribute,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstanceAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改实例属性信息
    ///
    /// 本接口用于修改一台ECS实例的部分属性信息，支持修改密码、实例名称、主机名、所属安全组、实例的MTU以及用户自定义数据等。
    ///
    /// 被安全锁定的实例不支持调用该接口。更多信息，请参见[资源安全锁定对调用API的影响](~~25695~~)。
    ///
    /// # Error Codes
    /// - `InvalidInstanceName.Malformed`: The specified parameter "InstanceName" is not valid.
    /// - `InvalidDescription.Malformed`: The specified parameter "Description" is not valid.
    /// - `InvalidRemoteConnectionOptions.Password`: The remote connection password is invalid.
    /// - `InvalidRemoteConnectionOptions.Type`: The remote connection type is invalid.
    /// - `InstanceType.ValueNotSupported`: The instance type not supported.
    /// - `OSType.ValueNotSupported`: The OS type is not supported.
    /// - `InvalidHostPassword.Malformed`: The specified parameter "Password" is not valid.
    /// - `InvalidHostName.Malformed`: The specified parameter "HostName" is not valid.
    /// - `InvalidPassword.Malformed`: The specified parameter "Password" is not valid.
    /// - `InvalidUserData.SizeExceeded`: The specified parameter "UserData" exceeds the size.
    /// - `InvalidUserData.NotSupported`: TThe specified parameter "UserData" only support the vpc and IoOptimized Instance.
    /// - `ImageNotSupportCloudInit`: The specified image does not support cloud-init.
    /// - `ChargeTypeViolation`: Pay-As-You-Go instances do not support this operation.
    /// - `InvalidParameter.RecycleBin`: You do not have permission to set recyclable properties.
    /// - `InvalidParameter.CreditSpecification`: The specified CreditSpecification is not supported in this region.
    /// - `InvalidInstanceStatus.CreditSpecRestricted`: The current status of the resource does not support this operation.
    /// - `InvalidInstanceStatus.NotRunning`: The current status of the resource is invalid, you can only do this operation when instance is running.
    /// - `InvalidNetworkType.NotSupported`: The classic networkType does not support to modify security group
    /// - `InvalidOperation.EniCountExceeded`: =The maximum number of eni in a enterprise security group is exceeded.
    /// - `JoinedGroupLimitExceed`: %s
    /// - `InvalidParameter`: The specified parameter is not valid.
    /// - `InvalidOperation.InvalidEcsState`: %s
    /// - `InvalidParam.NotSupportJumboFrame`: Not support jumbo frame.
    /// - `InvalidOperation.InstanceStatusNotSupport`: The instance status is not support modify mtu config.
    /// - `InvalidOperation.InstanceStatusUnsupported`: The specified instance status does not support modification of cpu topology type.
    /// - `InvalidParameter.CpuOptionsTopologyType`: The specified parameter CpuOptions.TopologyType: %s is not valid.
    /// - `InvalidInstanceType.NotSupportCpuOptionsTopologyType`: The specified instance type does not support CpuOptions.TopologyType: %s.
    /// - `InvalidAdditionalInfoPvdConfig.SizeExceeded`: The specified parameter AdditionalInfo.PvdConfig exceeds the size.
    /// - `InvalidInstanceType.NotSupportHighDensityMode`: The specified instance type does not support the use of the high density mode.
    /// - `InvalidStatus.StoppedRequired`: The current state of the resource does not support this operation, it can only be operated in a stopped state.
    /// - `InvalidParameter.CpuOptionsTurboMode`: The specified parameter TurboMode is not valid.
    /// - `InvalidInstanceType.EnableNVSUnsupported`: The specified instance type does not support EnableNVS.
    /// - `InvalidInstanceType.EnableVISSTUnsupported`: The specified instance type does not support EnableVISST.
    /// - `InvalidInstanceType.EnableVRDTUnsupported`: The specified instance type does not support EnableVRDT.
    /// - `InvalidInstanceType.SingleCoreMaxModeUnsupported`: The specified instance type does not support TurboMode: "SINGLE CORE MAX".
    /// - `InvalidInstanceType.GpuOptionsConfidentialComputingUnsupported`: The specified instance type does not support the confidential computing mode.
    /// - `InvalidParameter.GpuOptionsConfidentialComputing`: The specified parameter confidential computing mode is not valid.
    /// - `InvalidParameterAuthorized.GpuOptionsConfidentialComputing`: The specified parameter    confidential computing mode is unauthorized.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `OperationDenied`: The instance amount in the specified SecurityGroup reach its limit.
    /// - `InvalidUserData.Forbidden`: User not authorized to input the parameter "UserData"please apply for permission "UserData"
    /// - `InvalidUserData.Base64FormatInvalid`: The specified UserData is not valid
    /// - `InvalidChargeType.ValueNotSupported`: Deletion protection is only valid for postPaid instance, not for prePaid or spot instance.
    /// - `InvalidUser.Unauthorized`: The user is not authorized
    /// - `EnterpriseGroupLimited.MutliGroupType`: The specified instance can not join multi SecurityGroup types.
    /// - `SecurityGroupInstanceLimitExceed`: %s
    /// - `InstanceNotInSecurityGroup`: The instance not in the group.
    /// - `InvalidOperation.InvalidRegion`: %s
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidParameter.InvalidEniQueueNumber`: %s
    /// - `InvalidOperation.MaxEniQueueNumberExceeded`: %s
    /// - `InvalidOperation.ExceedInstanceTypeQueueNumber`: %s
    /// - `InvalidOperation.InstanceTypeNotSupportHighPerformanceTrafficMode`: %s
    /// - `InvalidParameter.InvalidQueuePairNumber`: %s
    /// - `InvalidOperation.MaxEniQueuePairNumberExceed`: %s
    /// - `InvalidOperation.EniQueuePairNumberOverflow`: %s
    /// - `AclLimitExceed`: %s
    /// - `InvalidInstanceType.CpuOptionsThreadsPerCoreUnsupported`: The current instance type does not support setting or modifying the CpuOptions.ThreadsPerCore parameter.
    /// - `InvalidParameter.CpuOptionsCore`: The specified parameter CpuOptions.Core is not valid.
    /// - `InvalidParameter.CpuOptionsThreadsPerCore`: The specified parameter CpuOptions.ThreadsPerCore is not valid.
    /// - `InvalidOperation.UserNotSupportNetworkEncryption`: User not support network encryption.
    /// - `InvalidOperation.InstanceTypeNotSupportNetworkEncryption`: The specified instance type does not support network encryption.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `Credit.NotFound`: The specified credit information does not exist.
    /// - `InvalidInstanceStatus.NeedRestart`: The current status of the resource is invalid, you can only do this operation after instance is restarted.
    /// - `InvalidParameter.SecurityGroupIdRepeated`: The specified security group ids has repeated.
    /// - `InvalidSecurityGroupType.NotSupportClassic`: The specified SecurityGroupIds have classic group type.
    /// - `InvalidSecurityGroupVpc.NotBelongToOneVpc`: The specified SecurityGroupIds are belong to different vpc.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_attribute(
        &self,
        req: ModifyInstanceAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改实例时钟选项
    ///
    /// 按需修改实例时钟选项。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// -  当前接口是异步接口。调用后返回异步任务ID。通查查询异步任务结果来判断是否执行完成。
    ///
    /// -  修改 PtpStatus，需要对应的规格支持设置该参数。具体支持的实例规格，可以查询实例规格列表（[DescribeInstanceTypes](~~25620~~)）。
    ///
    /// # Error Codes
    /// - `InvalidInstanceId.NotFound`: The specified instanceId does not exist.
    /// - `InvalidParameter.ClientToken`: The parameter ClientToken is invalid.
    /// - `InvalidParameter.PtpStatus`: The specified parameter PtpStatus: %s is not valid.
    /// - `InvalidInstanceType.NotSupportEnablePtp`: The specified instance type does not support enable PTP.
    /// - `Abs.InvalidRegionId.MalFormed`: The specified parameter RegionId is not valid.
    /// - `InvalidOperation.PtpStatusAlreadyEnabled`: The specified instance already has PTP enabled.
    /// - `InvalidOperation.PtpStatusAlreadyDisabled`: The specified instance does not have PTP enabled.
    /// - `OperationDenied.HardwareNotSupportEnablePtp`: The hardware of the instance does not support enable PTP.
    /// - `OperationDenied.ClockPtpNoStock`: The resource of PTP is out of usage.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_clock_options(
        &self,
        req: ModifyInstanceClockOptions,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceClockOptionsResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改实例网络选项
    ///
    /// 修改实例网络选项。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// -  当前接口是异步接口。调用后返回异步任务ID。通查查询异步任务结果来判断是否执行完成。
    ///
    /// -  当前接口每次调用仅支持修改一个属性。如果修改多个属性，请分多次调用。
    ///
    /// -  修改BandwidthWeighting，需要对应的规格支持设置该参数。您可以通过[DescribeInstanceTypes](~~2679699~~)查询当前实例规格是否支持带宽权重及支持的带宽权重值。
    ///
    /// # Error Codes
    /// - `IdempotentParameterMismatch`: The request uses the same client token as a previous, but non-identical request. Do not reuse a client token with different requests, unless the requests are identical.
    /// - `InvalidInstanceType.NetworkOptionsBandwidthWeightingUnsupported`: The current instance type does not support setting or modifying the BandwidthWeighting parameter.
    /// - `InvalidParameter.NetworkOptionsBandwidthWeighting`: The specified parameter BandwidthWeighting is not valid.The correct value should be in [%s].
    /// - `InvalidInstanceId.NotFound`: Specified instance does not exist.
    /// - `LimitedOperation.ServiceUnavailable`: The service is currently unavailable. Please try again later.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_network_options(
        &self,
        req: ModifyInstanceNetworkOptions,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceNetworkOptionsResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改实例计费方式
    ///
    /// 本接口用于修改ECS实例的计费方式，支持批量修改。
    ///
    /// ### 使用须知
    /// - 请确保在使用该接口前，您已充分了解的云服务器ECS的[包年包月](~~56220~~)、[按量付费](~~40653~~)等计费方式和<props="china">[价格](https://www.aliyun.com/price/product#/ecs/detail)</props><props="intl">[价格](https://www.alibabacloud.com/product/ecs#pricing)</props>。</props>
    /// - 请确保目标实例的状态为**运行中**（`Running`）或者**已停止**（`Stopped`），并且账号无欠费。
    /// - 更换计费方式后，默认自动扣费。请确保账户余额充足，否则会生成异常订单，此时只能作废订单。如果您的账户余额不足，可以将参数`AutoPay`置为`false`，此时会生成正常的未支付订单，您可以登录[ECS管理控制台](https://ecs.console.aliyun.com/)支付。
    ///
    /// ### 注意事项
    /// - **包年包月转按量付费**：
    /// <props="china">
    ///     - 包年包月实例转按量实例的时候，新计费方式将覆盖实例的整个生命周期。您会收到修改前后的实例计费的价格差退款，退还到您的原付款渠道中，已使用的代金券将不退回。
    /// </props>
    /// <props="intl">
    ///     - 包年包月实例转按量实例的时候，新计费方式将覆盖实例的整个生命周期。您会收到修改前后的实例计费的价格差退款，退还到您的原付款渠道中，已使用的代金券将不退回。
    /// </props>
    ///     - **退款规则**：您在一个月内能自由操作的退款额度有限且不累计，消耗完退款额度后，只能等待次月转换计费方式。一次转换计费消耗的退款额度公式为**vCPU数 \*（退款天数*24±浮动小时数）**。更多信息，请参见[包年包月转按量付费](~~85517~~)。
    /// - **按量付费转包年包月**：
    ///     - 支持将实例挂载的所有按量付费数据盘同时转换为包年包月数据盘。
    ///     - 如果按量付费实例已经设置了释放时间，则不能调用该接口。更多信息，请参见[包年包月转按量付费](~~49884~~)。
    ///     - 若实例处于节省停机模式需先启动实例。
    ///
    /// # Error Codes
    /// - `InvalidInstance.UnpaidOrder`: %s
    /// - `Throttling`: Request was denied due to request throttling, try again later.
    /// - `InstanceHasProcessingConvertOrder`: %s
    /// - `InvalidParameter.InstanceIds`: The specified InstanceIds are invalid.
    /// - `InvalidParameter`: %s
    /// - `InvalidStatus.ValueNotSupported`: %s
    /// - `InvalidInstanceChargeType.ValueNotSupported`: %s
    /// - `InvalidSpotStrategy`: The specified spotStrategy is not valid.
    /// - `ExpiredInstance`: The specified instance has expired.
    /// - `InstancesIdQuotaExceed`: The maximum number of Instances is exceeded.
    /// - `InvalidClientToken.ValueNotSupported`: The ClientToken provided is invalid.
    /// - `InvalidInternetChargeType.ValueNotSupported`: %s
    /// - `ReleaseTimeHaveBeenSet`: The specified instance has been set released time.
    /// - `QuotaExceed.AfterpayInstance`: The maximum number of Pay-As-You-Go instances is exceeded: %s.
    /// - `InvalidParameter.Bandwidth`: %s
    /// - `QuotaExceed.RufundVcpu`: The maximum number of refund vcpu is exceeded: %s.
    /// - `InvalidPeriod.UnitMismatch`: The specified Period must be correlated with the PeriodUnit.
    /// - `InvalidImageType.NotSupported`: %s
    /// - `InvalidPeriod.ExceededDedicatedHost`: Instance expired date can't exceed dedicated host expired date.
    /// - `InvalidMarketImageChargeType.NotSupport`: The specified chargeType of marketImage is unsupported.
    /// - `InvalidSystemDiskCategory.ValueNotSupported`: %s
    /// - `InvalidAccountStatus.PayAmountLimitExceeded`: Your account is being restricted, due to no default payment method is set or you has not being authorized.
    /// - `InvalidInstance.NotFoundSystemDisk`: The specified instance has no system disk.
    /// - `AccountForbidden.ProductCreationLimited`: The commodity must be officially operated by Aliyun and in pay-as-you-go billing method.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `InvalidPeriod`: The specified period is not valid.
    /// - `DISK_IN_DEDICATED_BLOCK_STORAGE_CLUSTER`: The disk in dedicated block storage cluster is not allowed to do this operation.
    /// - `NoPermission.Price`: The operation requires price permission. Please either apply for permission from your main account, or set the parameter AutoPay as true.
    /// - `NoPermission.Refund`: The operation requires refund permission. Please apply for permission from your main account.
    /// - `QuotaExceeded.InternetBandwidth`: %s.
    /// - `InvalidInstance.TempBandwidthUpgrade`: Cannot switch to Pay-As-You-Go during the period of temporary bandwidth upgrade.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InstanceType.Offline`: %s
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `Account.Arrearage`: Your account has an outstanding payment.
    /// - `InvalidParameter.NotMatch`: %s
    /// - `InvalidAction`: %s
    /// - `QuotaExceed.PostPaidDisk`: Living postPaid disks quota exceeded.
    /// - `ImageNotSupportInstanceType`: The specified instanceType is not supported by instance with marketplace image.
    /// - `InvalidInstanceType.PhasedOut`: This instanceType is no longer offered.
    /// - `InvalidPeriod.ExceededDedicatedHost`: Instance expired date can't exceed dedicated host expired date.
    /// - `RealNameAuthenticationError`: Your account has not passed the real-name authentication yet.
    /// - `InvalidOperation.NotSupport`: Instance on dedicated host not support modify charge type.
    /// - `QuotaExceed.ElasticQuota`: No additional quota is available for the specified ECS instance type.
    /// - `PeriodNotSupported.InstanceOnManagedPrivateSpace`: The instance on ManagedPrivateSpace is not supported to modify chargeType.
    /// - `UnsupportedIspChargeType`: %s
    /// - `InvalidOperation.StoppedModeUnsupported`: The specified instance is StopCharging.
    /// - `InvalidInstanceId.NotFound`: The specified instanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType is not authorized.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_charge_type(
        &self,
        req: ModifyInstanceChargeType,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceChargeTypeResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改实例的实例规格或公网带宽
    ///
    /// 本接口用于修改一台按量付费ECS实例的实例规格或者公网带宽大小。
    ///
    /// <props="china">
    ///
    /// **请确保在使用该接口前，已充分了解ECS产品的收费方式和[价格](https://www.aliyun.com/price/product#/ecs/detail)。**
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// **请确保在使用该接口前，已充分了解ECS产品的收费方式和[价格](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl)。**
    ///
    /// </props>
    ///
    /// [更改按量付费实例规格](~~60051~~)前，您可以通过[DescribeResourcesModification](~~66187~~)查询当前实例支持变配的实例规格。
    ///
    /// **注意事项**
    ///
    /// - 账号必须处于无欠费状态。
    /// - 每次调用只能修改单项配置，即单次只能修改实例规格，或者只能调整公网带宽大小。
    /// - 实例状态必须为**运行中**（`Running`）或者**已停止**（`Stopped`）时才能调节公网带宽大小，修改后立即生效。
    /// - 实例状态必须为**已停止**（`Stopped`）时才能修改实例规格，修改后需要[启动实例](~~25441~~)后生效。
    ///
    /// > 单个地域下，单个阿里云账号按固定带宽计费的公网带宽峰值总和存在限制，请参见[公网带宽限制](~~25412#BandwidthQuota~~)。
    ///
    /// # Error Codes
    /// - `InvalidInternetChargeType.ValueNotSupported`: The specified InternetChargeType is not valid.
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidParameter`: The specified parameter "InternetMaxBandwidthOut" is not valid.
    /// - `InvalidParameter.Mismatch`: Too many parameters in one request.
    /// - `BandwidthUpgradeDenied.EipBoundInstance`: The specified VPC instance has bound EIP, temporary bandwidth upgrade is denied.
    /// - `InvalidTemporary.StartTime`: The specifed Temporary.StartTime is not valid.
    /// - `InvalidTemporary.EndTime`: The specifed Temporary.EndTime is not valid.
    /// - `Downgrade.NotSupported`: Downgrade operation is not supported.
    /// - `DependencyViolation.InstanceType`: The current InstanceType cannot be changed to the specified InstanceType.
    /// - `Account.Arrearage`: Your account has an outstanding payment.
    /// - `InvalidParameter.Bandwidth`: The specified parameter Bandwidth is not valid.
    /// - `InvalidParameter.Conflict`: The specified image does not support the specified instance type.
    /// - `InvalidParameter.AllowMigrateAcrossZone`: The specified parameter CanMigrateAcrossZone is not valid.
    /// - `InvalidParam.SystemDiskCategory`: The specified param SystemDisk.Category is not valid.
    /// - `Throttling`: Request was denied due to request throttling, please try again after 5 minutes.
    /// - `InvalidInstanceStatus.NotStopped`: The specified Instance status is not stopped.
    /// - `InvalidAction`: Specified action is not valid.
    /// - `IdempotenceParamNotMatch`: There is a idempotence signature mismatch between this and last request.
    /// - `InvalidClientToken.ValueNotSupported`: The ClientToken provided is invalid.
    /// - `Price.PricePlanResultNotFound`: The internetMaxBandwidthIn or internetMaxBandwidthOut provided is invalid.
    /// - `InvalidAction.NotSupport`: The ecs on dedicatedHost not support modify instanceType.
    /// - `InvalidMarketImageStatus.NotSupported`: The status of specified market image does not support this operation.
    /// - `InvalidOperation.VpcHasEnabledAdvancedNetworkFeature`: The specified vpc has enabled advanced network feature.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `InstanceTypeNotSupported.TooManyDisksAttached`: %s
    /// - `InvalidDiskCategory.NotSupported`: The upgrade operation of instance does not support this category of disk.
    /// - `InvalidParameter.CloudboxNotSupported`: %s
    /// - `QuotaExceed.DiskCapacity`: The used capacity of disk type has exceeded the quota in the zone,  %s.
    /// - `InvalidParam.Async`: The specified parameter async is not valid.
    /// - `MissingParameter.DiskCategory`: The specified parameter Disk.Category can not be null when Disk.DiskId is specified.
    /// - `InvalidParameter.DiskCategory`: The specified parameter Disk.Category is not valid.
    /// - `InvalidPerformanceLevel.Malformed`: The specified parameter Disk.n.PerformanceLevel is not valid.
    /// - `NoPermission.Price`: The operation requires price permission. Please either apply for permission from your main account, or set the parameter AutoPay as true.
    /// - `InvalidParameter.DedicatedRegionNotSupported`: The specified action is rejected  because the specified ECS instance in the dedicated region does not support public IP.
    /// - `InvalidOperation.OnlineModificationUnsupported`: Online modification of instance type is not supported for the specified instance due to its CPU topology.
    /// - `QuotaExceeded.InternetBandwidth`: %s.
    /// - `InvalidOperation.InstanceTypeNotSupportRss`: The ECS instance type does not support Rss.
    /// - `CategoryViolation`: The specified instance does not support this operation because of its disk category.
    /// - `InvalidStatus.ValueNotSupported`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `ChargeTypeViolation`: The operation is not permitted due to charge type of the instance.
    /// - `OperationDenied`: The specified instance is out of usage.
    /// - `LastTokenProcessing`: The last token request is processing.
    /// - `InvalidInstance.UnpaidOrder`: The specified instance has unpaid order.
    /// - `InstanceSpecModification.NotEffective`: The specified instance has been reserved for making a spec modification and not taken effective in the current contract period.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified zone does not offer the specified instancetype.
    /// - `ImageNotSupportInstanceType`: The specified image do not support the InstanceType instance.
    /// - `InstanceType.Offline`: The specified InstanceType has been offline.
    /// - `InvalidParameter.NotMatch`: %s
    /// - `InvalidInstance.EipNotSupport`: The specified instance with eip is not supported, please unassociate eip first.
    /// - `InvalidInstance.NatPortMapNotSupport`: The special instance with nat port map not support operate, please remove nat port map first.
    /// - `InvalidOperation.StarterPackage`: StarterPackage not support modification.
    /// - `OperationDenied.NoStock`: The resource is out of usage.
    /// - `OperationDenied.UnpaidOrder`: The specified instance has unpaid order.
    /// - `InvalidOperation.EipNotSupport`: The special instance with eip not support operate, please unassociate eip first.
    /// - `InvalidParameter.InternetMaxBandwidthOut`: The specified parameter InternetMaxBandwidthOut is invalid.
    /// - `InvalidOperation.EniCountExceeded`: %s
    /// - `InvalidOperation.Ipv4CountExceeded`: %s
    /// - `InvalidOperation.Ipv6CountExceeded`: %s
    /// - `InvalidOperation.Ipv6NotSupport`: %s
    /// - `InvalidOperation.Ipv4NotSupport`: %s
    /// - `InvalidOperation.InstanceWithEipNotSupport`: The special instance with eip not support operate, please unassociate eip first.
    /// - `SecurityRisk.3DVerification`: We have detected a security risk with your default credit or debit card. Please proceed with verification via the link in your email.
    /// - `InvalidInstance.NotFoundSystemDisk`: The specified instance has no system disk.
    /// - `InvalidInstanceType.NotSupportDiskCategory`: The instanceType of the specified instance does not support this disk category.
    /// - `QuotaExceed.ElasticQuota`: No additional quota is available for the specified ECS instance type.
    /// - `InvalidResourceType.NotSupported`: %s
    /// - `InvalidOperation.NotAllowed`: The specified vpc %s has enabled senior network feature.
    /// - `InvalidOperation.InstanceTypeNotSupportEniTrunking`: %s
    /// - `InvalidOperation.MaxEniQueueNumberExceeded`: %s
    /// - `InvalidOperation.ExceedInstanceTypeQueueNumber`: %s
    /// - `InvalidParameter.InvalidEniQueueNumber`: %s
    /// - `HibernationConfigured.InstanceOperationForbidden`: The operation is not permitted due to limit of the hibernation configured instance.
    /// - `InvalidOperation.InstanceTypeNotSupportHighPerformanceTrafficMode`: %s
    /// - `InvalidOperation.EniQueuePairNumberOverflow`: %s
    /// - `InvalidOperation.HighPerformanceEniPerInstanceLimitExceeded`: %s
    /// - `InvalidOperation.MaxEniQueuePairNumberExceed`: %s
    /// - `InvalidOperation.MaxModifyOnlineNumberExceeded`: The specified instance has reached the maximum number of modify online attempts and needs to be rebooted.
    /// - `InvalidOperation.RebootingRequired`: The specified instance needs to be rebooted.
    /// - `InvalidOperation.OSTypeNotSupported`: The specified OS type is not supported.
    /// - `InvalidSystemDiskCategory.ValueNotSupported`: The specified parameter  SystemDisk.Category is not valid.
    /// - `InvalidDataDiskCategory.ValueNotSupported`: The specified Category of Data Disk is not valid.
    /// - `InvalidDiskCategory.NotSupported`: The upgrade operation of instance does not support this category of disk.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `MissingTemporary.StartTime`: Temporary.StartTime is not specified.
    /// - `MissingTemporary.EndTime`: Temporary.EndTime is not specified.
    /// - `InvalidInstanceChargeType.NotFound`: The InstanceChargeType does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.
    /// - `LimitedOperation.ServiceUnavailable`: The service is currently unavailable. Please try again later.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_spec(
        &self,
        req: ModifyInstanceSpec,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceSpecResponse>> + Send {
        self.call(req)
    }

    /// # 修改包年包月实例的实例规格
    ///
    /// 本接口用于修改一台包年包月ECS实例的实例规格，支持您升级或者降低实例规格，修改后的实例规格在实例整个生命周期内生效。
    ///
    /// <props="china">
    ///
    /// **请确保在使用该接口前，已充分了解ECS产品的收费方式、[价格](https://www.aliyun.com/price/product#/ecs/detail)以及[降配退款规则](~~116043~~)。**
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// **请确保在使用该接口前，已充分了解ECS产品的收费方式、[价格](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl)以及[降配退款规则](~~476339~~)。**
    ///
    /// </props>
    ///
    /// 本接口属于异步操作，等待约5~10秒后配置变更完成。升级或者降低包年包月ECS实例规格前，您可以通过[DescribeResourcesModification](~~66187~~)查询当前实例支持变配的实例规格。
    ///
    /// **注意事项**
    ///   - 已过期实例无法修改实例规格，您可以续费后重新操作。
    ///   - 降低实例规格：
    ///     - 实例必须处于**已停止**（`Stopped`）状态。
    ///     - 降低前后的实例规格价格差退款会退还到您的原付费方式中，已使用的代金券不退回。
    ///     - 变配后的实例规格需要[启动实例](~~25441~~)后生效。
    ///
    ///   - 升级实例规格：
    ///     - 实例必须处于**已停止**（`Stopped`）或者**运行中**（`Running`）状态。
    ///     - 变配后的实例规格需要[启动实例](~~25441~~)或者[重启实例](~~25440~~)后生效。
    ///
    /// # Error Codes
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType is not authorized.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidBillingMethod.ValueNotSupported`: The operation is not permitted due to an invalid billing method of the instance.
    /// - `InvalidInstance.PurchaseNotFound`: The specified instance has no purchase history.
    /// - `InvalidInstance.UnpaidOrder`: The specified instance has unpaid order.
    /// - `InvalidInstanceType.NotSupported`: The specified InstanceType is not Supported.
    /// - `OrderCreationFailed`: Order creation failed, please check your params and try it again later.
    /// - `Throttling`: You have made too many requests within a short time; your request is denied due to request throttling.
    /// - `Account.Arrearage`: Your account has an outstanding payment.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidRebootTime.MalFormed`: The specified rebootTime is not valid.
    /// - `InvalidRebootTime.ValueNotSupported`: The specified RebootTime is not valid.
    /// - `IdempotenceParamNotMatch`: Request uses a client token in a previous request but is not identical to that request.
    /// - `InvalidInstanceChargeType.ValueNotSupported`: %s
    /// - `InvalidStatus.NotStopped`: Instance status must be stopped.
    /// - `InvalidAction`: %s
    /// - `InstanceDowngrade.QuotaExceed`: Quota of instance downgrade is exceed.
    /// - `InvalidParameter`: %s
    /// - `OperationDenied`: The current user does not support this operation.
    /// - `LastOrderProcessing`: The previous order is still processing, please try again later.
    /// - `InvalidOperation.VpcHasEnabledAdvancedNetworkFeature`: The specified vpc has enabled advanced network feature.
    /// - `InvalidAction.WithActiveElasticUpgrade`: The instance has active Elastic Upgrade.
    /// - `InstanceTypeNotSupported.TooManyDisksAttached`: %s
    /// - `QuotaExceed.DiskCapacity`: The used capacity of disk type has exceeded the quota in the zone,  %s.
    /// - `MissingParameter.DiskCategory`: The specified parameter Disk.Category can not be null when Disk.DiskId is specified.
    /// - `InvalidParameter.DiskCategory`: The specified parameter Disk.Category is not valid.
    /// - `InvalidPerformanceLevel.Malformed`: The specified parameter Disk.n.PerformanceLevel is not valid.
    /// - `InvalidSystemDiskCategory.NotMatchInstanceType`: The system disk category does not match the instance type.
    /// - `QuotaExceed.RufundVcpu`: The maximum number of refunded vcpu is exceeded: %s .
    /// - `NoPermission.Price`: The operation requires price permission. Please either apply for permission from your main account, or set the parameter AutoPay as true.
    /// - `NoPermission.Refund`: The operation requires refund permission. Please apply for permission from your main account.
    /// - `InvalidInstanceStatus`: The current status of the instance does not support this operation.
    /// - `InvalidOperation.InstanceRenewWithDowngradeInPlan`: The operation is denied due to the specified instance has renew with downgrade record in plan.
    /// - `InvalidOperation.OnlineModificationUnsupported`: Online modification of instance type is not supported for the specified instance due to its CPU topology.
    /// - `OperationDenied.NoStock`: The specified instance is out of usage.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidUser.PassRoleForbidden`: The RAM user does not have privilege to pass a role.
    /// - `ImageNotSupportInstanceType`: The specified image does not support the specified InstanceType.
    /// - `InstanceType.Offline`: %s
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `Throttling`: You have made too many requests within a short time; your request is denied due to request throttling.
    /// - `InvalidParameter.InstanceId`: %s
    /// - `OperationDenied`: %s
    /// - `InvalidInstanceStatus`: The current status of the instance does not support this operation.
    /// - `InvalidOperation.StarterPackage`: StarterPackage not support modification.
    /// - `InvalidInstance.PreInstanceExpired`: Instance business status is not Expired.
    /// - `InvalidInstance.EipNotSupport`: The special instance with eip not support operate, please unassociate eip first.
    /// - `OperationDenied.ImageNotValid`: The specified image is not authorized.
    /// - `OperationDenied.LocalDiskUnsupported`: The configuration change is not allowed when the specified instance has local disks mounted.
    /// - `InvalidOperation.EniCountExceeded`: %s
    /// - `InvalidOperation.Ipv4CountExceeded`: %s
    /// - `InvalidOperation.Ipv6CountExceeded`: %s
    /// - `InvalidOperation.Ipv6NotSupport`: %s
    /// - `InvalidOperation.Ipv4NotSupport`: %s
    /// - `InvalidInstance.NotFoundSystemDisk`: The specified instance has no system disk.
    /// - `InvalidInstanceType.NotSupportDiskCategory`: The instanceType of the specified instance does not support this disk category.
    /// - `QuotaExceed.ElasticQuota`: No additional quota is available for the specified ECS instance type.
    /// - `InvalidResourceType.NotSupported`: %s
    /// - `InvalidOperation.MaxEniQueueNumberExceeded`: %s
    /// - `InvalidOperation.ExceedInstanceTypeQueueNumber`: %s
    /// - `InvalidParameter.InvalidEniQueueNumber`: %s
    /// - `HibernationConfigured.InstanceOperationForbidden`: The operation is not permitted due to limit of the hibernation configured instance.
    /// - `InvalidOperation.MaxModifyOnlineNumberExceeded`: The specified instance has reached the maximum number of modify online attempts and needs to be rebooted.
    /// - `InvalidOperation.RebootingRequired`: The specified instance needs to be rebooted.
    /// - `InvalidOperation.OSTypeNotSupported`: The specified OS type is not supported.
    /// - `OperationDenied.UnpaidOrder`: The specified instance has unpaid order.
    /// - `InvalidDisk.DetachedSystemDisk`: The specified resource is/has a detached system disk %s , not support current operation.
    /// - `InvalidDataDiskCategory.ValueNotSupported`: The specified Category of Data Disk is not valid.
    /// - `InvalidDiskCategory.NotSupported`: The upgrade operation of instance does not support this category of disk.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `BillingMethodNotFound`: The account has not chosen any billing method.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.
    /// - `ImageOrderFailed`: Create marketplace image order failed.
    /// - `LimitedOperation.ServiceUnavailable`: The service is currently unavailable. Please try again later.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_prepay_instance_spec(
        &self,
        req: ModifyPrepayInstanceSpec,
    ) -> impl std::future::Future<Output = crate::Result<ModifyPrepayInstanceSpecResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改实例自动释放时间
    ///
    /// 本接口用于修改指定按量付费实例或者抢占式实例的自动释放时间，同时支持取消自动释放功能。
    ///
    /// # Error Codes
    /// - `MissingParameter`: InstanceId should not be null.
    /// - `InvalidAutoReleaseTime.Malformed`: The specified paramter autoReleaseTime is not valid.
    /// - `UnsupportedParameter`: The parameters is unsupported.
    /// - `ChargeTypeViolation`: The operation is not permitted due to charge type of the instance.
    /// - `NoSuchResource`: The specified resource is not found.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_auto_release_time(
        &self,
        req: ModifyInstanceAutoReleaseTime,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceAutoReleaseTimeResponse>> + Send
    {
        self.call(req)
    }

    /// # 为实例授予RAM角色
    ///
    /// 本接口用于为一台或多台ECS实例授予RAM角色。
    ///
    /// 您可以通过[DescribeInstanceRamRole](~~2679686~~)查询实例被授予的[实例RAM角色](~~61175~~)。
    /// > 如果实例已存在被授予的实例RAM角色，则报错提示您不能授予新的角色。
    ///
    /// # Error Codes
    /// - `InvalidInstanceIds.Malformed`: The specified instanceIds are not valid.
    /// - `InvalidNetworkType.MismatchRamRole`: Ram role cannot be applied to instances of Classic network type.
    /// - `InvalidUser.PassRoleForbidden`: The RAM user does not have the privilege to pass a RAM role.
    /// - `InvalidInstanceId.NotFound`: The specified instanceId does not exist.
    /// - `InvalidRamRole.NotFound`: The specified RAMRoleName does not exist.
    /// - `InvalidRamRole.NotEcsRole`: The specified ram role is not authorized for ecs, please check your role policy.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn attach_instance_ram_role(
        &self,
        req: AttachInstanceRamRole,
    ) -> impl std::future::Future<Output = crate::Result<AttachInstanceRamRoleResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询实例被授予的RAM角色
    ///
    /// 本接口具备两个主要功能，支持依据实例 ID 来查询一台或多台 ECS 实例所被授予的实RAM角色，同时也允许通过实例 RAM 角色名称来查询被授予了该特定角色的实例情况。
    ///
    /// ## 接口说明
    ///
    /// 通过阿里云CLI调用API时，不同数据类型的请求参数取值必须遵循格式要求。更多信息，请参见[CLI参数格式说明](~~110340~~)。
    ///
    /// # Error Codes
    /// - `InvalidInstanceIds.Malformed`: The specified instanceIds are not valid.
    /// - `InvalidNetworkType.MismatchRamRole`: Ram role cannot be applied to instances of Classic network type.
    /// - `InvalidParameter.AllEmpty`: %s
    /// - `InvalidInstanceId.NotFound`: The specified instanceId does not exist
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_ram_role(
        &self,
        req: DescribeInstanceRamRole,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstanceRamRoleResponse>> + Send
    {
        self.call(req)
    }

    /// # 收回实例被授予的RAM角色
    ///
    /// 本接口用于收回一台或多台ECS实例被授予的RAM角色。
    ///
    /// # Error Codes
    /// - `InvalidInstanceIds.Malformed`: The specified instanceIds are not valid.
    /// - `InvalidNetworkType.MismatchRamRole`: Ram role cannot be applied to instances of Classic network type.
    /// - `InvalidUser.PassRoleForbidden`: The RAM user does not have the privilege to pass a RAM role.
    /// - `InvalidInstanceId.NotFound`: The specified instanceId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn detach_instance_ram_role(
        &self,
        req: DetachInstanceRamRole,
    ) -> impl std::future::Future<Output = crate::Result<DetachInstanceRamRoleResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询实例VNC登录地址
    ///
    /// 本接口用于查询一台ECS实例的VNC登录地址。
    ///
    /// - 接口返回的是VNC登录地址（VncUrl），不能直接使用访问，您可以通过**Web管理终端地址**访问。
    /// > Web管理终端地址需在链接`https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?`末尾加上`vncUrl=\*\*\*\*`、`instanceId=****`和`isWindows=true/false`，参数之间使用`&`连接。其中：
    ///   >- `vncUrl`：VNC登录地址。
    ///   >- `instanceId`：实例ID。
    ///   >- `isWindows`：实例的操作系统是否为Windows系统。取值为`true`表示是Windows系统，取值为`false`表示不是Windows系统。
    ///   >- 当前已支持免VNC密码连接实例，您无需设置参数`password`。
    ///
    /// - 单个管理终端链接地址的KeepAlive时间为300秒，300秒内您与管理终端窗口没有任何交互操作时，连接自动断开。
    /// - 如果连接中断，您需要重新调用接口来获取新的`VncUrl`，以组成新的管理终端地址进行重新连接，且每分钟内重新连接的次数不能超过30次。
    ///
    ///
    ///
    /// Web管理终端地址示例：
    /// ```ignore
    /// https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?vncUrl=ws%3A%2F%****&instanceId=i-wz9hhwq5a6tm****&isWindows=true
    /// ```
    ///
    /// # Error Codes
    /// - `InvalidRegionInstance`: The specified InstanceId does not exist in given region.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceNotReady`: The specified instance is not ready for use
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_vnc_url(
        &self,
        req: DescribeInstanceVncUrl,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstanceVncUrlResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改实例VNC登录密码
    ///
    /// 本接口用于修改一台ECS实例的VNC登录密码。
    ///
    /// - 密码长度必须是六位字符，必须且仅能包含大写、小写英文字母及阿拉伯数字三种字符。
    /// - 修改密码后：
    ///     - I/O优化的实例，立刻生效，无需重启实例。
    ///     - 非I/O优化的实例，需要在控制台[重启实例](~~25440~~)或者调用[RebootInstance](~~25502~~)重启后才能生效。
    ///
    /// # Error Codes
    /// - `IncorrectVncPassword.Malformed`: The specified parameter VncPassword is not valid.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceNotReady`: Temporarily unable to connect the specified instance,please try later.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `NoSuchResource`: The specified resource is not found.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_vnc_passwd(
        &self,
        req: ModifyInstanceVncPasswd,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceVncPasswdResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改实例内的元数据访问设置
    ///
    /// 本接口用于修改指定地域下实例内的元数据访问设置，包括是否启用元数据访问通道和访问元数据时是否启用强制加固模式等设置。
    ///
    /// # Error Codes
    /// - `InvalidHttpEndpoint.NotSupported`: The specified HttpEndpoint not supported, you can use enabled(default) or disabled.
    /// - `InvalidHttpTokens.NotSupported`: The specified HttpTokens not supported, you can use optional(default) or required.
    /// - `InvalidHttpPutResponseHopLimit.NotSupported`: The specified HttpPutResponseHopLimit not supported, more than 1 and less than 64 is reasonable.
    /// - `InvalidInstanceMetadataTags.NotSupported`: The specified InstanceMetadataTags not supported.
    /// - `InvalidImdsAccessPolicyId.NotFound`: The specified parameter ImdsAccessPolicyId is not found.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId is not found.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_metadata_options(
        &self,
        req: ModifyInstanceMetadataOptions,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceMetadataOptionsResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询实例自定义数据
    ///
    /// 本接口用于查询一台ECS实例的自定义数据。
    ///
    /// # Error Codes
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_user_data(
        &self,
        req: DescribeUserData,
    ) -> impl std::future::Future<Output = crate::Result<DescribeUserDataResponse>> + Send {
        self.call(req)
    }

    /// # 续费实例
    ///
    /// 本接口用于续费一台包年包月的 ECS 实例，支持您设置续费时长或者续费至统一到期日。
    ///
    /// **请确保在使用该接口前，您已充分了解云服务器ECS的计费方式和<props="china">[价格](https://www.aliyun.com/price/product#/ecs/detail)</props><props="intl">[价格](https://www.alibabacloud.com/product/ecs#pricing)</props>**。
    ///
    /// - 请确保您的账号余额或信用额度充足。
    /// - 仅支持包年包月的实例，按量付费的实例调用该接口会报错。
    /// - 续费时长参数（`Period`、`PeriodUnit`）与统一到期日参数（`ExpectedRenewDay`）必须指定其中之一，但不能同时设置。
    ///
    /// # Error Codes
    /// - `InvalidInternetChargeType.ValueNotSupported`: The specified InternetChargeType is not valid.
    /// - `InvalidInstanceType.NotSupported`: The specified InstanceType is not Supported.
    /// - `InvalidParameter`: The specified parameter "InternetMaxBandwidthOut" is not valid.
    /// - `InvalidInstanceChargeType.NotFound`: The InstanceChargeType does not exist in our records.
    /// - `InvalidRebootTime.Malformed`: The specified RebootTime is not valid.
    /// - `InvalidRebootTime.ValueNotSupported`: The specified RebootTime is out of the permitted range.
    /// - `IdempotenceParamNotMatch`: Request uses a client token in a previous request but is not identical to that request.
    /// - `InvalidClientToken.ValueNotSupported`: The ClientToken provided is invalid.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidInstanceType.codeUnauthorized`: The specified InstanceType is not authorized.
    /// - `InvalidInternetChargeType.InstanceNotSupported`: The specified instance which is in vpc is not support the parameter InternetChargeType.
    /// - `InvalidPeriod`: The specified period is not valid.
    /// - `MissingParamter`: The specified parameter "Period" is not null.
    /// - `Upgrade.NotSupported`: Upgrade operation is not supported.
    /// - `OperationDenied`: Specified instance is in VPC.
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType is not authorized.
    /// - `DependencyViolation.InstanceType`: Current instancetype cannot be changed to the specified one.
    /// - `InvalidPeriodUnit.ValueNotSupported`: The specified parameter PeriodUnit is not valid.
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist.
    /// - `InvalidDedicatedHostStatus.NotSupport`: Operation denied due to dedicated host status.
    /// - `IncorrectDedicatedHostStatus`: The current status of the resource does not support this operation.
    /// - `InvalidPeriod.ExceededDedicatedHost`: Instance expired date can't exceed dedicated host expired date.
    /// - `InvalidStatus.Upgrading`: The instance is upgrading; please try again later.
    /// - `InvalidPeriod.ExceededMaximumExpirationDate`: The specified renewal period cannot exceed the maximum expiration date. We recommend you try shortening the renewal period at next attempt.
    /// - `LastOrderProcessing`: The previous order is still processing, please try again later.
    /// - `Idempotence.Processing`: The previous request is still processing, please try again later.
    /// - `InvalidLoanOrderStatus.Uncompleted`: Any unpaid order must be cancelled before you try this action again. The scheduled unpaid order is a loan order that cannot be auto cancelled. For more information, visit the loan management center.
    /// - `OperationDenied.UnfinishedOrder`: The current instance has unfinished refundOrder, this operation is denied.
    /// - `InvalidPeriod.NotFound`: The specified period and expectedRenewDay cannot both be empty.
    /// - `InvalidExpectedRenewDay.StarterPackageNotSupported`: The specified starterPackage cannot support renew with expectedRenewDay.
    /// - `InvalidParam.ExpectedRenewDay`: The specified param ExpectedRenewDay is not valid.
    /// - `QuotaExceed.AlignInstance`: The maximum number of align operations is exceeded.
    /// - `InvalidExpectedRenewDay.Conflict`: The specified expectedRenewDay is in conflict with period.
    /// - `InvalidExpectedRenewDay.ValueNotSupported`: The specified parameter ExpectedRenewDay is not valid.
    /// - `OperationDenied.AbnormalInstanceInfo`: The current renewable operation is not supported due to abnormal information of the instance, please submit ticket to process.
    /// - `NoPermission.Price`: The operation requires price permission. Please either apply for permission from your main account, or set the parameter AutoPay as true.
    /// - `InvalidOperation.ClassicNetworkTypeNotSupported`: The classic network instance does not support this operation.
    /// - `ChargeTypeViolation`: The operation is not permitted due to charge type of the instance.
    /// - `Diskcategory.Mismatch`: The disk specified to convert to portable is not allowed due to the disk category does not support.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceSpecModification.NotEffective`: The specified instance has been reserved for making a spec modification and not taken effective in the current contract period.
    /// - `LastTokenProcessing`: The last token request is processing.
    /// - `Instance.UnPaidOrder`: The specified instance has unpaid order.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `InvalidDisk.NotAllowed`: The specified disk is not allowed to be converted to portable.
    /// - `InstanceTypeNotSupported`: The specified zone does not offer the specified instancetype.
    /// - `InvalidChargeType.NotSupported`: The chargeType of the instance does not support this operation.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone, try other types of resources or other regions and zones.
    /// - `OperationDenied.ImageNotValid`: The specified image is not authorized.
    /// - `InvalidPeriod.StarterPackage`: This instance was created by using a Starter Package plan and can only be renewed monthly, not yearly.
    /// - `RenewDateNotSupported.StarterPackage`: This instance was created by using a Starter Package plan and can only be renewed three days before it expires.
    /// - `PrePaidInstance.Expired`: The prePaid instance has expired.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn renew_instance(
        &self,
        req: RenewInstance,
    ) -> impl std::future::Future<Output = crate::Result<RenewInstanceResponse>> + Send {
        self.call(req)
    }

    /// # 查询实例自动续费属性
    ///
    /// 本接口用于查询一台或多台包年包月ECS实例的自动续费属性，包括是否开启自动续费、续费周期等信息。
    ///
    /// - 仅支持包年包月的实例，按量付费的实例调用该接口会报错。
    /// - 在设置自动续费或者手动续费前，查询实例续费状态可以帮助您了解实例是否已为自动续费状态。
    ///
    /// # Error Codes
    /// - `Throttling`: Request was denied due to request throttling.
    /// - `MissingParameter.InstanceId`: InstanceId should not be null.
    /// - `InvalidParameter.ToManyInstanceIds`: InstanceId should be less than 100.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `ChargeTypeViolation`: Pay-As-You-Go instances do not support this operation.
    /// - `InvalidParameter.RenewalStatus`: The specified parameter RenewalStatus is not valid.
    /// - `InvalidParameter.RenewalStatusInstanceId`: The parameter RenewalStatus and InstanceId can not be both empty.
    /// - `InvalidParameter.PageSize`: The specified parameter PageSize is not valid.
    /// - `InvalidParameter.PageNumber`: The specified parameter PageNumber is not valid.
    /// - `InvalidParameter.InvalidInstanceId`: The specified InstanceId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_auto_renew_attribute(
        &self,
        req: DescribeInstanceAutoRenewAttribute,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstanceAutoRenewAttributeResponse>>
    + Send {
        self.call(req)
    }

    /// # 修改实例的自动续费属性
    ///
    /// 本接口用于修改一台或多台包年包月实例的自动续费属性，可以帮助您减少资源到期的维护成本。
    ///
    /// **请确保在使用该接口前，您已充分了解云服务器ECS的计费方式和<props="china">[价格](https://www.aliyun.com/price/product#/ecs/detail)</props><props="intl">[价格](https://www.alibabacloud.com/product/ecs#pricing)</props>**。
    ///
    /// - 请确保您的账号余额或者信用额度充足。
    /// - 仅支持包年包月的实例，按量付费的实例调用该接口会报错。
    /// - 自动续费扣款日为实例到期前第9天，扣费在北京时间（UTC +8）08:00:00开始执行。
    /// - 若前一日执行自动扣费失败，将会在下一日定时继续执行，直到扣费成功或者9天之后实例到期锁定。
    ///
    /// <props="china">
    ///
    /// - 若新建实例的购买时长为一周，则会在创建成功的第一天自动扣款续费。
    /// </props>
    ///
    /// # Error Codes
    /// - `OperationDenied.StarterPackage`: Instance created with a Starter Package plan can not set auto renew.
    /// - `MissingParameter.InstanceId`: InstanceId should not be null.
    /// - `InvalidParameter.ToManyInstanceIds`: InstanceId should be less than 100.
    /// - `InvalidParameter.InvalidInstanceId`: %s
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `ChargeTypeViolation`: Pay-As-You-Go instances do not support this operation.
    /// - `InvalidParameter.Duration`: %s
    /// - `InvalidParameter.RenewalStatus`: %s
    /// - `InvalidPeriodUnit.ValueNotSupported`: The specified parameter PeriodUnit is not valid.
    /// - `InvalidPeriod.StarterPackage`: This instance was created by using a Starter Package plan and can only be renewed monthly, not yearly.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_auto_renew_attribute(
        &self,
        req: ModifyInstanceAutoRenewAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceAutoRenewAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 重新激活已过期或欠费回收的实例
    ///
    /// 本接口用于重新启动一台已过期或欠费回收的按量付费ECS实例。
    ///
    /// 按量付费实例结清欠费账单后，您无需调用该接口激活实例，系统会自动重开机将您的实例恢复到欠费之前的状态。自动重开机偶尔会出现失败的情况，请您关注自动重开机是否成功。如果自动重开机失败，请通过该接口进行手动重开机。
    ///
    /// <props="china">- 结清欠费后，您的阿里云账户余额（即现金余额）和代金券的总值不得小于100.00元人民币，否则无法重新启动实例。</props>
    /// <props="china">- 实例必须处于**已过期**（`Stopped`）或者**欠费回收中**（`Stopped`）的状态。</props>
    /// <props="intl">- 实例必须处于**已过期**（`Stopped`）的状态。</props>
    ///
    /// - 被安全锁定的实例不能通过调用该接口启动。更多信息，请参见[资源安全锁定对调用API的影响](~~25695~~)。
    ///
    /// # Error Codes
    /// - `ReopenInstance.InstanceNotEnoughBalance`: Reopen instance must have enough account balance.
    /// - `ReopenInstance.ImageNotEnoughBalance`: Reopen instance must have enough cash balance.
    /// - `ReopenInstance.InstanceStatusNotValid`: Instance status is not Expired, ImageExpired or EcsAndImageExpired.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `InsufficientBalance`: Your account does not have enough balance.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidPayType.NotSupport`: The specified pre pay instance not support.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn re_activate_instances(
        &self,
        req: ReActivateInstances,
    ) -> impl std::future::Future<Output = crate::Result<ReActivateInstancesResponse>> + Send {
        self.call(req)
    }

    /// # 查询抢占式实例的历史价格
    ///
    /// 本接口用于查询抢占式实例的历史价格，最多支持获取近30天内的数据，通过历史价格数据可以帮助您合理的设置抢占式实例的单台实例上限价格。
    ///
    /// - 仅支持查询I/O优化的抢占式实例。
    /// - 接口返回的数据可能会分页，若返回的数据包含`NextOffset`参数，您可以将请求参数中的`Offset`值设置为`NextOffset`值进行后续数据查询。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidParams.StartTime`: %s
    /// - `InvalidParams.EndTime`: %s
    /// - `Abs.Abs.InvalidSpotInstanceUID`: %s
    /// - `InvalidParams.NetworkType`: %s
    /// - `InvalidParams.IoOptimized`: %s
    /// - `InvalidParams.OSType`: %s
    /// - `Abs.IoOptimized.ValueNotSupported`: %s
    /// - `InvalidZoneId.NotFound`: The specified zone does not exist.
    /// - `InvalidParams.ZoneId`: %s
    /// - `InvalidParams.RegionId`: %s
    /// - `InvalidParams.InstanceType`: %s
    /// - `InvalidParams.PageSize`: %s
    /// - `InvalidParams.Offset`: %s
    /// - `InvalidInstanceType.ValueNotSupported`: %s
    /// - `DependencyViolation.IoOptimized`: The specified instancetype must be IoOptimized instance.
    /// - `InvalidSpotDuration`: The specified SpotDuration is not valid.
    /// - `OperationDenied.QueryFail`: Query spot price fail, please retry later.
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbedden.NotSupportRAM`: %s
    /// - `Forbbiden.SubUser`: %s
    /// - `OperationDenied.RegionIdNotSupported`: region not support spot duration instance.
    /// - `OperationDenied.FlavorNotSupported`: flavor not support spot duration instance.
    /// - `OperationDenied.TimestampNotSupported`: timestamp not support spot duration instance.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_spot_price_history(
        &self,
        req: DescribeSpotPriceHistory,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSpotPriceHistoryResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询抢占式实例平均释放率和折扣率
    ///
    /// 本接口用于查询指定地域下，抢占式实例近30天的平均释放率、平均折扣率等信息。
    ///
    /// - 仅支持查询专有网络VPC、I/O优化的抢占式实例。
    /// - 您可以通过以下任一方式调用接口查询：
    ///     - 设置`Cores`、`Memory`两参数或`MinCores`、`MinMemory`两参数，查询符合vCPU及内存要求的实例规格信息。
    ///     - 设置`InstanceTypes.N`查询指定的实例规格信息。
    ///     - 设置`Cores`、`Memory`两参数或`MinCores`、`MinMemory`两参数后，再设置`InstanceTypeFamily`或`InstanceFamilyLevel`，查询某一实例规格族或某一级别内，符合vCPU及内存要求的实例规格信息。
    ///
    /// - 通过平均折扣率和按量付费实例价格可以计算出抢占式实例平均价格。
    ///
    /// # Error Codes
    /// - `Invalid.SaleStrategy`: The specified saleStrategy is not valid.
    /// - `Invalid.Param`: The input parameter DestinationResource that is mandatory for processing this request is not supplied.
    /// - `InvalidRegionId.MalFormed`: The specified parameter RegionId is not valid.
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist in our records.
    /// - `InvalidParam.TypeAndCpuMem.Conflict`: The specified 'InstanceType' and 'Cores','Memory' are not blank at the same time.
    /// - `InvalidParam.Cores`: The specified parameter 'Cores' should not be empty
    /// - `InvalidParam.Memory`: The specified parameter 'Memory' should not be empty
    /// - `OperationDenied.RegionIdNotSupported`: region not support spot duration instance.
    /// - `OperationDenied.FlavorNotSupported`: flavor not support spot duration instance.
    /// - `OperationDenied.TimestampNotSupported`: timestamp not support spot duration instance.
    /// - `Invalid.RegionId`: The specified RegionId does not exist.
    /// - `Unavailable.Regions`: The available regions does not exists
    /// - `Invalid.ResourceType`: The ResourceType provided does not exist in our records.
    /// - `Invalid.DestinationResource`: The specified DestinationResource is not valid.
    /// - `Invalid.IoOptimized`: The specified IoOptimized is not valid.
    /// - `Invalid.NetworkType`: The specified NetworkType is not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_spot_advice(
        &self,
        req: DescribeSpotAdvice,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSpotAdviceResponse>> + Send {
        self.call(req)
    }

    /// # 创建自定义镜像
    ///
    /// 创建一份自定义镜像。后续您可以使用创建的自定义镜像创建ECS实例（RunInstances），或者更换实例的系统盘（ReplaceSystemDisk）。
    ///
    /// ### 注意事项
    ///
    /// - 本接口为异步接口，创建自定义镜像请求发送成功后会返回镜像 ID，镜像的创建不是立即完成的，需要调用 [DescribeImage](~~2679797~~) 查看镜像信息，当返回信息中的状态为`Available`时代表镜像创建成功并可用。更多信息，请参见[自定义镜像概述](~~172789~~)。
    ///
    /// - 查询 ECS 实例信息时，如果返回数据中包含{"OperationLocks": {"LockReason" : "security"}}，则禁止创建自定义镜像。
    ///
    /// - 建议在创建镜像时配置镜像检测参数`DetectionStrategy`，有助于系统帮助优化您的镜像。更多信息，请参见[镜像检测概述](~~439819~~)。
    ///
    /// 以下描述了三种通过该接口创建自定义镜像的方法。请求参数的优先级为：InstanceId > DiskDeviceMapping > SnapshotId，若您的请求中同时含有两个及以上参数，默认以优先级更高的参数为准创建镜像。
    ///
    /// - **根据实例创建自定义镜像**：指定实例ID（`InstanceId`）。
    ///   - 实例的状态必须为运行中（`Running`）或者已停止（`Stopped`）。
    ///   - 接口调用成功后，实例的每块云盘均会新增一份快照。
    ///
    ///   ><notice>由于运行中的实例存在缓存数据未落盘的情况，可能导致创建的自定义镜像数据与实例数据不完全一致，因此建议您停止实例（[StopInstances](~~155372~~)）后创建镜像。></notice>
    ///
    /// - **根据快照创建自定义镜像（指定的快照不能是2013年7月15日（含）之前创建的快照。）**
    ///   - **使用系统盘快照创建自定义镜像**：只需指定实例系统盘的快照ID（`SnapshotId`）。
    ///   - **使用系统盘快照和数据盘快照创建自定义镜像**：这需要建立几块云盘的数据关联（`DiskDeviceMapping`）。
    ///     -  系统盘快照只能被指定一个。
    ///     -  数据盘快照可以指定多个，最多不能超过16块。不指定`DiskDeviceMapping.N.SnapshotId`时会创建一个默认容量的空数据盘。  
    ///  
    /// > 当释放实例时，系统盘将被转为按量付费数据盘保留。该盘创建的快照不支持创建自定义镜像，请根据需要在实例释放前制作自定义镜像。
    ///
    /// # Error Codes
    /// - `InvalidImageName.Malformed`: The specified Image name is wrongly formed.
    /// - `InvalidImageName.Duplicated`: The specified image name is already in use.
    /// - `InvalidDescription.Malformed`: The specified description is wrongly formed.
    /// - `InvalidImageVersion.Malformed`: The specified ImageVersion is wrongly formed.
    /// - `IncorrectInstanceStatus`: The current status of the instance does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `InvalidDevice.Malformed`: The specified parameter DiskDeviceMapping.n.Device is not valid.
    /// - `MissingParameter`: The input parameter SnapshotId or InstanceId or DiskDeviceMapping that is mandatory for processing this request is not supplied.
    /// - `InvalidSize.ValueNotSupported`: The specified parameter DiskDeviceMapping.n.Size beyond the permitted range.
    /// - `InvalidDevice.InUse`: The specified parameter DiskDeviceMapping.n.Device has been occupied.
    /// - `OperationDenied`: The specified parameter DiskDeviceMapping.n.SnapshotId does not contain system disk snapshot.
    /// - `InvalidDiskCategory.CreateImage`: The specified diskCategory is not allowed to create image.
    /// - `InvalidArchitecture.Malformed`: The specified Architecture is wrongly formed.
    /// - `InvalidPlatform.Malformed`: The specified Platform is wrongly formed.
    /// - `InvalidParameter.AllEmpty`: %s
    /// - `InvalidParameter.DiskType`: The specified disk type which has kms key can't convert to system disk.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidInstance.NotFoundSystemDisk`: The specified instance does not have system disk.
    /// - `InvalidImageFamily.Malformed`: The format of the specified image family is invalid.
    /// - `ImageQuotaExceed.ImageFamily`: The specified image family exceeds the maximum number of images for one image family.
    /// - `ImageFamilyQuotaExceed`: The number of image families exceeds the limit in the region.
    /// - `InvalidDiskType.ValueNotSupported`: The specified disk type is not supported.
    /// - `IdempotenceParamNotMatch`: Request uses a client token in a previous request but is not identical to that request.
    /// - `InvalidBootMode.NotSupport`: The specified parameter BootMode is not supported for current image architecture.
    /// - `InvalidParameter.FeaturesImdsSupport`: The specified parameter Features.ImdsSupport is not supported.
    /// - `InvalidOperation.DiskCategoryUnsupported`: The current category of the disk does not support this operation.
    /// - `AccountForbidden.CreateOrder`: Order cannot be created due to abnormal account.
    /// - `InvalidBootMode.Malformed`: The specified parameter BootMode is invalid. Valid options are BIOS, UEFI, and UEFI-Preferred.
    /// - `InvalidDetectionStrategy.Malformed`: The specified value for parameter DetectionStrategy is not supported. Please refer to the documentation for accepted values.
    /// - `IncorrectDiskStatus.NeverAttached`: The specified disk has never been attached to instance.
    /// - `InvalidSnapshotId.NotReady`: The current status of the DiskDeviceMapping.n.SnapshotId or SnapshotId does not support this operation.
    /// - `InvalidSnapshot.TooOld`: This operation is denied because the specified snapshot by DiskDeviceMapping.n.SnapshotId or SnapshotId is created before 2013-07-15.
    /// - `OperationDenied`: The specified snapshot is not allowed to create image.
    /// - `QuotaExceed.Image`: The Image Quota exceeds.
    /// - `InvalidParamter.Conflict`: The specified same token is trying to make requests with different parameters.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `InvalidAccountStatus.SnapshotServiceUnavailable`: Snapshot service has not been opened yet.
    /// - `UserNotInTheWhiteList`: The user is not in the white list of create image by data disk snapshot.
    /// - `IncorrectDiskStatus.Invalid`: Device status is invalid, please restart instance and try again.
    /// - `OperationDenied.InvalidSnapshotCategory`: %s
    /// - `QuotaExceed.Snapshot`: The snapshot quota exceeds.
    /// - `IncorrectDiskStatus.Transferring`: The specified device is transferring, you can retry after the process is finished.
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `InvalidSystemSnapshot.Missing`: %s
    /// - `IncorrectDiskStatus.CreatingSnapshot`: A previous snapshot creation is in process.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK needs to be added ECS tag.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be enabled.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `QuotaExceed.Tags`: %s
    /// - `InvalidSnapshotCategory.NotSupportImageCreation`: The specified snapshot category does not support create image.
    /// - `TooManySnapshot.Unfinished`: There are too many snapshots being created, please wait for them to be created done.
    /// - `HibernationConfigured.InstanceOperationForbidden`: The operation is not permitted due to limit of the hibernation configured instance.
    /// - `SnapshotNotReady`: The specified snapshot is not ready.
    /// - `IncorrectInstanceStatus.NeedRestart`: The instance needs to be restarted after adding a disk in a shutdown status.
    /// - `QuotaExceed.ConcurrentSnapshotQuota`: The number of snapshots being created for the disk %s has exceeded the concurrent quota (%s). Please wait for the previous snapshots to complete before trying again.
    /// - `InvalidOperation.SnapshotStorageLocationUnsupported`: Snapshots with storage location in CloudBox do not support the current operation.
    /// - `AccountEnterpriseStatusInvalid`: Your enterprise registration is marked as revoked/deregistered in the National Enterprise Credit Information Publicity System. Account transaction features (purchase/renewal/recharge) are disabled. Please update real-name certification via Account Center. Restrictions will auto-remove after verification.
    /// - `InvalidSnapshotId.NotFound`: The specified SnapshotId does not exist.
    /// - `InvalidInstanceId.NotFound`: The specified instance %s does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError`: The process of creating snapshot has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_image(
        &self,
        req: CreateImage,
    ) -> impl std::future::Future<Output = crate::Result<CreateImageResponse>> + Send {
        self.call(req)
    }

    /// # 查询镜像资源
    ///
    /// 指定ImageId、镜像被使用场景、Filter过滤等参数，查询您可以使用的镜像资源列表。
    ///
    /// - 您可以查询的镜像资源包括您的自定义镜像、阿里云提供的公共镜像、云市场镜像以及其他阿里云用户主动共享给您的共享镜像。
    /// - 支持分页查询，查询结果包括可使用的镜像资源的总数和当前页的镜像资源。每页的数量默认为10条。
    /// - 通过阿里云CLI调用API时，不同数据类型的请求参数取值必须遵循格式要求。更多信息，请参见[CLI参数格式说明](~~110340~~)。
    /// - 当查询阿里云官方提供的镜像或共享镜像（ImageOwnerAlias指定system或others）时，本次请求可忽略RAM鉴权规则。更多信息，请参见[鉴权规则](~~25497~~)。
    ///
    /// # Error Codes
    /// - `InvalidImageOwnerAlias.ValueNotSupported`: The specified ImageOwnerAlias value is not supported.
    /// - `InvalidParamter`: Invalid Parameter.
    /// - `InvalidTag.Mismatch`: The specified Tag.n.Key and Tag.n.Value are not match.
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified instance type %s does not exist. You can use the DescribeInstanceTypes API to query the available instance types.
    /// - `InvalidFilterValue.NetworkType`: The specified networkType value in the Filter is invalid.
    /// - `InvalidOperation.ImageOwnerIdUnsupported`: The parameter "ImageOwnerId" is not supported in this context, it is only valid when querying shared images or community images.
    /// - `InvalidImageOwnerAlias.PublicImageUnsupported`: When querying images, the parameter ImageOwnerAlias should be others while specified parameter IsPublic is true.
    /// - `CurrentAccount.NotSupportPublicImage`: Public image is not supported for current account.
    /// - `InvalidFilterKey.NotFound`: The specified Filter Key is not found.
    /// - `InvalidFilterValue`: The specified Filter Value is not valid.
    /// - `InvalidUsage`: The specified Usage is not valid.
    /// - `InvalidOSType`: The specified OSType is not valid.
    /// - `InvalidArchitecture`: The specified Architecture is not valid.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_images(
        &self,
        req: DescribeImages,
    ) -> impl std::future::Future<Output = crate::Result<DescribeImagesResponse>> + Send {
        self.call(req)
    }

    /// # 修改自定义镜像属性
    ///
    /// 调用ModifyImageAttribute接口，并可以指定ImageId、ImageFamily等参数，修改一份自定义镜像的属性，例如镜像族系、名称、启动模式、状态以及是否支持NVMe等。
    ///
    /// # Error Codes
    /// - `InvalidImageName.Malformed`: Image names must be between 2 and 128 characters long, using either English or Chinese characters. The name must start with a letter or a Chinese character, and can include numbers, colons, underscores and hyphens.
    /// - `MissingParameter`: The input parameter "RegionId" that is mandatory for processing this request is not supplied.
    /// - `InvalidImageName.Duplicated`: The specified Image name has already bean used.
    /// - `InvalidDescription.Malformed`: The specified description is wrongly formed.
    /// - `ImageQuotaFull.ImageFamily`: The specified image family has exceeded max number of images for one image family.
    /// - `InvalidImageFamily.Malformed`: The specified parameter "ImageFamily" is malformed.
    /// - `ImageFamilyQuotaFull`: The specified region has exceeded max number of image family.
    /// - `InvalidBootMode.NotSupport`: The specified parameter BootMode is not supported.
    /// - `InvalidLicenseType.NotSupported`: The specified parameter LicenseType is not supported.
    /// - `InvalidParameter.FeaturesImdsSupport`: The specified parameter Features.ImdsSupport is not supported.
    /// - `ImageStatus.NotAvailable`: The specified image status is not available.
    /// - `ImageStatus.NotDeprecated`: The specified image status is not deprecated.
    /// - `ImageUseShared`: The specified image has been shared to others, please remove shared accounts first.
    /// - `OperationDeined.ImageUsingByInstance`: The boot mode of the image cannot be modified because it has associated instances.
    /// - `InvalidOperation.FeaturesImdsSupportNotMatch`: The specified parameter Features.ImdsSupport can not be set to v1 from v2.
    /// - `InvalidStatus.ImageIsCreating`: The operation cannot be performed because the image is creating. Please wait until the creation is complete and try again.
    /// - `InvalidOperation.PublicImageUnsupported`: The community image's publisher is not the current account. Modification is not permitted.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_image_attribute(
        &self,
        req: ModifyImageAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyImageAttributeResponse>> + Send {
        self.call(req)
    }

    /// # 删除自定义镜像
    ///
    /// 调用DeleteImage接口，并可以指定参数ImageId、Force删除一份自定义镜像。
    ///
    /// 对于不允许删除自定义镜像的情况以及镜像删除后的注意事项，请参见[删除自定义镜像](~~25466~~)。
    ///
    /// # Error Codes
    /// - `ImageUsingByInstance`: The specified image has been used to create instances. You can use the DescribeInstances API to query these instances, or you can use the force parameter to proceed.
    /// - `ImageUseShared`: The specified image has been shared to others. You can use the DescribeImageSharePermission API to query the users who have been shared.
    /// - `OperationDenied.ImageCopying`: The image is being copied. Please use the CancelCopyImage API.
    /// - `ImageIsImporting`: The specified Image is importing.
    /// - `ImageIsExporting`: The specified image is currently being exported. You can use the DescribeTasks API to check the status of related tasks and cancel them if needed.
    /// - `ImageIsPublic`: You can not delete public image, please modify it to private.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_image(
        &self,
        req: DeleteImage,
    ) -> impl std::future::Future<Output = crate::Result<DeleteImageResponse>> + Send {
        self.call(req)
    }

    /// # 查询镜像族系内可用镜像
    ///
    /// 查询指定镜像族系内最新创建的可用自定义镜像。
    ///
    /// ## 接口说明
    ///
    /// 指定查询的镜像族系如果不存在可用的镜像，则返回结果为空。
    ///
    /// # Error Codes
    /// - `InvalidUser.Unauthorized`: The user is not authorized.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_image_from_family(
        &self,
        req: DescribeImageFromFamily,
    ) -> impl std::future::Future<Output = crate::Result<DescribeImageFromFamilyResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询指定镜像支持的实例规格
    ///
    /// 查询指定镜像支持的实例规格。
    ///
    /// # Error Codes
    /// - `InvalidParamter`: Invalid Parameter.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidUsage`: The specifed Usage is not valid.
    /// - `InvalidImageId.NotFound`: The specified image %s does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_image_support_instance_types(
        &self,
        req: DescribeImageSupportInstanceTypes,
    ) -> impl std::future::Future<Output = crate::Result<DescribeImageSupportInstanceTypesResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询自定义镜像已经共享的所有用户
    ///
    /// 查询一份自定义镜像已经共享的所有用户。持返回结果支分页显示，每页的信息条目默认为10条。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The input parameter  "RegionId "that is mandatory for processing this request is not supplied.
    /// - `InvalidImageId.NotFound`: The specified image %s does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_image_share_permission(
        &self,
        req: DescribeImageSharePermission,
    ) -> impl std::future::Future<Output = crate::Result<DescribeImageSharePermissionResponse>> + Send
    {
        self.call(req)
    }

    /// # 管理镜像共享权限
    ///
    /// 管理镜像共享权限。您可以将自己的自定义镜像共享给其他阿里云账号，也可以发布为社区镜像供他人使用。
    ///
    /// 调用该接口前，请您仔细阅读[共享自定义镜像](~~25463~~)。
    ///
    /// 调用该接口时，请注意以下共享规则：
    ///
    /// - **共享限制**：只能共享自己账号下创建的自定义镜像，每份镜像最多可共享给 50 个阿里云账号，每份镜像一次最多共享给10个阿里云账号。
    ///
    /// - **实例影响**：使用共享镜像创建ECS实例（[RunInstances](~~63440~~)）后，一旦自定义镜像拥有者解除了镜像共享关系，或者删除了自定义镜像（[DeleteImage](~~25537~~)），该实例将无法初始化系统盘（[ReInitDisk](~~25519~~)）。
    ///
    /// ><notice>云服务器 ECS 共享加密镜像规则变更：仅支持共享使用用户主密钥 CMK 加密的镜像，不再支持共享使用服务密钥加密的镜像，使用服务密钥加密的镜像在共享时将会报错。如果您保有服务密钥加密的镜像且计划共享给他人使用，请通过复制镜像（CopyImage），将镜像密钥改为用户主密钥CMK。
    /// ></notice>
    ///
    /// 发布或下架社区镜像，您需要注意：
    ///
    /// - **责任与协议**：社区镜像由其所有者负责质量和迭代更新，阿里云仅提供平台支持。发布前请确保您已了解并签署社区镜像协议，否则不允许发布，社区镜像详情见[发布社区镜像](~~208370~~)。
    ///
    /// - **加密限制**：加密镜像不可发布为社区镜像。
    ///
    /// - **公开性**：社区镜像完全公开，在镜像所属地域下，所有阿里云账号均可使用。
    ///
    /// - **功能限制**：社区镜像不支持共享、导出或复制。
    ///
    /// - **下架影响**：社区镜像下架后，将不再对其他阿里云账号公开，但已共享的镜像关系会继续保持。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The input parameter "RegionId" that is mandatory for processing this request is not supplied.
    /// - `InvalidGroup.Malformed`: The specified Group is wrongly formed.
    /// - `UnnecessaryParameter.LaunchPermission`: The specified parameter "LaunchPermission" is unnecessary if paramter "AddAccounts" or "RemoveAccounts" exist.
    /// - `InvalidParameter.LaunchPermission`: The specified parameter "LaunchPermission" is invalid.
    /// - `ForbiddenParameter.LaunchPermission`: The specified parameter "LaunchPermission" is forbidden for current account.
    /// - `AssumeRoleError`: Requires a RAM role of AliyunECSShareEncryptImageDefaultRole before sharing encrypted image.
    /// - `ImageDescription.ContainsSensitiveWords`: The specified image description contains sensitive words.
    /// - `ImageName.ContainsSensitiveWords`: The specified image name contains sensitive words.
    /// - `Image.Public`: The specified image is public image.
    /// - `CurrentRegion.NotSupportPublicImage`: Public image is not supported for current region.
    /// - `Image.NotPublic`: The specified image is not public image.
    /// - `OperationDeined.FullImage`: The encrypted image contains multiple snapshots, which do not support share.
    /// - `QuotaExceed.ShareImage`: The shared Image Quota exceeds.
    /// - `QuotaExceed.ShareImageUser`: The shared Image user Quota exceeds.
    /// - `InvalidImageId.BidMismatch`: Cannot share the image with users %s of other sites.
    /// - `OperationDeined.EncryptedSnapshot`: The image contains encrypted snapshots, which do not support share.
    /// - `OperationDenied.InvalidImageStatus`: The specified image cannot be shared when it is deprecated.
    /// - `PublicImageAgreement.NotSigned`: The current account has not signed "Community Image Terms of Service".
    /// - `InvalidParameter.IsPublic`: The specified parameter IsPublic is conflicted with other parameters.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidOperation.ServiceKeyEncryptedImageUnsupported`: The specified service key encrypted image is not supported for this operation. Please switch to a CMK (Customer Master Key) encrypted image and retry.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.
    /// - `InvalidAccount.NotFound`: The specified account %s in parameter "AddAccount.n" or "RemoveAccount.n" does not exist.
    /// - `InvalidAccount.Forbbiden`: The specified Account does not yourself.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_image_share_permission(
        &self,
        req: ModifyImageSharePermission,
    ) -> impl std::future::Future<Output = crate::Result<ModifyImageSharePermissionResponse>> + Send
    {
        self.call(req)
    }

    /// 修改镜像共享组权限
    ///
    /// # Error Codes
    /// - `MissingParameter`: The input parameter "RegionId" that is mandatory for processing this request is not supplied.
    /// - `Forbbiden`: User not authorized to operate on the specified resource.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.
    /// - `InvalidGroup.Malformed`: The specified parameter "AddGroup.n" or "RemoveGroup.n" does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_image_share_group_permission(
        &self,
        req: ModifyImageShareGroupPermission,
    ) -> impl std::future::Future<Output = crate::Result<ModifyImageShareGroupPermissionResponse>> + Send
    {
        self.call(req)
    }

    /// # 导入本地镜像文件
    ///
    /// 导入一份您的本地镜像文件到云服务器ECS，作为自定义镜像出现在相应地域中。后续您可以使用导入的镜像创建ECS实例（RunInstances），或者更换实例的系统盘（ReplaceSystemDisk）。
    ///
    /// ### 接口说明
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 您必须提前上传镜像文件到对象存储OSS。具体操作，请参见[上传文件](~~31886~~)。
    ///
    /// - 为避免部分服务器、虚拟机或者云主机的操作系统在导入自定义镜像后，创建的ECS实例无法启动，您需要在导入镜像前检查是否需要在源服务器中安装virtio驱动。具体操作，请参见[安装virtio驱动](~~62423~~)。
    ///
    /// - 首次导入镜像时，您必须提前通过访问控制RAM授权ECS访问您的OSS Bucket，否则会报错`NoSetRoletoECSServiceAccount`或`InvalidOperation.CloudBoxImageImportRoleRequired`。分为以下两种场景情况：
    ///
    ///   - **不通过云盒导入镜像文件**：您可以通过RAM管理控制台一键完成授权操作，具体的授权页面，请参见[云资源访问授权](https://ram.console.aliyun.com/?spm=5176.2020520101image.0.0.2ffa4df57kSoHX#/role/authorize?request=%7B%22Requests%22%3A%20%7B%22request1%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageImportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSImportRole%22%7D%2C%20%22request2%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageExportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSExportRole%22%7D%7D%2C%20%22ReturnUrl%22%3A%20%22https%3A//ecs.console.aliyun.com/%22%2C%20%22Service%22%3A%20%22ECS%22%7D)。您也可以手动完成授权操作，部分操作中策略与权限如下所示。具体操作，请参见[账号访问控制](~~25481~~)。
    ///
    ///     1. 创建角色`AliyunECSImageImportDefaultRole`（必须是这个名称，否则导入镜像会失败），角色的策略为：
    /// ```ignore
    ///         {
    /// 			"Statement": [
    /// 			{
    /// 				"Action": "sts:AssumeRole",
    /// 				"Effect": "Allow",
    /// 				"Principal": {
    /// 				"Service": [
    /// 					"ecs.aliyuncs.com"
    /// 				]
    /// 				}
    /// 			}
    ///         ],
    /// 			"Version": "1"
    ///         }
    ///         ```
    ///
    ///     2. 在该角色下，添加系统策略`AliyunECSImageImportRolePolicy`。您也可以创建自定义策略，权限必须包含：
    /// ```ignore
    ///
    ///         {
    /// 			"Version": "1",
    /// 			"Statement": [
    /// 			{
    /// 				"Action": [
    ///         				"oss:GetObject",
    ///         				"oss:GetBucketLocation",
    ///         				"oss:GetBucketInfo"
    /// 			],
    ///         			"Resource": "*",
    ///         			"Effect": "Allow"
    ///         			}
    /// 			]
    ///         }
    ///         
    ///         ```
    ///
    ///   - **通过云盒导入镜像文件**：您可以通过RAM管理控制台一键完成授权操作，具体的授权页面，请参见[云资源访问授权](https://ram.console.aliyun.com/role/authorize?request=%7B%22ReturnUrl%22%3A%22https%3A%2F%2Fecs.console.aliyun.com%2F%22%2C%22Services%22%3A%5B%7B%22Roles%22%3A%5B%7B%22RoleName%22%3A%22AliyunECSCloudBoxImageImportDefaultRole%22%2C%22TemplateId%22%3A%22AliyunECSCloudBoxImageImportDefaultRole%22%7D%5D%2C%22Service%22%3A%22ECS%22%7D%5D%7D)。您也可以手动完成授权操作，部分操作中策略与权限如下所示。具体操作，请参见[账号访问控制](~~25481~~)。
    ///
    ///     1. 创建角色`AliyunECSCloudBoxImageImportDefaultRole`（必须是这个名称，否则导入镜像会失败），角色的策略为：
    /// ```ignore
    ///         {
    /// 			"Statement": [
    /// 			{
    /// 				"Action": "sts:AssumeRole",
    /// 				"Effect": "Allow",
    /// 				"Principal": {
    /// 				"Service": [
    /// 					"ecs.aliyuncs.com"
    /// 				]
    /// 				}
    /// 			}
    ///         ],
    /// 			"Version": "1"
    ///         }
    ///         ```
    ///
    ///     2. 在该角色下，添加系统策略`AliyunECSCloudBoxImageImportRolePolicy`。您也可以创建自定义策略，权限必须包含：
    /// ```ignore
    ///
    ///         {
    /// 			"Version": "1",
    /// 			"Statement": [
    /// 			{
    /// 				"Action": [
    ///         				"oss-cloudbox:GetObject",
    ///         				"oss-cloudbox:GetBucketLocation",
    ///         				"oss-cloudbox:GetBucketInfo"
    /// 			],
    ///         			"Resource": "*",
    ///         			"Effect": "Allow"
    ///         			}
    /// 			]
    ///         }
    ///         
    ///         ```
    ///
    /// - 不能删除正在导入的镜像，只能调用[CancelTask](~~25624~~)取消导入镜像任务。
    ///
    /// - 导入镜像的地域必须跟镜像文件上传的OSS Bucket的地域相同。
    ///
    /// - 参数`DiskDeviceMapping.N`中N的取值范围为1~17。N为1时表示系统盘，N为2~17时表示数据盘，当N大于17时系统会自动忽略。
    ///
    /// - 当参数`Architecture`取值为`arm64`，或者参数`Platform`取值为`CentOS Stream`、`Anolis`、`AlmaLinux`、`UOS`、`Kylin`或`Rocky Linux`时，您需要注意：
    ///
    ///     - 为了使导入后的镜像支持配置密码或者支持修改密钥对，镜像必须满足以下条件：
    ///
    ///         - 操作系统的内核需要支持`CONFIG_FW_CFG_SYSFS`特性。Linux社区内核4.6版本之后默认支持该特性，CentOS的内核在3.10.0-826.el7版本之后默认支持该特性。您可以在该镜像对应的服务器内运行`grep -nr CONFIG_FW_CFG_SYSFS /boot/config-$(uname -r)`命令，如果回显结果中包含`CONFIG_FW_CFG_SYSFS=y`信息，则说明该镜像中的内核已支持`CONFIG_FW_CFG_SYSFS`特性。
    ///
    ///
    ///         - 操作系统中已安装阿里云最新版本cloud-init。其中，19.1版本cloud-init必须在19.1.3版本及以上，部分低版本操作系统中的0.7.6a版本cloud-init必须在0.7.6a15版本及以上。具体操作，请参见[安装cloud-init](~~57803~~)。
    ///
    ///         - 操作系统需要支持SHA-512加密算法。
    ///
    ///     - 为了使导入后的镜像支持扩容云盘与扩容文件系统，镜像必须满足以下条件：
    ///
    ///         - 操作系统的内核版本需要高于3.6版本。
    ///
    ///         - 支持growpart命令。支持该命令需要安装`cloud-utils-growpart`包，不同操作系统安装方式有所不同。具体操作，请参见[扩容分区和文件系统（Linux）](~~2949817#bb3b1f02e51pj~~)。
    ///
    ///         - 支持resize2fs命令。支持该命令需要安装`e2fsprogs`包，该包在操作系统中默认已安装，如果没有安装您需要自行安装。
    ///
    ///         - 操作系统中已安装阿里云最新版本cloud-init。其中，19.1版本cloud-init必须在19.1.3版本及以上，部分低版本操作系统中的0.7.6a版本cloud-init必须在0.7.6a15版本及以上。具体操作，请参见[安装cloud-init](~~57803~~)。
    /// - 如果您待导入的自定义镜像对应的系统架构为arm64时，您需要设置其RTC时钟使用UTC时间标准。具体操作，请参见[Linux时间和时区说明](~~405080~~)。
    ///
    /// - 强烈建议在导入镜像时配置镜像检测参数，有助于系统帮助优化您的镜像。更多信息，请参见[镜像检测概述](~~439819~~)。
    ///
    /// # Error Codes
    /// - `UnsupportedSuffix.OSSObject`: The specified OSS object suffix is not supported.
    /// - `MissingParameter`: An input parameter "RegionId" that is mandatory for processing the request is not supplied.
    /// - `InvalidImageName.Malformed`: The specified Image name is wrongly formed.
    /// - `InvalidOSSObject.Malformed`: The specified OSS object is wrongly formed.
    /// - `InvalidOSSBucket.Malformed`: The specified OSS bucket is wrongly formed.
    /// - `InvalidOSSObject.Size`: The specified OSS object size is zero.
    /// - `InvalidDescription.Malformed`: The specified Image description is wrongly formed.
    /// - `InvalidArchitecture.Malformed`: The specified Architecture is wrongly formed.
    /// - `InvalidPlatform.Malformed`: The specified Platform is wrongly formed.
    /// - `InvalidOSType.Malformed`: The specified OSType is wrongly formed.
    /// - `InvalidImageName.Duplicated`: The destination image is exist.
    /// - `InvalidImageSize`: %s
    /// - `InvalidDataDiskSize`: The specified DiskDeviceMapping.N.DiskImSize should be in the specified range.
    /// - `InvalidImageFormat.Malformed`: The specified Image Format is wrongly formed.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidRegion.NotSupport`: The specified region does not support image import or export.
    /// - `InvalidOSSBucket.NotFound`: The specified OSS bucket does not exist in this region.
    /// - `InvalidOSSObject.NotFound`: The specified OSS object does not exist in this region.
    /// - `InvalidOSSObject.NeedRestore`: The specified OSS object is a archive object, need restore first.
    /// - `InvalidOSSBucket.NotMatched`: The specified OSS bucket is incorrect, %s.
    /// - `InvalidLicenseType.NotSupported`: The specified LicenseType is not supported.
    /// - `InvalidLicenseType.BYOLOnly`: Only BYOL LicenseType is supported for the current platform provided.
    /// - `InvalidOSSBucket.FlowLimit`: %s
    /// - `InvalidImageFormat.RegionNotSupported`: The specified image format is not supported in current region.
    /// - `InvalidBootMode.Malformed`: The specified parameter "BootMode" is malformed.
    /// - `InvalidParameter.DetectionStrategy`: The specified parameter DetectionStrategy is invalid.
    /// - `InvalidBootMode.NotSupport`: The specified parameter BootMode is not supported for current image architecture.
    /// - `DRYRUN.SUCCESS`: This request is a dryrun request with successful result.
    /// - `InvalidClientToken.Malformed`: The specified parameter clientToken is not valid.
    /// - `InvalidParameter.FeaturesImdsSupport`: The specified parameter Features.ImdsSupport is not supported.
    /// - `Account.Arrearage`: Your account has an outstanding payment.
    /// - `ImageIsImporting`: The specified Image is importing.
    /// - `QuotaExceed.Image`: The Image Quota exceeds.
    /// - `ImportImageFailed`: Importing image is failed, Please contact the administrator.
    /// - `UserNotInTheWhiteList`: The user is not in the white list of importing image.
    /// - `NoSetRoletoECSServiceAcount`: ECS service account Have no right to access your OSS.please attach a role of access your oss to ECS service account.
    /// - `InvalidParameter.Malformed`: The specified parameter "DiskDeviceMapping.n.Device " is not valid.
    /// - `MissingParameter.DiskDeviceMapping`: The specified parameter DiskDeviceMapping is not supplied.
    /// - `InvalidOSS.NotAuthorized`: The specified OSS bucket or object is not allowed to access.
    /// - `InvalidBlockSize.NotSupport`: %s
    /// - `InvalidImageFormat.Malformed`: %s
    /// - `ImageCheckUnsupported.WindowsImage`: Image check is unsupported for windows image.
    /// - `InvalidVHDImage.IncorrectSize`: The specified size of the VHD image does not meet the 'header.MaxTableEntries * header.BlockSize' specification.
    /// - `InvalidOSSBucket.EncryptUnsupported`: Accessing objects from encrypted OSS bucket is not supported.
    /// - `InvalidArchitecture.PlatformUnsupported`: The OS platform you selected does not support the specified architecture.
    /// - `InvalidAccountStatus.OSSDisabled`: OSS is disabled due to invalid account status.
    /// - `InvalidStorageLocation.NotFound`: The specified cloud box storage location %s could not be found.
    /// - `InvalidOperation.CloudBoxImageImportRoleRequired`: The role for cloud box image import is not set to the ECS service.
    /// - `InvalidOperation.CloudBoxImageImportUnsupported`: Importing cloud box images is not supported.
    /// - `TagKey.Duplication`: The TagKey has duplication with others, case-insensitive.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn import_image(
        &self,
        req: ImportImage,
    ) -> impl std::future::Future<Output = crate::Result<ImportImageResponse>> + Send {
        self.call(req)
    }

    /// # 导出一份自定义镜像到OSS
    ///
    /// 导出一份自定义镜像到与自定义镜像同一地域的OSS Bucket里。
    ///
    /// 导出镜像前：
    ///
    /// - 您需要先了解前提条件以及注意事项。更多信息，请参见[导出镜像](~~58181~~)。
    ///
    /// - 设置参数`ImageFormat`镜像导出格式功能仅在部分地域可用，支持的地域有日本（东京）、印度尼西亚（雅加达）、德国（法兰克福）、阿联酋（迪拜）、美国（弗吉尼亚）、英国（伦敦）、新加坡、马来西亚（吉隆坡）和美国（硅谷）。不支持设置镜像格式的地域，默认导出RAW格式的镜像。
    ///
    /// - 您必须通过RAM授权云服务器ECS写入OSS的权限。具体操作说明如下：
    ///
    ///     - 创建角色：`AliyunECSImageExportDefaultRole`（其他任何角色名称无效），为该角色设置以下角色策略：
    /// ```ignore
    ///          {
    ///            "Statement": [
    ///              {
    ///                "Action": "sts:AssumeRole",
    ///                "Effect": "Allow",
    ///                "Principal": {
    ///                  "Service": [
    ///                    "ecs.aliyuncs.com"
    ///                  ]
    ///                }
    ///              }
    ///            ],
    ///            "Version": "1"
    ///          }
    ///   - 在角色`AliyunECSImageExportDefaultRole`下加入默认的系统权限策略：`AliyunECSImageExportRolePolicy`，该策略是云服务器ECS提供导出镜像的默认策略。更多详情，请参见[云资源访问授权](https://ram.console.aliyun.com/?spm=5176.2020520101.0.0.64c64df5dfpmdY#/role/authorize?request=%7B%22Requests%22:%20%7B%22request1%22:%20%7B%22RoleName%22:%20%22AliyunECSImageImportDefaultRole%22,%20%22TemplateId%22:%20%22ECSImportRole%22%7D,%20%22request2%22:%20%7B%22RoleName%22:%20%22AliyunECSImageExportDefaultRole%22,%20%22TemplateId%22:%20%22ECSExportRole%22%7D%7D,%20%22ReturnUrl%22:%20%22https:%2F%2Fecs.console.aliyun.com%2F%22,%20%22Service%22:%20%22ECS%22%7D)。您也可以创建自定义策略，权限需要包含：
    ///     ```
    ///          {
    ///            "Version": "1",
    ///            "Statement": [
    ///              {
    ///                "Action": [
    ///                  "oss:GetObject",
    ///                  "oss:PutObject",
    ///                  "oss:DeleteObject",
    ///                  "oss:GetBucketLocation",
    ///                  "oss:GetBucketInfo",
    ///                  "oss:AbortMultipartUpload",
    ///                  "oss:ListMultipartUploads",
    ///                  "oss:ListParts"
    ///                ],
    ///                "Resource": "*",
    ///                "Effect": "Allow"
    ///              }
    ///            ]
    ///          }
    /// ```ignore
    ///
    /// 导出镜像后：
    ///
    /// 自定义镜像将保存在指定的OSS bucket中，您可以下载自定义镜像。具体操作，请参见[下载自定义镜像文件](~~31912~~)。
    ///
    /// # Error Codes
    /// - `MissingParameter`: An input parameter "RegionId" that is mandatory for processing the request is not supplied.
    /// - `InvalidImageName.Malformed`: The specified Image name is wrongly formed.
    /// - `InvalidOSSPrefix.Malformed`: The specified OSSPrefix format is wrongly formed.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidRegion.NotSupport`: The specified region does not support image import or export.
    /// - `IncorrectImageStatus`: The specified Image is not available.
    /// - `InvalidImageFormat.Malformed`: The specified Image Format is wrongly formed.
    /// - `InvalidOSSBucket.NotFound`: The specified OSS bucket does not exist in this region.
    /// - `OperationDenied`: The specified image contains the snapshot of the data disk,does not support this operation.
    /// - `InvalidImage.DiskAmountOrSize`: %s
    /// - `ImageNotSupported`: The specified Image contains encrypted snapshots, do not support export.
    /// - `InvalidOSSObject.NeedRestore`: The specified OSS object is a archive object, need restore first.
    /// - `InvalidOSSBucket.NotMatched`: The specified OSS bucket is incorrect, %s.
    /// - `InvalidImageFormat.RegionNotSupported`: The specified image format is not supported in current region.
    /// - `InvalidOSSBucket.ArchiveOssBucketNotSupported`: Exporting an image to an OSS bucket with Archive, Cold Archive, or Deep Cold Archive storage class is not supported.
    /// - `ImageNotSupported`: The specified image from the image market, do not support export image.
    /// - `ImageIsExporting`: The specified Image is being exported. You can use the DescribeTasks API to check the status of existing tasks.
    /// - `ExportImageFailed`: Exporting image is failed, Please contact the administrator.
    /// - `UserNotInTheWhiteList`: The user is not in the white list of exporting image.
    /// - `NoSetRoletoECSServiceAcount`: ECS service account Have no right to access your OSS.please attach a role of access your oss to ECS service account.
    /// - `InvalidOSS.NotAuthorized`: The specified OSS bucket or object is not allowed to access.
    /// - `ConcurrentQuotaExceed.ExportImage`: %s
    /// - `WeeklyQuotaExceed.ExportImage`: %s
    /// - `InvalidImageLicense.NotSupported`: %s
    /// - `InvalidImageCategory.NotSupported`: The specified image category is not supported.
    /// - `InvalidOSSBucket.EncryptUnsupported`: Accessing objects from encrypted OSS bucket is not supported.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn export_image(
        &self,
        req: ExportImage,
    ) -> impl std::future::Future<Output = crate::Result<ExportImageResponse>> + Send {
        self.call(req)
    }

    /// # 复制一个地域下的自定义镜像到其他地域
    ///
    /// 复制一个地域下的自定义镜像到其他地域。复制镜像可以实现跨地域部署ECS实例、跨地域复制ECS实例等目的。
    ///
    /// ## 接口说明
    /// 您可以在其他地域使用复制后的镜像创建ECS实例（RunInstances），或者更换实例的系统盘（ReplaceSystemDisk）。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 自定义镜像的状态必须为可用（`Available`）。  
    /// - 镜像是您账号下的自定义镜像时，可以跨地域复制镜像；镜像是其他人共享给您的镜像时，只能同地域复制镜像。
    /// - 复制镜像期间，您无法直接操作删除（[DeleteImage](~~25537~~)）复制中的镜像，但是您可以通过取消复制任务（[CancelCopyImage](~~25539~~)）的方式来删除复制中的镜像。  
    /// - 同一个地域下同时只能有五个镜像复制任务运行，其余任务需要排队等待上述任一任务完成后再依次排队执行。
    /// - 您可以通过`ResourceGroupId`参数指定复制后的镜像所属的资源组。如果不设置`ResourceGroupId`参数值，复制后的镜像属于默认资源组。
    ///
    /// # Error Codes
    /// - `InvalidDescription.Malformed`: The specified destination description is wrongly formed.
    /// - `SourceRegion.NotFound`: The source region not found.
    /// - `DestinationRegion.NotFound`: The destination region not found.
    /// - `IncorrectImageStatus`: The image not available.
    /// - `InvalidSnapshotId.NotFound`: The specified SnapshotId does not exist.
    /// - `InvalidImageName.Duplicated`: The specified image name is already in use in the target region. Please try a different one.
    /// - `InvalidParameter.EncryptedIllegal`: The specified parameter Encrypted must be true when kmsKeyId is not empty.
    /// - `InvalidEncrypted.NotMatchEncryptAlgorithm`: The specified parameter Encrypted must be true when EncryptAlgorithm is not empty.
    /// - `InvalidEncryptAlgorithm`: The specified parameter EncryptAlgorithm is not valid.
    /// - `InvalidEncrypted.NotMatchKmsKeyId`: The specified parameter Encrypted must be true when KmsKeyId is not empty.
    /// - `OperationDenied.CommunityImage`: Community image does not support copy.
    /// - `InvalidImageName.Malformed`: The specified destination image name is wrongly formed.
    /// - `InvalidParameter.KmsNotEnabled`: The specified operation need enable KMS.
    /// - `OperationDenied.ImageCopyConflict`: The same image cannot be copied concurrently. Please wait until the last copy is completed before performing the next operation.
    /// - `Account.Arrearage`: Your account has an outstanding payment.
    /// - `InvalidAliUid.IsNull`: The aliUid must not be null.
    /// - `Forbbiden`: User not authorized to operate on the specified resource.
    /// - `InvalidOperation.CopyingDataFromThisRegionUnsupported`: Data transfer from the current region to other regions is not supported.
    /// - `InvalidOperation.CopyingDataToThisRegionUnsupported`: Only Some Regions %s can copy data to this region.
    /// - `QuotaExceed.Image`: The number of images exceeds the limit (%s).
    /// - `QuotaExceed.Snapshot`: The snapshot quota exceeds.
    /// - `OperationDenied.ImageCopying`: The image is currently being copied. Please try again later.
    /// - `RegionNotSupportCopy`: The region not support copy.
    /// - `InvalidSnapshot.TooOld`: This operation is denied because the specified snapshot is created before 2013-07-15.
    /// - `OperationDenied`: The specified snapshot is not allowed to create image.
    /// - `IncorrectDestinationRegion`: The destination region is not equal the target region.
    /// - `OperationDeined.EncryptedSnapshot`: The image contains encrypted snapshots, which do not support copying.
    /// - `OperationDenied.SameRegionOnly`: The image shared from others can not be copied to another region directly.
    /// - `OperationDenied.NotPublished`: The operation is denied because corresponding marketplace image is not published in destination region.
    /// - `OperationDenied.NotAuthorized`: The operation is denied because corresponding marketplace image is not authorized to current user.
    /// - `OperationDenied.EncryptSnapshotAcrossRegion`: The image do not contain encrypted snapshots, which do not support copying to encrypted ones.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `InvalidRegion.NotSupport`: The specified region does not support byok.
    /// - `UserNotInTheWhiteList`: The user is not in byok white list.
    /// - `InvalidRegionId.NotSupportEncryptAlgorithm`: The current region does not support creating encrypted disks with EncryptAlgorithm.
    /// - `OperationDenied.KmsServiceUnauthorized`: The account is not authorized to kms service, please authorize it.
    /// - `OperationDenied.NonCompliantDestinationRegion`: The copy operation to the destination region is not in compliance with regulations.
    /// - `InvalidEncrypted.NotMatchDiskDefaultEncryption`: The specified parameter Encrypted not match for your account default encryption settings.
    /// - `InvalidParameter.DataEncryptedKeyCreateFailed`: Create kms data encrypted key fail. If you need further assistance, you can contact the KMS Technical Support.
    /// - `SizeExceed.Image`: The image exceeds the maximum size. You can use the CopySnapshot API to copy your snapshots of the image and then create a new image from them.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.
    /// - `InvalidOperation.VhdImageUnsupported`: The specified vhd image is not supported for this operation. Please switch to a raw image and retry.
    /// - `InvalidOperation.CloudBoxImageCopyUnsupported`: Copying CloudBox images is not supported.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.
    /// - `InvalidParameter.KMSKeyId.NotFound`: The specified KMSKeyId does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InvalidOperation.Conflict`: Request was denied due to conflict with a previous request, please try again later.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn copy_image(
        &self,
        req: CopyImage,
    ) -> impl std::future::Future<Output = crate::Result<CopyImageResponse>> + Send {
        self.call(req)
    }

    /// # 取消正在进行中的复制镜像任务
    ///
    /// 取消正在进行中的复制镜像（CopyImage）任务。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 取消复制镜像后，目标地域中新建的镜像会被自动删除，源镜像保持不变。
    /// - 若复制镜像已完成，则操作失败并返回错误提示。
    ///
    /// # Error Codes
    /// - `ImageCreatedNotFromCopy`: The specified image is not the target image of a copy action.
    /// - `InvalidDescription.Malformed`: The specified description is wrongly formed.
    /// - `IncorrectImageStatus`: The specified snapshot is not coping.
    /// - `CancelNotSupported`: The specified image coping can not be cancelled.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn cancel_copy_image(
        &self,
        req: CancelCopyImage,
    ) -> impl std::future::Future<Output = crate::Result<CancelCopyImageResponse>> + Send {
        self.call(req)
    }

    /// # 创建镜像组件
    ///
    /// 创建一个镜像组件。镜像组件用于存储您在构建镜像时，常用的构建模板命令。
    ///
    /// ## 接口说明
    ///
    /// 创建镜像组件前，您需要注意：
    ///
    /// - 仅支持创建您自定义的镜像组件。
    /// - 相同名称的组件版本号不能重复，当在模板中使用组件时，可以通过名称和版本号进行引用。
    /// - 镜像组件的内容大小不能超过16 KB。支持的命令详情，请参见[镜像构建服务支持的命令说明](~~200206~~)。
    ///
    /// 更多信息，请参见[镜像构建概述](~~197410~~)。
    ///
    /// # Error Codes
    /// - `InvalidCommand.Component`: Image component does not support component command.
    /// - `InvalidName.Malformed`: %s
    /// - `InvalidDescription.Malformed`: %s
    /// - `InvalidSystemType.NotSupportedValue`: %s
    /// - `InvalidComponentType.NotSupportedValue`: %s
    /// - `InvalidContent.LengthExceeded`: %s
    /// - `InvalidImageTemplateCommandSize.ExceededMaxNumber`: %s
    /// - `InvalidImageTemplateCommand.NotSupported`: %s
    /// - `InvalidCommandContent.RUN`: %s
    /// - `InvalidCommandContent.ENV`: %s
    /// - `InvalidCommandContent.WORKDIR`: %s
    /// - `InvalidCommandContent.COPY`: %s
    /// - `InvalidCommandContent.USER`: %s
    /// - `InvalidCommandContent.CMD`: %s
    /// - `InvalidCommandContent.ENTRYPOINT`: %s
    /// - `MissingParameter.Content`: %s
    /// - `EmptyCommandContent.RUN`: %s.
    /// - `EmptyCommandContent.ENV`: %s.
    /// - `EmptyCommandContent.LABEL`: %s.
    /// - `EmptyCommandContent.COPY`: %s.
    /// - `EmptyCommandContent.ENTRYPOINT`: %s.
    /// - `EmptyCommandContent.CMD`: %s.
    /// - `NotEmptyCommandContent.RESTART`: %s.
    /// - `EmptyCommandContent.WORKDIR`: %s.
    /// - `EmptyCommandContent.USER`: %s.
    /// - `QuotaExceed.ImageComponent`: %s.
    /// - `InvalidParameter.Content`: %s.
    /// - `InvalidImage.OsTypeUnsupported`: The specified base image does not support image building.
    /// - `InvalidParameter.ComponentVersion`: The specified ComponentVersion is invalid.
    /// - `InvalidComponentVersion.Exist`: The specified ComponentVersion does exist with the specified Name.
    /// - `InvalidOperation.NoPermissionCreateServiceLinkedRole`: You are not authorized to create Service-linked role. The system will automatically create it when the API is called for the first time. Check your RAM policies, and ensure that you are using the correct credentials.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `NotSupportedCommand.FROM`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_image_component(
        &self,
        req: CreateImageComponent,
    ) -> impl std::future::Future<Output = crate::Result<CreateImageComponentResponse>> + Send {
        self.call(req)
    }

    /// # 查询镜像组件的详细信息
    ///
    /// 查询一个或多个镜像组件的详细信息。
    ///
    /// 您可以设置`NextToken`查询凭证（Token），其取值是上一次调用DescribeImageComponents返回的`NextToken`参数值，再通过`MaxResults`设置单页查询的最大条目数进行查询。
    ///
    /// # Error Codes
    /// - `InvalidParameter.Owner`: The specified parameter \"Owner\" is not valid.
    /// - `InvalidImageComponentIdSize.ExceededMaxNumber`: %s
    /// - `InvalidSystemType.NotSupportedValue`: %s.
    /// - `InvalidComponentType.NotSupportedValue`: %s.
    /// - `InvalidParameter.ComponentVersion`: The specified ComponentVersion is invalid.
    /// - `Invalid.NextToken`: The specified NextToken is not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_image_components(
        &self,
        req: DescribeImageComponents,
    ) -> impl std::future::Future<Output = crate::Result<DescribeImageComponentsResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除镜像组件
    ///
    /// 调用DeleteImageComponent接口，并指定参数RegionId、ImageComponentId，删除一个镜像组件。
    ///
    /// - 仅支持删除您已创建的自定义镜像组件。
    /// - 当删除组件时，确保该组件不在模板中使用，否则将会删除失败。
    ///
    /// # Error Codes
    /// - `InvalidImageComponent.InUse`: %s.
    /// - `InvalidImageComponent.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_image_component(
        &self,
        req: DeleteImageComponent,
    ) -> impl std::future::Future<Output = crate::Result<DeleteImageComponentResponse>> + Send {
        self.call(req)
    }

    /// # 创建镜像构建模板
    ///
    /// 创建一个镜像模板。镜像模板可用于构建镜像。
    ///
    /// ## 接口说明
    ///
    /// 您可以通过镜像模板定制镜像内容，并支持跨地域跨账号构建镜像。创建镜像模板前，您需要注意：
    ///
    /// - 仅支持创建您自定义的镜像模板。
    /// - 仅支持使用公共镜像、自定义镜像、共享镜像或者镜像族系作为源镜像进行构建。
    /// - 通过镜像模板构建镜像时，需要创建多台中转实例辅助构建镜像，中转实例为按量计费的ECS实例，将收取一定的费用。更多信息，请参见[按量付费](~~40653~~)。
    ///
    /// 关于构建模板内容`BuildContent`，您需要注意：
    /// - `FROM`命令已被弃用，不管参数`BuildContent`是否设置`FROM`命令，系统都会以源镜像类型`BaseImageType`和源镜像`BaseImage`为准进行源镜像的选取。
    /// - 一个镜像模板内容大小不能超过16 KB。支持的命令说明详情，请参见[镜像构建服务支持的命令说明](~~200206~~)。
    ///
    /// 更多信息，请参见[镜像构建概述](~~197410~~)。
    ///
    /// # Error Codes
    /// - `InvalidSourceInstance.NotFound`: The specified source instance is not found.
    /// - `InvalidName.Malformed`: %s
    /// - `InvalidDescription.Malformed`: %s
    /// - `InvalidImageName.Malformed`: %s
    /// - `InvalidBaseImageType.NotSupportedValue`: %s
    /// - `InvalidSystemDiskSize.NotSupportedValue`: %s
    /// - `InvalidInternetMaxBandwidthOut.NotSupportedValue`: %s
    /// - `InvalidAddAccountSize.ExceededMaxNumber`: %s
    /// - `InvalidToRegionIdSize.ExceededMaxNumber`: %s
    /// - `InvalidBuildContent.LengthExceeded`: %s
    /// - `InvalidImageTemplateCommandSize.ExceededMaxNumber`: %s
    /// - `DuplicatedCommand.FROM`: %s
    /// - `InvalidCommandOrder.FROM`: %s
    /// - `InvalidImageTemplateCommand.NotSupported`: %s
    /// - `InvalidCommandContent.RUN`: %s
    /// - `InvalidCommandContent.ENV`: %s
    /// - `InvalidCommandContent.WORKDIR`: %s
    /// - `InvalidCommandContent.COPY`: %s
    /// - `InvalidCommandContent.USER`: %s
    /// - `InvalidCommandContent.FROM`: %s
    /// - `InvalidCommandContent.CMD`: %s
    /// - `InvalidCommandContent.ENTRYPOINT`: %s
    /// - `QuotaExceed.ImagePipeline`: %s.
    /// - `NoPermission`: %s.
    /// - `EmptyCommandContent.LABEL`: %s.
    /// - `EmptyCommandContent.ENV`: %s.
    /// - `EmptyCommandContent.ENTRYPOINT`: %s.
    /// - `EmptyCommandContent.CMD`: %s.
    /// - `EmptyCommandContent.COPY`: %s.
    /// - `EmptyCommandContent.WORKDIR`: %s.
    /// - `NotEmptyCommandContent.RESTART`: %s.
    /// - `EmptyCommandContent.USER`: %s.
    /// - `EmptyCommandContent.RUN`: %s.
    /// - `InvalidImage.OsTypeUnsupported`: The specified base image does not support image building.
    /// - `InvalidParameter.BuildContent`: %s.
    /// - `InvalidParameter.TestContent`: %s.
    /// - `InvalidImageComponent.NotSupported`: %s.
    /// - `InvalidParameterCombination`: %s.
    /// - `InvalidParameter.RepairMode`: The specified parameter RepairMode is invalid.
    /// - `InvalidImageFamily.Malformed`: The format of the specified image family is invalid.
    /// - `InvalidImage.ImageOwnerAliasUnsupported`: The specified base image does not support distributing.
    /// - `InvalidParameter.ImportImageOptionsArchitecture`: The specified parameter ImportImageOptions.Architecture is invalid. The correct value should be in [%s].
    /// - `InvalidParameter.ImportImageOptionsOSType`: The specified parameter ImportImageOptions.OSType is invalid. The correct value should be in [%s].
    /// - `InvalidParameter.ImportImageOptionsBootMode`: The specified parameter ImportImageOptions.BootMode is invalid. The correct value should be in [%s].
    /// - `InvalidImportImageOptionsDiskDeviceMappings.LengthLimitExceeded`: The length of the specified parameter ImportImageOptions.DiskDeviceMappings exceeds the limit(17).
    /// - `InvalidParameter.ImportImageOptionsDiskDeviceMappingsOSSObject`: The specified parameter ImportImageOptions.DiskDeviceMappings.OSSObject is invalid. OSSObject supports up to 1023 characters, and cannot start with http:// or https://.
    /// - `InvalidParameter.ImportImageOptionsDiskDeviceMappingsOSSBucket`: The specified parameter ImportImageOptions.DiskDeviceMappings.OSSBucket is invalid. OSSBucket supports up to 63 characters, only lowercase letters, numbers, and dashes are allowed, and cannot start or end with a dash.
    /// - `InvalidParameter.ImportImageOptionsPlatform`: The specified parameter ImportImageOptions.Platform is invalid. The correct value should be in [%s].
    /// - `InvalidParameter.ImportImageOptionsLicenseType`: The specified parameter ImportImageOptions.LicenseType is invalid. The correct value should be in [%s].
    /// - `InvalidParameter.ImportImageOptionsFeaturesNvmeSupport`: The specified parameter ImportImageOptions.Features.NvmeSupport is invalid. The correct value should be in [%s].
    /// - `InvalidParameter.NvmeSupport`: The specified parameter NvmeSupport is invalid. The correct value should be in [%s].
    /// - `InvalidParameter.ImportImageOptionsDiskDeviceMappingsFormat`: The specified parameter ImportImageOptions.DiskDeviceMappings.Format is invalid. The correct value should be in [%s].
    /// - `InvalidOperation.DiskImageSizeExceeded`: The disk size exceeds the limit. Please check the specified parameter ImportImageOptions.DiskDeviceMappings.DiskImageSize and ImportImageOptions.DiskDeviceMappings.OSSObject. Ensure that each of them is between 1 and 2048 in size.
    /// - `InvalidImageOptions.Description`: The specified parameter ImageOptions.Description is invalid. The length should be between 2 to 256 characters, and cannot start with http:// or https://.
    /// - `InvalidImageName.Duplicated`: The specified image name is already in use in the target region. Please try a different one.
    /// - `InvalidImage.NotSupportRepair`: The specified base image does not support repair.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.N.Key is not valid. Tag keys cannot be empty or null, support up to 128 characters, cannot start with "aliyun" or "acs:", and cannot contain "http://" or "https://".
    /// - `InvalidTagValue.Malformed`: The specified Tag.N.Value is not valid. Tag values support up to 128 characters, and cannot contain "http://" or "https://".
    /// - `InvalidAdvancedOptions.ImageNameSuffix`: The specified parameter AdvancedOptions.ImageNameSuffix is invalid. The correct value should be in [%s].
    /// - `ImagePipeline.NotSupportWindowsInstance`: Image pipeline does not support windows instance at this time.
    /// - `InvalidOSSObject.NotAuthorized`: The specified ImportImageOptions.DiskDeviceMappings.OSSObject is not allowed to be accessed.
    /// - `InvalidOperation.NoPermissionCreateServiceLinkedRole`: You are not authorized to create Service-linked role. The system will automatically create it when the API is called for the first time. Check your RAM policies, and ensure that you are using the correct credentials.
    /// - `InvalidOSSObject.NeedRestore`: The specified ImportImageOptions.DiskDeviceMappings.OSSObject is an archived object and needs to be restored first.
    /// - `InvalidOperation.NoRightAccessOSS`: ECS service is not authorized to access your OSS. Check your RAM roles and policies, and ensure that ecs.aliyuncs.com is authorized to assume AliyunECSImageImportDefaultRole.
    /// - `InvalidOperation.OSSObjectIsImporting`: The specified ImportImageOptions.DiskDeviceMappings.OSSObject is importing.
    /// - `InvalidImage.NotFound`: %s
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `ImageComponent.NotFound`: %s.
    /// - `InvalidInstanceType.NotFound`: The specified instance type does not exist.
    /// - `InvalidVSwitchId.NotFound`: The specified VSwitchId does not exist.
    /// - `InvalidRegionId.NotFound`: %s
    /// - `InvalidImportImageOptionsDiskDeviceMappingsOSSObject.NotFound`: The specified ImportImageOptions.DiskDeviceMappings.OSSObject is not found in this region.
    /// - `MissingParameter.RepairMode`: The specified parameter RepairMode is missing.
    /// - `MissingParameter.ImportImageOptions`: The specified parameter ImportImageOptions is missing.
    /// - `MissingParameter.ImportImageOptionsDiskDeviceMappingsOSSObject`: The specified parameter ImportImageOptions.DiskDeviceMappings.OSSObject is missing.
    /// - `MissingParameter.ImportImageOptionsDiskDeviceMappingsOSSBucket`: The specified parameter ImportImageOptions.DiskDeviceMappings.OSSBucket is missing.
    /// - `MissingParameter.ImageOptionsDiskDeviceMappings`: The specified parameter ImportImageOptions.DiskDeviceMappings is missing.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_image_pipeline(
        &self,
        req: CreateImagePipeline,
    ) -> impl std::future::Future<Output = crate::Result<CreateImagePipelineResponse>> + Send {
        self.call(req)
    }

    /// # 查询镜像模板的详细信息
    ///
    /// 查询一个或多个镜像模板的详细信息。
    ///
    /// 您可以设置`NextToken`查询凭证（Token），其取值是上一次调用`DescribeImagePipelines`返回的`NextToken`参数值，再通过`MaxResults`设置单页查询的最大条目数进行查询。
    ///
    /// # Error Codes
    /// - `InvalidImagePipelineIdSize.ExceededMaxNumber`: %s
    /// - `InvalidName.Malformed`: %s
    /// - `Invalid.NextToken`: The specified NextToken is not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_image_pipelines(
        &self,
        req: DescribeImagePipelines,
    ) -> impl std::future::Future<Output = crate::Result<DescribeImagePipelinesResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除镜像模板
    ///
    /// 删除一个镜像模板。
    ///
    /// 如果存在正在运行的构建任务，则不允许直接删除模板，需要等待构建任务达到终态：成功（SUCCESS）、失败（FAILED）、测试失败（TEST_FAILED）、部分成功（PARTITION_SUCCESS）或已取消（CANCELLED）。构建任务的详细信息可以通过DescribeImagePipelineExecutions查询。
    ///
    /// # Error Codes
    /// - `InvalidImagePipeline.HasRunningExecution`: %s
    /// - `InvalidImagePipeline.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_image_pipeline(
        &self,
        req: DeleteImagePipeline,
    ) -> impl std::future::Future<Output = crate::Result<DeleteImagePipelineResponse>> + Send {
        self.call(req)
    }

    /// # 通过镜像模板执行构建镜像的任务
    ///
    /// 通过一个镜像模板执行构建镜像的任务。
    ///
    /// - 镜像模板创建好之后，需要通过该接口执行构建镜像的任务，系统将根据镜像模板设置好的参数进行构建、分发、共享镜像。
    /// - 同一个镜像模板，同一时间只能执行一个构建镜像任务。取消构建镜像任务（CancelImagePipelineExecution）可同时执行多次，并且取消构建镜像任务和构建镜像任务之间互不干扰。
    /// - 执行镜像构建模板时，需要创建多台中转实例辅助构建镜像，中转实例为按量计费的ECS实例，将收取一定的费用。更多信息，请参见[按量付费](~~40653~~)。
    ///
    /// # Error Codes
    /// - `InvalidImage.OsTypeUnsupported`: The specified base image does not support image building.
    /// - `InvalidParameter.BuildContent`: %s.
    /// - `InvalidParameter.TestContent`: %s.
    /// - `InvalidImageComponent.NotSupported`: %s.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.N.Key is not valid. Tag keys cannot be empty or null, support up to 128 characters, cannot start with "aliyun" or "acs:", and cannot contain "http://" or "https://".
    /// - `InvalidTagValue.Malformed`: The specified Tag.N.Value is not valid. Tag values support up to 128 characters, and cannot contain "http://" or "https://".
    /// - `InvalidImagePipeline.HasRunningExecution`: %s
    /// - `InvalidImagePipeline.OSSObjectNotAuthorized`: The ImportImageOptions.DiskDeviceMappings.OSSObject of the specified ImagePipeline is not allowed to access.
    /// - `InvalidImagePipeline.OSSObjectNeedRestore`: The ImportImageOptions.DiskDeviceMappings.OSSObject of the specified ImagePipeline is an archived object and needs to be restored first.
    /// - `InvalidOperation.NoRightAccessOSS`: ECS service is not authorized to access your OSS. Check your RAM roles and policies, and ensure that ecs.aliyuncs.com is authorized to assume AliyunECSImageImportDefaultRole.
    /// - `InvalidImagePipeline.NotFound`: %s
    /// - `InvalidInstanceType.NotFound`: The specified instance type does not exist.
    /// - `InvalidVSwitchId.NotFound`: The specified VSwitchId does not exist.
    /// - `InvalidRegionId.NotFound`: %s
    /// - `InvalidImage.NotFound`: %s.
    /// - `ImageComponent.NotFound`: %s.
    /// - `InvalidImagePipeline.BaseImageNotFound`: The BaseImage of the specified ImagePipeline is not found.
    /// - `InvalidImagePipeline.OSSObjectNotFound`: The ImportImageOptions.DiskDeviceMappings.OSSObject of the specified ImagePipeline is not found in this region.
    /// - `StartImagePipelineExecution.Failed`: Start image pipeline execution failed.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn start_image_pipeline_execution(
        &self,
        req: StartImagePipelineExecution,
    ) -> impl std::future::Future<Output = crate::Result<StartImagePipelineExecutionResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询镜像构建任务的详细信息
    ///
    /// 调用DescribeImagePipelineExecutions查询一个镜像构建任务的详细信息。
    ///
    /// ## 接口说明
    ///
    /// - 指定的镜像模板ID`ImagePipelineId`不能是已删除的镜像模板，已删除的镜像模板会同步删除对应的构建任务。
    /// - 镜像模板ID`ImagePipelineId`和构建任务ID`ExecutionId`不能同时为空。
    /// - 您可以设置`NextToken`查询凭证（Token），其取值是上一次调用`DescribeImagePipelineExecutions`返回的`NextToken`参数值，再通过`MaxResults`设置单页查询的最大条目数进行查询。
    ///
    /// # Error Codes
    /// - `InvalidParameter.Status`: %s
    /// - `MissingParameter.ImagePipelineId`: The specified parameter ImagePipelineId should not be empty.
    /// - `InvalidExecutionId.SizeExceeded`: ExecutionId list exceeds maximum size of %s. Current size is %s.
    /// - `Invalid.NextToken`: The specified NextToken is not valid.
    /// - `InvalidImagePipeline.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_image_pipeline_executions(
        &self,
        req: DescribeImagePipelineExecutions,
    ) -> impl std::future::Future<Output = crate::Result<DescribeImagePipelineExecutionsResponse>> + Send
    {
        self.call(req)
    }

    /// # 取消镜像构建任务
    ///
    /// 取消一个镜像构建任务。
    ///
    /// 调用该接口前，请确认需要取消的镜像构建任务处于准备中（PREPARING）、修复中（REPAIRING）、构建中（BUILDING）的状态。
    ///
    /// # Error Codes
    /// - `InvalidStatus.CancelFailed`: Failed to cancel execution,status is success, failed or cancelled.
    /// - `InvalidStatus.ImagePipelineExecution`: %s
    /// - `InvalidImagePipelineExecution.NotFound`: The specified image pipeline execution does not exist!
    /// - `InvalidImagePipelineExecutionId.NotFound`: The specified ImagePipelineExecutionId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn cancel_image_pipeline_execution(
        &self,
        req: CancelImagePipelineExecution,
    ) -> impl std::future::Future<Output = crate::Result<CancelImagePipelineExecutionResponse>> + Send
    {
        self.call(req)
    }

    /// # 创建数据盘
    ///
    /// 创建一块按量付费或包年包月的数据盘。
    ///
    /// - 创建磁盘时支持开启多重挂载特性（`MultiAttach`）。建议您先了解该特性及使用限制，更多信息，请参见[ESSD云盘支持NVMe](~~256487~~)以及[使用多重挂载功能](~~262105~~)。
    /// - 支持创建的磁盘类型：普通云盘、高效云盘、SSD云盘、ESSD云盘、ESSD Entry云盘、ESSD同城冗余、ESSD AutoPL云盘、弹性临时盘-标准版和弹性临时盘-高级版。
    /// - 创建磁盘需要通过实名认证。请前往会员信息[实名认证](https://account.console.aliyun.com/#/auth/home)。
    /// - 创建磁盘会涉及到资源计费，建议您提前了解云服务器ECS的计费方式。更多信息，请参见[计费概述](~~25398~~)。
    ///
    /// - 创建磁盘时，默认设置：
    ///
    ///   - 删除磁盘时删除其自动快照，即`DeleteAutoSnapshot`取值为`true`。您可以调用[DescribeDisks](~~2679767~~)查询该参数配置，调用[ModifyDiskAttribute](~~25517~~)修改该参数。
    ///   - 创建ESSD云盘时，如果您不设置磁盘性能等级，默认为PL1等级。您可以通过[ModifyDiskSpec](~~123780~~)修改磁盘性能等级。
    ///   - 计费方式为按量付费，即默认`Portable`属性为`true`。
    ///
    /// # Error Codes
    /// - `InvalidSize.ValueNotSupported`: The specified parameter Size is not valid.
    /// - `InvalidDiskName.Malformed`: The specified disk name is wrongly formed.
    /// - `InvalidDescription.Malformed`: The specified description is wrongly formed.
    /// - `MissingParameter`: The input parameter either "SnapshotId" or "Size" should be specified.
    /// - `InvalidDiskCategory.NotSupported`: The specified disk category is not support.
    /// - `Account.Arrearage`: Your account has an outstanding payment.
    /// - `InvalidDiskCategory.ValueNotSupported`: The specified parameter "DiskCategory" is not valid.
    /// - `InvalidParameter.Conflict`: %s
    /// - `OperationDenied`: The specified Zone is not available or not authorized.
    /// - `InvalidDiskSize.NotSupported`: The specified parameter size is not valid.
    /// - `InvalidDiskSizeOrCategory`: The specified disk category or size is invalid.
    /// - `InvalidParameter.EncryptedIllegal`: The specified parameter Encrypted must be true when kmsKeyId is not empty.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidParameter.Arns`: The specified Arns is not valid.
    /// - `InvalidPerformanceLevel.Malformed`: The specified parameter PerformanceLevel is not valid.
    /// - `InvalidDiskCategory.ConflictSnapshotCategory`: The specified disk category conflict with snapshot category.
    /// - `InvalidEncrypted.NotMatchEncryptAlgorithm`: The specified parameter Encrypted must be true when EncryptAlgorithm is not empty.
    /// - `InvalidEncrypted.NotMatchKmsKeyId`: The specified parameter Encrypted must be true when KmsKeyId is not empty.
    /// - `InvalidEncryptAlgorithm.NotMatchSnapshot`: The specified parameter EncryptAlgorithm is different from the encrypt algorithm of the snapshot.
    /// - `InvalidKmsKeyId.NotMatchSnapshot`: The specified parameter KmsKeyId is different from the KmsKeyId of the snapshot.
    /// - `InvalidEncryptAlgorithm`: The specified parameter EncryptAlgorithm is not valid.
    /// - `InvalidPerformanceLevel.ValueNotSupported`: The current ZoneId does not support PL0 of cloud_essd.
    /// - `InvalidKMSKeyId.NotSymmetric`: The specified parameter KmsKeyId must be symmetric.
    /// - `InvalidStorageSetId.NotFound`: The specified storage set does not exist.
    /// - `InvalidStorageClusterId.StatusNotSupport`: The current status of the dedicated storage cluster cannot create a cloud disk yet.
    /// - `InvalidStorageClusterId.ConflictWithStorageSetId`: The specified StorageClusterId is in conflict with storageSetId.
    /// - `InvalidStorageClusterId.ConflictWithInstanceId`: The specified StorageClusterId is in conflict with instanceId.
    /// - `InvalidStorageClusterId.CategoryNotMatch`: The current dedicated storage cluster cannot create this category of disk.
    /// - `InvalidStorageClusterId.PerformanceLevelNotMatch`: The current dedicated storage cluster cannot create this performance level of disk.
    /// - `InvalidStorageClusterId.CapacityNotEnough`: The remaining capacity of the current dedicated storage cluster is less than the size of disk.
    /// - `InvalidCloudBoxZone.EncryptedNotSupported`: The cloud box zone does not support creating encrypted disks.
    /// - `InvalidInstance.NotFoundSystemDisk`: The specified instance has no system disk.
    /// - `ProvisionedIopsForDiskCategoryUnsupported`: The specified disk category does not support provisioned iops.
    /// - `InvalidProvisionedIops.LimitExceed`: The provisioned iops exceeds the limit.
    /// - `BurstingEnabledForDiskCategoryUnsupported`: The specified disk category does not support bursting enabled.
    /// - `BurstingEnabledForMultiAttachDiskUnsupported`: The multi attach disk does not support bursting enabled.
    /// - `ProvisionedIopsForDiskCategoryRequired`: The provisioned iops is required for this disk category.
    /// - `NotSupportSnapshotEncrypted.RegionId`: The specified region does not support creating encrypted disks with native snapshot encrypt.
    /// - `NotSupportSnapshotEncrypted.ZoneId`: The specified zone does not support creating encrypted disks with native snapshot encrypt.
    /// - `NotSupportSnapshotEncrypted.ShareImage`: Shared snapshot creating encrypted disks with native snapshot encrypt is not supported.
    /// - `NotSupport.SnapshotEncryptedAlgorithmConflict`: Changing encrypt algorithm with encrypted snapshot is not supported.
    /// - `QuotaExceed.DiskCapacity`: The used capacity of disk type has exceeded the quota in the zone,  %s.
    /// - `InsufficientBalance.AgentAccount`: The account balance is insufficient. Please contact your channel partner to recharge in time.
    /// - `InvalidParam.EncryptedMismatch`: Creating encrypted disks with shared encrypted snapshots requires replacing encryption keys.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance, please contact your partner to increase your account balance.
    /// - `InvalidParameter.KmsNotEnabled`: Failed to perform this operation because KMS is not activated.
    /// - `InvalidParameter.Encrypted.KmsNotEnable`: Failed to perform this operation because KMS is not activated.
    /// - `InvalidZoneId.DiskCategoryUnsupported`: The specified disk category does not support setting the ZoneId.
    /// - `InvalidStorageSetId.DiskCategoryUnsupported`: The specified disk category does not support setting the StorageSetId.
    /// - `InvalidStorageClusterId.DiskCategoryUnsupported`: The specified disk category does not support setting the StorageClusterId.
    /// - `InvalidParameter.Encrypted`: Creating non-encrypted disks with encrypted snapshots is not supported.
    /// - `EncryptedOption.Conflict`: Disk encryption attributes conflict.
    /// - `InvalidDataDiskCategory.NotSupported`: Specified disk category is not supported.
    /// - `InvalidBurstingEnabled.DiskSizeTooSmall`: The disk size must be greater than 3 GiB to enable burst.
    /// - `OperationDenied.RiskIssue`: Your action is denied by risk issue, please contact customer service.
    /// - `InvalidDiskSize.ExceedsMultiAttachLimit`: The specified disk size exceeds the maximum limit 65536 for enabling multi-attach.
    /// - `InvalidStatus.ValueNotSupported`: The specified instance status is not supported for this operation, expect status is Running or Stopped.
    /// - `InvalidDataDiskCategory.NotSupported`: Specified disk category is not supported.
    /// - `InstanceDiskCategoryLimitExceed`: The total size of specified disk category in an instance exceeds.
    /// - `InvalidSnapshot.NotReady`: The specified snapshot creation is not completed yet.
    /// - `InvalidSnapshot.TooOld`: This operation is forbidden because the specified snapshot is created before 2013-07-15.
    /// - `InvalidSnapshot.TooLarge`: The capacity of snapshot exceeds 2000GB.
    /// - `OperationDenied`: The specified snapshot is not allowed to create disk.
    /// - `QuotaExceed.PortableCloudDisk`: The quota of portable cloud disk exceeds.
    /// - `InvalidDiskCategory.ValueUnauthorized`: The disk category is not authorized.
    /// - `InvalidSnapshotId.NotReady`: The specified snapshot has not completed yet.
    /// - `InvalidSnapshotId.NotDataDiskSnapshot`: The specified snapshot is system disk snapshot.
    /// - `InvalidDiskSize.TooSmall`: Specified disk size is less than the size of snapshot.
    /// - `InvalidDiskSize.NotSupported`: Disk size is not supported.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `InvalidAccountStatus.SnapshotServiceUnavailable`: Snapshot service has not been opened yet.
    /// - `InvalidPayMethod`: The specified pay method is not valid.
    /// - `InvalidDiskCategory.NotSupported`: The specified disk category is not supported.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `QuotaExceed.PostPaidDisk`: Living postPaid disks quota exceeded.
    /// - `InvalidRegion.NotSupport`: The specified region does not support byok.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `SecurityRisk.3DVerification`: We have detected a security risk with your default credit or debit card. Please proceed with verification via the link in your email.
    /// - `InvalidParameter.AdvancedFeatures`: The specified parameter AdvancedFeatures is not valid.
    /// - `InvalidInstanceChargeType.ValueNotSupported`: The InstanceChargeType does not support this action.
    /// - `InvalidStatus.Upgrading`: The instance is upgrading; please try again later.
    /// - `InvalidParam.ZoneIdAndInstanceId.Conflict`: The specified parameter 'ZoneId' and 'InstanceId' are not blank at the same time.
    /// - `OperationDenied.PerformanceLevelNotMatch`: The specified PerformanceLevel and Size do not match.
    /// - `InvalidStorageSetName.Malformed`: Specified parameter StorageSetName is not valid.
    /// - `InvalidDescription.Malformed`: Specified parameter Description is not valid.
    /// - `InvalidMaxPartitionNumber.Malformed`: Specified parameter MaxPartitionNumber is not valid.
    /// - `InvalidParameter.StorageSetPartitionNumber`: Specified parameter StorageSetPartitionNumber is not valid.
    /// - `InvalidParameter.StorageSetId`: Specified parameter StorageSetId is not valid.
    /// - `InvalidParameter.StorageSetZoneId`: Specified parameter StorageSetZoneId is not valid.
    /// - `QuotaExceed.Tags`: %s
    /// - `QuotaExceeded.PostpaidDataDiskCapacity`: The quota of postpaid data disk capacity exceeds.
    /// - `InvalidRegionId.NotSupportEncryptAlgorithm`: The current region does not support creating encrypted disks with EncryptAlgorithm.
    /// - `OperationDenied.SnapshotNotAllowed`: The specified snapshot is not allowed to create disk.
    /// - `LastTokenProcessing`: The last token request is processing.
    /// - `InvalidParameter.MultiAttach`: The specified param MultiAttach is not valid.
    /// - `InvalidParameter.MultiAttachAndInstanceIdConflict`: The parameter MultiAttach and InstanceId are conflict.
    /// - `InvalidParameter.DiskCategoryAndMultiAttachConflict`: The specified disk category does not support multi attach set.
    /// - `InvalidParameter.DiskCategoryAndMultiAttachNotMatch`: The specified disk category does not support multi attach enabled.
    /// - `OperationDenied.ZoneNotSupportMultiAttachDisk`: The specified zone does support multi attach disk.
    /// - `InvalidAccountStatus.CouponAmountNotEnough`: Your coupon balance is insufficient or has expired.
    /// - `InvalidOperation.CreateFromSnapshotUnsupported`: The elastic ephemeral disk cannot be created from snapshot.
    /// - `NotSupportSnapshotEncrypted.DiskCategory`: The specified disk category does not support creating encrypted system disks or creating encrypted data disks from snapshots. Check the DiskCategory or Encrypted parameter, or check your account for default encryption settings.
    /// - `InvalidParameter.DataEncryptedKeyCreateFailed`: Create kms data encrypted key fail. If you need further assistance, you can contact the KMS Technical Support.
    /// - `Zone.NotOnSale`: The resource in the specified zone is no longer available for sale. Please try other regions and zones.
    /// - `RegionUnauthorized`: You are not authorized to perform the operation in the specified region.
    /// - `InvalidDataDiskCategory.ValueNotSupported`: The specified Category of Data Disk is not valid.
    /// - `InvalidParameter.EncryptedNotSupported`: The current disk category does not support encryption. If encryption is required, please switch to a different disk category.
    /// - `InvalidDataDiskSize.ValueNotSupported`: The specified disk size is beyond the permitted range, or the snapshot capacity exceeds the size limit for the specified disk category.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.
    /// - `InvalidEncrypted.NotMatchSnapshot`: The specified parameter Encrypted must be set to true when creating disks with encrypted snapshots.
    /// - `InvalidEncrypted.NotMatchDiskDefaultEncryption`: Enabling disk default encryption prevents the creation of non-encrypted disks.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidZoneId.NotFound`: The specified zone does not exist.
    /// - `InvalidSnapshotId.NotFound`: The specified SnapshotId does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InvalidParameter.KMSKeyId.NotFound`: The specified KMSKeyId does not exist.
    /// - `InvalidInstanceId.NotFound`: The InstanceId provided does not exist in our records.
    /// - `InvalidStorageClusterId.NotExist`: The specified StorageClusterId does not exist in current region.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_disk(
        &self,
        req: CreateDisk,
    ) -> impl std::future::Future<Output = crate::Result<CreateDiskResponse>> + Send {
        self.call(req)
    }

    /// # 查询块存储
    ///
    /// 查询一块或多块已创建的块存储（包括云盘、本地盘以及弹性临时盘）信息。
    ///
    /// - 请求参数`RegionId`、`ZoneId`、`DiskIds`和`InstanceId`等都是过滤器的概念，参数间是逻辑与（AND）关系。
    /// - 请求参数`DiskIds`是一个JSON格式的数组（Array），如果参数为空，则过滤器不起作用，但是`DiskIds`如果是一个空数组，则视为该过滤器有效，且返回空。
    /// - 支持Token分页查询：通过`NextToken`设置查询凭证（Token），其取值是上一次调用DescribeDisks返回的`NextToken`参数值，再通过`MaxResults`设置单页查询的最大条目数。
    ///
    /// - 开启多重挂载特性的云盘可以挂载到多个实例上，您可以根据返回结果的`Attachment`列表查看云盘涉及的所有挂载信息。
    ///
    /// 通过阿里云CLI调用API时，不同数据类型的请求参数取值必须遵循格式要求。更多信息，请参见[CLI参数格式说明](~~110340~~)。
    ///
    /// # Error Codes
    /// - `InvalidDiskType.ValueNotSupported`: The specified disk type is not supported.
    /// - `InvalidCategory.ValueNotSupported`: The specified disk category is not supported.
    /// - `InvalidStatus.ValueNotSupported`: The specified disk status is not supported.
    /// - `InvalidTag.Mismatch`: The specified Tag.n.Key and Tag.n.Value are not match.
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `InvalidRegion.NotFound`: The specified parameter RegionId is not valid.
    /// - `InvalidZoneId.NotFound`: The zoneId provided does not exist in our records.
    /// - `MissingParamter.RegionId`: The regionId should not be null.
    /// - `InvalidParameter.DiskIds`: The specified parameter diskIds is not valid.
    /// - `IncompleteParamter`: Some fields can not be null in this request.
    /// - `InvalidParamter`: Some parameters are invalid in this request.
    /// - `InvalidSnapshot.NotFound`: The specified parameter SnapshotId is not valid.
    /// - `InvalidDiskIds.Malformed`: The amount of specified disk Ids exceeds the limit.
    /// - `InvalidCategory.ValueNotSupported`: The specified disk category is not supported.
    /// - `UserNotInTheWhiteList`: The user is not in volume white list.
    /// - `InvalidParameter.MultiAttachAndEnableSharedNotMatch`: The parameter MultiAttach and EnableShared are not match.
    /// - `InvalidParameter.MultiAttach`: The specified param MultiAttach is not valid.
    /// - `InvalidFilterKey.NotFound`: The filter key is not found.
    /// - `InvalidFilterValue`: The filter value is not valid.
    /// - `InvalidDiskIds.ValueNotSupported`: The specified parameter "DiskIds" is not supported.
    /// - `InvalidDiskChargeType.NotFound`: The DiskChargeType does not exist in our records.
    /// - `InvalidLockReason.NotFound`: The specified LockReason is not found.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_disks(
        &self,
        req: DescribeDisks,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDisksResponse>> + Send {
        self.call(req)
    }

    /// # 为实例挂载磁盘
    ///
    /// 为一台ECS实例挂载一块按数据盘或系统盘。
    ///
    /// 调用该接口时，您需要注意：
    /// - 实例和磁盘必须在同一个可用区。
    /// - 磁盘的状态必须为**待挂载**（`Available`）。
    /// - 挂载数据盘时：
    ///
    ///     - 目标ECS实例必须处于**运行中**（`Running`）或者**已停止**（`Stopped`）状态。
    ///     - 如果是您单独购买的磁盘，计费方式必须是按量付费。
    ///     - 从ECS实例上卸载的系统盘作为数据盘挂载时，不限制计费方式。
    ///     - 弹性临时盘一旦卸载，只能重新挂载至其原始实例。
    ///
    /// - 挂载系统盘时：
    ///
    ///     - 目标ECS实例必须是卸载该系统盘时的源实例。
    ///     - 目标ECS实例必须处于**已停止**（`Stopped`）状态。
    ///     - 您必须设置实例登录凭证。
    ///     - 弹性临时盘不支持挂载为系统盘。
    ///     - 更多关于挂载系统盘的信息，请参见[卸载或挂载系统盘](~~146752~~)。
    ///
    /// - 查询ECS实例信息时，如果返回数据中包含`{"OperationLocks": {"LockReason" : "security"}}`，则禁止一切操作。
    ///
    /// <props="china">
    /// - 开启多重挂载特性的云盘，只能挂载到支持NVMe协议的实例上。
    ///    更多信息，请参见[ESSD云盘支持NVMe](~~256487~~)以及[使用多重挂载功能](~~262105~~)。
    /// </props>
    ///
    /// # Error Codes
    /// - `InvalidDevice.Malformed`: The specified device is not valid.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InvalidParameter`: The input parameter is mandatory for processing this request is empty.
    /// - `InvalidRegionId.MalFormed`: The specified RegionId is not valid.
    /// - `InvalidOperation.InstanceTypeNotSupport`: The instance type of the specified instance does not support hot attach disk.
    /// - `DiskCategory.OperationNotSupported`: The operation is not supported to the specified disk due to its disk category.
    /// - `InvalidDisk.DiskNotBootable`: The specified disk is not a bootable disk, can not be attached as system disk.
    /// - `InvalidInstance.NotOriginInstance`: The specified disk can not attached to other instance as system disk.
    /// - `InvalidParameterForce.DiskCategoryNotSupported`: The specified disk category does not support force attach operation.
    /// - `InvalidParameterForce.PrepaidDiskNotSupported`: The prepaid disk does not support force attach operation.
    /// - `InvalidParameterForce.MultiAttachDiskNotSupported`: The multi attach disk does not support force attach operation.
    /// - `InvalidParameterForce.RegionNotSupported`: The specified region does not support force attach operation.
    /// - `OperationConflict.DisksAttachingParallellyExceed`: The number of disks attaching parallelly exceeds the limit.
    /// - `InstanceDiskLimitExceeded`: The amount of the disk on instance in question reach its limits.
    /// - `InvalidDevice.InUse`: The specified device has been occupied.
    /// - `DiskNotPortable`: The specified disk is not a portable disk.
    /// - `InstanceLockedForSecurity`: The instance is locked due to security.
    /// - `ResourcesNotInSameZone`: The specified instance and disk are not in the same zone.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `DiskInArrears`: The specified operation is denied as your disk owing fee.
    /// - `DiskError`: IncorrectDiskStatus.
    /// - `DiskId.ValueNotSupported`: The specified parameter diskid is not supported.
    /// - `DiskId.StatusNotSupported`: The specified disk status is not supported.
    /// - `IncorrectInstanceStatus.NotSupportESSD`: The operation is not supported in this status, please reboot the instance.
    /// - `IncorrectDiskStatus`: The operation is not supported in this status.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be enabled.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK needs to be added ECS tag.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `DependencyViolation.WindowsInstance`: The instance image is windows, cannot use ssh key pair to login.
    /// - `InvalidInstanceType.NotSupportDiskCategory`: The instanceType of the specified instance does not support this disk category.
    /// - `InvalidInstanceType.NotSupportPL0`: The instanceType of the specified instance does not support PL0 of cloud_essd.
    /// - `InvalidInstanceType.NvmeRequired`: The instanceType of the specified instance requires nvme protocol.
    /// - `InvalidInstanceType.NvmeUnsupported`: The instanceType of the specified instance does not support nvme protocol.
    /// - `InvalidInstanceType.NotSupportMultiAttachDisk`: The instanceType of the specified instance does not support multi attach disk.
    /// - `DiskAttachedNumberExceeded`: The attaching times of the specified disk exceeded.
    /// - `InvalidOperation.CanNotAttachMultiAttachDiskAsSystemDisk`: Multi attach disk can not be attached as system disk.
    /// - `DeleteWithInstance.Conflict`: Multi attach disk cannot be set to DeleteWithInstance attribute.
    /// - `InvalidParameter.DeleteWithInstance`: The DeleteWithInstance for the elastic ephemeral disk must be set to true.
    /// - `InvalidOperation.OtherInstanceUnsupported`: The elastic ephemeral disk can only be attached to the instance it was last mounted on, please check the disk's system tag to get the last associated instance.
    /// - `InvalidInstance.ZoneConflict`: The force attach operation is not supported when both the current and target instances are in the same zone.
    /// - `InvalidParameter.AllEmpty`: The current operation requires either a password or a keyPairName to must be provided. Please ensure that at least one of them is not empty.
    /// - `InvalidOperation.DiskQueueNumberNotEnough`: The number of disk queues on the instance is not enough.
    /// - `InvalidOperation.DiskAttachModeUnsupported`: The instance type does not support the disk attach mode.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.
    /// - `InvalidDisk.InUse`: The specified disk has been occupied.
    /// - `DiskAttachedNumberExceeded`: The attaching times of the specified disk exceeded.
    /// - `InvalidKMSKeyId.NotFound`: The KMS key used by the disk does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn attach_disk(
        &self,
        req: AttachDisk,
    ) -> impl std::future::Future<Output = crate::Result<AttachDiskResponse>> + Send {
        self.call(req)
    }

    /// # 卸载按量付费数据盘或系统盘
    ///
    /// 从一台ECS实例上卸载一块按量付费的数据盘或者系统盘。
    ///
    /// 调用该接口时，请注意：
    ///
    /// - 该接口为异步操作，调用成功后等待一分钟左右才能完成卸载。
    /// - 所挂载的实例被安全控制后，`OperationLocks`中不能标记为`"LockReason" : "security"`的锁定状态。
    ///
    /// - 弹性临时盘一旦卸载，只能重新挂载至其原始实例。
    ///
    /// # Error Codes
    /// - `InvalidParameter`: The input parameter is mandatory for processing this request is empty.
    /// - `InvalidRegionId.MalFormed`: The specified RegionId is not valid.
    /// - `InvalidOperation.InstanceTypeNotSupport`: The instance type of the specified instance does not support hot detach disk.
    /// - `DisksDetachingOnEcsExceeded`: The number of disks detaching on the instance exceeds the limit.
    /// - `InvalidInstanceId.Malformed`: The specified parameter InstanceId is not valid.
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `DiskNotPortable`: The specified disk is not a portable disk.
    /// - `InstanceLockedForSecurity`: The instance is locked due to security.
    /// - `DependencyViolation`: The specified disk has not been attached on the specified instance.
    /// - `DiskTypeViolation`: The specified disk is a system disk and cannot support the operation.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `InvalidInstance.ImageCategory`: The image category of the specified instance does not support detaching system disk.
    /// - `DeleteWithInstance.Conflict`: Multi attach disk cannot be set to DeleteWithInstance attribute.
    /// - `InvalidOperation.DiskCategoryUnsupported`: The DetachDisk operation is not supported for elastic ephemeral disk.
    /// - `InvalidParameter.DeleteWithInstance`: The DeleteWithInstance for the elastic ephemeral disk must be set to true.
    /// - `InvalidOperation.DiskDetachingFromThisEcs`: The specified disk is detaching from this ecs.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.
    /// - `InvalidDisk.AlreadyDetached`: The specified disk has been detached.
    /// - `InvalidDiskId.OperationNotSupported`: The operation is not supported due to base image not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn detach_disk(
        &self,
        req: DetachDisk,
    ) -> impl std::future::Future<Output = crate::Result<DetachDiskResponse>> + Send {
        self.call(req)
    }

    /// # 扩容磁盘
    ///
    /// 扩容一块磁盘，支持扩容系统盘和数据盘。
    ///
    /// > 扩容前，请务必查询云盘采用的分区格式。如果是MBR格式，不支持扩容到2TiB以上，否则会造成数据丢失。对于MBR分区扩容，建议您重新创建并挂载一块数据盘，采用GPT分区格式后，再将已有数据拷贝至新的数据盘上。更多详情，请参见[扩容云盘容量](~~44986~~)。
    ///
    /// - 支持扩容的磁盘类型包括普通云盘（`cloud`）、高效云盘（`cloud_efficiency`）、SSD云盘（`cloud_ssd`）、ESSD云盘（`cloud_essd`）<props="china"><ph>、ESSD Entry云盘（cloud_essd_entry）</ph></props>、ESSD AutoPL云盘（cloud_auto）、弹性临时盘-标准版（elastic_ephemeral_disk_standard）和弹性临时盘-高级版（elastic_ephemeral_disk_premium）、 ESSD 同城冗余云盘（cloud_regional_disk_auto）。
    /// - 正在创建快照的云盘不支持扩容。请您等待快照创建完成后，再开始执行扩容操作。
    /// -  该接口不能扩容分区和文件系统，您需要在扩容云盘容量后自行分配分区和文件系统，具体操作，请参见[扩容分区与文件系统（Linux）](~~2949817#bb3b1f02e51pj~~)和[扩容分区与文件系统（windows）](~~2932233#a9f9b78f3fujb~~)。
    ///
    /// - 开启多重挂载特性的云盘支持在线扩容和离线扩容，请确保磁盘挂载的实例满足以下条件：
    ///
    ///   - 在线扩容时，实例状态为**运行中**（`Running`）。
    ///   - 离线扩容时，实例状态为**运行中**（`Running`）或**已停止**（`Stopped`）。
    ///
    /// - 请确保云盘满足以下条件：
    ///
    ///   - 云盘状态为使用中（`In Use`）或者待挂载（`Available`）。
    ///   - （强烈建议）已为云盘创建快照，做好数据备份。具体操作，请参见[创建快照](~~25455~~)。
    ///   - 如果您是全新购买的数据盘，请先完成初始化再执行扩容操作。更多信息，请参见[初始化概述](~~466323~~)。
    ///
    /// # Error Codes
    /// - `InvalidDataDiskSize.ValueNotSupported`: The specified DataDisk.n.Size beyond the permitted range, or the capacity of snapshot exceeds the size limit of the specified disk category.
    /// - `InvalidParameter.Conflict`: %s
    /// - `IncompleteParamter`: Some fields can not be null in this request.
    /// - `InvalidRegionId.MalFormed`: The specified RegionId is not valid.
    /// - `InvalidParam.Type`: The specified type is not supported.
    /// - `LastOrderProcessing`: The previous order is still processing, please try again later.
    /// - `InvalidStatus.Upgrading`: The instance which the disk attachs is upgrading; please try again later.
    /// - `InvalidSystemDiskSize.ImageNotSupportResize`: The image of the instance does not support resize.
    /// - `InvalidDisk.DetachedSystemDisk`: The specified disk is a detached system disk, does not support this operation.
    /// - `OperationDenied.NotEnoughCapacity`: The capacity of the current dedicated block storage cluster is not enough to expand.
    /// - `IncorrectDiskStatus.ReplicationStatusNotFound`: Disk replication status not found.
    /// - `IncorrectDiskStatus.InReplication`: Disk already in replication.
    /// - `QuotaExceed.DiskCapacity`: The used capacity of disk type has exceeded the quota in the zone,  %s.
    /// - `NoPermission.Price`: The operation requires price permission. Please either apply for permission from your main account, or set the parameter AutoPay as true.
    /// - `NoPermission.Refund`: The operation requires refund permission. Please apply for permission from your main account.
    /// - `InvalidOperation.InstanceRenewWithDowngradeInPlan`: The operation is denied due to the specified instance has renew with downgrade record in plan.
    /// - `InvalidSystemDiskSize.ValueNotSupported`: The specified system disk size is invalid.
    /// - `OperationDenied.UnfinishedOrder`: The current instance has unfinished refundOrder, this operation is denied.
    /// - `AccountForbidden.CreateOrder`: Order cannot be created due to abnormal account.
    /// - `InvalidDataDiskSize.ValueNotSupported`: The specified DataDisk.n.Size beyond the permitted range, or the capacity of snapshot exceeds the size limit of the specified disk category.
    /// - `OperationDenied`: The type of the disk does not support the operation.
    /// - `InvalidDiskSize.TooSmall`: Specified new disk size is less than the original disk size.
    /// - `InvalidDiskSize.TooLarge`: Specified new disk size is beyond the permitted range.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `DiskError`: Incorrect disk status.
    /// - `DiskInArrears`: The specified operation is denied as your disk owing fee.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `DiskCreatingSnapshot`: The operation is denied due to a snapshot of the specified disk is not completed yet.
    /// - `InvalidDiskSize`: Specified new disk size is less than or equal the original disk size.
    /// - `Operation.Conflict`: The operation may conflicts with others.
    /// - `InstanceLockedForSecurity`: The instance is locked due to security.
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `InvalidDiskCategory.NotSupported`: The specified disk category is not supported.
    /// - `InvalidRegion.NotSupport`: The specified region does not support resize online.
    /// - `InvalidInstanceStatus.NotRunning`: The status of instance to which the disk attachs must be running when resizing online.
    /// - `InvalidOperation.InstanceTypeNotSupportOnlineResize`: The instance type of the specified instance does not support resize online.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK needs to be added ECS tag.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be enabled.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `InstanceSpecModification.NotEffective`: The instance which the disk attachs has been reserved for making a spec modification and not taken effective in the current contract period.
    /// - `InvalidDiskSize.NotSupportResizeOnline`: The current size of the resource does not support resize online.
    /// - `SecurityRisk.3DVerification`: We have detected a security risk with your default credit or debit card. Please proceed with verification via the link in your email.
    /// - `QuotaExceeded.PostpaidDataDiskCapacity`: The quota of postpaid data disk capacity exceeds.
    /// - `InvalidOperation.MultiAttachDiskNotSupportResizeOnline`: Multi attach disk does not support resize online.
    /// - `InvalidDataDiskCategory.ValueNotSupported`: The specified Category of Data Disk is not valid.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn resize_disk(
        &self,
        req: ResizeDisk,
    ) -> impl std::future::Future<Output = crate::Result<ResizeDiskResponse>> + Send {
        self.call(req)
    }

    /// # 修改块存储属性
    ///
    /// 修改一个或多个块存储设备的名称、描述、是否随实例释放、是否随磁盘删除其自动快照、是否启用自动快照策略、是否开启性能突发功能等。
    ///
    /// 您可以调用`DiskId`参数修改一个块存储设备的名称、描述、是否随实例释放等属性，调用`DiskIds.N`参数批量修改多个块存储设备的属性。
    ///
    /// # Error Codes
    /// - `InvalidDiskName.Malformed`: The specified disk name is wrongly formed.
    /// - `NoAttributeToModify`: No attribute to be modified in this request.
    /// - `IncompleteParamter`: Some fields can not be null in this request.
    /// - `InvalidRegionId.MalFormed`: The specified RegionId is not valid.
    /// - `MissingParameter.DiskIdOrDiskIds`: Specified parameter DiskId or DiskIds is missing.
    /// - `ParameterConflict.DiskIdAndDiskIds`: Specified parameter DiskId and DiskIds conflict, only one can be chosen.
    /// - `BurstingEnabledForDiskCategoryUnsupported`: The specified disk category does not support bursting enabled.
    /// - `BurstingEnabledForMultiAttachDiskUnsupported`: The multi attach disk does not support bursting enabled.
    /// - `BurstingEnabledForModifyingDiskUnsupported`: The modifying disk does not support bursting enabled.
    /// - `InvalidBurstingEnabled.DiskSizeTooSmall`: The disk size must be greater than 3 GiB to enable burst.
    /// - `QuotaExceed.Snapshot`: The snapshot quota exceeds.
    /// - `DiskNotPortable`: The specified disk is not a portable disk.
    /// - `IncorrectDiskStatus`: The operation is not supported in this status.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `DeleteWithInstance.Conflict`: The specified image is from the image market, you cannot set DeleteWithInstance attribute to false.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.
    /// - `InvalidDescription.Malformed`: The specified description is wrongly formed.
    /// - `InvalidInstanceId.NotFound`: Specified attached instance does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_disk_attribute(
        &self,
        req: ModifyDiskAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyDiskAttributeResponse>> + Send {
        self.call(req)
    }

    /// # 修改云盘的计费方式
    ///
    /// 将包年包月ECS实例上挂载的数据盘的计费方式在按量付费和包年包月之间进行转换。
    ///
    /// 转换数据盘计费方式前，请仔细阅读[转换云盘计费方式](~~145018~~)。
    ///
    /// 使用该接口时，请注意：
    ///
    /// - 不支持修改挂载在按量付费实例上数据盘的计费方式，按量付费实例仅支持挂载按量付费云盘。
    /// - 数据盘挂载的实例不能为到期停机状态。
    /// - 更换计费方式前后的价格差退款会退还到您的原付费方式中，已使用的代金券不退回。
    /// - 每块云盘成功修改计费方式一次，五分钟内不能再次修改。  
    /// <props="china">- 开启多重挂载特性的云盘，仅支持按量付费的计费方式，不能转换为包年包月的计费方式。</props>
    ///
    ///
    /// 更换计费方式后，默认自动扣费。您需要确保账户余额充足，否则会生成异常订单，此时只能作废订单。如果您的账户余额不足，可以将参数AutoPay置为false，此时会生成正常的未支付订单，您可以登录阿里云**费用与成本**后，在<props="china"><ph>[我的订单](https://usercenter2.aliyun.com/order/list)</ph></props><props="intl"><ph>[订单管理](https://usercenter2-intl.aliyun.com/order/list)</ph></props>页面支付。
    ///
    /// # Error Codes
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType is not authorized.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType is not supported.
    /// - `MissingParameter.RegionId`: RegionId should not be null.
    /// - `MissingParameter.InstanceIdNotSupported`: InstanceId should not be null.
    /// - `ChargeTypeViolation`: The operation is not permitted due to charge type of the instance.
    /// - `InvalidInstanceId.Released`: The specified Instance is not exist.
    /// - `InvalidInstance.PurchaseNotFound`: The specified Instance has no purchase.
    /// - `InvalidInstance.UnPaidOrder`: The specified Instance has unpaid order.
    /// - `InvalidClientToken.ValueNotSupported`: The ClientToken provided is invalid.
    /// - `Account.Arrearage`: Your account has been in arrears.
    /// - `Idempotence.SignatureMismatch`: There is a idempotence signature mismatch between this and last request.
    /// - `OrderCreationFailed`: Create Order failed, please check your parameters and try it later.
    /// - `Throttling`: Request was denied due to request throttling, please try again after 5 minutes.
    /// - `InstanceDowngrade.QuotaExceed`: Quota of instance downgrade is exceed.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidDisk.DetachedSystemDisk`: The specified disk is a detached system disk, does not support this operation.
    /// - `LastOrderProcessing`: The previous order is still processing, please try again later.
    /// - `InvalidAction.WithActiveElasticUpgrade`: The instance has active Elastic Upgrade.
    /// - `DISK_IN_DEDICATED_BLOCK_STORAGE_CLUSTER`: The disk in dedicated block storage cluster is not allowed to do this operation.
    /// - `NoPermission.Price`: The operation requires price permission. Please either apply for permission from your main account, or set the parameter AutoPay as true.
    /// - `NoPermission.Refund`: The operation requires refund permission. Please apply for permission from your main account.
    /// - `InvalidOperation.DiskMustAttachedToInstance`: The specified data disks must have been attached to this instance.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `InvalidOrder.Overdue`: The specified account has overdue orders.
    /// - `IncorrectInstanceStatus`: The current status of the instance does not support this operation.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType is not supported.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `Throttling`: Request was denied due to request throttling, please try again after 5 minutes.
    /// - `InvalidInstanceChargeType.NotFound`: The chargeType of the instance does not support this operation.
    /// - `InvalidOperation.MultiAttachDisk`: Multi attach disk does not support this operation.
    /// - `InvalidOperation.UnpaidOrder`: The specified instance has unpaid orders and does not support the current operation.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist.
    /// - `PaymentMethodNotFound`: No billing method has been registered on the account.
    /// - `InvalidZoneId.NotFound`: The ZoneId provided does not exist in our records.
    /// - `InvalidRamRole.NotFound`: The specified parameter "RAMRoleName" does not exist.
    /// - `InvalidDiskIds.NotFound`: Some of the specified data disks do not exist.
    /// - `InvalidDiskIds.NotPortable`: The specified DiskId is not portable.
    /// - `InvalidDataDiskSize.ValueNotSupported`: The specified parameter "Size" is not supported.
    /// - `InvalidAction.NotSupported`: The specified action is not supported.
    /// - `InvalidInstanceStatus.NotSupported`: The status of the specified instance is invalid.
    /// - `InvalidInstanceId.NOT_FOUND`: The specified instance is not exist.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_disk_charge_type(
        &self,
        req: ModifyDiskChargeType,
    ) -> impl std::future::Future<Output = crate::Result<ModifyDiskChargeTypeResponse>> + Send {
        self.call(req)
    }

    /// # 变更云盘类型或性能级别
    ///
    /// 变更一块云盘类型，或者修改一块ESSD云盘的性能级别。ESSD同城冗余云盘、普通云盘、弹性临时盘和本地盘均不支持变更云盘类型。
    ///
    /// <props="china">请确保在使用该接口前，您已充分了解云盘的计费方式和[价格](https://www.aliyun.com/price/product#/disk/detail)。</props>
    ///
    /// 为了减少变配操作对您业务带来的影响，请您在业务低峰期进行变配。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 修改ESSD云盘性能级别：
    ///
    ///     - 包年包月ESSD云盘仅支持升级性能级别。
    ///
    ///     - 按量付费ESSD云盘支持升级和降低性能级别，但不支持降配到PL0。
    ///
    ///     - ESSD云盘的状态必须是**使用中**（In_use）状态或者**待挂载**（Available）状态。
    ///
    ///     - 若ESSD云盘已挂载到ECS实例上，实例必须处于**运行中**（Running）状态或者**已停止**（Stopped）状态，不能处于过期或者账号欠费状态。
    ///
    ///     - 由于ESSD云盘性能级别受容量限制，如果您无法升级性能级别，可以扩容（[ResizeDisk](~~25522~~)）后重新操作。更多信息，请参见[ESSD云盘](~~122389~~)。
    /// - 变更一块云盘类型的注意事项，请参见[变更云盘类型](~~161980#section_s4a_to0_1jx~~)。
    /// - 不同类型的云盘支持变配的情况，请参见[云盘支持变配情况](~~161980#eb8bb54032nho~~)。
    /// <props="china">* 开启多重挂载特性的云盘不支持云盘变配。</props>
    ///
    /// 云盘变配后，计费变化情况如下：
    ///
    /// - 按量付费云盘：按照新的云盘类型计费。
    ///
    /// - 包年包月云盘：在计费周期内，会根据新旧配置的价格差和剩余天数（从次日0点到有效期结束）来计算应补缴的费用。
    ///
    /// 关于云盘的计费信息，请参见[块存储计费](~~179022~~)。
    ///
    /// # Error Codes
    /// - `InvalidPerformanceLevel.Malformed`: The specified parameter PerformanceLevel is not valid.
    /// - `InvalidDiskCategory.ValueNotSupported`: The specified parameter "DiskCategory" is not valid.
    /// - `InvalidPerformanceLevelParam.Mismatch`: The specified parameter PerformanceLevel should be null when DiskCategory is not cloud_essd.
    /// - `OperationDenied.DiskInDedicatedBlockStorageCluster`: The disk in dedicated block storage cluster is not allowed to do this operation.
    /// - `IncorrectDiskStatus.ReplicationStatusNotFound`: Disk replication status not found.
    /// - `IncorrectDiskStatus.InReplication`: Disk already in replication.
    /// - `ProvisionedIopsForDiskCategoryUnsupported`: The specified disk category does not support provisioned iops.
    /// - `InvalidProvisionedIops.LimitExceed`: The provisioned iops exceeds the limit.
    /// - `QuotaExceed.DiskCapacity`: The used capacity of disk type has exceeded the quota in the zone,  %s.
    /// - `MalformedParameter.PerformanceControlOptions`: Parameter invalid, %s.
    /// - `InvalidPerformanceControlOptions.ModifyOperationUnsupported`: The specified performance control options are conflicts with disk category or performance level or ProvisionIOPS.
    /// - `NoPermission.Price`: The operation requires price permission. Please either apply for permission from your main account, or set the parameter AutoPay as true.
    /// - `NoPermission.Refund`: The operation requires refund permission. Please apply for permission from your main account.
    /// - `InvalidOperation.InstanceRenewWithDowngradeInPlan`: The operation is denied due to the specified instance has renew with downgrade record in plan.
    /// - `InvalidOperation.InstanceStatusUnsupported`: The specified instance status is not supported for this operation, expect status is Running or Stopped.
    /// - `MissingParameter.DestinationZoneId`: The parameter DestinationZoneId must be specified when modifying the disk specification from a regional disk to a zone disk.
    /// - `InvalidDestinationZoneId.Mismatch`: The specified DestinationZoneId of the regional disk with 'In-use' status should remain consistent with the ZoneId of instance.
    /// - `InvalidOperation.MultiAttachRegionalDiskUnsupported`: The multi-attach regional disk with 'In-use' status attached to more than one instance is not allowed to modify disk spec.
    /// - `InvalidDestinationZoneId.DiskCategoryUnsupported`: The specified disk category does not allow the DestinationZoneId parameter for this operation.
    /// - `IncorrectInstanceStatus`: The current status of the instance does not support this operation.
    /// - `DiskInArrears`: The specified operation is denied as your disk owing fee.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `DiskCreatingSnapshot`: The operation is denied due to a snapshot of the specified disk is not completed yet.
    /// - `OperationDenied`: The type of the disk does not support the operation.
    /// - `InvalidPerformanceLevel.TooLow`: Specified new performance level is lower than the original performance level.
    /// - `OperationDenied.PerformanceLevelNotMatch`: The specified PerformanceLevel and disk size do not match.
    /// - `UserNotInTheWhiteList`: The user is not in modify disk category white list.
    /// - `InvalidRegion.NotSupport`: The specified region does not support modify disk category.
    /// - `InvalidDiskCategory.ValueNotSupported`: The current disk category of the resource does not support this operation.
    /// - `Downgrade.NotSupported`: Downgrade operation for prepay resource is not supported.
    /// - `InvalidInstanceType.NotSupportDiskCategory`: The instanceType of the specified instance does not support this disk category.
    /// - `ModifyingDiskCategoryLimitExceed`: The amount of modifying disk category exceeds the limit.
    /// - `DiskInCoolingPeriod`: There is a cooling period after the disk is successfully modified.
    /// - `DiskHasFlashSnapshot`: The specified disk with flash snapshots do not support modify disk category.
    /// - `NoChangeInDiskCategoryAndPerformanceLevel`: There is no change between the parameters transmitted and the current.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone; try other types of resources or other regions and zones.
    /// - `InvalidOperation.MultiAttachDisk`: Multi attach disk does not support this operation.
    /// - `OperationDenied.DiskExpansionUnfinished`: The instance has not been restarted after a previous disk expansion.
    /// - `InvalidDiskCategory.NotSupported`: The specified disk category is not supported.
    /// - `InvalidPerformanceParameter.DiskNotInDedicatedStorageCluster`: The specified disk not in dedicated storage cluster, can not modify performance control options.
    /// - `InvalidStatus.DiskUnderPerformanceControl`: The specified disk is under performance control, any modifications to the category or performance level of the specified disk are unsupported..
    /// - `InvalidStatus.DiskNotReady`: This specified disk is not ready, status needs to be either In_use or Available.
    /// - `InvalidOperation.DiskInReplicaPairsUnsupported`: The disk in replication pairs does not support this operation.
    /// - `InvalidDisk.DetachedSystemDisk`: The specified resource is/has a detached system disk %s , not support current operation.
    /// - `InvalidDiskCategory.InstanceTypeUnsupported`: The current instance type does not support the specified disk category. Please check the list of disk category supported by the instance type and select an appropriate disk category for configuration.
    /// - `InvalidOperation.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidOperation.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.
    /// - `InstanceLockedForSecurity`: The instance is locked for security reasons. Please contact Security Technical Support for assistance.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.
    /// - `InvalidDiskCategory.ValueUnauthorized`: The specified DiskCategory is not authorized.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_disk_spec(
        &self,
        req: ModifyDiskSpec,
    ) -> impl std::future::Future<Output = crate::Result<ModifyDiskSpecResponse>> + Send {
        self.call(req)
    }

    /// # 更换系统盘（更换操作系统）
    ///
    /// 通过更换ECS实例系统盘的方式更换操作系统。更换后系统盘的云盘ID将发生变化，原云盘会被释放。
    ///
    /// 调用该接口前请您仔细阅读[更换系统盘（更换操作系统）](~~50134~~)。
    ///
    /// 更换系统盘时，您需要注意：
    ///
    /// - 不支持变更系统盘计费方式。
    /// - 不支持更换系统盘的云盘类型。
    ///
    /// - 系统盘挂载的ECS实例不能有未支付的订单。
    ///  
    /// - 实例的状态必须为已停止（`Stopped`）状态。
    ///
    ///     > 仅适用于专有网络VPC类型实例。如果ECS实例为按量付费计费模式，且开启默认启用节省停机模式，为防止地域范围内的ECS实例库存不足，引起的更换系统盘后无法重启实例。您需要在停止该实例时设置为普通停机模式。具体操作，请参见[StopInstance](~~25501~~)。  
    ///
    /// - 您可以通过参数`SystemDisk.Size`重新指定系统盘的容量大小（不能低于原系统盘容量）。
    ///
    /// - ECS实例被安全锁定，即实例的`OperationLocks`参数值包含`"LockReason": "security"`，不支持更换系统盘。更多信息，请参见[安全锁定时的API行为](~~25695~~)。
    ///
    /// 更换系统盘后，可通过[DescribeInstances](~~25506~~)接口查询更换系统盘的实例的状态验证是否更换成功。如果返回值`OperationLocks`为空，则表示更换系统盘的操作已完成。
    ///
    /// # Error Codes
    /// - `LoginAsNonRoot.ImageNotSupport`: The specified image does not support login as non-root.
    /// - `InvalidSystemDiskSize.ValueNotSupported`: The specified parameter SystemDisk.Size is invalid.
    /// - `InvalidParameter.Conflict`: The specified image does not support the specified instance type.
    /// - `InvalidSystemDiskSize.ImageNotSupportResize`: The specified image does not support resize.
    /// - `InvalidSystemDiskSize`: The specified parameter SystemDisk.Size is invalid.
    /// - `InvalidPassword.Malformed`: The specified parameter "Password" is not valid.
    /// - `InvalidPasswordParam.Mismatch`: The input password should be null when passwdInherit is true.
    /// - `OperationDenied`: The specified image contains the snapshot of the data disk,does not support this operation.
    /// - `InvalidDiskCategory.ValueNotSupported`: The specified parameter "DiskCategory" is not valid.
    /// - `InvalidKeyPairName.NotFound`: The specified KeyPairName does not exist.
    /// - `DependencyViolation.IoOptimize`: The specified parameter InstanceId is not valid.
    /// - `MissingParameter.Architecture`: Architecture should not be null.
    /// - `InvalidArchitecture.Malformed`: Architecture is not valid.
    /// - `MissingParameter.Platform`: Platform should not be null.
    /// - `InvalidPlatform.Malformed`: Platform is not valid.
    /// - `InvalidDiskId.NotFound`: The specified disk do not exist.
    /// - `InvalidDatadisk.DiskStatusViolation`: The operation is not permitted due to status of the Datadisk.
    /// - `InvalidDatadisk.DiskCategoryViolation`: The operation is not permitted due to category of the Datadisk.
    /// - `InvalidDatadisk.ChargeTypeViolation`: The operation is not permitted due to charge type of the Datadisk.
    /// - `MissingParameter`: The input parameter "ImageId" that is mandatory for processing this request is not supplied.
    /// - `InvalidInstance.NotFoundSystemDisk`: The specified instance has no system disk.
    /// - `InvalidParameter.DiskType`: The specified disk type which has kms key can't convert to system disk.
    /// - `DISK_IN_DEDICATED_BLOCK_STORAGE_CLUSTER`: The disk in dedicated block storage cluster is not allowed to do this operation.
    /// - `IncorrectDiskStatus.ReplicationStatusNotFound`: Disk replication status not found.
    /// - `IncorrectDiskStatus.InReplication`: Disk already in replication.
    /// - `InvalidInstanceType.NotSupported`: The specified instanceType is not supported by the image architecture.
    /// - `InvalidRegionId.NotSupportReplaceEncryptedSystemDisk`: The specified region not support replace encrypted system disk.
    /// - `InvalidStorageClusterId.CapacityNotEnough`: The remaining capacity of the current dedicated storage cluster is less than the size of disk.
    /// - `QuotaExceed.DiskCapacity`: The used capacity of disk type has exceeded the quota in the zone,  %s.
    /// - `AccountForbidden.ProductCreationLimited`: The commodity must be officially operated by Aliyun and in pay-as-you-go billing method.
    /// - `InternalError`: The requested services is not available now. Please try again later.
    /// - `InvalidDiskName.Malformed`: The specified parameter "SyatemDisk.DiskName or DataDisk.n.DiskName" is not valid.
    /// - `LoginAsNonRoot.RegionNotSupport`: The specified region does not support login as non-root.
    /// - `InvalidSystemDiskStatus.IsTransfering`: The current status of the resource does not support this operation, system disk is transfering.
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The instance is locked due to security.
    /// - `ImageNotSubscribed`: The specified image has not be subscribed.
    /// - `ImageRemovedInMarket`: The specified market image is not available, Or the specified user defined image includes product code because it is based on an image subscribed from marketplace, and that image in marketplace includeing exact the same product code has been removed.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `ChargeTypeViolation`: The operation is not permitted due to charge type of the instance.
    /// - `DiskCreatingSnapshot`: The operation is denied due to a snapshot of the specified disk is not completed yet.
    /// - `IoOptimized.NotSupported`: The specified image is not support IoOptimized Instance.
    /// - `ImageNotSupportInstanceType`: The specified image don not support the InstanceType instance.
    /// - `QuotaExceed.BuyImage`: The specified image is from the image market,You have not bought it or your quota has been exceeded.
    /// - `INST_HAS_UNPAID_ORDER`: The instance has unpaid order.
    /// - `OperationDenied.InstanceCreating`: The specified instance is creating.
    /// - `DependencyViolation.WindowsInstance`: The instance creating is windows, cannot use ssh key pair to login.
    /// - `InvalidParameter.NotMatch`: %s
    /// - `ResourcesNotInSameZone`: The specified instance and disk are not in the same zone.
    /// - `OperationDenied.UnpaidOrder`: The specified instance has unpaid order.
    /// - `InvalidHostname.MismatchImage`: The hostname of the current instance can not be applied to the image you choose.
    /// - `HibernationConfigured.InstanceOperationForbidden`: The operation is not permitted due to limit of the hibernation configured instance.
    /// - `InvalidOperation.MultiAttachDisk`: Multi attach disk does not support this operation.
    /// - `InvalidRegionId.NotSupportEncryptAlgorithm`: The current region does not support creating encrypted disks with EncryptAlgorithm.
    /// - `InvalidRegionId.NotExists`: The region not exists.
    /// - `InvalidEncryptAlgorithm`: The specified parameter EncryptAlgorithm is not valid.
    /// - `InvalidEncrypted.NotMatchKmsKeyId`: The specified parameter Encrypted must be true when KmsKeyId is not empty.
    /// - `InvalidEncrypted.NotMatchEncryptAlgorithm`: The specified parameter Encrypted must be true when EncryptAlgorithm is not empty.
    /// - `InvalidParameter.KmsNotEnabled`: The specified operation need enable KMS.
    /// - `InvalidParameter.DataEncryptedKeyCreateFailed`: Create kms data encrypted key fail. If you need further assistance, you can contact the KMS Technical Support.
    /// - `InvalidParameter.KMSKeyId.NotFound`: The specified KMSKeyId does not exist.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `InvalidKMSKeyId.NotSymmetric`: The specified parameter KmsKeyId must be symmetric.
    /// - `InvalidDiskId.NotSupportReplaceEncryptedSystemDisk`: The specified diskId not support replace encrypted system disk.
    /// - `NotSupportSnapshotEncrypted.DiskCategory`: The specified disk category does not support creating encrypted system disks or creating encrypted data disks from snapshots. Check the DiskCategory or Encrypted parameter, or check your account for default encryption settings.
    /// - `InvalidParameter.AllEmpty`: The current operation does not allow both diskId and imageId to be empty. Make sure that either diskId or imageId is not empty.
    /// - `InvalidParameter.Conflict`: The current operation does not allow both diskId and imageId to be set. Make sure that either diskId or imageId is not empty.
    /// - `OperationDenied`: The current region does not support changing the image type.
    /// - `OperationDenied.ImageNotValid`: The specified Image is disabled or deleted, please check the status of the image.
    /// - `OperationDenied.DiskNoStock`: The requested disk category is sold out in the specified zone. Please try a different disk category or another zone.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.
    /// - `InvalidEncrypted.NotMatchSnapshot`: The specified parameter Encrypted must be set to true when creating disks with encrypted snapshots.
    /// - `InvalidEncrypted.NotMatchDiskDefaultEncryption`: Enabling disk default encryption prevents the creation of non-encrypted disks.
    /// - `InvalidPayMethod.SyncPaymentNotSupport`: Synchronous payment is not supported. Use another payment method.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.
    /// - `InvalidSystemDiskSize.MoreThanMaxSize`: The specified SystemDisk.Size parameter exceeds the maximum size.
    /// - `InvalidSystemDiskSize.LessThanImageSize`: The specified parameter SystemDisk.Size is less than the image size.
    /// - `InvalidSystemDiskSize.LessThanMinSize`: The specified parameter SystemDisk.Size is less than the min size.
    /// - `NoSuchResource`: The specified resource is not found.
    /// - `OperationDenied`: Internal Error.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn replace_system_disk(
        &self,
        req: ReplaceSystemDisk,
    ) -> impl std::future::Future<Output = crate::Result<ReplaceSystemDiskResponse>> + Send {
        self.call(req)
    }

    /// # 使用快照回滚云盘
    ///
    /// 使用云盘快照，将云盘回滚到之前某一特定的历史状态。
    ///
    /// 调用该接口前，请您仔细阅读[使用快照回滚云盘](~~25450~~)。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 云盘的状态必须为使用中（`In_use`）或空闲（`Available`）的状态。  
    /// - 云盘挂载的实例的状态必须为已停止（`Stopped`）。您可以调用[StopInstances](~~155372~~)停止实例。  
    /// - 指定的参数`SnapshotId`必须是由`DiskId`创建的历史快照。  
    /// - 通过[DescribeInstances](~~25506~~)查询ECS实例信息时，如果返回数据中包含`{"OperationLocks": {"LockReason" : "security"}}`，则禁止一切操作。
    ///
    /// # Error Codes
    /// - `DiskCategory.OperationNotSupported`: The operation is not supported to the specified disk due to its disk category.
    /// - `InvalidRegionId.MalFormed`: The specified RegionId is not valid.
    /// - `DryRunOperation`: Request validation has been passed with DryRun flag set.
    /// - `InternalError`: The requested services is not available now. Please try again later.
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The instance is locked due to security.
    /// - `InvalidParameter.Mismatch`: The specified snapshot is not created from the specified disk.
    /// - `InvalidSnapshot.TooOld`: The snapshotId is created before 2013-07-15, it cannot be restored since the first time the disk detached.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `OperationDenied`: The specified snapshot dees not support ResetDisk.
    /// - `InvalidSnapshotId.NotReady`: The specified snapshot has not completed yet.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `InvalidAccountStatus.SnapshotServiceUnavailable`: Snapshot service has not been opened yet.
    /// - `Operation.Conflict`: The operation may conflicts with others.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK needs to be added ECS tag.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be enabled.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `IncorrectDiskStatus.HasUnfinishedSnapshot`: The current disk has unfinished snapshot.
    /// - `InvalidOperation.DiskResetInProgress`: The operation cannot be performed because the disk has an ongoing reset task, please try again later.
    /// - `InvalidParameter.KMSKeyId.NotFound`: The specified KMSKeyId does not exist.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.
    /// - `Disk.NotFound`: The specified disk does not exist.
    /// - `InvalidSnapshotId.NotFound`: The specified SnapshotId does not exist.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn reset_disk(
        &self,
        req: ResetDisk,
    ) -> impl std::future::Future<Output = crate::Result<ResetDiskResponse>> + Send {
        self.call(req)
    }

    /// # 批量重置磁盘
    ///
    /// 通过实例快照回滚一个或多个云盘。
    ///
    /// 该接口即将废弃，建议您使用[ResetDisk](~~25520~~)回滚云盘。
    ///
    /// # Error Codes
    /// - `DiskCategory.OperationNotSupported`: The operation is not supported to the specified disk due to its disk category.
    /// - `InvalidRegionId.MalFormed`: The specified RegionId is not valid.
    /// - `DryRunOperation`: Request validation has been passed with DryRun flag set.
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The instance is locked due to security.
    /// - `InvalidParameter.Mismatch`: The specified snapshot is not created from the specified disk.
    /// - `InvalidSnapshot.TooOld`: The snapshotId is created before 2013-07-15, it cannot be restored since the first time the disk detached.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `OperationDenied`: The specified snapshot dees not support ResetDisk.
    /// - `InvalidSnapshotId.NotReady`: The specified snapshot has not completed yet.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `InvalidAccountStatus.SnapshotServiceUnavailable`: Snapshot service has not been opened yet.
    /// - `Operation.Conflict`: The operation may conflicts with others.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK needs to be added ECS tag.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be enabled.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `IncorrectDiskStatus.HasUnfinishedSnapshot`: The current disk has unfinished snapshot.
    /// - `InvalidRegion.NotSupport`: The specified region does not support resetting disks.
    /// - `InvalidOperation.MultiAttachDisk`: Multi attach disk does not support this operation.
    /// - `InvalidDisk.ShareVolume`: The specified diskId is invalid. The shared volume does not support creating a snapshot group.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.
    /// - `Disk.NotFound`: The specified disk does not exist.
    /// - `InvalidSnapshotId.NotFound`: The specified SnapshotId does not exist.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidSnapshot.NotFound`: The SnapshotId provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn reset_disks(
        &self,
        req: ResetDisks,
    ) -> impl std::future::Future<Output = crate::Result<ResetDisksResponse>> + Send {
        self.call(req)
    }

    /// # 初始化磁盘至创建时的初始状态
    ///
    /// 重新初始化一块磁盘至创建时的初始状态。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 磁盘的状态必须为**使用中**（`In_use`），云盘挂载的ECS实例的状态必须为**已停止**（`Stopped`）。
    /// - 实例首次启动前，不能重新初始化挂载在其上的磁盘。
    /// - 已存在本地快照的云盘，不能重新初始化。
    /// <props="china">- 开启多重挂载特性的云盘，不能重新初始化。</props>
    /// - 对于系统盘，初始化到镜像的最初状态。若创建云盘的源镜像被删除，则无法初始化。
    /// - 对于直接创建的数据盘，初始化到空盘状态；对于通过快照创建的数据盘，初始化到快照状态。若源快照已被删除，则无法初始化并返回错误。
    ///
    /// # Error Codes
    /// - `LoginAsNonRoot.ImageNotSupport`: The specified image does not support login as non-root.
    /// - `DiskHasSnapshotsWithInstantAccessEnabled.OperationNotSupported`: The operation is not supported to the specified disk that have snapshots with InstantAccess enabled.
    /// - `InvalidPassword.Malformed`: The specified parameter "Password" is not valid.
    /// - `InvalidKeyPairName.NotFound`: The specified KeyPairName does not exist.
    /// - `DependencyViolation.IoOptimize`: The specified parameter InstanceId is not valid.
    /// - `DiskCategory.OperationNotSupported`: The operation is not supported to the specified disk due to its disk category.
    /// - `InvalidRegionId.MalFormed`: The specified RegionId is not valid.
    /// - `LoginAsNonRoot.RegionNotSupport`: The specified region does not support login as non-root.
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The instance is locked due to security.
    /// - `InvalidSnapshot.TooOld`: The disk is created from a snapshotId made before 2013-07-15, it cannot be re-initiated the specified disk any more since the detached first time.
    /// - `OperationDenied`: The snapshot which is used to create the specified disk has been deleted.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `DiskCreatingSnapshot`: The operation is denied due to a snapshot of the specified disk is not completed yet.
    /// - `SharedImageDeleted`: The specified image by others shared is deleted.
    /// - `DependencyViolation.WindowsInstance`: The instance creating is windows, cannot use ssh key pair to login.
    /// - `UserNotInTheWhiteList`: The user is not in volume white list.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be enabled.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `HibernationConfigured.InstanceOperationForbidden`: The operation is not permitted due to limit of the hibernation configured instance.
    /// - `InvalidOperation.MultiAttachDisk`: Multi attach disk does not support this operation.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK needs to be added ECS tag.
    /// - `InvalidSourceSnapshot`: The source snapshot of the disk has been deleted and cannot support the current operation.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.
    /// - `InvalidImageId.NotFound`: The specified ImageId does not exist.
    /// - `InvalidDiskId.OperationNotSupported`: The operation is not supported due to image not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn re_init_disk(
        &self,
        req: ReInitDisk,
    ) -> impl std::future::Future<Output = crate::Result<ReInitDiskResponse>> + Send {
        self.call(req)
    }

    /// # 迁移云盘
    ///
    /// 将云盘迁入、迁出专属块存储集群，或将云盘在不同专属块存储集群之间迁移。
    ///
    /// > 专属块存储集群功能目前支持华东1（杭州）、华东2（上海）、华北2（北京）、华北3（张家口）、华北6（乌兰察布）、华南1（深圳）、华南2（河源）、印度尼西亚（雅加达）、德国（法兰克福）以及华南1 金融云地域。
    ///
    /// 请确保在使用该接口前，您已充分了解云盘和专属块存储集群的计费方式和价格，并且专属块存储集群未到期，账号未处于欠费状态。更多信息，请参见[专属块存储计费](~~208883~~)和[块存储计费](~~179022~~)。
    ///
    /// 调用该接口时，您需要注意：
    /// - 云盘和专属块存储集群必须在同一个可用区。
    /// - 仅支持按量付费云盘，包年包月云盘需要先转成按量付费。具体操作，请参见[转换云盘计费方式](~~145018~~)。
    /// - 迁移时云盘规格需要和目标集群支持的云盘规格保持一致，当在不同专属块存储集群之间迁移时允许变更云盘规格，使其和目标集群支持的云盘规格保持一致。
    /// - 云盘的状态必须是**使用中**（In_use）状态或者**待挂载**（Available）状态。
    /// - 若云盘已挂载到ECS实例上，实例必须处于**运行中**（Running）状态或者**已停止**（Stopped）状态，ECS实例不能处于已过期状态。
    /// - 由于ESSD云盘性能级别受容量限制，如果您无法升级性能级别，可以扩容后重新操作。更多信息，请参见[ResizeDisk](~~25522~~)和[ESSD云盘](~~122389~~)。
    /// - 一个账号在同一地域内最多同时进行5个云盘迁移任务。
    /// - 迁移过程中不允许取消迁移、创建快照、变配、扩容、挂载、卸载、重新初始化云盘等操作。
    ///
    /// > 云盘迁移后遵循目标集群对应的计费方式、云盘规格和能力，调用接口后立即生效，阿里云按照新的云盘类型及云盘性能级别进行计费。更多信息，请参见[专属块存储计费](~~208883~~)和[块存储计费](~~179022~~)。
    ///
    /// # Error Codes
    /// - `InvalidDiskSpec.Malformed`: The specified parameter DiskCategory or PerformanceLevel is not supported.
    /// - `AccountInArrears`: The account is in arrears.
    /// - `InvalidStorageClusterId.DiskAlreadyInDestination`: The specified disk is already in destination.
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `DiskCreatingSnapshot`: The operation is denied due to a snapshot of the specified disk is not completed yet.
    /// - `InvalidOperation.DiskTypeUnsupported`: The type of the disk does not support this operation.
    /// - `InvalidOperation.ChargeTypeUnsupported`: The charge type of the disk does not support this operation.
    /// - `InvalidPerformanceLevel.DiskSizeUnsupported`: The specified parameter PerformanceLevel does not match the disk size.
    /// - `DiskLimitExceeded`: The number of migrated disks at the same time exceeds the limit.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone; try other types of resources or other regions and zones.
    /// - `InvalidOperation.MultiAttachDisk`: Multi attach disk does not support this operation.
    /// - `InvalidDisk.DetachedSystemDisk`: The specified resource is/has a detached system disk %s , not support current operation.
    /// - `InvalidOperation.NoPermission`: You are not authorized to do this action.
    /// - `InvalidOperation.LimitQosUnsupported`: The specified disk has limited bps or iops, can not do this operation.
    /// - `InvalidOperation.AcrossRegionsOrZonesUnsupported`: Migration across regions or available zones is not supported.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.
    /// - `InvalidStorageClusterId.NotFound`: The specified dedicated block storage cluster does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_disk_deployment(
        &self,
        req: ModifyDiskDeployment,
    ) -> impl std::future::Future<Output = crate::Result<ModifyDiskDeploymentResponse>> + Send {
        self.call(req)
    }

    /// # 释放按量付费数据盘
    ///
    /// 释放一块按量付费数据盘。磁盘类型包括普通云盘、高效云盘、SSD云盘和ESSD云盘。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 您的磁盘手动快照会被保留。
    /// - 您可以通过[ModifyDiskAttribute](~~25517~~)设置是否保留或者同时释放自动快照。建议您及时删除不必要的快照，以保持足够的快照额度完成周期性的自动快照策略。
    /// - 释放磁盘时，云盘的状态必须为待挂载（Available）。
    /// - 如果指定ID的磁盘不存在，请求将被忽略。
    ///
    /// # Error Codes
    /// - `InvalidRegionId.MalFormed`: The specified parameter RegionId is not valid.
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `DiskNotPortable`: The specified disk is not a portable disk.
    /// - `DiskTypeViolation`: The specified disk is a system disk and cannot support the operation.
    /// - `DiskCreatingSnapshot`: The operation is denied due to a snapshot of the specified disk is not completed yet.
    /// - `IncorrectDiskStatus.Initializing`: The current disk status does not support this operation.
    /// - `DiskStillAttached`: The disk is still attached to the disk.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `InvalidDiskStatus.DeleteProtection`: The specified disk is under delete protection, can not be deleted.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_disk(
        &self,
        req: DeleteDisk,
    ) -> impl std::future::Future<Output = crate::Result<DeleteDiskResponse>> + Send {
        self.call(req)
    }

    /// # 开启块存储账号级默认加密
    ///
    /// 开启指定地域块存储账号级默认加密。
    ///
    /// <props="china">
    ///
    /// > EBS账号级默认加密功能当前仅对部分地域和用户开放，若您有使用需求，请[提交工单](https://selfservice.console.aliyun.com/ticket/createIndex)。
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// > EBS账号级默认加密功能当前仅对部分地域和用户开放，若您有使用需求，请[提交工单](https://smartservice.console.aliyun.com/service/create-ticket-intl)。
    ///
    /// </props>
    ///
    /// - **使用须知**
    ///   - RAM用户（子账号）需要`AliyunECSFullAccess`权限，具体授权操作，请参见[为RAM用户授权](~~116146~~)。
    ///   - 开启块存储账号级默认加密前，您需要先[开通KMS产品服务](~~480156~~)。
    ///   - 开启块存储账号级默认加密后，限制只能新购加密云盘，详情见[加密云盘_使用限制](~~59643#50de175230erj~~)。
    ///
    /// - **注意事项**
    ///     - 开启块存储账号级默认加密后，新购的按量付费或包年包月云盘都必须是加密云盘，您可以使用块存储账号级默认加密配置的KMS密钥ID，也可以修改成其他任意的KMS密钥ID。
    ///
    ///     - 首次启用块存储账号级默认加密时，默认使用服务密钥。
    ///
    /// - **使用建议**
    ///     - 您可以通过 [DescribeDiskEncryptionByDefaultStatus](~~2851493~~) 和 [DescribeDiskDefaultKMSKeyId](~~2851490~~) 查询指定地域块存储账号级默认加密功能是否开启以及使用的KMS密钥ID。
    ///     - 您可以通过 [ModifyDiskDefaultKMSKeyId](~~2851492~~) 或 [ResetDiskDefaultKMSKeyId](~~2851539~~) 修改或重置块存储账号级默认加密的KMS密钥。
    ///     - 您可以通过 [DisableDiskEncryptionByDefault](~~2851491~~) 关闭指定地域块存储账号级默认加密功能。
    ///
    /// # Error Codes
    /// - `InvalidParameter.Encrypted.KmsNotEnabled`: KMS must be enabled for encrypted disks.
    /// - `InvalidParameter.KmsNotEnabled`: Failed to perform this operation because KMS is not activated.
    /// - `Abs.InvalidAction.RegionNotSupport`: This region does not support this action.
    /// - `InvalidOperation.DefaultEncryptionAlreadyEnabled`: The specified region is already default encryption settings.
    /// - `InvalidParameter.RegionIdNotExists`: The specified region does not exists.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `InvalidOperation.KMSKeyIdNotFound`: The specified KMSKeyId not found, %s.
    /// - `InvalidOperation.KMSServiceNotOpen`: KMS service is currently not open.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.///
    /// # Methods
    /// - GET
    /// - POST
    ///
    pub fn enable_disk_encryption_by_default(
        &self,
        req: EnableDiskEncryptionByDefault,
    ) -> impl std::future::Future<Output = crate::Result<EnableDiskEncryptionByDefaultResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询块存储账号级默认加密的服务状态
    ///
    /// 查询指定地域块存储账号级默认加密的服务状态。
    ///
    /// # Error Codes
    /// - `InvalidParameter.RegionIdNotExists`: The specified region does not exists.///
    /// # Methods
    /// - GET
    /// - POST
    ///
    pub fn describe_disk_encryption_by_default_status(
        &self,
        req: DescribeDiskEncryptionByDefaultStatus,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeDiskEncryptionByDefaultStatusResponse>,
    > + Send {
        self.call(req)
    }

    /// # 查询块存储账号级默认加密使用的密钥
    ///
    /// 查询块存储账号级默认加密使用的密钥。
    ///
    /// # Error Codes
    /// - `InvalidParameter.RegionIdNotExists`: The specified region does not exists.///
    /// # Methods
    /// - GET
    /// - POST
    ///
    pub fn describe_disk_default_kms_key_id(
        &self,
        req: DescribeDiskDefaultKMSKeyId,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDiskDefaultKMSKeyIdResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改块存储账号级默认加密使用的密钥
    ///
    /// 修改指定地域块存储账号级默认加密使用的KMS密钥ID。
    ///
    /// - RAM用户（子账号）需要`AliyunECSFullAccess`权限，具体授权操作，请参见[为RAM用户授权](~~116146~~)。
    /// - 指定地域需要开启块存储账号级默认加密功能。
    /// - 首次使用主密钥，需要先为ECS授权`AliyunECSDiskEncryptDefaultRole`角色，允许ECS访问KMS资源，详情见[通过RAM角色授予访问KMS密钥的权限](~~2838993~~)。
    ///
    /// # Error Codes
    /// - `InvalidParameter.Encrypted.KmsNotEnabled`: KMS must be enabled for encrypted disks.
    /// - `InvalidParameter.KmsNotEnabled`: Failed to perform this operation because KMS is not activated.
    /// - `Abs.InvalidAction.RegionNotSupport`: This region does not support this action.
    /// - `InvalidParameter.RegionIdNotExists`: The specified region does not exists.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `InvalidOperation.KMSKeyIdNotFound`: The specified KMSKeyId not found, %s.
    /// - `InvalidOperation.KMSServiceNotOpen`: KMS service is currently not open.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `InvalidDefaultEncryption.NotFound`: You have not configured default encryption setting in this region.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_disk_default_kms_key_id(
        &self,
        req: ModifyDiskDefaultKMSKeyId,
    ) -> impl std::future::Future<Output = crate::Result<ModifyDiskDefaultKMSKeyIdResponse>> + Send
    {
        self.call(req)
    }

    /// # 重置块存储账号级默认加密使用的密钥
    ///
    /// 将指定地域块存储账号级默认加密使用的 KMS 密钥 ID 重置为服务密钥的接口。
    ///
    /// - RAM用户（子账号）需要`AliyunECSFullAccess`权限，具体授权操作，请参见[为RAM用户授权](~~116146~~)。
    /// - 指定地域需要开启**块存储账号级默认加密**功能。
    ///
    /// # Error Codes
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be enabled.
    /// - `InvalidParameter.Encrypted.KmsNotEnabled`: KMS must be enabled for encrypted disks.
    /// - `InvalidParameter.KmsNotEnabled`: Failed to perform this operation because KMS is not activated.
    /// - `Abs.InvalidAction.RegionNotSupport`: This region does not support this action.
    /// - `InvalidParameter.RegionIdNotExists`: The specified region does not exists.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `InvalidOperation.KMSKeyIdNotFound`: The specified KMSKeyId not found, %s.
    /// - `InvalidOperation.KMSServiceNotOpen`: KMS service is currently not open.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `InvalidDefaultEncryption.NotFound`: You have not configured default encryption setting in this region.///
    /// # Methods
    /// - GET
    /// - POST
    ///
    pub fn reset_disk_default_kms_key_id(
        &self,
        req: ResetDiskDefaultKMSKeyId,
    ) -> impl std::future::Future<Output = crate::Result<ResetDiskDefaultKMSKeyIdResponse>> + Send
    {
        self.call(req)
    }

    /// # 关闭块存储账号级默认加密
    ///
    /// 关闭指定地域块存储账号级默认加密。
    ///
    /// - **使用须知**
    ///   - RAM用户（子账号）需要`AliyunECSFullAccess`权限，具体授权操作，请参见[为RAM用户授权](~~116146~~)。
    ///
    /// - **注意事项**
    ///   - 关闭块存储账号级默认加密后，已创建的云盘加密状态不受影响。
    ///   - 关闭块存储账号级默认加密后，您依旧可以在新购云盘时手动选择加密云盘。
    ///
    /// # Error Codes
    /// - `Abs.InvalidAction.RegionNotSupport`: This region does not support this action.
    /// - `InvalidParameter.RegionIdNotExists`: The specified region does not exists.
    /// - `UserNotInTheWhiteList`: The user is not in disk white list.
    /// - `InvalidDefaultEncryption.NotFound`: You have not configured default encryption setting in this region.///
    /// # Methods
    /// - GET
    /// - POST
    ///
    pub fn disable_disk_encryption_by_default(
        &self,
        req: DisableDiskEncryptionByDefault,
    ) -> impl std::future::Future<Output = crate::Result<DisableDiskEncryptionByDefaultResponse>> + Send
    {
        self.call(req)
    }

    /// # 开通快照服务
    ///
    /// 开通快照服务。
    ///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn open_snapshot_service(
        &self,
        req: OpenSnapshotService,
    ) -> impl std::future::Future<Output = crate::Result<OpenSnapshotServiceResponse>> + Send {
        self.call(req)
    }

    /// # 创建快照
    ///
    /// 为一块云盘创建一份快照。
    ///
    /// 原本地快照更替为快照极速可用能力。参数说明如下：
    /// - 如果您在 2020 年 12 月 14 日之前使用过本地快照，您可以正常使用参数`Category`。
    /// - 如果您在 2020 年 12 月 14 日之前未使用过本地快照，无需额外进行配置，ESSD系列云盘（ESSD、ESSD AutoPL、ESSD Entry和ESSD同城冗余）新建的快照将默认为创建后极速可用，且同时支持手动快照和自动快照。API接口中的“InstantAccess”、“InstantAccessRetentionDays”、“DisableInstantAccess”三个极速可用功能相关参数不再生效，“DescribeSnapshots”、“DescribeSnapshotGroups”这两个API接口将新增出参Available来描述快照可用的状态。
    ///
    /// 前提条件：
    ///
    /// - 已开通快照。具体操作，请参见[开通快照](~~108381~~)。
    ///
    /// - 云盘必须处于**使用中**或**待挂载**状态。不同状态下的注意事项如下：
    ///   - 如果云盘处于**使用中**的状态，则实例必须处于**运行中**或**已停止**状态。
    ///   - 如果云盘处于**待挂载**的状态，则需要保证云盘有过挂载到ECS实例的历史操作。从未挂载过ECS实例的云盘不支持创建快照。
    ///   - 当云盘被用作创建动态扩展卷或者RAID阵列时，建议您使用快照一致性组并开启应用一致性快照备份数据。快照一致性组能够保证在业务系统跨多块云盘的场景下，数据写入云盘的时序一致性，并保证其崩溃一致性。更多信息，请参见[创建快照一致性组](~~199625~~)和[创建应用一致性快照](~~208589~~)。
    ///
    /// 创建快照时，您需要注意：
    ///
    /// - 创建快照应避开业务高峰期。创建快照时，云盘I/O性能降低10%以内，读写性能出现短暂瞬间变慢。
    /// - 如果创建快照还未完成，这份快照无法用于创建自定义镜像（[CreateImage](~~25535~~)）。
    /// - 创建快照期间，操作云盘产生的增量数据不会备份到快照中。
    /// - 如果云盘已挂载到ECS实例上，创建快照期间请勿变更实例状态，如停止或重启ECS实例，否则会导致快照创建失败。
    /// - 正在创建快照的云盘不支持扩容。请您等待快照创建完成后，再开始执行扩容操作。
    ///
    /// - 支持对处于**已过期**（`Expired`）状态的云盘创建快照。若创建快照时云盘正好达到过期释放时间，云盘被释放的同时也会删除**创建中**（`Creating`）的快照。
    ///
    /// - 创建快照后，系统根据快照容量大小，按每个地域单独结算费用。更多信息，请参见[快照计费](~~56159~~)
    ///
    /// - 以下场景中，您无法为指定的云盘创建快照：
    ///
    ///   - 云盘保留的手动快照数达到了256份。
    ///
    ///   - 创建快照存在并发限制，超过限制会导致创建失败。更多信息，请参见[快照使用限制](~~25412#SnapshotQuota1~~)。
    ///
    ///   - 查询ECS实例信息时，如果返回数据中包含`{"OperationLocks": {"LockReason" : "security"}}`，则禁止一切操作。
    ///
    /// # Error Codes
    /// - `InvalidParameter.KMSKeyId.NotFound`: The specified KMSKeyId does not exist.
    /// - `InvalidSnapshotName.Malformed`: The specified SnapshotName is wrongly formed.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `DiskCategory.OperationNotSupported`: The type of the specified disk does not support creating a snapshot.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidRetentionDays.Malformed`: The specified RetentionDays is not valid.
    /// - `CreateSnapshot.Failed`: The process of creating snapshot is failed.
    /// - `Throttling`: Request was denied due to user flow control.
    /// - `IncorrectDiskStatus.CreatingSnapshot`: A previous snapshot creation is in process.
    /// - `InstanceLockedForSecurity`: The disk attached instance is locked due to security.
    /// - `IncorrectDiskStatus.NeverAttached`: The specified disk has never been attached to any instance.
    /// - `QuotaExceed.Snapshot`: The snapshot quota exceeds.
    /// - `IncorrectDiskStatus.NeverUsed`: The specified disk has never been used after creating.
    /// - `CreateSnapshot.Failed`: The process of creating snapshot is failed.
    /// - `DiskInArrears`: The specified operation is denied as your disk has expired.
    /// - `DiskId.ValueNotSupported`: The specified parameter diskid is not supported.
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `InvalidAccountStatus.SnapshotServiceUnavailable`: Snapshot service has not been opened yet.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `IncorrectVolumeStatus`: The current volume status does not support this operation.
    /// - `IdempotentParameterMismatch`: The specified clientToken is used.
    /// - `IncorrectDiskStatus.Invalid`: The specified disk status invalid, restart instance and try again.
    /// - `IncorrectDiskType.NotSupport`: The specified device type is not supported.
    /// - `IncorrectDiskStatus.Transferring`: The specified device is transferring, you can retry after the process is finished.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: ECS tags must be added to the CMK.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be enabled.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `IdempotentProcessing`: The previous idempotent request(s) is still processing.
    /// - `InvalidSnapshotCategory.Malformed`: The specified Category is not valid.
    /// - `InvalidAction.Unauthorized`: The specified action is not valid.
    /// - `InvalidRegion.NotSupportSnapshotInstantAccessRegion`: The snapshot InstantAccess is not supported for this region.
    /// - `InvalidCategoryAndInstantAccess.Malformed`: The snapshot Category and InstantAccess can't be used together.
    /// - `DISK_HAS_CREATING_SNAPSHOT`: The operation cannot be performed while a snapshot is being created for the disk.
    /// - `HibernationConfigured.InstanceOperationForbidden`: The operation is not permitted due to limit of the hibernation configured instance.
    /// - `QuotaExceed.SnapshotQuota`: The quota is insufficient, please contact your channel partner to increase the quota.
    /// - `InvalidInstantAccessRetentionDays.Malformed`: The specified InstantAccessRetentionDays is not valid.
    /// - `CloudBoxNotSupportSnapshotWithInstantAccess`: The specified disk in CloudBox does not support to create a snapshot with InstantAccess.
    /// - `InvalidOperation.UnfinishedEncryptedSnapshotCopy`: This disk has unfinished encrypted copy snapshots in the target region.
    /// - `QuotaExceed.ConcurrentSnapshotQuota`: The number of snapshots being created for the disk %s has exceeded the concurrent quota (%s). Please wait for the previous snapshots to complete before trying again.
    /// - `InvalidClientToken.Malformed`: The specified clientToken is improperly formatted. It must contain only ASCII characters and must not exceed 64 characters in length.
    /// - `InvalidParameter.UnauthorizedStorageLocationArn`: The operation has failed due to lack of permission for the specified "StorageLocationArn". Please use a resource with appropriate permission for the operation.
    /// - `InvalidDiskId.NotFound`: The specified DiskId does not exist.
    /// - `InvalidDescription.Malformed`: The specified description is wrongly formed.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidVolumeId.NotFound`: The specified volume does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_snapshot(
        &self,
        req: CreateSnapshot,
    ) -> impl std::future::Future<Output = crate::Result<CreateSnapshotResponse>> + Send {
        self.call(req)
    }

    /// # 查询云盘快照列表
    ///
    /// 查询云盘的快照列表信息。例如快照状态、正在创建的快照剩余完成时间、自动快照保留天数等。
    ///
    /// `InstanceId`、`DiskId`和`SnapshotIds`不是必需的请求参数，但是可以构建过滤器逻辑，参数之间为逻辑与（And）关系。
    ///
    /// 通过阿里云CLI调用API时，不同数据类型的请求参数取值必须遵循一定的格式要求，详情请参见[CLI参数格式说明](~~110340~~)。
    ///
    /// 请求示例：
    /// <details>
    /// <summary>查询杭州地域下ECS实例所有云盘的快照信息列表</summary>
    ///
    /// ```ignore
    /// RegionId:  cn-hangzhou,   //设置华东 1（杭州）地域。
    /// InstanceId:  i-bp1fh7by6d9mw7zr****   //设置待查询的实例ID。
    ///
    /// ```
    /// </details>
    ///
    /// <details>
    /// <summary>查询杭州地域下某一云盘的快照信息</summary>
    ///
    /// ```ignore
    /// RegionId:  cn-hangzhou,   //设置华东 1（杭州）地域。
    /// DiskId:   d-bp10e7ej8z743dmu****   //设置待查询的云盘ID。
    /// ```
    /// </details>
    ///
    /// <details>
    /// <summary>根据快照ID查询杭州地域下两个快照的信息</summary>
    ///
    /// ```ignore
    /// RegionId:  cn-hangzhou,   //设置华东 1（杭州）地域。
    /// SnapshotIds:   ["d-bp10e7ej8z743dmu****", "s-bp19vd1lorzgzt2s****"]   //设置待查询的快照ID数组。
    ///
    /// ```
    /// </details>
    ///
    /// <details>
    /// <summary>查询杭州地域下某一时间节点后创建的快照信息</summary>
    ///
    /// ```ignore
    /// RegionId:  cn-hangzhou,   //设置华东 1（杭州）地域。
    /// Filter.1.Key:   CreationStartTime,   //设置待查询的快照ID数组。
    /// Filter.1.Value:   2024-11-27T00:00Z
    ///
    /// ```
    /// </details>
    ///
    /// # Error Codes
    /// - `InvalidTag.Mismatch`: The specified Tag.n.Key and Tag.n.Value are not match.
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `InvalidSnapshotIds.Malformed`: The amount of specified specified snapshot Ids exceeds the limit.
    /// - `InvalidSnapshotCategory.Malformed`: The specified Category is not valid.
    /// - `InvalidFilterKey.NotFound`: The specified FilterKey is not found.
    /// - `InvalidFilterValue`: The specified FilterValue  exceeds the limit.
    /// - `InvalidUsage`: The specifed Usage is not valid.
    /// - `InvalidSourceDiskType`: The specifed SourceDiskType is not valid.
    /// - `InvalidStatus.NotFound`: The specified Status is not found.
    /// - `InvalidSnapshotType.NotFound`: The specfied SnapshotType is not found.
    /// - `InvalidSnapshotLinkId.NotFound`: The specified snapshot link is not found.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_snapshots(
        &self,
        req: DescribeSnapshots,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSnapshotsResponse>> + Send {
        self.call(req)
    }

    /// # 查询快照数量和容量
    ///
    /// 查询您在一个地域下的快照数量以及快照容量。
    ///
    /// ## 接口说明
    ///
    /// 如果您想知道当前地域下每块磁盘的快照使用情况，推荐使用[DescribeSnapshotLinks](~~55837~~)查询快照链。
    ///
    /// # Error Codes
    /// - `InvalidParam.RegionId`: The specified region is not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_snapshots_usage(
        &self,
        req: DescribeSnapshotsUsage,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSnapshotsUsageResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改快照属性
    ///
    /// 修改一份快照的名称、描述或保留天数。
    ///
    /// # Error Codes
    /// - `InvalidSnapshotName.Malformed`: The specified SnapshotName is wrongly formed.
    /// - `NoAttributeToModify`: No attribute to be modified in this request.
    /// - `InvalidRetentionDays.Malformed`: The specified RetentionDays is not valid.
    /// - `InvalidOperation.DecreaseRetentionDaysUnsupported`: The requested operation to decrease retention days for the snapshot is not supported.
    /// - `InvalidSnapshotId.NotReady`: The specified snapshot has not completed yet.
    /// - `IncorrectDiskStatus.CreatingSnapshot`: A previous snapshot creation is in process.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: The current operation is not supported because the resource is managed by a cloud product. Please contact the relevant cloud product to confirm the reason.
    /// - `InvalidDescription.Malformed`: The specified description is wrongly formed.
    /// - `InvalidSnapshotId.NotFound`: The specified SnapshotId does not exist.
    /// - `InvalidSnapshotDisableInstantAccess.Malformed`: The specified DisableInstantAccess is not valid!///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_snapshot_attribute(
        &self,
        req: ModifySnapshotAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifySnapshotAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改快照类型
    ///
    /// 修改快照类型,可以通过该接口将标准快照转换为归档快照。
    ///
    /// <props="china">
    /// **请确保在使用该接口前，已充分了解归档快照产品的收费方式和[价格](https://www.aliyun.com/price/product?#/disk/detail/disk)。**
    /// </props>
    ///
    /// - 归档快照不支持还原为标准快照。
    ///
    /// - 标准快照创建完成之后，必须至少已保留14天，才能进行归档。
    ///
    /// - 共享来的快照、云产品托管的快照、云盒内的快照不支持归档。
    ///
    /// # Error Codes
    /// - `InvalidRetentionDays.Malformed`: The specified RetentionDays is not valid.
    /// - `InvalidOperation.DecreaseRetentionDaysUnsupported`: The requested operation to decrease retention days for the snapshot is not supported.
    /// - `InvalidSnapshotId.NotReady`: The specified snapshot has not completed yet.
    /// - `InvalidOperation.ArchiveSharedSnapshotUnsupported`: The specified shared snapshot is not support archive.
    /// - `InvalidOperation.ArchiveCloudBoxSnapshotUnsupported`: The specified snapshot in CloudBox is not support archive.
    /// - `InvalidStatus.SnapshotUnfinished`: The specified unfinished snapshot is not support archive.
    /// - `InvalidStatus.SnapshotAgeLimit`: The specified snapshot created within 14 days is not support archive.
    /// - `InvalidStatus.SnapshotInArchive`: The specified snapshot is currently being archived.
    /// - `InvalidParameter.SnapshotCategory`: The specified parameter category is invalid.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: The current operation is not supported because the resource is managed by a cloud product. Please contact the relevant cloud product to confirm the reason.
    /// - `InvalidOperation.InstantAccessEnabledUnsupport`: The specified snapshot with legacy Instant Access enabled does not support archive.
    /// - `InvalidOperation.EncryptedSnapshotUnsupport`: Archiving encrypted snapshots is not currently supported.
    /// - `QuotaExceed.ConcurrentArchiveSnapshotQuota`: The number of concurrent archiving tasks associated with the disk of the current snapshot has exceeded the quota limit. Please try again later.
    /// - `InvalidSnapshotId.NotFound`: The specified SnapshotId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_snapshot_category(
        &self,
        req: ModifySnapshotCategory,
    ) -> impl std::future::Future<Output = crate::Result<ModifySnapshotCategoryResponse>> + Send
    {
        self.call(req)
    }

    /// # 复制快照
    ///
    /// 将一份标准快照或加密快照从一个地域复制到另一个地域。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 复制后的新快照不能回滚源快照对应的云盘。
    /// - 不支持复制本地快照。
    ///
    /// # Error Codes
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidRegionId.MalFormed`: The specified RegionId is not valid.
    /// - `InvalidParameter.Arns`: The specified Arns is not valid.
    /// - `InvalidSnapshotId.EncryptedNotSupport`: The specified snapshot  with encrypted does not support copy.
    /// - `InvalidSnapshotId.NotFound`: The specified snapshot is not exists.
    /// - `InvalidSnapshotCategory.NotSupportCopy`: The specified snapshot's category does not support copy.
    /// - `InvalidUser.NotInWhiteList`: The user is not in the white list of copying snapshot.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `InvalidAccountStatus.SnapshotServiceUnavailable`: Snapshot service has not been opened yet.
    /// - `InvalidSnapshotId.NotReady`: The specified snapshot has not completed yet.
    /// - `InvalidOperation.Unauthorized`: The specified operation is unauthorized.
    /// - `InvalidOperation.UnfinishedCrossRegionCopy`: This disk has unfinished cross-region copy snapshots in the target region.
    /// - `InvalidOperation.NotSupportCopyInSameRegion`: Copying snapshot in the same region is not supported.
    /// - `InvalidSnapshotName.Malformed`: The specified SnapshotName is wrongly formed.
    /// - `InvalidDescription.Malformed`: The specified description is wrongly formed.
    /// - `InvalidRetentionDays.Malformed`: The specified RetentionDays is not valid.
    /// - `InvalidRegionId.NotSupportedEncryptedSnapshotCopy`: The specified region not support copy encrypted snapshot.
    /// - `InvalidRegion.NotSupport`: The specified region does not support byok.
    /// - `InvalidRegionId.NotSupportEncryptAlgorithm`: The current region does not support creating encrypted disks with EncryptAlgorithm.
    /// - `InvalidRegionId.NotExists`: Region not exists.
    /// - `InvalidEncryptAlgorithm`: The specified parameter EncryptAlgorithm is not valid.
    /// - `InvalidEncrypted.NotMatchKmsKeyId`: The specified parameter Encrypted must be true when KmsKeyId is not empty.
    /// - `InvalidEncrypted.NotMatchEncryptAlgorithm`: The specified parameter Encrypted must be true when EncryptAlgorithm is not empty.
    /// - `InvalidEncrypted.NotSupportDecrypt`: Encrypted snapshot not support copy to decrypt snapshot.
    /// - `InvalidSnapshotCategory.NotSupportCrossRegionCopy`: The specified snapshot is not support cross region copy.
    /// - `InvalidSnapshotCategory.NotSupportEncryptedCopy`: The specified snapshot is not support encrypted copy.
    /// - `InvalidParameter.KmsNotEnabled`: The specified operation need enable KMS.
    /// - `InvalidParameter.DataEncryptedKeyCreateFailed`: Create kms data encrypted key fail. If you need further assistance, you can contact the KMS Technical Support.
    /// - `InvalidParameter.KMSKeyId.NotFound`: The specified KMSKeyId does not exist.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `InvalidKMSKeyId.NotSymmetric`: The specified parameter KmsKeyId must be symmetric.
    /// - `QuotaExceed.SnapshotQuota`: The quota is insufficient, please contact your channel partner to increase the quota.
    /// - `InvalidOperation.UnfinishedEncryptedSnapshotCopy`: This disk has unfinished encrypted copy snapshots in the target region.
    /// - `InvalidParameterDestinationStorageLocationArn.Unauthorized`: The operation has failed due to lack of permission for the specified "DestinationStorageLocationArn". Please use a resource with appropriate permission for the operation.
    /// - `InvalidParameterDestinationStorageLocationArn.RegionNotMatch`: The region information in the specified parameter "DestinationStorageLocationArn" is inconsistent with "DestinationRegionId". Please use the correct information for the operation.
    /// - `InvalidSnapshot.StorageLocationNotSupported`: The storage location of the current snapshot does not support this operation.
    /// - `InvalidSnapshot.EncryptedNotSupported`: The current operation does not support the use of encrypted snapshots.
    /// - `InvalidParameterDestinationStorageLocationArn.Malformed`: The specified DestinationStorageLocationArn is wrongly formed.
    /// - `OperationDenied.NonCompliantDestinationRegion`: The copy operation to the destination region is not in compliance with regulations.
    /// - `OperationDenied.SnapshotCategoryNotSupportCopy`: The specified category of snapshot not support copy.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.
    /// - `InvalidOperation.Conflict`: Request was denied due to conflict with a previous request, please try again later.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn copy_snapshot(
        &self,
        req: CopySnapshot,
    ) -> impl std::future::Future<Output = crate::Result<CopySnapshotResponse>> + Send {
        self.call(req)
    }

    /// # 删除快照
    ///
    /// 删除一份指定的快照。如果需要取消正在创建的快照，也可以调用该接口删除快照，即取消创建快照任务。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 如果指定的快照ID不存在，请求将被忽略。
    /// - 如果快照已经被用于创建自定义镜像，将不能执行删除操作。您需要先删除已创建的自定义镜像（[DeleteImage](~~25537~~)），才能继续删除快照。
    /// - 如果快照已经被用于创建云盘，且未设置`Force`参数或`Force=false`时，不能直接删除快照。如果您确定要删除快照，请设置`Force=true`进行强制删除，快照被强制删除后对应的云盘将不能执行重新初始化。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The input parameter SnapshotId that is mandatory for processing this request is not supplied.
    /// - `IncorrectDiskStatus.CreatingSnapshot`: A previous snapshot creation is in process.
    /// - `SnapshotCreatedImage`: The snapshot has been used to create user defined image(s).
    /// - `SnapshotCreatedDisk`: The snapshot has been used to create disk(s).
    /// - `Operation.Conflict`: The operation may conflicts with others, please retry later.
    /// - `InvalidOperation.RelatedSnapshotNotFinished`: The related standard snapshot is not finished.
    /// - `InvalidOperation.DeleteSharedSnapshotUnsupported`: The current snapshot shares authorization with other users. Please revoke the shared authorization through resource management first.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: The current operation is not supported because the resource is managed by a cloud product. Please contact the relevant cloud product to confirm the reason.
    /// - `InvalidSnapshotId.NotFound`: The specified snapshot is not found.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_snapshot(
        &self,
        req: DeleteSnapshot,
    ) -> impl std::future::Future<Output = crate::Result<DeleteSnapshotResponse>> + Send {
        self.call(req)
    }

    /// # 查询云盘快照链
    ///
    /// 查询云盘快照链。快照链是一块云盘所有快照组成的关系链，一块云盘对应一条快照链。
    ///
    /// ## 接口说明
    /// 调用该接口时，您需要注意：
    ///
    /// -  请求参数`RegionId`、`DiskIds`和`InstanceId`等充当过滤器功能，参数间是逻辑与关系。  
    ///
    /// -  如果不指定任何参数，则过滤器不起作用。当`DiskIds`和`SnapshotLinkIds`都为空数组时，同样视该过滤器有效，但是返回结果为空。
    ///
    /// # Error Codes
    /// - `InvalidInstanceId.NotFound`: The specified instanceId is not exists.
    /// - `InvalidRegionId`: The specified regionId is invalid.
    /// - `InvalidSnapshotLinkIds`: The specified snapshotLinkIds is invalid.
    /// - `InvalidDiskIds`: The specified diskIds is invalid.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_snapshot_links(
        &self,
        req: DescribeSnapshotLinks,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSnapshotLinksResponse>> + Send
    {
        self.call(req)
    }

    /// # 创建快照一致性组
    ///
    /// 为指定ECS实例中的云盘创建快照一致性组。快照一致性组包含一个或多个云盘对应的快照。
    ///
    /// 您可以设置`InstanceId`为实例内的指定云盘创建快照一致性组；也可以只使用`DiskId.N`为同可用区内多台ECS实例挂载的多块云盘创建快照一致性组。
    ///
    /// > `DiskId.N`不可与`ExcludeDiskId.N`同时设置。此外，如果设置了`InstanceId`，则`DiskId.N`只能设置指定实例内已挂载的云盘，不再支持设置多个跨实例的云盘ID。
    ///
    /// 创建快照一致性组时，请注意：
    ///
    /// - 待创建快照的云盘必须处于**使用中**（`In_use`）或**待挂载**（`Available`）的状态。
    ///
    ///     - 如果云盘处于**使用中**（`In_use`）的状态，则ECS实例状态为**运行中**（`Running`）或者**已停止**（`Stopped`）。
    ///     - 如果云盘处于**待挂载**（`Available`）的状态，则需要保证云盘有过挂载到ECS实例的历史操作。从未挂载过ECS实例的云盘不支持创建快照。
    ///
    /// - 目前快照一致性组只支持ESSD系列云盘（ESSD、ESSD AutoPL、ESSD Entry）。
    /// - 单个快照一致性组最多包括16块云盘（包括系统盘和数据盘），且总容量不超过32 TiB。
    /// - 您自行创建的快照会一直保留，请定期删除不再需要的快照，避免快照容量持续扣费。
    /// - 开启多重挂载特性的云盘不支持创建快照一致性组。如果实例挂载了开启多重挂载特性的云盘，您需要设置`ExcludeDiskId.N`参数排除该云盘。
    ///
    /// 关于快照一致性组的功能、计费等信息，请参见[快照一致性组](~~199625~~)。
    ///
    /// # Error Codes
    /// - `InvalidDiskIds.NotInSameZone`: The specified disks are not in the same availability zone.
    /// - `MissingParamter.InstanceId`: The specified InstanceId should not be null.
    /// - `InvalidParam.ExcludeDiskIdsAndDiskIds.Conflict`: The use of parameter 'ExcludeDiskIds' and 'DiskIds' at the same time is not supported.
    /// - `InvalidSnapshotName.Malformed`: The specified SnapshotName is wrongly formed.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidRetentionDays.Malformed`: The specified RetentionDays is not valid.
    /// - `DiskCategory.OperationNotSupported`: The special disk is encrypted, not support this operate.
    /// - `InvalidParameter.Name`: The specified Name is invalid.
    /// - `InvalidParameter.Description`: The specified Description is invalid.
    /// - `IncorrectDiskStatus.CreatingSnapshot`: A previous snapshot creation is in process.
    /// - `InstanceLockedForSecurity`: The disk attached instance is locked due to security.
    /// - `IncorrectDiskStatus.NeverAttached`: The specified disk has never been attached to any instance.
    /// - `QuotaExceed.Snapshot`: The snapshot quota exceeds.
    /// - `IncorrectDiskStatus.NeverUsed`: The specified disk has never been used after creating.
    /// - `CreateSnapshot.Failed`: The process of creating snapshot is failed.
    /// - `DiskInArrears`: The specified operation is denied as your disk has expired.
    /// - `DiskId.ValueNotSupported`: The specified parameter diskid is not supported.
    /// - `IncorrectDiskStatus`: The current disk status does not support this operation.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `InvalidAccountStatus.SnapshotServiceUnavailable`: Snapshot service has not been opened yet.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `IncorrectVolumeStatus`: The current volume status does not support this operation.
    /// - `IdempotentParameterMismatch`: The specified clientToken is used.
    /// - `IncorrectDiskStatus.Invalid`: The specified device status invalid, restart instance and try again.
    /// - `IncorrectDiskType.NotSupport`: The specified device type is not supported.
    /// - `IncorrectDiskStatus.Transferring`: The specified device is transferring, you can retry after the process is finished.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK needs to be enabled.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `IdempotentProcessing`: The previous idempotent request(s) is still processing.
    /// - `InvalidSnapshotCategory.Malformed`: The specified Category is not valid.
    /// - `InvalidOperation.Unauthorized`: The specified operation is unauthorized.
    /// - `InvalidRegion.NotSupportSnapshotInstantAccessRegion`: The snapshot InstantAccess is not supported for this region.
    /// - `InvalidCategoryAndInstantAccess.Malformed`: The snapshot Category and InstantAccess can't be used together.
    /// - `IncorrectDiskStatus.TooManyCreatingSnapshots`: The specified disk has too many unfinished snapshots.
    /// - `InvalidRegion.NotSupport`: The specified region does not support creating snapshot group.
    /// - `UserNotInTheWhiteList`: The user is not in the white list of creating snapshot group.
    /// - `InvalidInstance.NoDisk`: There is no disk mounted on the instance.
    /// - `NumberExceed.TooManyDisks`: The number of all disks in the request exceeds.
    /// - `CapacityExceed.TooManyDisks`: The capacity of all disks in the request exceeds.
    /// - `InvalidOperation.MultiAttachDisk`: Multi attach disk does not support this operation.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK needs to be added ECS tag.
    /// - `InvalidDisk.DiskCategoryInconsistent`: If any specified disk is of a regional disk category, then all disks must also be of that regional disk category.
    /// - `QuotaExceed.ConcurrentSnapshotQuota`: The number of snapshots being created for the disk %s has exceeded the concurrent quota (%s). Please wait for the previous snapshots to complete before trying again.
    /// - `InvalidDisk.ShareVolume`: The specified diskId is invalid. The shared volume does not support creating a snapshot group.
    /// - `InvalidParameter.UnauthorizedStorageLocationArn`: The operation has failed due to lack of permission for the specified "StorageLocationArn". Please use a resource with appropriate permission for the operation.
    /// - `InvalidDiskId.NotFound`: The specified DiskId does not exist.
    /// - `InvalidDescription.Malformed`: The specified description is wrongly formed.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidVolumeId.NotFound`: The specified volume does not exist.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidKMSKeyId.NotFound`: The KMS key used by the disk does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_snapshot_group(
        &self,
        req: CreateSnapshotGroup,
    ) -> impl std::future::Future<Output = crate::Result<CreateSnapshotGroupResponse>> + Send {
        self.call(req)
    }

    /// # 查询快照一致性组
    ///
    /// 查询一个或多个快照一致性组的信息。例如状态、所属的实例ID、快照创建进度等。
    ///
    /// `InstanceId`、`SnapshotGroupId.N`和`Status.N`不是必需的请求参数，但是可以构建过滤器逻辑，参数之间为逻辑与（And）关系。
    ///
    /// # Error Codes
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidSnapshotGroupId.MustBeOne`: The size of SnapshotGroupIds must be one when AdditionalAttributes has SNAPSHOT_GROUP_PROGRESS_STATUS.
    /// - `InvalidStatus.ValueNotSupported`: The specified parameter status is not valid. The expected status is progressing, accomplished or failed.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidInstanceId.NotFound`: The InstanceId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_snapshot_groups(
        &self,
        req: DescribeSnapshotGroups,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSnapshotGroupsResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改快照一致性组
    ///
    /// 修改快照一致性组的名称与描述信息。
    ///
    /// # Error Codes
    /// - `InvalidParameter.Name`: The specified Name is invalid.
    /// - `InvalidParameter.Description`: The specified Description is invalid.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidSnapshotGroup.NotFound`: The SnapshotGroupId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_snapshot_group(
        &self,
        req: ModifySnapshotGroup,
    ) -> impl std::future::Future<Output = crate::Result<ModifySnapshotGroupResponse>> + Send {
        self.call(req)
    }

    /// # 删除快照一致性组
    ///
    /// 删除快照一致性组。
    ///
    /// 如果快照一致性组中的云盘快照已经用于创建自定义镜像，则快照一致性组删除时相关的云盘快照不会被删除。您如果需要删除相关的云盘快照，请先删除已创建的自定义镜像（[DeleteImage](~~25537~~)），再删除相关的云盘快照（[DeleteSnapshot](~~25525~~)）。
    ///
    /// # Error Codes
    /// - `SnapshotCreatedImage`: The snapshot has been used to create user defined image(s).
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `SnapshotCreatedDisk`: The snapshot that you are trying to delete is in use by one or more Disks.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: The current operation is not supported because the resource is managed by a cloud product. Please contact the relevant cloud product to confirm the reason.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidSnapshotGroup.NotFound`: The SnapshotGroupId provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_snapshot_group(
        &self,
        req: DeleteSnapshotGroup,
    ) -> impl std::future::Future<Output = crate::Result<DeleteSnapshotGroupResponse>> + Send {
        self.call(req)
    }

    /// # 创建自动快照策略
    ///
    /// 在指定地域下创建一条自动快照策略。可以指定自动快照的重复周期、保留时间以及跨地域备份等策略，为系统盘或数据盘创建快照备份数据。
    ///
    /// 调用该接口之前，请认真阅读[创建自动快照策略](~~127767~~)。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// -  一个阿里云账户在一个地域最多能创建100条自动快照策略。 当某块云盘的自动快照数量达到额度上限，系统在创建新的快照任务时，会删除由自动快照策略所生成的时间最早的自动快照点。
    ///
    ///
    /// - 当ECS实例存在停止或者重启任务时，系统不会执行自动快照策略。
    /// - 已启用快照跨地域复制且在未配置加密参数场景下，加密快照默认使用目的端服务密钥进行加密拷贝。跨地域复制快照的注意事项，请参见[复制快照](~~159441~~)。
    ///
    /// 创建自动快照策略后，需要调用[ApplyAutoSnapshotPolicy](~~25531~~)将策略应用到目标云盘。如果您需要调整自动快照策略的内容，请调用[ModifyAutoSnapshotPolicyEx](~~25529~~)。
    ///
    /// # Error Codes
    /// - `DiskCategory.OperationNotSupported`: The type of the specified disk does not support creating a snapshot.
    /// - `InvalidSnapshotPolicyName.Malformed`: The specified autoSnapshotPolicyName is wrongly formed.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidParameter.EncryptedIllegal`: The specified parameter Encrypted must be true when kmsKeyId is not empty.
    /// - `InvalidParameter.KmsNotEnabled`: Failed to perform this operation because KMS is not activated.
    /// - `InvalidParameter.Encrypted.KmsNotEnable`: Failed to perform this operation because KMS is not activated.
    /// - `InvalidParam.EncryptedMismatch`: Creating encrypted disks with shared encrypted image requires replacing encryption keys.
    /// - `ParameterInvalid`: The specified RegionId parameter is invalid.
    /// - `AutoSnapshotPolicy.QuotaExceed`: The maximum number of automatic snapshot policy has been reached.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `InvalidAccountStatus.SnapshotServiceUnavailable`: Snapshot service has not been opened yet.
    /// - `InvalidParameter.TargetCopyRegions`: The specified TargetCopyRegions is invalid.
    /// - `InvalidParameter.CopiedSnapshotsRetentionDays`: The specified CopiedSnapshotsRetentionDays is invalid.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `InvalidOperation.KMSKeyIdNotFound`: The specified KMSKeyId not found, %s.
    /// - `Abs.InvalidAction.RegionNotSupport`: This region does not support this action.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_auto_snapshot_policy(
        &self,
        req: CreateAutoSnapshotPolicy,
    ) -> impl std::future::Future<Output = crate::Result<CreateAutoSnapshotPolicyResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询已创建的自动快照策略
    ///
    /// 本接口用于查询指定地域下已创建的自动快照策略详细信息列表。
    ///
    /// # Error Codes
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidTag.Mismatch`: The specified Tag.n.Key and Tag.n.Value are not match.
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_auto_snapshot_policy_ex(
        &self,
        req: DescribeAutoSnapshotPolicyEx,
    ) -> impl std::future::Future<Output = crate::Result<DescribeAutoSnapshotPolicyExResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询自动快照策略的关联关系
    ///
    /// 查询自动快照策略的关联关系
    ///
    /// # Error Codes
    /// - `MissingParameter.AutoSnapshotPolicyIdOrDiskId`: The AutoSnapshotPolicyId and DiskId parameters cannot both be empty. Please specify one of them.
    /// - `ParameterConflict.AutoSnapshotPolicyIdAndDiskId`: The AutoSnapshotPolicyId and DiskId parameters cannot be specified at the same time. You may specify only one of them.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidAutoSnapshotPolicyId.NotFound`: Specified parameter AutoSnapshotPolicyId not found.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist.///
    /// # Methods
    /// - GET
    /// - POST
    ///
    pub fn describe_auto_snapshot_policy_associations(
        &self,
        req: DescribeAutoSnapshotPolicyAssociations,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeAutoSnapshotPolicyAssociationsResponse>,
    > + Send {
        self.call(req)
    }

    /// # 修改自动快照策略
    ///
    /// 修改一条自动快照策略，例如，快照创建时间点、重复日期、保留时间等。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 不支持修改系统策略。
    /// - 修改自动快照策略后，之前已应用该策略的云盘随即执行修改后的自动快照策略。
    /// - 已启用快照跨地域复制且在未配置加密参数场景下，加密快照默认使用目的端服务密钥进行加密拷贝。
    ///
    /// # Error Codes
    /// - `InvalidParameter.EncryptedIllegal`: The specified parameter Encrypted must be true when kmsKeyId is not empty.
    /// - `InvalidParameter.KmsNotEnabled`: Failed to perform this operation because KMS is not activated.
    /// - `InvalidParameter.Encrypted.KmsNotEnable`: Failed to perform this operation because KMS is not activated.
    /// - `InvalidParam.EncryptedMismatch`: Creating encrypted disks with shared encrypted image requires replacing encryption keys.
    /// - `ParameterInvalid`: The specified RegionId parameter is invalid.
    /// - `InvalidParameter.TargetCopyRegions`: The specified TargetCopyRegions is invalid.
    /// - `InvalidParameter.CopiedSnapshotsRetentionDays`: The specified CopiedSnapshotsRetentionDays is invalid.
    /// - `InvalidParameter.KMSKeyId.KMSUnauthorized`: ECS service have no right to access your KMS.
    /// - `Abs.InvalidAction.RegionNotSupport`: This region does not support this action.
    /// - `InvalidOperation.PolicyTypeUnsupported`: The current policy type does not support this operation. Only custom policies are permitted.
    /// - `InvalidParameter.KMSKeyId.CMKNotEnabled`: The CMK (Customer Master Key) must be in an active state.
    /// - `InvalidParameter.KMSKeyId.CMKUnauthorized`: The CMK(Customer Master Key) lacks authorization to add tags to the ECS service.
    /// - `ParameterInvalid`: The specified automatic snapshot policy does not exist.
    /// - `InvalidParameter.KMSKeyId.NotFound`: The specified KMSKeyId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_auto_snapshot_policy_ex(
        &self,
        req: ModifyAutoSnapshotPolicyEx,
    ) -> impl std::future::Future<Output = crate::Result<ModifyAutoSnapshotPolicyExResponse>> + Send
    {
        self.call(req)
    }

    /// # 为云盘应用自动快照策略
    ///
    /// 为一块或者多块云盘应用自动快照策略。目标云盘已经应用了自动快照策略时，调用ApplyAutoSnapshotPolicy可以更换云盘当前应用的自动快照策略。
    ///
    /// ## 接口说明
    /// 调用该接口时，您需要注意：
    /// -  一块云盘只能应用一条自动快照策略。
    /// -  一条自动快照策略能应用到多块云盘。
    ///
    /// 功能变更：
    ///
    /// 默认单块云盘仅可应用 1 条策略，功能升级后，单块云盘将支持同时应用最多 10 条自动快照策略，满足多场景备份需求。
    ///
    /// 功能升级需要申请白名单，请 [提交工单](https://smartservice.console.aliyun.com/service/create-ticket) 申请。
    ///
    /// 功能升级后，您需要注意：
    /// - 每块云盘支持应用多条自动快照策略，上限为 10 条。
    /// - 若目标云盘已应用自动快照策略，在调用该接口时，将在原有基础上新增，不会更换已有策略。
    /// >请自主取消不需要的自动快照策略，以免产生非预期费用。
    ///
    /// # Error Codes
    /// - `DiskCategory.OperationNotSupported`: The type of the specified disk does not support creating a snapshot.
    /// - `PartofDiskCategory.OperationNotSupported`: The types of some disks in the disk list do not support creating snapshots.
    /// - `InvalidAutoSnapshotPolicyId.NotFound`: The specified AutoSnapshotPolicyId does not exist.
    /// - `ParameterInvalid`: The specified RegionId parameter is invalid.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `InvalidAccountStatus.SnapshotServiceUnavailable`: Snapshot service has not been opened yet.
    /// - `InvalidOperation.SnapshotAlreadyCreatedUnsupported`: The current disk already has snapshots created by non-promotional activities. Snapshot policies bound to promotional activities are not supported.
    /// - `QuotaExceed.AppliedAutoSnapshotPolicyQuota`: The number of auto snapshot policies applied to the specified disk %s has exceeded the quota %s. Please cancel any unused policies and try again.
    /// - `InvalidOperation.AutoSnapshotPolicyConflict`: The disk %s cannot apply the auto snapshot policy of promotional activities and other policies at the same time.
    /// - `ParameterInvalid`: The specified automatic snapshot policy does not exist.
    /// - `InvalidDiskId.NotFound`: The specified disk does not exist in the region.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn apply_auto_snapshot_policy(
        &self,
        req: ApplyAutoSnapshotPolicy,
    ) -> impl std::future::Future<Output = crate::Result<ApplyAutoSnapshotPolicyResponse>> + Send
    {
        self.call(req)
    }

    /// # 取消云盘的自动快照策略
    ///
    /// 取消一块或者多块云盘的自动快照策略。
    ///
    /// # Error Codes
    /// - `ParameterInvalid`: The specified RegionId parameter is invalid.
    /// - `InvalidOperation.SnapshotPolicyHasDeleted`: The snapshot policy associated with the current operation has been deleted. Check whether the parameters are correct.
    /// - `OperationDenied.TooManyAutoSnapshotPolicies`: The specified disk %s has already applied multiple auto snapshot policies. To cancel a policy, please explicitly specify the autoSnapshotPolicyId parameter.
    /// - `InvalidDiskId.NotFound`: The specified DiskIds are not found.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn cancel_auto_snapshot_policy(
        &self,
        req: CancelAutoSnapshotPolicy,
    ) -> impl std::future::Future<Output = crate::Result<CancelAutoSnapshotPolicyResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除自动快照策略
    ///
    /// 删除一条自动快照策略。如果目标自动快照策略已经被应用到磁盘上，删除自动快照策略后，这些磁盘不再执行该策略。
    ///
    /// # Error Codes
    /// - `ParameterInvalid`: The specified automatic snapshot policy does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_auto_snapshot_policy(
        &self,
        req: DeleteAutoSnapshotPolicy,
    ) -> impl std::future::Future<Output = crate::Result<DeleteAutoSnapshotPolicyResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询某地域下已购买对象存储OSS存储包
    ///
    /// 调用DescribeSnapshotPackage查询您在一个阿里云地域下已经购买的OSS存储包。存储包可以用于抵扣标准快照存储容量，但不支持抵扣本地快照。
    ///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_snapshot_package(
        &self,
        req: DescribeSnapshotPackage,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSnapshotPackageResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询不同实例规格公网带宽上限
    ///
    /// 调用DescribeBandwidthLimitation查询不同实例规格可以购买、升级或降配的公网带宽上限。
    ///
    /// # Error Codes
    /// - `Invalid.InstanceChargeType`: The specified InstanceChargeType is not valid.
    /// - `InvalidParam`: The input parameter DestinationResource that is mandatory for processing this request is not supplied.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType beyond the permitted range.
    /// - `InvalidInstanceId.NotFound`: The specified ecs instance not found.
    /// - `Invalid.ResourceType.NotFound`: The ResourceType provided does not exist in our records.
    /// - `Invalid.NetworkCategory`: The specified NetworkCategory is not valid.
    /// - `Invalid.SpotStrategy`: The specified SpotStrategy is not valid.
    /// - `Invalid.IoOptimized`: The specified IoOptimized is not valid.
    /// - `Invalid.ResourceId`: The specified ResourceId is not valid.
    /// - `Invalid.InstancePayType`: The specified InstancePayType is not valid.
    /// - `Invalid.OperationType`: The specified OperationType is not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_bandwidth_limitation(
        &self,
        req: DescribeBandwidthLimitation,
    ) -> impl std::future::Future<Output = crate::Result<DescribeBandwidthLimitationResponse>> + Send
    {
        self.call(req)
    }

    /// # 调整ECS实例带宽或分配公网IP
    ///
    /// 修改ECS实例的带宽配置、分配公网IP、转换网络计费方式，支持升配和降配。
    ///
    /// -  修改包年包月（PrePaid）实例的带宽配置时，公网出带宽（InternetMaxBandwidthOut）从0 Mbit/s升级到一个非零值时会自动分配一个公网IP。
    ///
    /// -  修改按量付费（PostPaid）实例的带宽配置时，公网出带宽（InternetMaxBandwidthOut）从0 Mbit/s升级到一个非零值时不会自动分配公网IP。您需要指定参数`AllocatePublicIp`为`true`分配公网IP。
    /// -  对于经典网络（Classic）类型实例，当公网出带宽（InternetMaxBandwidthOut）从0 Mbit/s升级到一个非零值时，实例必须处于已停止（Stopped）状态。
    ///
    /// > 单个地域下，单个阿里云账号按固定带宽计费的公网带宽峰值总和存在限制，请参见[公网带宽限制](~~25412#BandwidthQuota~~)。
    ///   
    /// - 费用：
    ///   
    ///   - 升级带宽后，默认自动扣费。您需要确保支付方式余额充足，否则会生成异常订单，此时只能作废订单。如果您的账户余额不足，可以将参数AutoPay置为false，此时会生成正常的未支付订单，您可以登录ECS管理控制台支付。
    ///
    ///   - 降低带宽后，价格差退款将原路退还，已使用的代金券不退回。
    ///
    /// # Error Codes
    /// - `InvalidInternetMaxBandwidthIn.ValueNotSupported`: The specified InternetMaxBandwidthIn is beyond the permitted range.
    /// - `InvalidInternetMaxBandwidthOut.ValueNotSupported`: The specified InternetMaxBandwidthOut is beyond the permitted range.
    /// - `OperationDenied`: Specified instance is in VPC.
    /// - `InvalidParameter.Conflict`: %s
    /// - `InvalidStartTime.ValueNotSupported`: The specified StartTime is out of the permitted range.
    /// - `InvalidEndTime.ValueNotSupported`: The specified EndTime is out of the permitted range.
    /// - `ChargeTypeViolation`: The operation is not permitted due to billing method of the instance.
    /// - `Account.Arrearage`: Your account has an outstanding payment.
    /// - `InvalidInternetChargeType.ValueNotSupported`: The specified InternetChargeType is invalid.
    /// - `DecreasedBandwidthNotAllowed`: %s
    /// - `BandwidthUpgradeDenied.EipBoundInstance`: The specified VPC instance has bound EIP, temporary bandwidth upgrade is denied.
    /// - `InvalidClientToken.ValueNotSupported`: The ClientToken provided is invalid.
    /// - `Throttling`: Request was denied due to request throttling, please try again after 5 minutes.
    /// - `InvalidInstanceStatus.NotStopped`: The specified Instance status is not Stopped.
    /// - `InvalidAction`: Specified action is not valid.
    /// - `IpAllocationError`: Allocate public ip failed.
    /// - `InvalidParam.AllocatePublicIp`: The specified param AllocatePublicIp is invalid.
    /// - `InstanceDowngrade.QuotaExceed`: Quota of instance downgrade is exceed.
    /// - `InvalidBandwidth.ValueNotSupported`: Instance upgrade bandwidth of temporary not allow less then existed.
    /// - `InvalidInstanceStatus`: The specified instance status does not support this action.
    /// - `InvalidInstance.UnPaidOrder`: Unpaid order exists in your account, please complete or cancel the payment in the expense center.
    /// - `LastOrderProcessing`: The previous order is still processing, please try again later.
    /// - `LastRequestProcessing`: The previous request is still processing, please try again later.
    /// - `InvalidStartTime.BeyondLifeCycle`: The specified start time exceeds the expiration time.
    /// - `InvalidEndTime.BeyondLifeCycle`: The specified end time exceeds the expiration time.
    /// - `InvalidPayMethod.SyncPaymentNotSupport`: Synchronous payment is not supported. Use another payment method.
    /// - `InvalidBandwidthOut.LessThanZero`: The bandwidth must be larger than 0 when specifying isp.
    /// - `InvalidParameter.BandwidthBiggerThanBaseBandwidth`: %s
    /// - `InvalidAction.WithActiveElasticUpgrade`: The instance has active Elastic Upgrade.
    /// - `InvalidParameter.CloudboxNotSupported`: %s
    /// - `InvalidParameter.Bandwidth`: %s
    /// - `NoPermission.Price`: The operation requires price permission. Please either apply for permission from your main account, or set the parameter AutoPay as true.
    /// - `NoPermission.Refund`: The operation requires refund permission. Please apply for permission from your main account.
    /// - `InvalidParameter.DedicatedRegionNotSupported`: The specified action is rejected  because the specified ECS instance in the dedicated region does not support public IP.
    /// - `InvalidOperation.InstanceStatusUnsupported`: The specified instance status is not supported for this operation, expect status is Running or Stopped.
    /// - `QuotaExceeded.InternetBandwidth`: %s.
    /// - `UnsupportedIspNetworkChargeType`: The network charge type is not supported when specifying ISP.
    /// - `IncorrectInstanceStatus`: Current instance status does not support this operation.
    /// - `TaskConflict`: The operation is too frequent, please wait a moment and try again.
    /// - `InvalidOperation.InternetMaxBandwidthOutUnsupported`: The InternetMaxBandwidthOut is not allowed to modify.
    /// - `IncorrectInstanceStatus`: The current status of the instance does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `ChargeTypeViolation`: The operation is not permitted due to billing method of the instance.
    /// - `OperationDenied`: The operation is denied due to the instance is PrePaid.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `InvalidInstance.UnPaidOrder`: The specified Instance has unpaid order.
    /// - `Throttling`: Request was denied due to request throttling, please try again after 5 minutes.
    /// - `InvalidInstance.InstanceNotSupported`: The special vpc instance with eip not need bandwidth.
    /// - `InstanceDowngrade.QuotaExceed`: Quota of instance downgrade is exceed.
    /// - `InvalidInstanceStatus`: The current status of the instance does not support this operation.
    /// - `InvalidOperation.StarterPackage`: StarterPackage not support modification.
    /// - `NAT_PUBLIC_IP_BINDING_FAILED`: Binding nat public ip failed.
    /// - `InvalidInstance.EipNotSupport`: The specified instance with eip is not supported, please unassociate eip first.
    /// - `InvalidInstance.NatPortMapNotSupport`: The special instance with nat port map not support operate, please remove nat port map first.
    /// - `OperationDenied.UnpaidOrder`: The specified instance has unpaid order.
    /// - `Mayi.InternalError`: The request processing has failed due to some unknown error.
    /// - `InvalidNetworkType.ValueNotSupported`: The specified parameter NetworkType is not valid.
    /// - `OperationDenied.ImageNotValid`: The specified image is not authorized.
    /// - `InvalidInstanceChargeType.ValueNotSupported`: The specified parameter ChargeType is not valid.
    /// - `InvalidIspType.ValueNotSupported`: %s
    /// - `UnsupportedIspChargeType`: %s
    /// - `UnsupportedIspClassicNetwork`: %s
    /// - `InvalidIspBandwidthOut`: %s
    /// - `UnsupportedChangeIsp`: %s
    /// - `InvalidIspUID`: %s
    /// - `UnsupportedIspRegion`: %s
    /// - `BandIncreaseNotSupportIsp`: %s
    /// - `SecurityRisk.3DVerification`: We have detected a security risk with your default credit or debit card. Please proceed with verification via the link in your email.
    /// - `InvalidOperation.PublicIpAddressNoStock`: The public IP address for the specified Region or ChargeType of the instance is out of stock. Please try another Region or ChargeType.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `Image.OrderFailed`: Create marketplace image order failed.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_network_spec(
        &self,
        req: ModifyInstanceNetworkSpec,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceNetworkSpecResponse>> + Send
    {
        self.call(req)
    }

    /// # 分配公网IP
    ///
    /// 为一台ECS实例分配一个公网IP地址。推荐您使用接口ModifyInstanceNetworkSpec分配公网IP。
    ///
    /// ### 使用须知
    /// - 分配公网IP地址之前，实例必须处于**运行中**（`Running`）或者**已停止**（`Stopped`）状态。  
    ///
    /// - 被[安全控制](~~25695~~)的实例的`OperationLocks`中标记了`"LockReason" : "security"`时，不能分配公网IP地址。
    ///
    /// - 调用该接口时请确保实例带宽大于0，您可以调用[ModifyInstanceNetworkSpec](~~2679879~~)接口调整带宽。
    ///
    /// ### 注意事项
    ///
    /// - 仅白名单用户支持指定公网IP参数`IpAddress`，若公网带宽大于0，您可以设置`InstanceId`进行随机分配；若公网带宽为0，您需要调用[ModifyInstanceNetworkSpec](~~2679879~~)调整带宽之后再通过该接口分配。
    ///
    /// - 一台实例只能分配一个公网IP地址。如果实例已经拥有一个公网IP地址，将返回已绑定的公网 IP 地址`IpAddress`。
    ///
    /// - 重启实例（[RebootInstance](~~25502~~)）或者启动实例（[StartInstance](~~25500~~)）后，新的公网IP地址生效。  
    ///
    /// 除分配公网IP之外，您还可以给VPC类型ECS实例绑定弹性公网IP（EIP）。更多信息，请参见[AssociateEipAddress](~~2518064~~)。
    ///
    /// # Error Codes
    /// - `InvalidOperation.AllocateFailed`: The current instance failed to allocate public IP, please try again later.
    /// - `InvalidIpAddress.Malformed`: The specified parameter "IpAddress" is not valid.
    /// - `OperationDenied`: Specified operation is denied as your instance is in VPC.
    /// - `InsufficientPublicIp`: Ip address not found.
    /// - `AllocateIpInvalidInstanceBandwidth`: OperationDenied The InternetMaxBandwidthOut of the specified instance cannot be less than 0.
    /// - `OperationDenied.CloudboxNotSupport`: This operation is denied, because the specified ECS instance which is in the Cloudbox dose not support PublicIp or Eip.
    /// - `OperationDenied.DedicatedRegionNotSupported`: This operation is denied, because the specified ECS instance which is in the dedicated region dose not support PublicIp or Eip.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `IpInUse`: The specified IP is already in use.
    /// - `AllocatedAlready`: There is an IpAddress allocated already for the specified instance.
    /// - `AllocateIp.Fail`: The specified instance fails to allocate ip, please try again.
    /// - `NAT_PUBLIC_IP_BINDING_FAILED`: Binding nat public ip failed.
    /// - `NAT_PUBLIC_IP_ALLOCATE_FAILED`: Nat public ip binding failed.
    /// - `InvalidIpAddress.NotPublic`: The specified IP is not public address.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidVlanId.NotFound`: The VlanId provided does not exist in our records.
    /// - `InvalidIpAddress.NotFound`: The specified IP is not in the specified vlan.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn allocate_public_ip_address(
        &self,
        req: AllocatePublicIpAddress,
    ) -> impl std::future::Future<Output = crate::Result<AllocatePublicIpAddressResponse>> + Send
    {
        self.call(req)
    }

    /// # 将公网IP地址转化为弹性公网IP
    ///
    /// 将一台专有网络VPC类型ECS实例的公网IP地址（PublicIP）转化为弹性公网IP（EIP）。
    ///
    /// ## 接口说明
    ///
    /// 公网IP地址转换为EIP后，EIP将单独计费。请确保您已充分了解[EIP的计费方式](~~122035~~)。
    ///
    /// 调用该接口时，ECS实例必须满足以下条件：
    ///
    /// - 状态为**已停止**（`Stopped`）或者**运行中**（`Running`）。
    /// - 没有绑定EIP。
    /// - 没有未生效的变更配置任务。
    ///
    /// - 公网带宽不能为0 Mbit/s。
    ///
    /// - 包年包月实例的公网带宽计费方式必须为`按使用流量`计费，而`按固定带宽`计费方式的公网IP不支持转化为弹性公网IP。按量付费实例则不受该规则影响。更多信息，请参见[转换公网带宽计费方式](~~178883~~)。
    ///
    /// - 专有网络VPC类型的包年包月ECS实例24小时内不会到期。
    ///
    /// # Error Codes
    /// - `OperationDenied.CloudboxNotSupport`: This operation is denied, because the specified ECS instance which is in the Cloudbox dose not support PublicIp or Eip.
    /// - `InvalidParameter.CloudboxNotSupported`: %s
    /// - `OperationDenied.DedicatedRegionNotSupported`: This operation is denied, because the specified ECS instance which is in the dedicated region dose not support PublicIp or Eip.
    /// - `InvalidInstanceId.PlanedChange`: %s
    /// - `InvalidEndTime.OperateNotSupport`: %s
    /// - `InvalidInstanceStatus.Released`: %s
    /// - `IncorrectInstanceStatus`: %s
    /// - `OperationDenied`: %s
    /// - `InvalidInstance.ZeroBandwidth`: %s
    /// - `InvalidInternetChargeType.ValueNotSupported`: %s
    /// - `InvalidInstanceId.NotFound`: %s
    /// - `MaxEIPQuotaExceeded`: The number of EIP exceeds the limit per region.
    /// - `Forbidden.InvalidPublicBandwidth`: The specified instance public bandwidth is less than 1M.
    /// - `InvalidInstance.OverduePayment`: The special instance due to overdue payment,this operation is not supported.
    /// - `EIPMaxBandwidthExceeded`: The bandwidth of instance exceeds the limitation of EIP in this region.
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `Forbidden.RiskControl`: This operation is forbidden by Aliyun RiskControl system.
    /// - `UnsupportedPublicIpWithIsp`: %s
    /// - `InvalidInstanceId.NotFound`: %s
    /// - `InvalidInstance.IpAddressMissing`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn convert_nat_public_ip_to_eip(
        &self,
        req: ConvertNatPublicIpToEip,
    ) -> impl std::future::Future<Output = crate::Result<ConvertNatPublicIpToEipResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改实例的VPC属性
    ///
    /// 修改一台专有网络类型ECS实例的专有网络VPC、私网IP地址、安全组或交换机。
    ///
    /// 调用接口时，ECS实例的状态必须是**已停止**（`Stopped`）。
    ///
    /// - 修改实例的私网IP地址或交换机时，请注意：
    ///
    ///     - 新建的ECS实例必须经过重启才能调用该接口。
    ///     - 成功修改一次后，ECS实例必须经过重启才能继续调用该接口进行修改。
    ///
    /// - 修改实例的专有网络VPC时，请注意：
    ///
    ///     - **实例：**
    ///         - 实例状态：不能为已锁定、等待释放、已过期、过期回收中、欠费回收中。更多信息，请参见[实例生命周期介绍](~~25380~~)。
    ///         - 不支持已关联负载均衡实例的ECS实例。
    ///         - 实例不能在其它云服务中被使用。例如，实例不能在迁移中、不能已在更换VPC或实例内部署的数据库不能被DTS服务管理等。
    ///    
    ///     - **网络：**
    ///         - 不支持配置了EIP网卡可见模式或多EIP网卡可见模式的实例。
    ///         - 不支持绑定了高可用虚拟IP（HaVip）的实例。
    ///         - 不支持交换机绑定了自定义路由表的实例。
    ///         - 不支持开通了全球加速（GA）的实例。
    ///         - 不支持绑定辅助弹性网卡的实例。
    ///         - 不支持已分配IPv6地址的实例。
    ///         - 不支持主网卡有多IP的实例。
    ///         - 传入的交换机必须属于目标VPC。
    ///         - 修改前后交换机可用区必须一致。
    ///         - 如果指定主网卡私网IP，则IP必须在交换机地址段内且可用。如果不指定则随机分配，且目标交换机的可用IP数充足。
    ///         -  如果您使用的是其他账号共享给您的VPC，那么您需要确保目标安全组是由您的账号在该共享VPC中创建的，而不是由VPC所有者的账号创建的安全组。
    ///
    /// # Error Codes
    /// - `InvalidTarget.TrafficMirrorSession`: Instance is target of traffic mirror session.
    /// - `InvalidSource.TrafficMirrorSession`: Instance is source of traffic mirror session.
    /// - `InvalidPrivateIpAddress.Malformed`: Specified private IP address is malformed.
    /// - `InvalidPrivateIpAddress.Duplicated`: Specified private IP address is duplicated.
    /// - `IncorrectVSwitchStatus`: The current status of virtual switch does not support this operation.
    /// - `IncorrectInstanceStatus`: The current status of instance does not support this operation.
    /// - `OperationDenied`: Specified operation is denied as your instance is not in VPC.
    /// - `InvalidVSwitchId.Mismatch`: Specified instance and virtual switch are not in the same zone.
    /// - `InvalidPrivateIpAddress.Mismatch`: Specified private IP address is not in the CIDR block of virtual switch.
    /// - `InvalidPrivateIp.Changing`: Previous action is not finished yet.
    /// - `PrimaryEniHasSubIp`: Primary network interface of the specified instance has more than one private ip.
    /// - `VSwitchIdNotMatch`: The subnet of private ip is different to the instance, please unbind ha vip.
    /// - `InvalidOperation.EniCountExceeded`: The number of ENIs in an enterprise security group has reached the maximum limit.
    /// - `InvalidParameter.SecurityGroupId`: Security group ids are invalid.
    /// - `InvalidOperation.SecurityGroupNotAuthorized`: The specified security group is not authorized to operate.
    /// - `OperationDenied`: The Specified operation is denied as your instance is locked for security reasons.
    /// - `InvalidIp.Ipv6Assigned`: The specified instance has been assigned IPv6 address.
    /// - `SecurityGroupInstanceLimitExceed`: %s
    /// - `InvalidInstance.HasTransitionRecord`: The operation is denied because the specified instance has a migration plan.
    /// - `InvalidInstanceStatus.NotNormal`: The Specified operation is denied due to instance status.
    /// - `InvalidVpcId.SharedVpc`: The Specified operation is denied as your targe vpc is SharedVpc.
    /// - `InvalidOperation.NotAllowed`: The operation is denied because the specified VPC has advanced features enabled.
    /// - `InvalidParameter.ToSecurityGroupId`: %s
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidOperation.VswAndEcsAvailabilityZoneMismatch`: Specified instance and virtual switch are not in the same zone.
    /// - `InvalidOperation.CloudBoxEcsNotSupport`: Cloud box ecs instance does not support modifying VPC.
    /// - `AclLimitExceed`: %s
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidVSwitchId.NotFound`: Specified virtual switch does not exist.
    /// - `NoSuchResource`: The specified resource is not found.
    /// - `InvalidParameter.InvalidInstanceId`: The specified InstanceId does not exist.
    /// - `InvalidParameter.VSwitchId`: The specified virtual vswitch does not exist.
    /// - `InvalidRegion.ValueNotSupported`: The specified Region does not exist.
    /// - `InvalidInstance.AttachedEni`: The Specified operation is denied due to elastic network interface.
    /// - `InvalidIp.MultiPrimaryIp`: The Specified operation is denied due to multi private ip.
    /// - `InvalidIp.Ipv6`: The Specified operation is denied due to ipv6.
    /// - `InvalidVSwitch.NotBelongToVpc`: %s
    /// - `InvalidParameter.EniNo`: %s
    /// - `InvalidSecurityGroupId.NotFound`: %s
    /// - `InvalidParameter.SecurityGroupIdRepeated`: %s
    /// - `InvalidSecurityGroupType.NotSupportClassic`: The specified SecurityGroupIds have classic group type.
    /// - `InvalidSecurityGroupVpc.NotBelongToOneVpc`: The specified SecurityGroupIds are belong to different vpc.
    /// - `EnterpriseGroupLimited.MutliGroupType`: The specified instance can not join multi SecurityGroup types.
    /// - `InvalidParameter.AlreadyInTargetVpc`: The specified instance is already in the destination VPC.
    /// - `InvalidParameter.SecurityGroupId`: The specified SecurityGroupId.N is invalid or does not exist.
    /// - `JoinedGroupLimitExceed`: The specified instance has exceed quota of SecurityGroup.
    /// - `InvalidParameter.MustBeEmpty`: The specified parameter SecurityGroupId.N and VpcId need be empty.
    /// - `InvalidParameter.NotEnoughIpInVSwitch`: The specified virtual switch has not enough available ip.
    /// - `InvalidDependence.MutliDirectlyEip`: The Specified operation is denied due to multi directly Eips.
    /// - `InvalidDependence.HaVip`: The Specified operation is denied due to  HaVip.
    /// - `InvalidDependence.NextHopOfCustomRouter`: The Specified operation is denied due to next hop of Custom Router.
    /// - `InvalidDependence.BeenUsedAsAppServer`: The Specified operation is denied due to AppServer.
    /// - `InvalidDependence.GrantAccess`: The Specified operation is denied due to grant access.
    /// - `InvalidDependence.BindGA`: The Specified operation is denied due to GA.
    /// - `InvalidDependence.SLB`: The Specified operation is denied as your instance with alb or clb.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_vpc_attribute(
        &self,
        req: ModifyInstanceVpcAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceVpcAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询建立了连接的经典网络类型实例
    ///
    /// 查询一台或多台与专有网络VPC建立了连接的经典网络类型实例。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// -  该接口仅支持经典网络类型实例。
    /// -  单次最多只能查询100台经典网络类型实例。
    /// -  参数`VpcId`和`InstanceId`不能同时为空。
    ///
    /// # Error Codes
    /// - `InvalidInstanceId.NotFound`: The InstanceId provided does not exist in our records.
    /// - `InvalidParameter.ToManyInstanceIds`: No more than 100 InstanceIds can be specified.
    /// - `InvalidParameter.InvalidInstanceIdAndVpcId`: The parameter InstanceId and VpcId are not allowed to be empty at the same time.
    /// - `InvalidInstanceId.NotBelong`: The specified instance is not belong to you.
    /// - `InvalidVpc.NotBelong`: The specified vpc is not belong to you.
    /// - `InvalidParameter.PageNumber`: The parameter pageNumber is invalid.
    /// - `InvalidParameter.PageSize`: The parameter pageSize is invalid.
    /// - `InvalidRegionId.NotFound`: The specified region does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_classic_link_instances(
        &self,
        req: DescribeClassicLinkInstances,
    ) -> impl std::future::Future<Output = crate::Result<DescribeClassicLinkInstancesResponse>> + Send
    {
        self.call(req)
    }

    /// # 将经典网络类型实例连接到专有网络VPC
    ///
    /// 调用AttachClassicLinkVpc将一台经典网络类型实例连接到专有网络VPC中，使经典网络类型实例可以和VPC中的云资源私网互通。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// -  连接经典网络类型实例前，实例必须处于**运行中**（Running）或者**已停止**（Stopped）状态。
    /// -  目标VPC必须已开启ClassicLink功能。具体操作，请参见[开启ClassicLink功能](~~65413~~)。
    /// -  经典网络类型实例和VPC必须在同一个阿里云地域。
    ///
    /// # Error Codes
    /// - `InvalidInstanceId.NotFound`: The InstanceId provided does not exist in our records.
    /// - `InvalidRegionId.Malformed`: The specified parameter ?RegionId? is not valid.
    /// - `InvalidVpcId.Malformed`: The specified parameter ?VpcId? is not valid.
    /// - `InvalidInstanceId.MalFormed`: The specified instance is not a classic network instance.
    /// - `OperationDenied`: The instance does not allow link to vpc.
    /// - `InvalidParameter.InvalidInstanceIdAndVpcId`: The parameter InstanceId and VpcId are not allowed to be empty at the same time.
    /// - `InvalidStatus.InstanceStatus`: The specified instance status is not support this operation ,expect status is running or shutted.
    /// - `InvalidInstanceId.NotBelong`: The specified instance is not belong to you.
    /// - `QuotaExceeded`: The link quota exceeded in this vpc.
    /// - `InvalidStatus.InstanceLocked`: The specified instance is locked,please wait more.
    /// - `InvalidInstanceId.LimitedRegion`: The specified instance does not support this operation due to the limitation of its region.
    /// - `Forbidden.SubUser`: User not authorized to operate on the specified resource.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn attach_classic_link_vpc(
        &self,
        req: AttachClassicLinkVpc,
    ) -> impl std::future::Future<Output = crate::Result<AttachClassicLinkVpcResponse>> + Send {
        self.call(req)
    }

    /// # 取消经典网络类型实例与VPC的连接
    ///
    /// 调用DetachClassicLinkVpc取消一台经典网络类型ECS实例与专有网络VPC的连接（ClassicLink）。取消ClassicLink后，经典网络类型实例无法与VPC内的实例互通。
    ///
    /// # Error Codes
    /// - `InvalidInstanceId.NotFound`: The InstanceId provided does not exist in our records.
    /// - `InvalidRegionId.Malformed`: The specified parameter ?RegionId? is not valid.
    /// - `InvalidVpcId.Malformed`: The specified parameter ?VpcId? is not valid.
    /// - `InvalidInstanceId.MalFormed`: The specified instance is not a classic network instance.
    /// - `OperationDenied`: The instances are not allowed to detach from the linked vpc.
    /// - `InvalidParameter.InvalidInstanceIdAndVpcId`: The parameter InstanceId and VpcId are not allowed to be empty at the same time.
    /// - `InvalidStatus.InstanceStatus`: The specified instance status is not support this operation ,expect status is running or shutted.
    /// - `InvalidInstanceId.NotBelong`: The specified instance is not belong to you.
    /// - `Forbidden.SubUser`: User not authorized to operate on the specified resource.
    /// - `InvalidOperation.InvalidVpc`: The specified instance not link specify vpc.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidParameter.RegionIdAndInstanceId`: The specified instance does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn detach_classic_link_vpc(
        &self,
        req: DetachClassicLinkVpc,
    ) -> impl std::future::Future<Output = crate::Result<DetachClassicLinkVpcResponse>> + Send {
        self.call(req)
    }

    /// # 创建弹性网卡
    ///
    /// 创建一张弹性网卡（ENI），支持指定主私网IP地址。
    ///
    /// 调用该接口时，请注意：
    /// - 该接口为同步接口，新创建的弹性网卡为可用（`Available`）状态，可以直接进行附加操作。
    /// - 若创建接口返回结果中`NetworkInterfaceId`为空，请再次尝试创建弹性网卡。
    /// - 一张弹性网卡只能附加到一台专有网络的实例。
    /// - 弹性网卡重新附加到另一台实例时，其属性不变，网络流量也会重定向到新的实例。
    /// - 创建弹性网卡时，调用该接口最多可以分配49个辅助私网IP地址。
    /// - 创建弹性网卡时，如果您需要设置IPv6地址，则需要确保指定的交换机开通了IPv6。更多信息，请参见[什么是IPv6网关](~~98896~~)。
    /// - 一个账号在一个阿里云地域内创建弹性网卡有数量限制。可在ECS管理控制台查看资源配额。具体操作，请参见[查看和提升资源配额](~~184115~~)。
    ///
    /// ### 请求示例
    /// <details>
    /// <summary>创建一张弹性网卡</summary>
    ///
    /// ```ignore
    /// RegionId:  cn-hangzhou,   //设置华东 1（杭州）地域。
    /// SecurityGroupId:  sg-bp10jztp6b0sdsyl****,   //设置安全组 ID。
    /// VSwitchId:  vsw-bp19wo63nleroq22g****,   //设置虚拟交换机 ID。
    /// ```
    /// </details>
    ///
    /// <details>
    /// <summary>创建一张弹性网卡，并指定主私网IP地址</summary>
    ///
    /// ```ignore
    /// RegionId:  cn-hangzhou,   //华东 1（杭州）地域。
    /// SecurityGroupId:  sg-bp10jztp6b0sdsyl****,   //安全组 ID。
    /// VSwitchId:  vsw-bp19wo63nleroq22g****,   //虚拟交换机 ID。
    /// PrimaryIpAddress:  192.168.0.*,   //主私网IP地址。
    /// ```
    /// </details>
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidOperation.InvalidEcsState`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidOperation.DetachPrimaryEniNotAllowed`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `JoinedGroupLimitExceed`: %s
    /// - `InvalidParameter.SecurityGroupIdRepeated`: %s
    /// - `InvalidSecurityGroupId.SingleIdAndMultiIdConflict`: %s
    /// - `InvalidParameter.Conflict`: %s
    /// - `InvalidConnectionTrackingConfiguration.RegionOrUserNotSupported`: The specified parameter ConnectionTrackingConfiguration is not supported in this region, or this account is not in the whitelist of using network interface ConnectionTrackingConfiguration.
    /// - `InvalidOperation.EniCountExceeded`: %s.
    /// - `InvalidPrivateIpAddress.Duplicated`: The specified private IP address "%s" is duplicated.
    /// - `IncorrectVSwitchStatus`: The operation is not allowed in the current VSwitch state. Expecting state includes "Created Available", but current state is "%s".
    /// - `InvalidEniQueueSize.RegionOrUserNotSupported`: The specified parameter "RxQueueSize" or "TxQueueSize" is not supported in this region or this account is not allowed to use ENI QueueSize.
    /// - `InvalidParameter.EniQueueSize`: The specified parameter "TxQueueSize" and "RxQueueSize" are not equal or the value must be 8192 or 16384.
    /// - `InvalidParameter.EniConnectionTrackingConfiguration`: The specified ENI connection tracking configuration "%s" must be between %s and %s.
    /// - `QuotaExceeded.PrivateIpAddress`: There are not enough private IPs in the specified VSwitch.
    /// - `Throttling`: Request was denied due to request throttling.
    /// - `InvalidVSwitch.IllegalStatus`: The operation is not allowed in the current VSwitch state. Expecting state includes "Created", but current state is "%s".
    /// - `InvalidParameter.EniEnhancedNetwork`: The input parameter "EnhancedNetwork" is illegal, when EnableSriov is true, VirtualFunctionTotalQueueNumber must not be empty, and VirtualFunctionQuantity must be 1 to 256. When EnableSriov is empty or false, VirtualFunctionTotalQueueNumber and VirtualFunctionQuantity must be empty.
    /// - `InvalidOperation.SecurityGroupNotAuthorized`: The specified security group is not authorized to operate.
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `InValidParameter`: %s
    /// - `MaxEniCountExceeded`: %s
    /// - `EniPerInstanceLimitExceeded`: %s
    /// - `InvalidOperation.AvailabilityZoneMismatch`: %s
    /// - `InvalidOperation.VpcMismatch`: %s
    /// - `SecurityGroupInstanceLimitExceed`: %s
    /// - `InvalidSecurityGroupId.NotVpc`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `InvalidVSwitchId.IpNotEnough`: %s
    /// - `InvalidVSwitchId.IpInvalid`: %s
    /// - `QuotaExceed.Tags`: %s
    /// - `InvalidIp.Address`: %s
    /// - `InvalidIp.IpRepeated`: %s
    /// - `MaxEniPrivateIpsCountExceeded`: %s
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidOperation.TrunkingIsNotAllowed`: %s
    /// - `InvalidParameter.InvalidEniQueueNumber`: %s
    /// - `InvalidOperation.MaxEniQueueNumberExceeded`: %s
    /// - `InvalidOperation.ExceedInstanceTypeQueueNumber`: %s
    /// - `InvalidParameter.EniTrafficMode`: %s
    /// - `InvalidOperation.HighPerformanceTrafficModeIsNotAllowed`: %s
    /// - `InvalidParameter.QueuePairNumberMustEmpty`: %s
    /// - `InvalidParameter.InvalidQueuePairNumber`: %s
    /// - `InvalidParams.NetworkInterfaceName`: %s
    /// - `InvalidIp.IpPrefixIllegal`: The ip prefixes %s is/are illegal.
    /// - `InvalidIp.IpPrefixMustInReserveSegment`: The ip prefix must in vswitch reserve segment.
    /// - `InvalidOperation.Ipv4CountExceeded`: %s
    /// - `InvalidOperation.Ipv6CountExceeded`: %s
    /// - `InvalidOperation.HighPerformanceTrafficModeEniUnsupported`: High performance traffic mode does not support the current ENI type. Expected ENI type is "%s" but the current ENI type is "%s".
    /// - `AclLimitExceed`: %s
    /// - `InvalidIp.IpPrefixMaskInvalid`: The IP prefix mask %s is illegal which must be between %s and %s.
    /// - `InvalidVSwitchId.IpPrefixNotEnough`: The specified VSwitch does not have enough IP prefixes.
    /// - `InvalidIp.IpPrefixMaskNotSame`: The IP prefixes %s are illegal.The IP prefix mask must be the same.
    /// - `EnterpriseGroupLimited.MutliGroupType`: The specified instance can't associate security group of different types.
    /// - `InvalidOperation.BoundingEniSlaveQuotaExceed`: The number of Slave ENIs exceeds the limit of Bond ENI.
    /// - `InvalidIp.IpPrefixNotAvailable`: The IP prefix is not available.
    /// - `InvalidIp.IpPrefixMaskIllegal`: The current IP prefix mask is illegal.
    /// - `InvalidIp.IpPrefixNotStrict`: The IP prefix "%s" must be strict CIDR format.
    /// - `InvalidOperation.NotSupport`: The specified region does not support allocating IPv6 when creating ENI.
    /// - `InvalidEcsId.NotFound`: %s
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidVSwitchId.NotFound`: %s
    /// - `InvalidSecurityGroupId.NotFound`: %s
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InvalidOperation.MaxEniIpv6IpsCountExceeded`: The ipv6 address count exceed limitation.
    /// - `InvalidOperation.VSwitchIpv6Disabled`: The specified VSwitch does not support Ipv6 feature.
    /// - `InvalidOperation.EnableIpv6Failed`: The specified VSwitch does not support Ipv6 feature.
    /// - `InvalidOperation.AddressAlreadyAllocated`: The specified ipv6 has been already allocated.
    /// - `InvalidOperation.AddressNotInVSwitchCidr`: The specified ipv6 does not match VSwitch cidr scope.
    /// - `InvalidOperation.SlaveEniMustHaveBondingEni`: Ensure you create the corresponding Bond ENI before creating Slave ENI.
    /// - `InvalidOperation.EniTrafficModeNotSupportIpv6`: The High Performance(RDMA) traffic mode does not support IPv6.
    /// - `InvalidOperation.VSwitchCidrReservationNotExist`: The specified VSwitch does not have CIDR reservation.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.
    /// - `InvalidOperation.RegionNotSupportIpPrefix`: The current region does not support IP prefix feature.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_network_interface(
        &self,
        req: CreateNetworkInterface,
    ) -> impl std::future::Future<Output = crate::Result<CreateNetworkInterfaceResponse>> + Send
    {
        self.call(req)
    }

    /// # 查看弹性网卡（ENI）列表
    ///
    /// 查询一个或多个弹性网卡（ENI）的详细信息。
    ///
    /// ## 接口说明
    ///
    /// `DescribeNetworkInterfaces`接口支持指定`MaxResults`或`NextToken`参数通过分页查询。具体使用说明：
    ///
    /// - 分页查询首页时，仅需设置`MaxResults`以限制返回信息的条目数，返回结果中的`NextToken`将作为查询后续页的凭证。
    ///
    /// - 查询后续页时，将`NextToken`参数设置为上一次返回结果中获取到的`NextToken`作为查询凭证，并设置`MaxResults`限制返回条目数。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidOperation.InvalidEcsState`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidOperation.DetachPrimaryEniNotAllowed`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidRegionId.MalFormed`: The specified parameter RegionId is not valid.
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `InvalidParameter`: %s
    /// - `MaxEniCountExceeded`: %s
    /// - `EniPerInstanceLimitExceeded`: %s
    /// - `InvalidOperation.AvailabilityZoneMismatch`: %s
    /// - `InvalidOperation.VpcMismatch`: %s
    /// - `SecurityGroupInstanceLimitExceed`: %s
    /// - `InvalidSecurityGroupId.NotVpc`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `InvalidVpc.Empty`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidOperation.InvalidEniPageNumber`: %s
    /// - `InvalidVpc.Indeterminacy`: %s
    /// - `InvalidEcsId.NotFound`: %s
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidVSwitchId.NotFound`: %s
    /// - `InvalidSecurityGroupId.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_network_interfaces(
        &self,
        req: DescribeNetworkInterfaces,
    ) -> impl std::future::Future<Output = crate::Result<DescribeNetworkInterfacesResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询网卡属性
    ///
    /// 指定弹性网卡ID，查询一个网卡的详细信息。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidRegionId.MalFormed`: The specified parameter RegionId is not valid.
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidEniId.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_network_interface_attribute(
        &self,
        req: DescribeNetworkInterfaceAttribute,
    ) -> impl std::future::Future<Output = crate::Result<DescribeNetworkInterfaceAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改弹性网卡属性
    ///
    /// 修改一个弹性网卡（ENI）的网卡队列数、所属安全组、队列深度、通讯模式以及释放实例时是否保留网卡等属性。
    ///
    /// # Error Codes
    /// - `InvalidOperation.NotSupportModifyQueueNumber`: %s
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidOperation.InvalidEcsState`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidOperation.DetachPrimaryEniNotAllowed`: %s
    /// - `InvalidParams.EniId`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `JoinedGroupLimitExceed`: %s
    /// - `InvalidEniQueueSize.RegionOrUserNotSupported`: The specified parameter RxQueueSize or TxQueueSize is not supported in this region, or this account is not in the whitelist of using eni QueueSize.
    /// - `InvalidParameter.EniQueueSize`: The specified parameter TxQueueSize and RxQueueSize are not equal or exceed limit.
    /// - `InvalidParameter.Conflict`: %s
    /// - `InvalidConnectionTrackingConfiguration.RegionOrUserNotSupported`: The specified parameter ConnectionTrackingConfiguration is not supported in this region, or this account is not in the whitelist of using network interface ConnectionTrackingConfiguration.
    /// - `InvalidParameter.InvalidQueuePairNumber`: The specified parameter QueuePairNumber exceeds limit.
    /// - `InvalidParameter.EniConnectionTrackingConfiguration`: The specify network interface connection tracking configuration exceeds limit.
    /// - `InvalidOperation.MaxEniQueuePairNumberExceed`: The QueuePairNumber on the RDMA ENI exceeds the upper limit allowed for a single ENI.
    /// - `InvalidOperation.HighPerformanceEniPerInstanceLimitExceeded`: The number of RDMA ENIs attached to the ECS instance exceeds the upper limit.
    /// - `InvalidOperation.InstanceTypeNotSupportHighPerformance`: The ECS instance type where the ENI is located does not support the RDMA mode.
    /// - `InvalidTrafficMode.ModifyToStandardNotSupported`: The specified parameter NetworkInterfaceTrafficMode is not supported to modify to Standard.
    /// - `InvalidOperation.EniTrafficModeNotSupportIPv6`: The ENI using High Performance traffic mode does not support IPv6.
    /// - `InvalidOperation.EniQueuePairNumberOverflow`: The RDMA QueuePairNumber of the ECS instance associated with the specified ENI exceeds the limit.
    /// - `InvalidParameter.QueuePairNumberMustEmpty`: When the traffic mode is set to Standard, the QueuePairNumber must be empty.
    /// - `InvalidParameter.EniTrafficMode`: The ENI traffic mode is set incorrectly, it must be either Standard or HighPerformance.
    /// - `InvalidOperation.InstanceTypeNotSupportRss`: The ECS instance type does not support Rss.
    /// - `InvalidParameter.EniEnhancedNetwork`: The input parameter "EnhancedNetwork" is illegal, when EnableSriov is true, VirtualFunctionTotalQueueNumber must not be empty, and VirtualFunctionQuantity must be 1 to 256. When EnableSriov is empty or false, VirtualFunctionTotalQueueNumber and VirtualFunctionQuantity must be empty.
    /// - `InvalidOperation.NotSupportModifyVFQueueNumberAndVFQuantity`: The ENI not support modify VirtualFunctionTotalQueueNumber and VirtualFunctionQuantity when EnableSriov is true.
    /// - `InvalidOperation.TrunkAttachmentMustEmpty`: The Attachment of the current Trunk type Network Interface must be empty when modify EnableSriov to true.
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `MaxEniCountExceeded`: %s
    /// - `EniPerInstanceLimitExceeded`: %s
    /// - `InvalidOperation.AvailabilityZoneMismatch`: %s
    /// - `InvalidOperation.VpcMismatch`: %s
    /// - `SecurityGroupInstanceLimitExceed`: %s
    /// - `InvalidSecurityGroupId.NotVpc`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `InvalidOperation.MultiGroupType`: The specified instance can't join different types of security group.
    /// - `InvalidOperation.EniCountExceeded`: The maximum number of eni in a enterprise level security group is exceeded.
    /// - `InvalidParams.NetworkInterfaceName`: %s
    /// - `InvalidOperation.ModifyPrimaryEniQueueNumber`: Primary NetworkInterface is not allowed to modify queue number.
    /// - `InvalidOperation.InvalidEniState`: Available status or ECS instance attached is Stopped is allowed to modify network interface queue number.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidParameter.InvalidEniQueueNumber`: %s
    /// - `InvalidOperation.MaxEniQueueNumberExceeded`: %s
    /// - `InvalidOperation.ExceedInstanceTypeQueueNumber`: %s
    /// - `AclLimitExceed`: %s
    /// - `InvalidEcsId.NotFound`: %s
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidVSwitchId.NotFound`: %s
    /// - `InvalidSecurityGroupId.NotFound`: %s
    /// - `InvalidOperation.PrimaryEniOnlySupportModifyNameAndDesc`: Primary NetworkInterface is only allowed to modify name and description.
    /// - `InvalidParameter.SecurityGroupIdRepeated`: The specified security group ids has repeated.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_network_interface_attribute(
        &self,
        req: ModifyNetworkInterfaceAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyNetworkInterfaceAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除弹性网卡（ENI）
    ///
    /// 异步删除一张弹性网卡（ENI）。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// -  弹性网卡必须处于可用（Available）状态。
    ///
    /// -  如果弹性网卡已经附加到ECS实例，必须先从实例分离（[DetachNetworkInterface](~~58514~~)），才能删除弹性网卡。
    ///
    /// -  删除弹性网卡之后：
    ///
    ///     - 弹性网卡的所有私有地址（包括主私网地址和辅助私网地址）会自动释放。
    ///
    ///     - 被删除的弹性网卡退出所属的所有安全组。
    /// -  本接口为异步接口，调用成功后，您可以通过查询弹性网卡状态或监听网卡操作事件来感知操作结果， 弹性网卡状态机如下图所示：
    /// ![](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/zh-CN/20221208/xual/DeleteNetworkInterface.jpg)
    ///     - Deleting说明删除弹性网卡请求发送成功，弹性网卡正在删除中。
    ///     - 若无法查询到弹性网卡，说明弹性网卡删除成功。
    ///     - 若弹性网卡状态长时间为Deleting说明删除失败，此时您可以重新发起删除请求弹性网卡操作。      
    ///
    /// **调用示例详情参见**[删除弹性网卡](~~471553~~)。
    ///
    /// # Error Codes
    /// - `InvalidOperation.HasSlaveEniBonded`: %s
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidOperation.InvalidEcsState`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidOperation.DetachPrimaryEniNotAllowed`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidParams.EniId`: %s
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `MaxEniCountExceeded`: %s
    /// - `EniPerInstanceLimitExceeded`: %s
    /// - `InvalidOperation.AvailabilityZoneMismatch`: %s
    /// - `InvalidOperation.VpcMismatch`: %s
    /// - `SecurityGroupInstanceLimitExceed`: %s
    /// - `InvalidSecurityGroupId.NotVpc`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `InvalidEcsId.NotFound`: %s
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidVSwitchId.NotFound`: %s
    /// - `InvalidSecurityGroupId.NotFound`: %s
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_network_interface(
        &self,
        req: DeleteNetworkInterface,
    ) -> impl std::future::Future<Output = crate::Result<DeleteNetworkInterfaceResponse>> + Send
    {
        self.call(req)
    }

    /// # 附加弹性网卡到专有网络VPC类型实例上
    ///
    /// 调用AttachNetworkInterface接口，并可以指定NetworkInterfaceId、InstanceId、NetworkCardIndex等参数，附加一个弹性网卡（ENI）到一台专有网络VPC类型ECS实例上。
    ///
    /// 调用该接口时，请注意：
    ///
    /// - 弹性网卡必须处于**可用**（`Available`）状态，一个弹性网卡只能同时附加到一台相同可用区且相同专有网络的实例上。
    ///
    /// - 实例需处于运行中（Running）或者已停止（Stopped）状态，部分实例规格的实例在附加弹性网卡时必须为已停止（Stopped）状态，更多信息，请参见[附加弹性网卡](~~58503~~)中的需要停止实例的ECS实例规格章节。
    ///
    ///     > 如果实例最后一次启动时间在2018年4月1日之前（包括但不限于启动新购的实例、重启、重开机），您必须提前调用RebootInstance重启一直保持运行中状态的实例，否则无法附加弹性网卡。
    ///
    /// - 一台实例可以同时附加多个弹性网卡，更多信息，请参见[弹性网卡概述](~~58496~~)。
    ///   
    /// - 弹性网卡所在的交换机必须与实例所在交换机属于同一可用区且同一专有网络VPC。   
    ///
    /// - 该接口为异步接口，调用成功后，您可以通过查询弹性网卡状态或监听网卡操作事件的方式来感知操作结果。 弹性网卡状态机如下图所示：
    /// ![](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/zh-CN/20221124/esgu/AttachNetworkInterface.jpg)
    ///     - Attaching说明附加弹性网卡请求发送成功，弹性网卡正在附加到ECS实例中。
    ///     - InUse说明弹性网卡已附加到ECS实例。
    ///     - Available说明弹性网卡附加到ECS实例失败。   
    ///
    /// **调用示例详情参见**[附加弹性网卡](~~471550~~)。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidOperation.InvalidRegion`: %s
    /// - `InvalidOperation.InvalidEcsState`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidOperation.DetachPrimaryEniNotAllowed`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidOperation.InvalidGeneration`: %s
    /// - `InvalidParams.EniId`: %s
    /// - `InvalidOperation.UserNotSupportNetworkCard`: User not support network card.
    /// - `InvalidOperation.ConnectionTrackingConfigNotSupportMemberEni`: Member eni not support ConnectionTrackingConfiguration.
    /// - `InvalidParameter.NetworkCardIndexInvalid`: The network card index is invalid or the current ECS/ENI type does not support the value.
    /// - `InvalidOperation.InstanceTypeNotSupportRss`: The ECS instance type does not support Rss.
    /// - `OperationDenied.NoEniStock`: The requested resource of ENI is insufficient in the specified ECS, please retry or upgrade to enterprise-level computing instance types.
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `MaxEniCountExceeded`: %s
    /// - `EniPerInstanceLimitExceeded`: %s
    /// - `InvalidOperation.AvailabilityZoneMismatch`: %s
    /// - `InvalidOperation.VpcMismatch`: %s
    /// - `SecurityGroupInstanceLimitExceed`: %s
    /// - `InvalidSecurityGroupId.NotVpc`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `InvalidInstanceId.NotFound`: %s
    /// - `InvalidEni.NotSameVpc`: %s
    /// - `InvalidOperation.Ipv4CountExceeded`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `InvalidOperation.MultiGroupType`: The specified instance can't join different types of security group.
    /// - `InvalidOperation.NotSupportEnterpriseGroup`: The specified instance type doesn't support enterprise level security group.
    /// - `InvalidOperation.EniCountExceeded`: The maximum number of eni in a enterprise level security group is exceeded.
    /// - `InvalidOperation.EipBindModel`: %s
    /// - `InvalidOperation.Ipv6NotSupport`: %s
    /// - `InvalidOperation.HotPlugNotSupport`: %s
    /// - `InvalidInstance.NetworkType`: %s
    /// - `InvalidOperation.InvalidTrunkEniStatus`: %s
    /// - `InvalidOperation.TrunkingIsNotAllowed`: %s
    /// - `InvalidOperation.InstanceTypeNotSupportEniTrunking`: %s
    /// - `InvalidOperation.EniTypeNotSupportTrunking`: %s
    /// - `InvalidOperation.EniTrunkDeviceFull`: %s
    /// - `InvalidParameter.EniNotBelongTrunk`: %s
    /// - `InvalidOperation.EniTypeNotSupportAttachToTrunk`: %s
    /// - `InvalidParameter.EniNotBelongEcs`: %s
    /// - `InvalidParameter.InvalidEniQueueNumber`: %s
    /// - `InvalidOperation.MaxEniQueueNumberExceeded`: %s
    /// - `InvalidOperation.ExceedInstanceTypeQueueNumber`: %s
    /// - `InvalidOperation.HighPerformanceTrafficModeNotSupportTrunkEni`: %s
    /// - `InvalidOperation.HighPerformanceTrafficModeNotSupportMemberEni`: %s
    /// - `InvalidOperation.InstanceTypeNotSupportHighPerformanceTrafficMode`: %s
    /// - `InvalidOperation.EniTrafficModeNotSupportIpv6`: %s
    /// - `InvalidOperation.MaxEniQueuePairNumberExceed`: %s
    /// - `InvalidParameter.InvalidQueuePairNumber`: %s
    /// - `InvalidOperation.EniQueuePairNumberOverflow`: %s
    /// - `InvalidOperation.HighPerformanceEniPerInstanceLimitExceeded`: %s
    /// - `InvalidOperation.Ipv6CountExceeded`: %s.
    /// - `InvalidEcsId.NotFound`: %s
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidVSwitchId.NotFound`: %s
    /// - `InvalidSecurityGroupId.NotFound`: %s
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn attach_network_interface(
        &self,
        req: AttachNetworkInterface,
    ) -> impl std::future::Future<Output = crate::Result<AttachNetworkInterfaceResponse>> + Send
    {
        self.call(req)
    }

    /// # 从实例上分离弹性网卡（ENI）
    ///
    /// 从一台ECS实例上分离一张弹性网卡（ENI）。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// -  不允许分离实例主网卡。
    ///
    /// -  弹性网卡必须处于分离中（Detaching）或者已附加（InUse）状态。
    ///
    /// -  实例必须处于运行中（Running）或者已停止（Stopped）状态。
    ///
    /// -  本接口为异步接口，调用成功后，您可以通过查询弹性网卡状态或监听网卡操作事件来感知操作结果， 弹性网卡状态机如下图所示：
    /// ![](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/zh-CN/20221124/mvga/DetachNetworkInterface.jpg)
    ///
    ///     - Detaching状态说明分离弹性网卡请求发送成功，弹性网卡正在从ECS实例分离。
    ///
    ///     - Available状态说明弹性网卡从ECS实例分离成功。
    ///
    ///     - 若弹性网卡长时间为Detaching状态，可能是因为实例内部的操作系统不响应网卡的分离请求等原因导致了分离失败。此时，您可以对该弹性网卡重新发起分离请求，若长时间不成功的话，可以尝试重启实例后重试。   
    ///
    /// **调用示例详情参见**[分离弹性网卡](~~471551~~)。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidOperation.InvalidRegion`: %s
    /// - `InvalidOperation.InvalidEcsState`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidOperation.DetachPrimaryEniNotAllowed`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidParams.EniId`: %s
    /// - `InvalidParameter.EniNotBelongEcs`: %s
    /// - `InvalidOperation.EniHotPlugNotSupported`: The ENI with high-performance traffic mode cannot be hot-plugged. Please stop the ECS instance to which the ENI is attached, and try again.
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `MaxEniCountExceeded`: %s
    /// - `EniPerInstanceLimitExceeded`: %s
    /// - `InvalidOperation.AvailabilityZoneMismatch`: %s
    /// - `InvalidOperation.VpcMismatch`: %s
    /// - `SecurityGroupInstanceLimitExceed`: %s
    /// - `InvalidSecurityGroupId.NotVpc`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `InvalidOperation.EniLinked`: %s
    /// - `InvalidInstanceId.NotFound`: %s
    /// - `InvalidOperation.HotPlugNotSupport`: %s
    /// - `InvalidOperation.InvalidTrunkEniStatus`: %s
    /// - `InvalidOperation.TrunkingIsNotAllowed`: %s
    /// - `InvalidOperation.InstanceTypeNotSupportEniTrunking`: %s
    /// - `InvalidParameter.EniNotBelongTrunk`: %s
    /// - `InvalidOperation.EniTypeNotSupportTrunking`: %s
    /// - `InvalidOperation.HasMemberEniAttached`: %s
    /// - `InvalidParameter.EniNotBelongEcs`: %s
    /// - `InvalidEcsId.NotFound`: %s
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidVSwitchId.NotFound`: %s
    /// - `InvalidSecurityGroupId.NotFound`: %s
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn detach_network_interface(
        &self,
        req: DetachNetworkInterface,
    ) -> impl std::future::Future<Output = crate::Result<DetachNetworkInterfaceResponse>> + Send
    {
        self.call(req)
    }

    /// # 为弹性网卡分配辅助私有IP地址
    ///
    /// 为一块弹性网卡分配一个或多个辅助私网IP地址。可以为网卡指定在所属交换机（vSwitch）的空闲私网IP地址，或者通过指定私网地址数量自动分配私网IP地址。
    ///
    /// ## 接口说明
    ///
    /// - 仅支持可用（Available）或者已附加（InUse）状态下的弹性网卡。
    /// - 操作主网卡时，网卡附加的实例必须处于运行中（Running）或者已停止（Stopped）状态。
    /// - 网卡处于可用（Available）状态时，最多可以分配49个辅助私网IP地址。一旦挂载到实例上，网卡能分配的辅助私网IP地址数将受到实例规格限制。更多详情，请参见[实例规格族](~~25378~~)。
    /// - 成功调用该接口后，您可以从返回结果中获取已分配的辅助私网IP地址信息。
    ///
    /// # Error Codes
    /// - `Throttling`: Request was denied due to request throttling.
    /// - `InvalidOperation.Unsupported`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidOperation.InvalidEcsState`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidOperation.DetachPrimaryEniNotAllowed`: %s
    /// - `MissingParameter`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidAction`: %s
    /// - `InvalidPrivateIpAddress.Duplicated`: Specified private IP address is duplicated.
    /// - `InvalidPrivateIpAddress.Malformed`: %s
    /// - `InvalidSecondaryPrivateIpAddressCount.Malformed`: %s
    /// - `InvalidParameter.Conflict`: %s
    /// - `InvalidOperation.InstanceNotSupportMulitipleIp`: Assigning private ip for instance in cloud box is unsupported.
    /// - `IncorrectVSwitchStatus`: The operation is not allowed in the current VSwitch state. Expecting state includes "Created Available", but current state is "%s".
    /// - `QuotaExceeded.PrivateIpAddress`: There are not enough private IPs in the specified VSwitch.
    /// - `InvalidStatus.InstanceIsMigrating`: The ECS which ENI is attached to is migrating. Please try again later.
    /// - `InvalidEniId.Malformed`: The specified parameter "NetworkInterfaceId" is not valid. Ensure you provide the full ENI id in the form eni-xxx.
    /// - `InvalidVSwitch.IllegalStatus`: The operation is not allowed in the current VSwitch state. Expecting state includes "Created", but current state is "%s".
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `MissingParameter`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `MaxEniCountExceeded`: %s
    /// - `EniPerInstanceLimitExceeded`: %s
    /// - `InvalidOperation.AvailabilityZoneMismatch`: %s
    /// - `InvalidOperation.VpcMismatch`: %s
    /// - `SecurityGroupInstanceLimitExceed`: %s
    /// - `InvalidSecurityGroupId.NotVpc`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `InvalidVSwitchId.IpNotEnough`: %s
    /// - `InvalidVSwitchId.IpInvalid`: %s
    /// - `InvalidIp.IpAssigned`: %s
    /// - `MaxEniPrivateIpsCountExceeded`: %s
    /// - `Operation.Conflict`: %s
    /// - `InvalidOperation.Ipv4CountExceeded`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `InvalidIp.IpRepeated`: %s
    /// - `InvalidIp.IpPrefixIllegal`: The ip prefixes %s is/are illegal.
    /// - `InvalidIp.IpPrefixMaskIllegal`: The current IP prefix mask is illegal.
    /// - `InvalidIp.IpPrefixMaskNotSame`: The IP prefixes %s are illegal.The IP prefix mask must be the same.
    /// - `InvalidIp.IpPrefixNotAvailable`: The IP prefix is not available.
    /// - `InvalidIp.IpPrefixNotStrict`: The IP prefix "%s" must be strict CIDR format.
    /// - `InvalidVSwitchId.IpPrefixNotEnough`: The specified VSwitch does not have enough IP prefixes.
    /// - `InvalidIp.IpPrefixMaskInvalid`: The IP prefixes mask "%s" is illegal.Ensure the mask is between %s and %s.
    /// - `InvalidIp.IpPrefixMustInReserveSegment`: The IP prefix must be in VSwitch reserved segment. Ensure you create reserved segment for the VSwitch.
    /// - `InvalidEcsId.NotFound`: %s
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidVSwitchId.NotFound`: %s
    /// - `InvalidSecurityGroupId.NotFound`: %s
    /// - `InvalidInstanceId.NotFound`: %s
    /// - `InvalidOperation.VSwitchCidrReservationNotExist`: The specified VSwitch does not have CIDR reservation.
    /// - `InvalidOperation.RegionNotSupportIpPrefix`: The current region does not support IP prefix feature.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn assign_private_ip_addresses(
        &self,
        req: AssignPrivateIpAddresses,
    ) -> impl std::future::Future<Output = crate::Result<AssignPrivateIpAddressesResponse>> + Send
    {
        self.call(req)
    }

    /// # 从弹性网卡删除辅助私有IP地址
    ///
    /// 从一张弹性网卡删除一个或多个辅助私有IP地址。
    ///
    /// ## 接口说明
    ///
    /// - 只支持**可用**（Available）或者**已附加**（InUse）状态下的弹性网卡。
    ///
    /// - 操作主网卡时，网卡附加的实例必须处于**运行中**（Running）或者**已停止**（Stopped）状态。
    ///
    /// # Error Codes
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidOperation.InvalidEcsState`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidOperation.DetachPrimaryEniNotAllowed`: %s
    /// - `MissingParameter`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidAction`: %s
    /// - `InvalidEniId.Malformed`: The specified parameter "EniId" is not valid.
    /// - `InvalidParameter.Conflict`: %s
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `MissingParameter`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `MaxEniCountExceeded`: %s
    /// - `EniPerInstanceLimitExceeded`: %s
    /// - `InvalidOperation.AvailabilityZoneMismatch`: %s
    /// - `InvalidOperation.VpcMismatch`: %s
    /// - `SecurityGroupInstanceLimitExceed`: %s
    /// - `InvalidSecurityGroupId.NotVpc`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `InvalidVSwitchId.IpInvalid`: %s
    /// - `InvalidIp.IpUnassigned`: %s
    /// - `Operation.Conflict`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `InvalidPrivateIpAddress.Malformed`: %s
    /// - `InvalidIp.IpPrefixMaskInvalid`: The ip prefixes mask %s is illegal which must be between %s and %s.
    /// - `InvalidIp.IpPrefixMaskNotSame`: The ip prefixes %s are illegal which mask must be same.
    /// - `InvalidIp.IpPrefixNotStrict`: The ip prefix must be strict cidr format.
    /// - `InvalidIp.IpPrefixIllegal`: The ip prefixes %s is/are illegal.
    /// - `InvalidEcsId.NotFound`: %s
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidVSwitchId.NotFound`: %s
    /// - `InvalidSecurityGroupId.NotFound`: %s
    /// - `InvalidInstanceId.NotFound`: %s
    /// - `InvalidOperation.RegionNotSupportIpPrefix`: The current region does not support ip prefix.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn unassign_private_ip_addresses(
        &self,
        req: UnassignPrivateIpAddresses,
    ) -> impl std::future::Future<Output = crate::Result<UnassignPrivateIpAddressesResponse>> + Send
    {
        self.call(req)
    }

    /// # 为弹性网卡分配IPv6地址
    ///
    /// 为弹性网卡分配一个或多个IPv6地址。
    ///
    /// ## 接口说明
    /// 您可以指定弹性网卡所属交换机下CIDR的IPv6地址，也可以指定IPv6地址数量自动创建IPv6地址。您需要注意：
    ///
    /// - 弹性网卡所属的交换机必须开通了IPv6。更多信息，请参见[为已有交换机开通IPv6网段](~~98923~~)。
    ///
    /// - 弹性网卡必须处于可用（Available）或已附加（InUse）状态。
    ///
    /// - 操作主网卡时，网卡附加的实例必须处于运行中（Running）或已停止（Stopped）状态。
    ///
    /// - 单个网卡能够分配的IPv6地址数量和网卡附加的实例规格有关。
    ///     - 如果弹性网卡处于可用（Available）状态，最多可以分配10个IPv6地址。
    ///
    ///     - 如果弹性网卡附加到实例上，能够分配的IPv6地址数将受到实例规格限制。更多信息，请参见[实例规格族](~~25378~~)。
    ///
    /// - 成功调用该接口后，您可以从返回结果中获取已分配的IPv6地址信息。
    ///
    /// # Error Codes
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `MissingParameter`: %s
    /// - `InValidParameter`: %s
    /// - `InvalidParams.EniId`: %s
    /// - `InvalidOperation.InvalidEcsState`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidPrivateIpAddress.Duplicated`: Specified private IP address is duplicated.
    /// - `IncorrectVSwitchStatus`: The current status of vSwitch does not support this operation.
    /// - `InvalidParameter.Conflict`: %s
    /// - `InvalidOperation.EniOperationConflict`: The previous ENI operation is still in progress. Please try again later.
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `MissingParameter`: %s
    /// - `Forbedden.NotSupportRAM`: %s
    /// - `Forbbiden.SubUser`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `MaxEniIpv6IpsCountExceeded`: %s
    /// - `InvalidIp.IpUnassigned`: %s
    /// - `InvalidIp.IpRepeated`: %s
    /// - `InvalidIp.IpAssigned`: %s
    /// - `InvalidIp.Address`: %s
    /// - `InvalidOperation.EniCountExceeded`: %s
    /// - `InvalidOperation.Ipv4CountExceeded`: %s
    /// - `InvalidOperation.Ipv6CountExceeded`: %s
    /// - `InvalidOperation.Ipv6NotSupport`: %s
    /// - `InvalidOperation.Ipv4NotSupport`: %s
    /// - `InvalidVSwitch.Ipv6NotTurnOn`: %s
    /// - `InvalidParam.IpAssign`: %s
    /// - `InvalidVSwitchId.IpInvalid`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `SecurityGroupInstanceLimitExceed`: %s
    /// - `InvalidOperation.HighPerformanceTrafficModeEniNotSupport`: %s
    /// - `InvalidOperation.EniTypeNotSupport`: The member eni does not support ipv6.
    /// - `InvalidIp.IpPrefixIllegal`: The ip prefixes %s is/are illegal.
    /// - `InvalidIp.IpPrefixMaskIllegal`: The ip prefix mask is illegal.
    /// - `InvalidIp.IpPrefixMaskInvalid`: The ip prefixes mask %s is illegal which must be between %s and %s.
    /// - `InvalidIp.IpPrefixMaskNotSame`: The ip prefixes %s are illegal which mask must be same.
    /// - `InvalidIp.IpPrefixMustInReserveSegment`: The ip prefix must in vswitch reserve segment.
    /// - `InvalidIp.IpPrefixNotAvailable`: The ip prefix is/are not available.
    /// - `InvalidIp.IpPrefixNotStrict`: The ip prefix must be strict cidr format.
    /// - `InvalidVSwitchId.IpPrefixNotEnough`: The specified vSwitch has not enough ip prefix.
    /// - `InvalidEniId.NotFound`: %s
    /// - `MaxEniIpv6IpsCountExceeded`: The ipv6 address count exceed limitation.
    /// - `InvalidOperation.VSwitchIpv6Disabled`: The specified VSwitch does not support Ipv6 feature.
    /// - `InvalidOperation.EnableIpv6Failed`: The specified VSwitch does not support Ipv6 feature.
    /// - `InvalidIp.IpAssigned`: The specified ipv6 has already been allocated.
    /// - `InvalidVSwitchId.IpInvalid`: The specified ipv6 does not match VSwitch cidr scope.
    /// - `InvalidOperation.HasIpv6RouteEntry`: The specified eni has been pointed to the next hop of the route.
    /// - `InvalidOperation.VSwitchCidrReservationNotExist`: The specified vSwitch has no cidr reservation.
    /// - `InvalidOperation.RegionNotSupportIpPrefix`: The current region does not support ip prefix.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn assign_ipv6_addresses(
        &self,
        req: AssignIpv6Addresses,
    ) -> impl std::future::Future<Output = crate::Result<AssignIpv6AddressesResponse>> + Send {
        self.call(req)
    }

    /// # 回收弹性网卡IPv6地址
    ///
    /// 回收一个或多个弹性网卡IPv6地址。
    ///
    /// ## 接口说明
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 弹性网卡必须处于**可用**（Available）或**已附加**（InUse）状态。
    /// - 操作主网卡时，网卡附加的ECS实例必须处于**运行中**（Running）或**已停止**（Stopped）状态。
    ///
    /// # Error Codes
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `MissingParameter`: %s
    /// - `InvalidOperation.InvalidEcsState`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidEniId.Malformed`: The specified parameter "EniId" is not valid.
    /// - `InvalidParameter.Conflict`: %s
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `MissingParameter`: %s
    /// - `Forbedden.NotSupportRAM`: %s
    /// - `Forbbiden.SubUser`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `InvalidIp.IpUnassigned`: %s
    /// - `InvalidIp.IpRepeated`: %s
    /// - `InvalidIp.Address`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `InvalidIp.IpPrefixIllegal`: The ip prefixes %s is/are illegal.
    /// - `InvalidIp.IpPrefixMaskInvalid`: The ip prefixes mask %s is illegal which must be between %s and %s.
    /// - `InvalidIp.IpPrefixMaskNotSame`: The ip prefixes %s are illegal which mask must be same.
    /// - `InvalidIp.IpPrefixNotStrict`: The ip prefix must be strict cidr format.
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidOperation.RegionNotSupportIpPrefix`: The current region does not support ip prefix.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn unassign_ipv6_addresses(
        &self,
        req: UnassignIpv6Addresses,
    ) -> impl std::future::Future<Output = crate::Result<UnassignIpv6AddressesResponse>> + Send
    {
        self.call(req)
    }

    /// # 为认证ISV或个人授权弹性网卡权限
    ///
    /// 调用CreateNetworkInterfacePermission为阿里云合作伙伴（认证ISV）或者个人用户授权弹性网卡权限。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `NotBelongUser`: %s
    /// - `InvalidOperation.PermissionExisted`: %s
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `InvalidOperation.PermissionNotExisted`: %s
    /// - `InvalidEniId.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_network_interface_permission(
        &self,
        req: CreateNetworkInterfacePermission,
    ) -> impl std::future::Future<Output = crate::Result<CreateNetworkInterfacePermissionResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询授权给认证ISV或个人的弹性网卡权限
    ///
    /// 调用DescribeNetworkInterfacePermissions查询您授权给阿里云合作伙伴（认证ISV）或者个人用户的弹性网卡权限列表。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `NotBelongUser`: %s
    /// - `InvalidOperation.PermissionExisted`: %s
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `InvalidOperation.PermissionNotExisted`: %s
    /// - `InvalidEniId.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_network_interface_permissions(
        &self,
        req: DescribeNetworkInterfacePermissions,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeNetworkInterfacePermissionsResponse>,
    > + Send {
        self.call(req)
    }

    /// # 创建前缀列表
    ///
    /// 创建一个前缀列表。
    ///
    /// ## 接口说明
    ///
    /// - 前缀列表是一些网络前缀（即CIDR地址块）的集合，您可以在配置其他资源的网络规则时引用前缀列表。关于前缀列表的详细说明，请参见[前缀列表概述](~~206223~~)。
    /// - 创建前缀列表时：
    ///
    ///     - 您必须为该前缀列表指定地址族（IPv4或IPv6），同一前缀列表中的条目只能属于同一地址族，且地址族创建后不能修改。
    ///     - 您必须为该前缀列表设置最大条目容量，且创建后不能修改。
    ///     - 您可以为该前缀列表指定一些条目，条目由CIDR地址块和描述构成，条目数量不能超过您设置的最大条目容量。
    ///
    /// - 关于前缀列表及其他资源的使用限制说明，请参见[使用限制](~~25412~~)。
    ///
    /// - 通过RAM用户可以让您避免与其他用户共享阿里云账号密钥，按需为用户分配最小权限，从而降低企业的信息安全风险。关于如何为RAM用户授予前缀列表相关权限的具体操作，请参见[为RAM用户授予前缀列表相关权限](~~206175~~)。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `InvalidParameter.AddressFamily`: The parameter AddressFamily should be IPv4 or IPv6.
    /// - `InvalidParameter`: %s
    /// - `InvalidParameter.PrefixListName`: The parameter PrefixListName is not valid.
    /// - `InvalidDescription.Malformed`: The specified Description is wrongly formed.
    /// - `InvalidClientToken.ValueNotSupported`: The ClientToken provided is invalid.
    /// - `InvalidParameter.CidrMalformed`: %s
    /// - `InvalidParameter.CidrDuplicated`: %s
    /// - `LimitExceed.Entry`: The number of entries added or removed exceeds the limit.
    /// - `LimitExceed.MaxEntries`: The number of entries exceeds the MaxEntries of the specified prefix list.
    /// - `LimitExceed.PrefixListPerRegion`: The number of prefix lists in the region exceeds the limit.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidResourceGroup.NotFound`: The specified resource group is not found.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_prefix_list(
        &self,
        req: CreatePrefixList,
    ) -> impl std::future::Future<Output = crate::Result<CreatePrefixListResponse>> + Send {
        self.call(req)
    }

    /// # 查询前缀列表
    ///
    /// 调用DescribePrefixLists查询一个或多个前缀列表的信息。
    ///
    /// 请求参数`AddressFamily`、`PrefixListId.N`和`PrefixListName`类似于过滤器，为逻辑与（AND）关系。如果某一参数为空，则过滤器不起作用。
    ///
    /// # Error Codes
    /// - `InvalidParameter`: %s
    /// - `LimitExceed.PrefixListId`: The specified number of PrefixListId exceeds the limit.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_prefix_lists(
        &self,
        req: DescribePrefixLists,
    ) -> impl std::future::Future<Output = crate::Result<DescribePrefixListsResponse>> + Send {
        self.call(req)
    }

    /// # 查询前缀列表的详细信息
    ///
    /// 查询指定前缀列表的详细信息，包含前缀列表的名称、地址族、最大条目容量以及条目的详细信息等。
    ///
    /// # Error Codes
    /// - `InvalidPrefixListId.NotFound`: The specified prefix list was not found.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_prefix_list_attributes(
        &self,
        req: DescribePrefixListAttributes,
    ) -> impl std::future::Future<Output = crate::Result<DescribePrefixListAttributesResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询前缀列表已关联的资源信息
    ///
    /// 查询指定前缀列表已关联的资源信息，例如，资源ID和资源类型。
    ///
    /// # Error Codes
    /// - `InvalidParameter`: %s
    /// - `NotSupported.ResourceType`: The specified resource type is not supported.
    /// - `InvalidPrefixListId.NotFound`: The specified prefix list was not found.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_prefix_list_associations(
        &self,
        req: DescribePrefixListAssociations,
    ) -> impl std::future::Future<Output = crate::Result<DescribePrefixListAssociationsResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改前缀列表的属性
    ///
    /// 修改指定前缀列表的名称、描述等，支持增加、修改和删除条目。
    ///
    /// ## 接口说明
    ///
    /// - 指定的CIDR地址块应当为标准形式。例如，10.0.0.0/8是正确形式的CIDR地址块，而10.0.0.1/8是错误形式。更多信息，请参见[什么是CIDR](~~40637#section-jua-0tj-q5m~~)。
    /// - 新增或删除条目时，不能指定重复的CIDR地址块。例如：
    ///     - 对于IPv4 CIDR地址块：不能同时指定两个CIDR地址块均为10.0.0.0/8的条目；不能同时指定两个CIDR地址块分别为10.0.0.1/32和10.0.0.1的条目，这两个地址块重复。
    ///     - 对于IPv6 CIDR地址块：不能同时指定两个条目的CIDR地址块分别为2001:fd01:0:0:0:0:0:0/32和2001:fd01::/32，这两个地址块重复。
    /// - 新增条目的CIDR地址块不能与删除条目的CIDR地址块重复。例如，在您新增CIDR地址块为10.0.0.0/8的条目时，不能在待删除的条目中包含CIDR地址块10.0.0.0/8。
    /// - 若您需要修改条目的描述，需要指定条目的CIDR地址块（`AddEntry.N.Cidr`）和新的描述信息（`AddEntry.N.Description`）。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `InvalidParameter.PrefixListName`: The parameter PrefixListName is not valid.
    /// - `InvalidDescription.Malformed`: The specified Description is wrongly formed.
    /// - `InvalidParameter.CidrDuplicated`: %s
    /// - `InvalidParameter.CidrMalformed`: %s
    /// - `LimitExceed.MaxEntries`: The number of entries exceeds the MaxEntries of the specified prefix list.
    /// - `LimitExceed.Entry`: The number of entries added or removed exceeds the limit.
    /// - `InvalidPrefixListId.NotFound`: The specified prefix list was not found.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_prefix_list(
        &self,
        req: ModifyPrefixList,
    ) -> impl std::future::Future<Output = crate::Result<ModifyPrefixListResponse>> + Send {
        self.call(req)
    }

    /// # 删除前缀列表
    ///
    /// 调用DeletePrefixList删除指定的前缀列表，同时删除前缀列表中的所有条目。
    ///
    /// 前缀列表与其他资源存在关联时，不能直接删除，需要先在其他资源中解除对该前缀列表的关联，再执行删除操作。您可以调用[DescribePrefixListAssociations](~~204724~~)查询指定前缀列表的已关联资源。
    ///
    /// # Error Codes
    /// - `NotAllowed.AssociationExist`: The specified prefix list has associated resources.
    /// - `InvalidPrefixListId.NotFound`: The specified prefix list was not found.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_prefix_list(
        &self,
        req: DeletePrefixList,
    ) -> impl std::future::Future<Output = crate::Result<DeletePrefixListResponse>> + Send {
        self.call(req)
    }

    /// # 创建端口列表
    ///
    /// 创建端口列表，后续可关联资源（例如安全组）使用。
    ///
    /// # Error Codes
    /// - `InvalidParam.Entry`: The specified parameter Entry is not valid.
    /// - `InvalidOperation.MaxEntriesCountExceed`: The specified MaxEntries exceeded the upper limit.
    /// - `InvalidOperation.EntryCountExceedMaxEntries`: The number of entries in the port list exceeds MaxEntries.
    /// - `InvalidParameter.PortRange`: The specified parameter PortRange is not valid. It should be two integers less than 65535 in specified format.
    /// - `InvalidParameter.PortRangeListName`: The specified parameter PortRangeListName is not valid.
    /// - `LimitExceed.MaxEntries`: The number of entries exceeds the MaxEntries of the specified PortRangeList.
    /// - `LimitExceed.Entry`: The number of entries added or removed exceeds the limit.
    /// - `InvalidOperation.MaxCountExceed`: The number of port range list in the current account has exceeded quota.
    /// - `InvalidParameter.PortRangeDuplicated`: The specified PortRange is duplicated.
    /// - `InvalidDescription.Malformed`: The specifid Description is not valid.
    /// - `InvalidRegionId.NotFound`: The specified parameter RegionId is not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_port_range_list(
        &self,
        req: CreatePortRangeList,
    ) -> impl std::future::Future<Output = crate::Result<CreatePortRangeListResponse>> + Send {
        self.call(req)
    }

    /// # 查询端口列表
    ///
    /// 查询端口列表。
    ///
    /// # Error Codes
    /// - `LimitExceed.PortRangeListId`: The specified number of PortRangeListId exceeds the limit.
    /// - `InvalidParameter`: The specified parameter is not valid.
    /// - `InvalidRegionId.NotFound`: The specified parameter RegionId is not valid.///
    /// # Methods
    /// - GET
    /// - POST
    ///
    pub fn describe_port_range_lists(
        &self,
        req: DescribePortRangeLists,
    ) -> impl std::future::Future<Output = crate::Result<DescribePortRangeListsResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询端口列表的条目
    ///
    /// 查询指定端口列表的条目。
    ///
    /// # Error Codes
    /// - `InvalidPortRangeListId.NotFound`: The specified port range list was not found.
    /// - `InvalidRegionId.NotFound`: The specified parameter RegionId is not valid.///
    /// # Methods
    /// - GET
    /// - POST
    ///
    pub fn describe_port_range_list_entries(
        &self,
        req: DescribePortRangeListEntries,
    ) -> impl std::future::Future<Output = crate::Result<DescribePortRangeListEntriesResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询端口列表已关联的资源信息
    ///
    /// 查询指定端口列表已关联的资源信息，例如，安全组。
    ///
    /// # Error Codes
    /// - `InvalidPortRangeListId.NotFound`: The specified port range list was not found.
    /// - `InvalidParameter`: The specified parameter is not valid.
    /// - `InvalidRegionId.NotFound`: The specified parameter RegionId is not valid.///
    /// # Methods
    /// - GET
    /// - POST
    ///
    pub fn describe_port_range_list_associations(
        &self,
        req: DescribePortRangeListAssociations,
    ) -> impl std::future::Future<Output = crate::Result<DescribePortRangeListAssociationsResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改端口列表的属性
    ///
    /// 修改指定端口列表的名称、条目，支持增加、修改和删除条目。
    ///
    /// # Error Codes
    /// - `InvalidOperation.Conflict`: The port range list has conflict task.
    /// - `InvalidPortRangeListId.NotFound`: The specified port range list was not found.
    /// - `InvalidOperation.MaxEntriesCountExceed`: The specified MaxEntries exceeded the upper limit.
    /// - `InvalidOperation.EntryCountExceedMaxEntries`: The number of entries in the port list exceeds MaxEntries.
    /// - `LimitExceed.MaxEntries`: The number of entries exceeds the MaxEntries of the specified PortRangeList.
    /// - `LimitExceed.Entry`: The number of entries added or removed exceeds the limit.
    /// - `InvalidParameter.PortRangeDuplicated`: The specified PortRange is duplicated.
    /// - `InvalidParameter.PortRangeListName`: The specified parameter PortRangeListName is not valid.
    /// - `InvalidMaxEntries.LessThanCurrentEntries`: The specified MaxEntries is less than current entries.
    /// - `InvalidParameter.PortRange`: The specified parameter PortRange is not valid. It should be two integers less than 65535 in specified format.
    /// - `MissingParameter`: Missing mandatory parameter.
    /// - `InvalidDescription.Malformed`: The specifid Description is not valid.
    /// - `AuthorizationLimitExceed`: The limit of authorization records in the security group reaches.
    /// - `InvalidRegionId.NotFound`: The specified parameter RegionId is not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_port_range_list(
        &self,
        req: ModifyPortRangeList,
    ) -> impl std::future::Future<Output = crate::Result<ModifyPortRangeListResponse>> + Send {
        self.call(req)
    }

    /// # 删除端口列表
    ///
    /// 删除指定端口列表，同时端口列表下的端口列表条目都将被删除。
    ///
    /// # Error Codes
    /// - `InvalidOperation.Conflict`: The port range list has conflict task.
    /// - `InvalidPortRangeListId.AssociationExist`: The specified port range list has association resources.
    /// - `InvalidPortRangeListId.NotFound`: The specified port range list was not found.
    /// - `InvalidRegionId.NotFound`: The specified parameter RegionId is not valid.///
    /// # Methods
    /// - GET
    /// - POST
    ///
    pub fn delete_port_range_list(
        &self,
        req: DeletePortRangeList,
    ) -> impl std::future::Future<Output = crate::Result<DeletePortRangeListResponse>> + Send {
        self.call(req)
    }

    /// # 创建安全组
    ///
    /// 本接口用于创建一个安全组。
    ///
    /// - 通过该接口创建的普通安全组组内连通策略默认是**组内互通**，您可以通过[ModifySecurityGroupPolicy](~~2679846~~)进行修改。
    /// - 通过该接口创建的企业安全组组内连通策略默认是**组内隔离**，并且不能修改。
    /// -  单个地域下，安全组的数量有限制，您最少可以创建100个安全组。详细信息，请参见[安全组使用限制](~~25412#SecurityGroupQuota1~~)。
    /// -  创建专有网络VPC类型的安全组时，您必须指定参数VpcId。
    ///
    /// # Error Codes
    /// - `InvalidDescription.Malformed`: The specified parameter "Description" is not valid.
    /// - `InvalidSecurityGroupDiscription.Malformed`: Specified security group description is not valid.
    /// - `IncorrectVpcStatus`: Current VPC status does not support this operation.
    /// - `InvalidTagKey.Malformed`: Specified tag key is not valid.
    /// - `InvalidTagValue.Malformed`: Specified tag value is not valid.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidParams.GroupType`: The specified security group type is not valid.
    /// - `InvalidParams.VpcIdGroupType`: Only VPC instance supports enterprise level security group.
    /// - `InvalidSecurityGroupName.Malformed`: The specified parameter SecurityGroupName is not valid.
    /// - `QuotaExceed.SecurityGroup`: The maximum number of security groups is reached.
    /// - `InvalidVpcId.NotFound`: The VpcId must not empty when only support vpc vm.
    /// - `IncorrectVpcStatus`: Current VPC status does not support this operation.
    /// - `IdempotentProcessing`: The previous idempotent request(s) is still processing.
    /// - `QuotaExceed.Tags`: %s
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidRegionId.NotFound`: The specified region does not exist.
    /// - `InvalidVpcId.NotFound`: Specified VPC does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_security_group(
        &self,
        req: CreateSecurityGroup,
    ) -> impl std::future::Future<Output = crate::Result<CreateSecurityGroupResponse>> + Send {
        self.call(req)
    }

    /// # 查询安全组基本信息列表
    ///
    /// 本接口用于查询安全组基本信息列表，支持您通过地域、安全组ID、安全组类型等不同参数查询。
    ///
    /// - **分页查询**：推荐您使用`MaxResults`与`NextToken`参数进行查询。
    ///   - 当返回结果中没有`NextToken`时，表示该页为末页，不再有后续页。
    ///   - 分页查询首页时，仅需设置`MaxResults`以限制返回信息的条目数，返回结果中的`NextToken`将作为查询后续页的凭证。
    ///   - 查询后续页时，将`NextToken`参数设置为上一次返回结果中获取到的`NextToken`作为查询凭证，并设置`MaxResults`限制返回条目数。
    /// - 通过阿里云CLI调用API时，不同数据类型的请求参数取值必须遵循一定的格式要求。更多信息，请参见[CLI参数格式说明](~~110340~~)。
    ///
    /// # Error Codes
    /// - `NotSupported.PageNumberAndPageSize`: The parameters PageNumber and PageSize are currently not supported, please use NextToken and MaxResults instead.
    /// - `InValidParameter.NextToken`: The parameter NextToken is invalid.
    /// - `MissingParameter.RegionId`: The input parameter RegionId that is mandatory for processing this request is not supplied.
    /// - `InvalidParameter.SecurityGroupType`: The specified SecurityGroupType is not valid.
    /// - `InvalidSecurityGroupId.Malformed`: The specified parameter SecurityGroupId is not valid.
    /// - `InvalidSecurityGroupName.Malformed`: The specified parameter SecurityGroupName is not valid.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_security_groups(
        &self,
        req: DescribeSecurityGroups,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSecurityGroupsResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询安全组和组内规则信息
    ///
    /// 本接口主要用于查询一个指定安全组的详细信息，并关联查询安全组规则详细信息列表。
    ///
    /// # Error Codes
    /// - `InvalidNicType.ValueNotSupported`: The specified NicType does not exist.
    /// - `InvalidParamter`: Invalid Parameter.
    /// - `InvalidSecurityGroupId.Malformed`: The specified parameter "SecurityGroupId" is not valid.
    /// - `MissingParameter.RegionId`: The parameter RegionId is missing.
    /// - `InvalidParameter.AttributeNotSupported`: The specified value for parameter Attribute is not supported. Valid values: snapshotPolicyIds.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_security_group_attribute(
        &self,
        req: DescribeSecurityGroupAttribute,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSecurityGroupAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改普通安全组的组内连通策略
    ///
    /// 本接口用于修改一个普通安全组的组内连通策略。
    ///
    /// -  企业级安全组不支持修改组内连通策略，默认**组内隔离**。
    /// -  您可以通过[DescribeSecurityGroupAttribute](~~25555~~)查询当前安全组组内连通策略。
    /// -  安全组的组内连通策略是**组内互通**时，会忽略其他自定义访问规则，组内所有实例的内网保持默认连通。  
    ///
    /// -  安全组的组内连通策略是**组内隔离**时，在不添加其他访问规则的情况下，组内所有实例的内网默认不连通。但您可以自定义安全组规则改变内网状态，例如，您可以通过[AuthorizeSecurityGroup](~~25554~~)使安全组内的两台ECS实例网络互通。
    ///
    /// # Error Codes
    /// - `MissingParamter.RegionId`: The RegionId should not be null.
    /// - `InvalidSecurityGroupId.Malformed`: The SecurityGroupId is invalid. Only letters, numbers and underscores are supported. Maximum length is 100 characters.
    /// - `InvalidPolicy.Malformed`: The Policy is invalid. Only 'Accept' and 'Drop' are supported. Ignore case.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `InvalidParameter.InnerAccessPolicy`: The InnerAccessPolicy attribute of enterprise level security group can't be modified.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_security_group_policy(
        &self,
        req: ModifySecurityGroupPolicy,
    ) -> impl std::future::Future<Output = crate::Result<ModifySecurityGroupPolicyResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改安全组的名称或者描述
    ///
    /// 本接口用于修改一个指定安全组的名称或者描述信息。
    ///
    /// # Error Codes
    /// - `InvalidSecurityGroupName.Malformed`: Specified security group name is not valid.
    /// - `InvalidSecurityGroupDiscription.Malformed`: Specified security group description is not valid.
    /// - `InvalidParameter`: Invalid Parameter.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_security_group_attribute(
        &self,
        req: ModifySecurityGroupAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifySecurityGroupAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除安全组
    ///
    /// 本接口用于删除一个安全组，并关联删除组内所有安全组规则。
    ///
    /// -  请确保安全组内不存在ECS实例，您可以通过[DescribeInstances](~~2679689~~)进行查询。
    /// -  请确保安全组内不存在弹性网卡，您可以通过[DescribeNetworkInterfaces](~~2679884~~)进行查询。
    /// -  请确保没有其他安全组与该安全组有授权行为，您可以通过[DescribeSecurityGroupReferences](~~57320~~)进行查询。
    /// -  在您使用该接口删除安全组时若返回错误码`InvalidOperation.DeletionProtection`，说明开启了删除保护功能。创建ACK集群时，关联的安全组会开启删除保护功能，来防止误删除。删除保护功能无法手动关闭，只有在删除了关联的ACK集群后，才能够自动关闭。更多信息，请参见[关闭安全组删除保护](~~353191~~)。
    ///
    /// # Error Codes
    /// - `MissingParameter.RegionId`: The parameter "RegionId" should not be null.
    /// - `InvalidOperation.SecurityGroupNotAuthorized`: The specified security group is not authorized to operate.
    /// - `DependencyViolation`: There is still instance(s) in the specified security group.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidSecurityGroup.NotFound`: The specified security group is not found.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_security_group(
        &self,
        req: DeleteSecurityGroup,
    ) -> impl std::future::Future<Output = crate::Result<DeleteSecurityGroupResponse>> + Send {
        self.call(req)
    }

    /// # 增加安全组入方向规则
    ///
    /// 本接口是阿里云 ECS 中用于增加一条或多条安全组入方向规则的接口。通过该接口，用户可以指定安全组入方向的访问权限，允许或者拒绝其他设备发送入方向流量到安全组内的实例，从而实现对网络访问的精细控制。
    ///
    /// ### 使用须知
    /// - **数量限制：** 单张弹性网卡关联的所有安全组的规则（包括入方向规则与出方向规则）数量之和不能超过1000。具体限制请参见[安全组使用限制](~~25412#SecurityGroupQuota1~~)。  
    /// - **优先级设置：** 安全组入方向规则优先级（Priority）可选范围为1~100。数字越小，代表优先级越高，优先级相同的安全组规则，优先以拒绝访问（drop）的规则为准。
    ///
    /// ### 注意事项
    /// 如果指定的安全组规则已存在，此次调用成功，但不会增加规则。
    ///
    /// ### 规则确定方式
    ///
    /// 确定一条安全组入方向规则必要的一组相关参数：
    ///
    /// - 源端设置：选择SourceCidrIp（IPv4 地址）、Ipv6SourceCidrIp（IPv6 地址）、SourcetPrefixListId（前缀列表 ID）、SourceGroupId（源端安全组）中的一项。
    /// - 目的端口范围：PortRange。
    /// - 协议类型：IpProtocol。
    /// - 权限策略：Policy。
    ///
    /// > 企业安全组不支持授权其他安全组访问，普通安全组支持授权的安全组数量最多为 20 个。
    ///
    /// ### 请求示例
    ///
    /// 假设要在杭州地域下指定安全组中增加几条不同源端的入方向规则：
    ///
    ///   - 增加指定IP地址段的访问权限。
    ///
    /// ```ignore
    ///     "RegionId":"cn-hangzhou", //设置地域
    ///     "SecurityGroupId":"sg-bp67acfmxazb4p****", //设置安全组
    ///     "Permissions":[
    ///          {
    ///            "SourceCidrIp":"10.0.0.0/8", //设置源端IPv4 地址
    ///            "PortRange":"22/22", //设置端口范围
    ///            "IpProtocol":"TCP", //设置协议类型
    ///            "Policy":"Accept" //设置访问策略
    ///          }
    ///     ]
    ///     ```
    ///
    ///   - 增加一条其他安全组和一条前缀列表的访问权限。
    ///
    /// ```ignore
    ///     "RegionId":"cn-hangzhou",
    ///     "SecurityGroupId":"sg-bp67acfmxazb4p****",
    ///     "Permissions":[
    ///          {
    ///            "SourceGroupId":"sg-bp17vs63txqxbd****", //设置源端安全组
    ///            "PortRange":"22/22",
    ///            "IpProtocol":"TCP",
    ///            "Policy":"Drop"
    ///          },{
    ///            "SourcePrefixListId":"pl-x1j1k5ykzqlixdcy****", //设置源端前缀列表
    ///            "PortRange":"22/22",
    ///            "IpProtocol":"TCP",
    ///            "Policy":"Drop"
    ///          }
    ///     ]
    ///     ```
    ///
    /// # Error Codes
    /// - `OperationDenied`: The specified IpProtocol does not exist or IpProtocol and PortRange do not match.
    /// - `InvalidIpProtocol.Malformed`: The specified parameter PortRange is not valid.
    /// - `InvalidSourceCidrIp.Malformed`: The specified parameter SourceCidrIp is not valid.
    /// - `InvalidPolicy.Malformed`: The specified parameter Policy is not valid.
    /// - `InvalidNicType.ValueNotSupported`: The specified NicType does not exist.
    /// - `InvalidNicType.Mismatch`: The specified NicType conflicts with the authorization record.
    /// - `InvalidSourceGroupId.Mismatch`: Specified security group and source group are not in the same VPC.
    /// - `InvalidSourceGroup.NotFound`: Specified source security group does not exist.
    /// - `InvalidPriority.Malformed`: The parameter Priority is invalid.
    /// - `InvalidPriority.ValueNotSupported`: The specified parameter %s is invalid.
    /// - `InvalidSecurityGroupDiscription.Malformed`: The specified security group rule description parameter %s is not valid.
    /// - `InvalidSecurityGroup.InvalidNetworkType`: The specified security group network type is not support this operation, please check the security group network types. For VPC security groups, ClassicLink must be enabled.
    /// - `MissingParameter.Source`: One of the parameters SourceCidrIp, Ipv6SourceCidrIp, SourceGroupId or SourcePrefixListId in %s must be specified.
    /// - `InvalidParam.PortRange`: The specified parameter %s is not valid. It should be two integers less than 65535 in ?/? format.
    /// - `InvalidIpProtocol.ValueNotSupported`: The parameter %s must be specified with case insensitive TCP, UDP, ICMP, GRE or All.
    /// - `InvalidSecurityGroupId.Malformed`: The specified parameter SecurityGroupId is not valid.
    /// - `InvalidParamter.Conflict`: The specified SourceCidrIp should be different from the DestCidrIp.
    /// - `InvalidSourcePortRange.Malformed`: The specified parameter SourcePortRange is not valid.
    /// - `InvalidPortRange.Malformed`: The specified parameter PortRange must set.
    /// - `InvalidParam.SourceIp`: The Parameters SourceCidrIp and Ipv6SourceCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.DestIp`: The Parameters DestCidrIp and Ipv6DestCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.Ipv6DestCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv6SourceCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv4ProtocolConflictWithIpv6Address`: IPv6 address cannot be specified for IPv4-specific protocol.
    /// - `InvalidParam.Ipv6ProtocolConflictWithIpv4Address`: IPv4 address cannot be specified for IPv6-specific protocol.
    /// - `InvalidParameter.Ipv6CidrIp`: The specified Ipv6CidrIp is not valid.
    /// - `InvalidGroupAuthParameter.OperationDenied`: The security group can not authorize to enterprise level security group.
    /// - `InvalidDestCidrIp.Malformed`: The specified parameter DestCidrIp is not valid.
    /// - `InvalidParameter.Conflict`: IPv6 and IPv4 addresses cannot exist at the same time.
    /// - `InvalidParam.PrefixListAddressFamilyMismatch`: The address family of the specified prefix list does not match the specified CidrIp.
    /// - `NotSupported.ClassicNetworkPrefixList`: The prefix list is not supported when the network type of security group is classic.
    /// - `AuthorizedGroupRule.LimitExceed`: You have reached the limit on the number of group authorization rules that you can add to a security group.When authorization object of rule is security group, the limit is 20.
    /// - `InvalidParam.SourceCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.DestCidrIp`: The specified parameter %s is not valid.
    /// - `MissingParameter`: %s
    /// - `InvalidParam.Permissions`: The specified parameter Permissions cannot coexist with other parameters.
    /// - `InvalidParam.DuplicatePermissions`: There are duplicate permissions in the specified parameter Permissions.
    /// - `InvalidGroupParameter.OperationDenied`: The attributes Policy, SourceGroupId, DestGroupId of enterprise level security groups are not allowed to be set or modified.
    /// - `InvalidParam.ProtocolNotSupportPortRangeList`: The specified protocol does not support the port range list.
    /// - `InvalidPortRangeListId.NotFound`: The specified port range list was not found.
    /// - `InvalidOperation.SecurityGroupNotAuthorized`: The specified security group is not authorized to operate.
    /// - `InvalidSourceGroupId.Mismatch`: NicType is required or NicType expects intranet.
    /// - `MissingParameter`: The input parameter SourceGroupId or SourceCidrIp cannot be both blank.
    /// - `AuthorizationLimitExceed`: The limit of authorization records in the security group reaches.
    /// - `InvalidParamter.Conflict`: The specified SecurityGroupId should be different from the SourceGroupId.
    /// - `InvalidNetworkType.Mismatch`: The specified SecurityGroup network type should be same with SourceGroup network type (vpc or classic).
    /// - `InvalidNetworkType.Conflict`: The specified SecurityGroup network type should be same with SourceGroup network type (vpc or classic).
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `LimitExceed.PrefixListAssociationResource`: The number of resources associated with the prefix list exceeds the limit.
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `InvalidSourceGroupId.NotFound`: The SourceGroupId provided does not exist in our records.
    /// - `InvalidPrefixListId.NotFound`: The specified prefix list was not found.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn authorize_security_group(
        &self,
        req: AuthorizeSecurityGroup,
    ) -> impl std::future::Future<Output = crate::Result<AuthorizeSecurityGroupResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改安全组入方向规则
    ///
    /// 本接口用于修改指定安全组中的一条入方向安全组规则。
    ///
    /// 指定安全组规则ID修改安全组规则时，您需要注意以下使用限制：
    ///
    /// - 安全组规则的授权对象分为IPv4的CIDR地址块（或IP地址）、IPv6的CIDR地址块（或IP地址）、安全组、前缀列表，您不能通过该接口修改已有安全组规则的授权对象类型。如原来授权对象类型为IPv4的CIDR地址块，您可以更改为另一个IPv4的CIDR地址块（或IP地址），但不能修改为IPv6的CIDR地址块（或IP地址）、安全组或前缀列表。
    ///
    /// - 字段不支持从非空修改为空，如果需要修改建议先增加一条新规则，再删除当前规则。
    ///
    /// # Error Codes
    /// - `OperationDenied`: The specified IpProtocol does not exist or IpProtocol and PortRange do not match.
    /// - `InvalidIpProtocol.Malformed`: The specified parameter PortRange is not valid.
    /// - `InvalidSourceCidrIp.Malformed`: The specified parameter SourceCidrIp is not valid.
    /// - `InvalidPolicy.Malformed`: The specified parameter Policy is not valid.
    /// - `InvalidNicType.ValueNotSupported`: The specified NicType does not exist.
    /// - `InvalidNicType.Mismatch`: The specified NicType conflicts with the authorization record.
    /// - `InvalidSourceGroupId.Mismatch`: Specified security group and source group are not in the same VPC.
    /// - `InvalidSourceGroup.NotFound`: Specified source security group does not exist.
    /// - `InvalidPriority.Malformed`: The parameter Priority is invalid.
    /// - `InvalidPriority.ValueNotSupported`: The parameter Priority is invalid.
    /// - `InvalidSecurityGroupDiscription.Malformed`: The specified security group rule description is not valid.
    /// - `MissingParameter.Source`: One of the parameters SourceCidrIp, SourceGroupId or SourcePrefixListId must be specified.
    /// - `InvalidParam.PortRange`: The specified parameter %s is not valid. It should be two integers less than 65535 in ?/? format.
    /// - `InvalidIpProtocol.ValueNotSupported`: The parameter IpProtocol must be specified with case insensitive TCP, UDP, ICMP, GRE or All.
    /// - `InvalidParam.SourceIp`: The Parameters SourceCidrIp and Ipv6SourceCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.DestIp`: The Parameters DestCidrIp and Ipv6DestCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.Ipv6DestCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv6SourceCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv4ProtocolConflictWithIpv6Address`: IPv6 address cannot be specified for IPv4-specific protocol.
    /// - `InvalidParam.Ipv6ProtocolConflictWithIpv4Address`: IPv4 address cannot be specified for IPv6-specific protocol.
    /// - `InvalidParameter.Ipv6CidrIp`: The specified Ipv6CidrIp is not valid.
    /// - `InvalidParam.DestCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidSourcePortRange.Malformed`: The specified parameter SourcePortRange is not valid.
    /// - `InvalidSecurityGroupId.Malformed`: The specified parameter SecurityGroupId is not valid.
    /// - `InvalidParam.SourceCidrIp`: The specified param SourceCidrIp is not valid.
    /// - `InvalidParameter.Conflict`: IPv6 and IPv4 addresses cannot exist at the same time.
    /// - `InvalidParam.SecurityGroupRuleId`: The specified parameter SecurityGroupRuleId is not valid.
    /// - `InvalidOperation.ModifySgRuleEntityType`: The source or destination type of the rules cannot be modified.
    /// - `AuthorizationLimitExceed`: The limit of authorization records in the security group reaches.
    /// - `InvalidParam.ProtocolAndPortRangeMismatch`: The specified Protocol and PortRange do not match.
    /// - `InvalidParam.ProtocolAndAddressFamilyMismatch`: The specified Protocol and address family do not match.
    /// - `InvalidParam.PrefixListAddressFamilyMismatch`: The address family of the prefix list does not match the rule.
    /// - `InvalidParam.InvalidModifyRuleRequest`: The request parameters are illegal.
    /// - `InvalidOperation.ModifyNicType`: NicType is not allowed to modify.
    /// - `InvalidParamter.Conflict`: The specified SourceCidrIp should be different from the DestCidrIp.
    /// - `InvalidOperation.RuleDuplicate`: %s.
    /// - `InvalidParam.ProtocolNotSupportPortRangeList`: The specified protocol does not support the port range list.
    /// - `InvalidSourceOrDestGroupId.DirectionMissmatch`: The specified SourceGroupId or DestGroupId does not match the direction of the rule.
    /// - `InvalidOperation.ModifyPortRangeType`: The PortRange type is not allowed to be modified. You cannot modify a rule from using the port list to not using it, and vice versa.
    /// - `InvalidPortRangeListId.NotFound`: The specified port range list was not found.
    /// - `InvalidSourceGroupId.Mismatch`: NicType is required or NicType expects intrnet.
    /// - `MissingParameter`: The input parameter SourceGroupId or SourceCidrIp cannot be both blank.
    /// - `AuthorizationLimitExceed`: The limit of authorization records in the security group reaches.
    /// - `InvalidParamter.Conflict`: The specified SecurityGroupId should be different from the SourceGroupId.
    /// - `InvalidNetworkType.Mismatch`: The specified SecurityGroup network type should be same with SourceGroup network type (vpc or classic).
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `InvalidSourceGroupId.NotFound`: The SourceGroupId provided does not exist in our records.
    /// - `SecurityGroupRule.NotFound`: The target security group rule not exist.
    /// - `InvalidPrefixListId.NotFound`: The specified prefix list was not found.
    /// - `InvalidSecurityGroupRuleId.NotFound`: The specified SecurityGroupRuleId is not exists.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_security_group_rule(
        &self,
        req: ModifySecurityGroupRule,
    ) -> impl std::future::Future<Output = crate::Result<ModifySecurityGroupRuleResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除安全组入方向规则
    ///
    /// 本接口用于删除指定安全组内的一条或多条入方向安全组规则。
    ///
    /// ><notice>阿里云已于2024年7月8日对该接口进行了校验规则调整。当删除不存在的安全组规则时，从返回成功调整为返回错误码：“InvalidParam.SecurityGroupRuleId“。请您及时做好错误码兼容，避免影响线上业务。></notice>
    /// 该接口存在两种传参方式来删除规则：
    /// - 通过指定安全组规则ID参数删除规则（推荐）。
    ///      - 如果指定的安全组规则ID不存在，接口调用将失败。
    ///
    /// - 通过指定Permissions删除规则。
    ///     - 如果匹配的安全组规则不存在，此次调用成功，但不会删除规则。
    ///     - 确定一条安全组入方向规则必要的一组相关参数：
    ///       - 源端设置：选择SourceCidrIp（IPv4 地址）、Ipv6SourceCidrIp（IPv6 地址）、SourcetPrefixListId（前缀列表 ID）、SourceGroupId（源端安全组）中的一项。
    ///       - 目的端口范围：PortRange。
    ///       - 协议类型：IpProtocol。
    ///       - 权限策略：Policy。
    ///
    /// > 不支持同时设置安全组规则ID和Permissions参数。
    ///
    /// ### 请求示例
    /// - 根据指定安全组规则ID删除。
    /// ```ignore
    /// "SecurityGroupId":"sg-bp67acfmxazb4p****", //设置安全组ID
    /// "SecurityGroupRuleId":["sgr-bpdfmk****","sgr-bpdfmg****"] //设置安全组规则ID
    /// ```
    ///
    /// - 根据指定IP地址段删除。
    /// ```ignore
    /// "SecurityGroupId":"sg-bp67acfmxazb4p****",
    /// "Permissions":[
    ///   {
    ///     "SourceCidrIp":"10.0.0.0/8", //设置源端IP地址段
    ///     "IpProtocol":"TCP", //设置协议类型
    ///     "PortRange":"80/80", //设置目的端口范围
    ///     "Policy":"accept" //设置访问策略
    ///   }
    /// ]
    /// ```
    ///
    /// - 根据其他安全组删除。
    /// ```ignore
    /// "SecurityGroupId":"sg-bp67acfmxazb4p****",
    /// "Permissions":[
    ///   {
    ///     "SourceGroupId":"sg-bp67acfmxa123b****", //设置源端安全组ID
    ///     "IpProtocol":"TCP,"
    ///     "PortRange":"80/80",
    ///     "Policy":"accept"
    ///   ]
    /// }
    /// ```
    /// - 根据指定前缀列表删除。
    /// ```ignore
    /// "SecurityGroupId":"sg-bp67acfmxazb4p****",
    /// "Permissions":[
    ///   {
    ///     "SourcePrefixListId":pl-x1j1k5ykzqlixdcy****", //设置源端前缀列表ID
    ///     "IpProtocol":"TCP",
    ///     "PortRange":"80/80",
    ///     "Policy":"accept"
    ///   }
    /// ]
    /// ```
    ///
    /// # Error Codes
    /// - `InvalidSecurityGroupId.Malformed`: The specified parameter SecurityGroupId is not valid.
    /// - `InvalidIpProtocol.ValueNotSupported`: The parameter IpProtocol must be specified with case insensitive TCP, UDP, ICMP, GRE or All.
    /// - `InvalidIpPortRange.Malformed`: The specified parameter PortRange is not valid.
    /// - `InvalidSourceCidrIp.Malformed`: The specified parameter SourceCidrIp is not valid.
    /// - `MissingParameter`: The input parameter SourceGroupId or SourceCidrIp cannot be both blank.
    /// - `InvalidPolicy.Malformed`: The specified parameter %s is not valid.
    /// - `InvalidNicType.ValueNotSupported`: The specified parameter %s is not valid.
    /// - `InvalidSourceGroupId.Mismatch`: Specified security group and source group are not in the same VPC.
    /// - `MissingParameter.Source`: One of the parameters SourceCidrIp, Ipv6SourceCidrIp, SourceGroupId or SourcePrefixListId in %s must be specified.
    /// - `InvalidParam.PortRange`: The specified parameter %s is not valid. It should be two integers less than 65535 in ?/? format.
    /// - `InvalidPriority.Malformed`: The parameter Priority is invalid.
    /// - `InvalidPriority.ValueNotSupported`: The specified parameter %s is invalid.
    /// - `InvalidParamter.Conflict`: The specified SecurityGroupId should be different from the SourceGroupId.
    /// - `InvalidDestCidrIp.Malformed`: The specified parameter DestCidrIp is not valid.
    /// - `InvalidParam.SourceIp`: The Parameters SourceCidrIp and Ipv6SourceCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.DestIp`: The Parameters DestCidrIp and Ipv6DestCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.Ipv6DestCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv6SourceCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv4ProtocolConflictWithIpv6Address`: IPv6 address cannot be specified for IPv4-specific protocol.
    /// - `InvalidParam.Ipv6ProtocolConflictWithIpv4Address`: IPv4 address cannot be specified for IPv6-specific protocol.
    /// - `InvalidParameter.Ipv6CidrIp`: The specified Ipv6CidrIp is not valid.
    /// - `InvalidGroupAuthParameter.OperationDenied`: The security group can not authorize to enterprise level security group.
    /// - `InvalidPortRange.Malformed`: The specified parameter PortRange must set.
    /// - `InvalidSourcePortRange.Malformed`: The specified parameter SourcePortRange is not valid.
    /// - `InvalidSecurityGroupDiscription.Malformed`: The specified security group rule description is not valid.
    /// - `NotSupported.ClassicNetworkPrefixList`: The prefix list is not supported when the network type of security group is classic.
    /// - `InvalidParam.SourceCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.DestCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Permissions`: The specified parameter Permissions cannot coexist with other parameters.
    /// - `InvalidParam.DuplicatePermissions`: There are duplicate permissions in the specified parameter Permissions.
    /// - `InvalidSecurityGroupId.NotFound`: The specified parameter SecurityGroupId is not valid.
    /// - `InvalidParam.SecurityGroupRuleId`: The specified parameter SecurityGroupRuleId is not valid.
    /// - `InvalidParam.SecurityGroupRuleIdRepeated`: The specified parameter SecurityGroupRuleId is repeated.
    /// - `InvalidGroupParameter.OperationDenied`: The attributes Policy, SourceGroupId, DestGroupId of enterprise level security groups are not allowed to be set or modified.
    /// - `InvalidSecurityGroupRule.RuleNotExist`: The specified rule does not exist.
    /// - `InvalidParam.ProtocolNotSupportPortRangeList`: The specified protocol does not support the port range list.
    /// - `InvalidPortRangeListId.NotFound`: The specified port range list was not found.
    /// - `InvalidOperation.SecurityGroupNotAuthorized`: The specified security group is not authorized to operate.
    /// - `InvalidNicType.Mismatch`: The specified NicType conflicts with the authorization record.
    /// - `InvalidGroupAuthItem.NotFound`: Specified group authorized item does not exist in our records.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `InvalidSourceGroupId.NotFound`: The SourceGroupId provided does not exist in our records.
    /// - `InvalidPrefixListId.NotFound`: The specified prefix list was not found.
    /// - `InvalidSecurityGroupRuleId.NotFound`: The specified SecurityGroupRuleId is not exists.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn revoke_security_group(
        &self,
        req: RevokeSecurityGroup,
    ) -> impl std::future::Future<Output = crate::Result<RevokeSecurityGroupResponse>> + Send {
        self.call(req)
    }

    /// # 增加安全组出方向规则
    ///
    /// 本接口是阿里云 ECS 中用于增加一条或多条安全组出方向规则的接口。通过该接口，用户可以指定安全组出方向的访问权限，允许或拒绝安全组内的实例发送出方向流量到其他设备，从而实现对网络访问的精细控制。
    ///
    /// ### 使用须知
    /// - **数量限制：** 单张弹性网卡关联的所有安全组的规则（包括入方向规则与出方向规则）数量之和不能超过1000。具体限制请参见[安全组使用限制](~~25412#SecurityGroupQuota1~~)。  
    /// - **优先级设置：** 安全组出方向规则优先级（Priority）可选范围为1~100。数字越小，代表优先级越高，优先级相同的安全组规则，优先以拒绝访问（drop）的规则为准。
    ///
    /// ### 注意事项
    /// 如果指定的安全组规则已存在，此次调用成功，但不会增加规则。
    ///
    ///
    /// ### 规则确定方式
    ///
    /// 确定一条安全组出方向规则必要的一组相关参数：
    ///
    /// - 目的端设置：选择DestCidrIp（IPv4 地址）、Ipv6DestCidrIp（IPv6 地址）、DestPrefixListId（前缀列表 ID）、DestGroupId（目的端安全组）中的一项。
    /// - 目的端口范围：PortRange。
    /// - 协议类型：IpProtocol。
    /// - 权限策略：Policy。
    ///
    /// > 企业安全组不支持授权其他安全组访问，普通安全组支持授权的安全组数量最多为 20 个。
    ///
    /// ### 请求示例
    ///
    /// 假设要在杭州地域下指定安全组中增加几条不同目的端的出方向规则：
    ///
    ///   - 增加指定IP地址段的访问权限。
    ///
    /// ```ignore
    ///     "RegionId":"cn-hangzhou",  //设置地域
    ///     "SecurityGroupId":"sg-bp17vs63txqxbds9***", //设置安全组
    ///     "Permissions":[
    ///          {
    ///            "DestCidrIp":"10.0.0.0/8", //设置目的端IPv4 地址
    ///            "PortRange":"-1/-1", //设置端口范围
    ///            "IpProtocol":"ICMP", //设置协议类型
    ///            "Policy":"Accept" //设置访问策略
    ///          }
    ///     ]
    ///     ```
    ///
    ///   - 增加一条其他安全组和一条前缀列表的访问权限。
    ///
    /// ```ignore
    ///     "RegionId":"cn-hangzhou",
    ///     "SecurityGroupId":"sg-bp17vs63txqxbds9***",
    ///     "Permissions":[
    ///          {
    ///            "DestGroupId":"sg-bp67acfmxazb4pi***", //设置目的端安全组
    ///            "PortRange":"22/22",
    ///            "IpProtocol":"TCP",
    ///            "Policy":"Drop"
    ///          },{
    ///            "DestPrefixListId":"pl-x1j1k5ykzqlixdcy****", //设置目的端前缀列表
    ///            "PortRange":"22/22",
    ///            "IpProtocol":"TCP",
    ///            "Policy":"Drop"
    ///          }
    ///     ]
    ///     ```
    ///
    /// # Error Codes
    /// - `OperationDenied`: The specified IpProtocol does not exist or IpProtocol and PortRange do not match.
    /// - `InvalidIpProtocol.Malformed`: The specified parameter PortRange is not valid.
    /// - `InvalidDestCidrIp.Malformed`: The specified parameter DestCidrIp is not valid.
    /// - `InvalidPolicy.Malformed`: The specified parameter Policy is not valid.
    /// - `InvalidNicType.ValueNotSupported`: The specified NicType does not exist.
    /// - `InvalidNicType.Mismatch`: The specified NicType conflicts with the authorization record.
    /// - `InvalidDestGroupId.Mismatch`: Specified security group and destination group are not in the same VPC.
    /// - `InvalidDestGroup.NotFound`: Specified destination security group does not exist.
    /// - `InvalidPriority.Malformed`: The parameter Priority is invalid.
    /// - `InvalidPriority.ValueNotSupported`: The specified parameter %s is invalid.
    /// - `InvalidSecurityGroupDiscription.Malformed`: The specified security group rule description parameter %s is not valid.
    /// - `InvalidSecurityGroup.InvalidNetworkType`: The specified security group network type is not support this operation, please check the security group network types. For VPC security groups, ClassicLink must be enabled.
    /// - `MissingParameter.Dest`: One of the parameters DestCidrIp, Ipv6DestCidrIp, DestGroupId or DestPrefixListId in %s must be specified.
    /// - `InvalidParam.PortRange`: The specified parameter %s is not valid. It should be two integers less than 65535 in ?/? format.
    /// - `InvalidIpProtocol.ValueNotSupported`: The parameter %s must be specified with case insensitive TCP, UDP, ICMP, GRE or All.
    /// - `InvalidSecurityGroupId.Malformed`: The specified parameter SecurityGroupId is not valid.
    /// - `InvalidParamter.Conflict`: The specified SourceCidrIp should be different from the DestCidrIp.
    /// - `InvalidSourcePortRange.Malformed`: The specified parameter SourcePortRange is not valid.
    /// - `InvalidPortRange.Malformed`: The specified parameter PortRange must set.
    /// - `InvalidParam.SourceIp`: The Parameters SourceCidrIp and Ipv6SourceCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.DestIp`: The Parameters DestCidrIp and Ipv6DestCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.Ipv6DestCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv6SourceCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv4ProtocolConflictWithIpv6Address`: IPv6 address cannot be specified for IPv4-specific protocol.
    /// - `InvalidParam.Ipv6ProtocolConflictWithIpv4Address`: IPv4 address cannot be specified for IPv6-specific protocol.
    /// - `InvalidParameter.Ipv6CidrIp`: The specified Ipv6CidrIp is not valid.
    /// - `InvalidGroupAuthParameter.OperationDenied`: The security group can not authorize to enterprise level security group.
    /// - `InvalidParameter.Conflict`: IPv6 and IPv4 addresses cannot exist at the same time.
    /// - `InvalidParam.PrefixListAddressFamilyMismatch`: The address family of the specified prefix list does not match the specified CidrIp.
    /// - `NotSupported.ClassicNetworkPrefixList`: The prefix list is not supported when the network type of security group is classic.
    /// - `AuthorizedGroupRule.LimitExceed`: You have reached the limit on the number of group authorization rules that you can add to a security group.When authorization object of rule is security group, the limit is 20.
    /// - `InvalidParam.DestCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.SourceCidrIp`: The specified param SourceCidrIp is not valid.
    /// - `InvalidParam.Permissions`: The specified parameter Permissions cannot coexist with other parameters.
    /// - `InvalidParam.DuplicatePermissions`: There are duplicate permissions in the specified parameter Permissions.
    /// - `InvalidGroupParameter.OperationDenied`: The attributes Policy, SourceGroupId, DestGroupId of enterprise level security groups are not allowed to be set or modified.
    /// - `InvalidParam.ProtocolNotSupportPortRangeList`: The specified protocol does not support the port range list.
    /// - `InvalidPortRangeListId.NotFound`: The specified port range list was not found.
    /// - `InvalidOperation.SecurityGroupNotAuthorized`: The specified security group is not authorized to operate.
    /// - `InvalidDestGroupId.Mismatch`: NicType is required or NicType expects intranet.
    /// - `MissingParameter`: The input parameter DestGroupId or DestCidrIp cannot be both blank.
    /// - `AuthorizationLimitExceed`: The limit of authorization records in the security group reaches.
    /// - `InvalidParamter.Conflict`: The specified SecurityGroupId should be different from the SourceGroupId.
    /// - `InvalidNetworkType.Conflict`: The specified SecurityGroup network type should be same with SourceGroup network type (vpc or classic).
    /// - `InvalidSecurityGroup.IsSame`: The authorized SecurityGroupId should be different from the DestGroupId.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `LimitExceed.PrefixListAssociationResource`: The number of resources associated with the prefix list exceeds the limit.
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `InvalidDestGroupId.NotFound`: The DestGroupId provided does not exist in our records.
    /// - `InvalidPrefixListId.NotFound`: The specified prefix list was not found.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn authorize_security_group_egress(
        &self,
        req: AuthorizeSecurityGroupEgress,
    ) -> impl std::future::Future<Output = crate::Result<AuthorizeSecurityGroupEgressResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改安全组出方向规则
    ///
    /// 本接口用于修改一条出方向安全组规则。
    ///
    /// 指定安全组规则ID修改安全组规则时，您需要注意以下使用限制：
    ///
    /// - 安全组规则的授权对象分为IPv4的CIDR地址块（或IP地址）、IPv6的CIDR地址块（或IP地址）、安全组、前缀列表，您不能通过该接口修改已有安全组规则的授权对象类型。如原来授权对象类型为IPv4的CIDR地址块，您可以更改为另一个IPv4的CIDR地址块（或IP地址），但不能修改为IPv6的CIDR地址块（或IP地址）、安全组或前缀列表。
    /// - 字段不支持从非空修改为空，如果需要修改建议先增加一条新规则，再删除当前规则。
    ///
    /// # Error Codes
    /// - `OperationDenied`: The specified IpProtocol does not exist or IpProtocol and PortRange do not match.
    /// - `InvalidIpProtocol.Malformed`: The specified parameter PortRange is not valid.
    /// - `InvalidDestCidrIp.Malformed`: The specified parameter DestCidrIp is not valid.
    /// - `InvalidPolicy.Malformed`: The specified parameter Policy is not valid.
    /// - `InvalidNicType.ValueNotSupported`: The specified NicType does not exist.
    /// - `InvalidNicType.Mismatch`: The specified NicType conflicts with the authorization record.
    /// - `InvalidDestGroupId.Mismatch`: Specified security group and destination group are not in the same VPC.
    /// - `InvalidDestGroup.NotFound`: Specified destination security group does not exist.
    /// - `InvalidPriority.Malformed`: The specified parameter Priority is not valid.
    /// - `InvalidPriority.ValueNotSupported`: The specified Priority is invalid.
    /// - `InvalidSecurityGroupDiscription.Malformed`: The specified security group rule description is not valid.
    /// - `InvalidSecurityGroup.InvalidNetworkType`: The specified security group network type is not support this operation, please check the security group network types. For VPC security groups, ClassicLink must be enabled.
    /// - `MissingParameter.Dest`: One of the parameters DestCidrIp, DestGroupId or DestPrefixListId must be specified.
    /// - `InvalidParam.PortRange`: The specified parameter %s is not valid. It should be two integers less than 65535 in ?/? format.
    /// - `InvalidIpProtocol.ValueNotSupported`: The specified parameter IpProtocol should not be null and only tcp, udp, icmp, gre or all is supported. Ignore case.
    /// - `InvalidParam.SourceIp`: The Parameters SourceCidrIp and Ipv6SourceCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.DestIp`: The Parameters DestCidrIp and Ipv6DestCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.Ipv6DestCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv6SourceCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv4ProtocolConflictWithIpv6Address`: IPv6 address cannot be specified for IPv4-specific protocol.
    /// - `InvalidParam.Ipv6ProtocolConflictWithIpv4Address`: IPv4 address cannot be specified for IPv6-specific protocol.
    /// - `InvalidParameter.Ipv6CidrIp`: The specified Ipv6CidrIp is not valid.
    /// - `InvalidSourcePortRange.Malformed`: The specified parameter SourcePortRange is not valid.
    /// - `InvalidParam.SourceCidrIp`: The specified param SourceCidrIp is not valid.
    /// - `InvalidParam.DestCidrIp`: The specified param DestCidrIp is not valid.
    /// - `InvalidParameter.Conflict`: IPv6 and IPv4 addresses cannot exist at the same time.
    /// - `InvalidParam.SecurityGroupRuleId`: The specified parameter SecurityGroupRuleId is not valid.
    /// - `InvalidOperation.ModifySgRuleEntityType`: The source or destination type of the rules cannot be modified.
    /// - `AuthorizationLimitExceed`: The limit of authorization records in the security group reaches.
    /// - `InvalidPrefixListId.NotFound`: The specified prefix list was not found.
    /// - `InvalidParam.ProtocolAndPortRangeMismatch`: The specified Protocol and PortRange do not match.
    /// - `InvalidParam.ProtocolAndAddressFamilyMismatch`: The specified Protocol and address family do not match.
    /// - `InvalidParam.PrefixListAddressFamilyMismatch`: The address family of the prefix list does not match the rule.
    /// - `InvalidParam.InvalidModifyRuleRequest`: The request parameters are illegal.
    /// - `InvalidOperation.ModifyNicType`: NicType is not allowed to modify.
    /// - `InvalidParamter.Conflict`: The specified SourceCidrIp should be different from the DestCidrIp.
    /// - `InvalidOperation.RuleDuplicate`: %s.
    /// - `InvalidParam.ProtocolNotSupportPortRangeList`: The specified protocol does not support the port range list.
    /// - `InvalidSourceOrDestGroupId.DirectionMissmatch`: The specified SourceGroupId or DestGroupId does not match the direction of the rule.
    /// - `InvalidOperation.ModifyPortRangeType`: The PortRange type is not allowed to be modified. You cannot modify a rule from using the port list to not using it, and vice versa.
    /// - `InvalidPortRangeListId.NotFound`: The specified port range list was not found.
    /// - `InvalidDestGroupId.Mismatch`: NicType is required or NicType expects intranet.
    /// - `MissingParameter`: The input parameter DestGroupId or DestCidrIp cannot be both blank.
    /// - `AuthorizationLimitExceed`: The limit of authorization records in the security group reaches.
    /// - `InvalidParamter.Conflict`: The specified SecurityGroupId should be different from the SourceGroupId.
    /// - `InvalidNetworkType.Conflict`: The specified SecurityGroup network type should be same with SourceGroup network type (vpc or classic).
    /// - `InvalidSecurityGroup.IsSame`: The authorized SecurityGroupId should be different from the DestGroupId.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `InvalidDestGroupId.NotFound`: The DestGroupId provided does not exist in our records.
    /// - `SecurityGroupRule.NotFound`: The target security group rule do not exist.
    /// - `InvalidPrefixListId.NotFound`: The specified prefix list was not found.
    /// - `InvalidSecurityGroupRuleId.NotFound`: The specified SecurityGroupRuleId is not exists.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_security_group_egress_rule(
        &self,
        req: ModifySecurityGroupEgressRule,
    ) -> impl std::future::Future<Output = crate::Result<ModifySecurityGroupEgressRuleResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除出方向安全组规则
    ///
    /// 本接口用于删除指定安全组内的一条或多条出方向安全组规则。
    ///
    /// ><notice>阿里云已于2024年7月8日对该接口进行了校验规则调整。当删除不存在的安全组规则时，从返回成功调整为返回错误码：“InvalidSecurityGroupRule.RuleNotExist“。请您及时做好错误码兼容，避免影响线上业务。></notice>
    /// 该接口有两种传参方式来删除安全组规则：
    /// - 通过指定安全组规则ID参数删除规则（推荐）。
    ///   - 如果指定的安全组规则ID不存在，会报异常。
    ///
    /// - 通过指定Permissions参数删除规则。
    ///     - 如果匹配的安全组规则不存在，此次调用成功，但不会删除规则。
    ///     - 删除一条安全组规则必要的相关参数：
    ///       - 目的端设置：选择 DestCidrIp（IPv4 地址）、Ipv6DestCidrIp（IPv6 地址）、DestPrefixListId（前缀列表 ID）、DestGroupId（目的端安全组）中的一项。
    ///       - 目的端口范围：PortRange。
    ///       - 协议类型：IpProtocol。
    ///       - 权限策略：Policy。
    ///
    /// > 不支持同时设置安全组规则ID和Permissions参数。
    ///
    /// ### 请求示例
    /// - 根据安全组规则ID删除。
    /// ```ignore
    /// "SecurityGroupId":"sg-bp67acfmxazb4p****", //设置安全组ID
    /// "SecurityGroupRuleId":["sgr-bpdfmk****","sgr-bpdfmg****"] //设置安全组规则ID
    /// ```
    ///
    /// - 根据IP地址段删除。
    /// ```ignore
    /// "SecurityGroupId":"sg-bp67acfmxazb4ph***",
    /// "Permissions":[
    ///   {
    ///     "IpProtocol":"TCP", //设置协议类型
    ///     "DestCidrIp":"10.0.0.0/8", //设置目的端IP地址段
    ///     "PortRange":"22/22", //设置目的端口范围
    ///     "Policy":"accept" // 设置访问策略
    ///   }
    /// ]
    /// ```
    ///     
    /// - 根据目的端安全组删除。
    /// ```ignore
    /// "SecurityGroupId":"sg-bp67acfmxazb4ph***",
    /// "Permissions":[
    ///   {
    ///     "DestGroupId":"sg-bp67acfmxa123b****", //设置目的端安全组ID
    ///     "IpProtocol":"TCP",
    ///     "PortRange":"22/22",
    ///     "Policy":"accept"
    ///   }
    /// ]
    /// ```
    ///
    /// - 根据指定前缀列表删除。
    /// ```ignore
    /// "SecurityGroupId":"sg-bp67acfmxazb4ph***",
    /// "Permissions":[
    ///   {
    ///     "IpProtocol":"TCP",
    ///     "DestPrefixListId":"pl-x1j1k5ykzqlixdcy****", //设置目的端前缀列表ID
    ///     "PortRange":"22/22",
    ///     "Policy":"accept",
    ///   }
    /// ]
    /// ```
    ///
    /// # Error Codes
    /// - `InvalidIpProtocol.ValueNotSupported`: The parameter IpProtocol must be specified with case insensitive TCP, UDP, ICMP, GRE or All.
    /// - `InvalidIpPortRange.Malformed`: The specified parameter PortRange is not valid.
    /// - `InvalidDestCidrIp.sMalformed`: The specified parameter DestCidrIp is not valid.
    /// - `MissingParameter`: The input parameter DestGroupId or DestCidrIp cannot be both blank.
    /// - `InvalidPolicy.Malformed`: The specified parameter %s is not valid.
    /// - `InvalidNicType.ValueNotSupported`: The specified parameter %s is not valid.
    /// - `InvalidDestGroupId.Mismatch`: Specified security group and destination group are not in the same VPC.
    /// - `InvalidDestCidrIp.Malformed`: The specified parameter DestCidrIp is not valid.
    /// - `MissingParameter.Dest`: One of the parameters DestCidrIp, Ipv6DestCidrIp, DestGroupId or DestPrefixListId in %s must be specified.
    /// - `InvalidParam.PortRange`: The specified parameter %s is not valid. It should be two integers less than 65535 in ?/? format.
    /// - `InvalidPriority.Malformed`: The parameter Priority is invalid.
    /// - `InvalidPriority.ValueNotSupported`: The specified parameter %s is invalid.
    /// - `InvalidParam.SourceIp`: The Parameters SourceCidrIp and Ipv6SourceCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.DestIp`: The Parameters DestCidrIp and Ipv6DestCidrIp in %s cannot be set at the same time.
    /// - `InvalidParam.Ipv6DestCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv6SourceCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Ipv4ProtocolConflictWithIpv6Address`: IPv6 address cannot be specified for IPv4-specific protocol.
    /// - `InvalidParam.Ipv6ProtocolConflictWithIpv4Address`: IPv4 address cannot be specified for IPv6-specific protocol.
    /// - `InvalidParameter.Ipv6CidrIp`: The specified Ipv6CidrIp is not valid.
    /// - `InvalidGroupAuthParameter.OperationDenied`: The security group can not authorize to enterprise level security group.
    /// - `InvalidSecurityGroupId.Malformed`: The specified parameter SecurityGroupId is not valid.
    /// - `InvalidPortRange.Malformed`: The specified parameter PortRange must set.
    /// - `InvalidSourcePortRange.Malformed`: The specified parameter SourcePortRange is not valid.
    /// - `InvalidSecurityGroupDiscription.Malformed`: The specified security group rule description is not valid.
    /// - `NotSupported.ClassicNetworkPrefixList`: The prefix list is not supported when the network type of security group is classic.
    /// - `InvalidParam.SourceCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.DestCidrIp`: The specified parameter %s is not valid.
    /// - `InvalidParam.Permissions`: The specified parameter Permissions cannot coexist with other parameters.
    /// - `InvalidParam.DuplicatePermissions`: There are duplicate permissions in the specified parameter Permissions.
    /// - `InvalidParam.SecurityGroupRuleId`: The specified parameter SecurityGroupRuleId is not valid.
    /// - `InvalidParam.SecurityGroupRuleIdRepeated`: The specified parameter SecurityGroupRuleId is repeated.
    /// - `InvalidGroupParameter.OperationDenied`: The attributes Policy, SourceGroupId, DestGroupId of enterprise level security groups are not allowed to be set or modified.
    /// - `InvalidSecurityGroupRule.RuleNotExist`: The specified rule does not exist.
    /// - `InvalidParam.ProtocolNotSupportPortRangeList`: The specified protocol does not support the port range list.
    /// - `InvalidPortRangeListId.NotFound`: The specified port range list was not found.
    /// - `InvalidOperation.SecurityGroupNotAuthorized`: The specified security group is not authorized to operate.
    /// - `InvalidNicType.Mismatch`: Specified nic type conflicts with the authorization record.
    /// - `InvalidGroupAuthItem.NotFound`: Specified group authorized item does not exist in our records.
    /// - `InvalidSecurityGroup.IsSame`: The authorized SecurityGroupId should be different from the DestGroupId.
    /// - `InvalidParamter.Conflict`: The specified SecurityGroupId should be different from the SourceGroupId.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `InvalidDestGroupId.NotFound`: The DestGroupId provided does not exist in our records.
    /// - `InvalidSecurityGroupRuleId.NotFound`: The specified SecurityGroupRuleId is not exists.
    /// - `InvalidPrefixListId.NotFound`: The specified prefix list was not found.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn revoke_security_group_egress(
        &self,
        req: RevokeSecurityGroupEgress,
    ) -> impl std::future::Future<Output = crate::Result<RevokeSecurityGroupEgressResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询被授权的安全组列表
    ///
    /// 本接口用于查询一个或多个指定安全组已经被授权的其他安全组列表信息。
    ///
    /// -  当您无法删除某一安全组（[DeleteSecurityGroup](~~25558~~)）时，可以调用该接口查看指定的安全组是否已被其他安全组授权。如果指定的安全组已被授权，您可以通过[RevokeSecurityGroup](~~2679855~~)和[RevokeSecurityGroupEgress](~~2679856~~)删除对应的安全组规则来解除授权行为。
    ///
    /// # Error Codes
    /// - `InvalidSecurityGroupId.Malformed`: The specified parameter SecurityGroupId is essential and size should less than 10
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidSecurityGroupId.NotFound`: The SecurityGroupId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_security_group_references(
        &self,
        req: DescribeSecurityGroupReferences,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSecurityGroupReferencesResponse>> + Send
    {
        self.call(req)
    }

    /// # 加入安全组
    ///
    /// 本接口用于将一台ECS实例或一张弹性网卡加入到指定的安全组。
    ///
    /// > 该API已不推荐使用。推荐您调用[ModifyInstanceAttribute](~~25503~~)接口将ECS实例加入或移除安全组；调用[ModifyNetworkInterfaceAttribute](~~58513~~)接口将弹性网卡（ENI）加入或移除安全组。
    /// - 该接口不支持同时将实例和弹性网卡加入一个安全组，即参数`InstanceId`和`NetworkInterfaceId`不能同时传值。
    /// -  您的安全组和实例必须属于同一个阿里云地域。
    /// -  您的安全组和实例的网络类型必须相同。如果网络类型为专有网络VPC，则安全组和实例必须属于同一个VPC。
    /// -  加入安全组之前，实例必须处于**已停止**（Stopped）或者**运行中**（Running）状态。
    /// - 一台实例或一张弹性网卡最多可以加入五个安全组。更多信息，请参见[安全组使用限制](~~25412#SecurityGroupQuota1~~)。
    ///
    /// # Error Codes
    /// - `InstanceSecurityGroupLimitExceeded`: Exceeding the allowed amount of security groups that an instance can be in.
    /// - `InvalidInstanceId.Mismatch`: Specified instance and security group are not in the same VPC.
    /// - `InvalidInstanceId.Malformed`: The specified parameter "InstanceId" is not valid.
    /// - `InvalidOperation.NotSupportEnterpriseGroup`: The specified instance type doesn't support enterprise level security group.
    /// - `InvalidOperation.MultiGroupType`: The specified instance can't join different types of security group.
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidOperation.EniAndGroupNotBelongSameUser`: %s
    /// - `NotBelongUser`: %s
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidStatus.EniOrInstanceIsBeingCreated`: %s.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `SecurityGroupInstanceLimitExceeded`: The maximum number of instances in a security group is exceeded.
    /// - `InvalidInstanceId.AlreadyExists`: The specified instance already exists in the specified security group.
    /// - `AclLimitExceed`: %s
    /// - `InstanceSecurityGroupLimitExceeded`: %s
    /// - `InvalidOperation.NetworkInterfaceCountExceeded`: The maximum number of NetworkInterface in a enterprise level security group is exceeded.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `InvalidOperation.VpcMismatch`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `InvalidParam.Malformed`: %s
    /// - `InvalidParam.EniIdAndInstanceId.Conflict`: %s
    /// - `Forbidden.InstanceIsBeingCreated`: The specified instance is being created.
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidEniId.NotFound`: %s
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn join_security_group(
        &self,
        req: JoinSecurityGroup,
    ) -> impl std::future::Future<Output = crate::Result<JoinSecurityGroupResponse>> + Send {
        self.call(req)
    }

    /// # 移出安全组
    ///
    /// 本接口用于将一台ECS实例或一张弹性网卡移出指定的安全组。
    ///
    /// > 该API已不推荐使用。推荐您调用[ModifyInstanceAttribute](~~25503~~)接口将ECS实例加入或移除安全组；调用[ModifyNetworkInterfaceAttribute](~~58513~~)接口将弹性网卡（ENI）加入或移除安全组。
    ///
    /// ><notice>阿里云已于2024年7月8日对该接口进行了校验规则调整。当移除不在组内的实例或者网卡时，从返回成功调整为返回错误码：“InvalidSecurityGroupAssociation.NotFound”。请您及时做好错误码兼容，避免影响线上业务。></notice>
    /// - 不支持同时将实例和弹性网卡移出一个安全组，即参数`InstanceId`和`NetworkInterfaceId`不能同时传值。
    /// -  移出安全组之前，实例必须处于**已停止**（Stopped）或者**运行中**（Running）状态。  
    /// -  一台实例或者一张弹性网卡必须至少加入一个安全组，当该实例或者弹性网卡只加入了一个安全组时，移出请求失败报错。  
    /// -  移除不在组内的实例或者网卡时，移出请求失败报错。
    ///
    /// # Error Codes
    /// - `InvalidInstanceId.Malformed`: The specified parameter "InstanceId" is not valid.
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `InvalidSecurityGroupAssociation.NotFound`: %s.
    /// - `InstanceLastSecurityGroup`: The specified security group is the last security group for the instance.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `InstanceNotInSecurityGroup`: The instance not in the group.
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidOperation.AtLeastInOneGroup`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `InvalidOperation.InvalidEniType`: %s
    /// - `InvalidParam.Malformed`: %s
    /// - `InvalidParam.EniIdAndInstanceId.Conflict`: %s
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InvalidSecurityGroupId.NotFound`: The specified SecurityGroupId does not exist.
    /// - `InvalidEniId.NotFound`: %s
    /// - `RequestTimeout`: The request encounters an upstream server timeout.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn leave_security_group(
        &self,
        req: LeaveSecurityGroup,
    ) -> impl std::future::Future<Output = crate::Result<LeaveSecurityGroupResponse>> + Send {
        self.call(req)
    }

    /// # 创建密钥对
    ///
    /// 调用CreateKeyPair创建一对SSH密钥对。系统会为您保管密钥的公钥部分，并返回未加密的PEM编码的PKCS#8格式私钥。您需要自行妥善保管私钥部分。
    ///
    /// 除了调用CreateKeyPair创建密钥对之外，您还可以使用第三方工具创建密钥对，然后上传（[ImportKeyPair](~~51774~~)）到某一阿里云地域，其使用方法和系统为您创建的密钥对是一致的。
    ///
    /// 您在每个地域的密钥对数最高为500对。更多信息，请参见[使用限制](~~25412~~)。
    ///
    /// # Error Codes
    /// - `InvalidKeyPairName.Malformed`: Specified Key Pair name is not valid.
    /// - `KeyPair.AlreadyExist`: The key pair already exist.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `QuotaExceed.KeyPair`: The key pair quota exceeds.
    /// - `QuotaExceed.Tags`: %s
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_key_pair(
        &self,
        req: CreateKeyPair,
    ) -> impl std::future::Future<Output = crate::Result<CreateKeyPairResponse>> + Send {
        self.call(req)
    }

    /// # 导入密钥对公钥
    ///
    /// 导入由其他工具产生的RSA密钥对的公钥部分。导入密钥对后，阿里云为您保管公钥部分，您需要自行妥善保存密钥对的私钥部分。
    ///
    /// ## 接口说明
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 您在每个地域的密钥对数最高为500对。
    /// - 导入的密钥对必须支持下列任一种加密方式：
    ///     - rsa
    ///     - dsa
    ///     - ssh-rsa
    ///     - ssh-dss
    ///     - ecdsa
    ///
    /// # Error Codes
    /// - `InvalidKeyPairName.Malformed`: Specified Key Pair name is not valid.
    /// - `InvalidPublicKeyBody.Malformed`: The PublicKeyBody format is not supported.
    /// - `MissingParameter`: The input parameter "PublicKeyBody" that is mandatory for processing this request is not supplied.
    /// - `KeyPair.AlreadyExist`: The key pair already exist.
    /// - `QuotaExceed.KeyPair`: The key pair quota exceeds.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn import_key_pair(
        &self,
        req: ImportKeyPair,
    ) -> impl std::future::Future<Output = crate::Result<ImportKeyPairResponse>> + Send {
        self.call(req)
    }

    /// # 查询密钥对列表
    ///
    /// 调用DescribeKeyPairs查询一个或多个密钥对。
    ///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_key_pairs(
        &self,
        req: DescribeKeyPairs,
    ) -> impl std::future::Future<Output = crate::Result<DescribeKeyPairsResponse>> + Send {
        self.call(req)
    }

    /// # 绑定密钥对到Linux实例
    ///
    /// 绑定一个SSH密钥对到一台或多台Linux实例。
    ///
    /// 当您使用该接口时，需要注意：
    ///
    /// -  Windows实例不支持SSH密钥对。
    /// -  绑定SSH密钥对后，将禁用用户名加密码的验证方式。
    /// -  如果实例处于**运行中**（Running）状态，重启实例（[RebootInstance](~~25502~~)）后，SSH密钥对生效。  
    /// -  如果实例处于**已停止**（Stopped）状态，启动实例（[StartInstance](~~25500~~)）后，SSH密钥对生效。  
    /// -  如果实例已经绑定了SSH密钥对，新的SSH密钥对自动替换原来的SSH密钥对。
    ///
    /// # Error Codes
    /// - `InvalidKeyPairName.NotFound`: The specified KeyPairName does not exist in our records.
    /// - `InvalidInstanceIds.ValueNotSupported`: The specified parameter InstanceIds is not valid.
    /// - `DependencyViolation.IoOptimize`: The specified parameter InstanceIds is not valid.
    /// - `DependencyViolation.WindowsInstance`: The instance creating is windows, cannot use ssh key pair to login
    /// - `InstanceKeyPairLimitExceeded`: The specified instances are beyond the permitted range.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn attach_key_pair(
        &self,
        req: AttachKeyPair,
    ) -> impl std::future::Future<Output = crate::Result<AttachKeyPairResponse>> + Send {
        self.call(req)
    }

    /// # Linux实例解绑密钥对
    ///
    /// 为一台或者多台Linux实例解绑SSH密钥对。
    ///
    /// 使用该接口时，请注意：
    ///
    /// -  解绑SSH密钥对后，您需要重启实例（[RebootInstance](~~25502~~)）使更改生效。  
    /// -  解绑SSH密钥对后，实例默认使用用户名和密码的验证方式。
    ///
    /// # Error Codes
    /// - `InvalidKeyPairName.NotFound`: The specified KeyPairName does not exist in our records.
    /// - `InvalidInstanceIds.ValueNotSupported`: The specified parameter InstanceIds is not valid.
    /// - `DependencyViolation.WindowsInstance`: The instance creating is windows, cannot use ssh key pair to login.
    /// - `InstanceKeyPairLimitExceeded`: The specified instances are beyond the permitted range.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn detach_key_pair(
        &self,
        req: DetachKeyPair,
    ) -> impl std::future::Future<Output = crate::Result<DetachKeyPairResponse>> + Send {
        self.call(req)
    }

    /// # 批量删除密钥对
    ///
    /// 调用DeleteKeyPairs删除一对或者多对SSH密钥对。
    ///
    /// 删除SSH密钥对后，您需要注意：
    ///
    /// - 无法通过[DescribeKeyPairs](~~51773~~)查询该SSH密钥对。  
    /// - 若已有ECS实例绑定了该SSH密钥对，则该SSH密钥对不支持被删除。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The input parameter "KeyPairNames" that is mandatory for processing this request is not supplied.
    /// - `InvalidKeyPairNames.ValueNotSupported`: The specified parameter "KeyPairNames" is not valid.
    /// - `InvalidParameter.KeypairAlreadyAttachedInstance`: The specified parameter "KeyPairNames" attached to instances can not be deleted.
    /// - `InstanceKeyPairLimitExceeded`: Exceeding the allowed amount of instance which will be deleted.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_key_pairs(
        &self,
        req: DeleteKeyPairs,
    ) -> impl std::future::Future<Output = crate::Result<DeleteKeyPairsResponse>> + Send {
        self.call(req)
    }

    /// # 创建实例启动模板
    ///
    /// 创建一个ECS实例启动模板，简称模板。实例启动模板能免除每次创建实例时都需要填入大量配置参数。
    ///
    /// 调用CreateLaunchTemplate创建模板后，会自动生成该模板的一个默认版本，版本号为1，您后续可以基于该模板创建多个版本（`CreateLaunchTemplateVersion`），版本号从1开始顺序递增。如果您在创建实例（[RunInstances](~~63440~~)）时不指定模板版本号，会采用默认版本。
    ///
    /// 实例启动模板的版本中包含用于创建实例的相关配置，例如实例所属地域、镜像ID、实例规格、安全组ID和公网带宽等。如果版本中没有指定某一实例配置，您需要在创建实例时为实例指定该配置。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// -   每个账号在一个地域最多能创建30个实例启动模板，且每个模板最多能有30个版本。
    ///
    /// -   实例启动模板的参数大多数为可选参数。创建模板时，阿里云不会验证模板中参数取值的存在性和有效性。只会在真正创建实例时校验参数取值的有效性。
    ///
    /// -   如果实例启动模板中设置了某一配置，创建实例（[RunInstances](~~63440~~)）时就无法过滤掉该配置。例如，如果模板设置了`HostName=LocalHost`，`RunInstances`中`HostName`取值为空时，实例的主机名依然是`LocalHost`。如果您想覆盖`HostName=LocalHost`这一配置，可以在`RunInstances`中取`HostName=MyHost`或其他参数值。
    ///
    /// # Error Codes
    /// - `InvalidRegion.NotExist`: %s
    /// - `MissingParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidLaunchTemplateName.Malformed`: The specified parameter LaunchTemplateName is not valid.
    /// - `InvalidDescription.Malformed`: The specified parameter "VersionDescription" is not valid.
    /// - `InvalidUserData.SizeExceeded`: %s
    /// - `InvalidUserData.Base64FormatInvalid`: %s
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidHostName.Malformed`: The specified parameter "HostName" is not valid.
    /// - `InvalidParams.CreateEniParams`: %s
    /// - `LaunchTemplateLimitExceed`: %s
    /// - `LaunchTemplateName.Duplicated`: %s
    /// - `QuotaExceed.Tags`: %s
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_launch_template(
        &self,
        req: CreateLaunchTemplate,
    ) -> impl std::future::Future<Output = crate::Result<CreateLaunchTemplateResponse>> + Send {
        self.call(req)
    }

    /// # 查询一个或多个可用的实例启动模板
    ///
    /// 调用DescribeLaunchTemplates接口，并可以指定TemplateTag、TemplateResourceGroupId、LaunchTemplateId等参数，查询一个或多个实例启动模板的信息，例如启动模板总个数、模板创建时间、模板最新版本号等信息集合。
    ///
    /// # Error Codes
    /// - `InvalidRegion.NotExist`: %s
    /// - `MissingParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InnerServiceFailed`: %s
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.
    /// - `ServiceUnavailable`: The request has failed due to a temporary failure of the server.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_launch_templates(
        &self,
        req: DescribeLaunchTemplates,
    ) -> impl std::future::Future<Output = crate::Result<DescribeLaunchTemplatesResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除实例启动模板
    ///
    /// 指定参数LaunchTemplateId或LaunchTemplateName删除目标地域下的一个实例启动模板。
    ///
    /// 调用该接口时，您需要注意：
    /// - 删除启动模板后，已通过启动模板创建的ECS实例不受影响。
    ///
    /// - 删除启动模板后，模板下的所有版本也将被同步删除且无法恢复，如果您只想删除启动模板下的某个版本，请参考[DeleteLaunchTemplateVersion](~~2679735~~)。
    ///
    /// # Error Codes
    /// - `InvalidRegion.NotExist`: %s
    /// - `MissingParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InnerServiceFailed`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_launch_template(
        &self,
        req: DeleteLaunchTemplate,
    ) -> impl std::future::Future<Output = crate::Result<DeleteLaunchTemplateResponse>> + Send {
        self.call(req)
    }

    /// # 在实例启动模板中创建新版本
    ///
    /// 在指定的ECS实例启动模板下创建一个新版本用于后续创建ECS实例、弹性伸缩组或弹性供应组。
    ///
    /// ## 接口说明
    /// 当您想修改某个版本的参数时，能通过新建模板版本的方式修改。每个实例启动模板最多创建30个版本。
    ///
    /// # Error Codes
    /// - `InvalidRegion.NotExist`: %s
    /// - `MissingParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidDescription.Malformed`: The specified parameter "Description" is not valid.
    /// - `InvalidUserData.SizeExceeded`: %s
    /// - `InvalidUserData.Base64FormatInvalid`: %s
    /// - `InvalidHostName.Malformed`: The specified parameter "HostName" is not valid.
    /// - `InvalidParams.CreateEniParams`: %s
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `LaunchTemplateVersionLimitExceed`: %s
    /// - `InvalidLaunchTemplate.NotFound`: %s
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_launch_template_version(
        &self,
        req: CreateLaunchTemplateVersion,
    ) -> impl std::future::Future<Output = crate::Result<CreateLaunchTemplateVersionResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询实例启动模板的版本信息
    ///
    /// 查询ECS实例启动模板版本的信息，例如实例启动模板总数、模板名称、模板版本号等。
    ///
    /// # Error Codes
    /// - `InvalidRegion.NotExist`: %s
    /// - `MissingParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InnerServiceFailed`: %s
    /// - `InvalidLaunchTemplate.NotFound`: The specified LaunchTemplate is not found.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_launch_template_versions(
        &self,
        req: DescribeLaunchTemplateVersions,
    ) -> impl std::future::Future<Output = crate::Result<DescribeLaunchTemplateVersionsResponse>> + Send
    {
        self.call(req)
    }

    /// # 切换启动模板的默认版本
    ///
    /// 调用ModifyLaunchTemplateDefaultVersion接口，并通过指定DefaultVersionNumber参数，切换启动模板的默认版本。如果您在创建实例（RunInstances）时不指定模板版本号，则会采用默认版本。
    ///
    /// # Error Codes
    /// - `InvalidRegion.NotExist`: %s
    /// - `MissingParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InnerServiceFailed`: %s
    /// - `InvalidLaunchTemplate.NotFound`: %s
    /// - `InvalidLaunchTemplateVersion.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_launch_template_default_version(
        &self,
        req: ModifyLaunchTemplateDefaultVersion,
    ) -> impl std::future::Future<Output = crate::Result<ModifyLaunchTemplateDefaultVersionResponse>>
    + Send {
        self.call(req)
    }

    /// # 删除实例启动模板的版本
    ///
    /// 指定LaunchTemplateId、DeleteVersion等参数，删除指定实例启动模板的一个或多个版本。
    ///
    /// 调用该接口时，您需要注意：
    /// - 不支持删除默认版本，您必须通过删除整个实例启动模板才能删除默认版本。
    ///
    /// - 如果您需要删除的版本为默认版本，可以通过调用[ModifyLaunchTemplateDefaultVersion](~~2679734~~)或在**启动模板**控制台切换默认版本以后，进行删除操作。
    ///
    /// - 删除版本不会影响通过该版本已创建的实例。
    ///
    /// # Error Codes
    /// - `InvalidRegion.NotExist`: %s
    /// - `MissingParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidOperation.DeleteDefaultVersion`: %s
    /// - `InnerServiceFailed`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_launch_template_version(
        &self,
        req: DeleteLaunchTemplateVersion,
    ) -> impl std::future::Future<Output = crate::Result<DeleteLaunchTemplateVersionResponse>> + Send
    {
        self.call(req)
    }

    /// # 创建弹性供应组
    ///
    /// 创建一个弹性供应组。
    ///
    /// ## 接口说明
    ///
    /// - 弹性供应是一个使用抢占式实例和按量付费实例快速部署实例集群的方案，支持一键部署跨计费方式、跨可用区、跨实例规格族的实例集群。更多信息，请参见[使用弹性供应组API批量创建ECS实例](~~200772~~)。
    /// - 弹性供应以供应组为载体调度和维护计算资源，您可以通过弹性供应组稳定提供计算力，缓解抢占式实例的回收机制带来的不稳定因素。
    /// - 弹性供应为免费功能，但是您需要为通过弹性供应组创建出的实例资源付费。更多信息，请参见[抢占式实例计费](~~52088~~)和[按量付费](~~40653~~)。
    /// - 当您同时指定启动模板（`LaunchTemplateId`）与启动配置信息（`LaunchConfiguration.*`）时，系统优先使用启动模板。
    ///
    /// # Error Codes
    /// - `InvalidParameter`: %s
    /// - `InvalidAutoProvisioningGroupName.Malformed`: The specified parameter "AutoProvisioningGroupName" is not valid.
    /// - `InvalidAutoProvisioningGroupType.ValueNotSupported`: The specified parameter "AutoProvisioningGroupType" is not supported.
    /// - `InvalidFleetExcessCapacityTerminationPolicy.ValueNotSupported`: The specified parameter "ExcessCapacityTerminationPolicy" is not supported.
    /// - `InvalidDefaultTargetCapacityType.ValueNotSupported`: The specified parameter "DefaultTargetCapacityType" is not supported.
    /// - `InvalidSpotAllocationStrategy.ValueNotSupported`: The specified parameter "SpotAllocationStrategy" is not supported.
    /// - `InvalidSpotInstanceInterruptionBehavior.ValueNotSupported`: The specified parameter "SpotInstanceInterruptionBehavior" is not supported.
    /// - `InvalidPayAsYouGoAllocationStrategy.ValueNotSupported`: The specified parameter "PayAsYouGoAllocationStrategy" is not supported.
    /// - `MissingParameter.SpotAllocationStrategy`: The specified parameter "SpotAllocationStrategy" is empty.
    /// - `MissingParameter.LaunchTemplateConfigs`: The specified parameter "LaunchTemplateConfigs" is empty.
    /// - `InvalidValidTime.MalFormed`: The specified parameter "ValidTime" is not supported.
    /// - `InvalidLaunchTemplateVersion.ValueNotSupported`: The specified parameter "LaunchTemplateVersion" is not valid.
    /// - `MissingParameter`: The specified parameter "AutoProvisioningGroup" should not be null.
    /// - `InvalidRegion.ValueNotSupported`: The specified Region does not exist.
    /// - `InvalidDescription.ValueNotSupported`: The specified description is illegal.
    /// - `InvalidLaunchTemplate.ValueNotSupported`: The SecurityGroupId or imageId in LaunchTemplate is not exists.
    /// - `InvalidCapacity.ValueNotSupported`: The Capacity is illegal, or the TargetCapacity is large than SpotCapacity + PayAsYouGoCapacity.
    /// - `InvalidInstanceType.ValueNotSupported`: The instanceType is illegal.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `InvalidLaunchTemplateConfigs.SizeExceed`: The size of LaunchTemplateConfigs exceeds limit.
    /// - `InvalidParameter.SpotInstancePoolsToUseCount`: The specified parameter "SpotInstancePoolsToUseCount" is not valid.
    /// - `InvalidParameter.ResourceGroupId`: The specified parameter "ResourceGroupId" is not valid.
    /// - `InvalidParameter.TargetCapacity`: The Capacity is illegal, TotalTargetCapacity, PayAsYouGoTargetCapacity, SpotTargetCapacity must be specified, meanwhile, the TargetCapacity must be larger than or equal to the sum of SpotCapacity and OnDemandCapacity.
    /// - `MissingParameter.WeightedCapacity`: The WeightedCapacity of LaunchTemplateConfig should not be empty.
    /// - `InvalidParameter.WeightedCapacityBeyondRange`: The WeightedCaTpacity of LaunchTemplateConfig beyond permitted range.
    /// - `InvalidParameter.MaxPrice`: The specified parameter "MaxSpotPrice" or "MaxPrice" of LaunchTemplateConfig is not valid.
    /// - `NoPermission`: %s
    /// - `Duplicate.DiskCategory`: The specified disk configs contains duplicate DiskCategory.
    /// - `InvalidImageFamily.Confict`: The specified parameter ImageFamily should be empty when the parameter ImageId is specified.
    /// - `Invalid.ResourcePoolOptions.PrivatePoolIds`: The zone or instancetype of the ResourcePoolOptions.PrivatePoolIds  does not match the LaunchTemplateConfig.
    /// - `Invalid.ResourcePoolOptions.Strategy`: The specified ResourcePoolOptions.Strategy is invalid.
    /// - `Invalid.ResourcePoolOptionsPrivatePoolIds.SizeExceed`: The size of ResourcePoolOptions.PrivatePoolIds exceeds limit.
    /// - `MissingParameter.ResourcePoolOptions.PrivatePoolIds`: The specified ResourcePoolOptions.PrivatePoolIds should not be null when ResourcePoolOptions.Strategy is PrivatePoolOnly.
    /// - `InvalidSpotDuration`: The specified SpotDuration is not valid.
    /// - `InvalidSpotInterruptionBehavior`: %s
    /// - `InvalidParameter.SecurityGroupIdRepeated`: The SecurityGroupId is repeated.
    /// - `VpcMismatch.SecurityGroupAndVSwitch`: Specified security group and virtual switch are not in the same VPC.
    /// - `InvalidMinTargetCapacity.NotSatisfied`: The inventory of specified InstanceType does not meet the MinTargetCapacity.
    /// - `InvalidParameterRange.MinTargetCapacity`: The MinTargetCapacity exceeds the limit[0-TotalTargetCapacity].
    /// - `InvalidUserData.Base64FormatInvalid`: The specified parameter UserData must be base64 encoded.
    /// - `InvalidUserData.SizeExceeded`: The specified parameter UserData exceeds the size.
    /// - `InvalidAutoReleaseTime.Malformed`: The specified parameter AutoReleaseTime is not valid.
    /// - `TotalTargetCapacityLimitExceed`: The TotalTargetCapacity exceeds the limit[0-2000].
    /// - `SpotTargetCapacityLimitExceed`: The SpotTargetCapacity exceeds the limit[0-2000].
    /// - `PayAsYouGoTargetCapacityLimitExceed`: The PayAsYouGoTargetCapacity exceeds the limit[0-2000].
    /// - `InvalidResourcePoolOptionsPrivatePoolIds.NotFound`: The ResourcePoolOptions.PrivatePoolIds do not exist.
    /// - `InvalidSecurityGroupId.NotFound`: The SecurityGroupId %s provided does not exist in our records.
    /// - `InvalidVSwitchId.NotFound`: The specified virtual switch %s  does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_auto_provisioning_group(
        &self,
        req: CreateAutoProvisioningGroup,
    ) -> impl std::future::Future<Output = crate::Result<CreateAutoProvisioningGroupResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询弹性供应组
    ///
    /// 查询一个或多个弹性供应组。
    ///
    /// # Error Codes
    /// - `MissingParamter.RegionId`: The regionId should not be null.
    /// - `InvalidName.Malformed`: The specified parameter "AutoProvisioningGroupName" is not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_auto_provisioning_groups(
        &self,
        req: DescribeAutoProvisioningGroups,
    ) -> impl std::future::Future<Output = crate::Result<DescribeAutoProvisioningGroupsResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询弹性供应组内的实例
    ///
    /// 查询一个弹性供应组内的实例信息。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The specified parameter "AutoProvisioningGroupId" should not be null.
    /// - `MissingParamter.RegionId`: The regionId should not be null.
    /// - `Forbidden.RAM`: User not authorized to operate on the specified resource, or this API doesn't support RAM.
    /// - `InvalidAutoProvisioningGroupId.NotFound`: The specified AutoProvisioningGroupId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_auto_provisioning_group_instances(
        &self,
        req: DescribeAutoProvisioningGroupInstances,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeAutoProvisioningGroupInstancesResponse>,
    > + Send {
        self.call(req)
    }

    /// # 修改弹性供应组的配置
    ///
    /// 修改一个弹性供应组的配置信息。
    ///
    /// 修改弹性供应组前，请注意：
    ///
    /// - 如果修改了供应组容量或者容量相关设置，供应组会在修改完成后执行一次调度任务。
    /// - 如果供应组处于删除中状态，无法修改供应组。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The specified parameter "AutoProvisioningGroupId" should not be null.
    /// - `NoPermission`: %s
    /// - `InvalidLaunchTemplateConfigs.SizeExceed`: The size of LaunchTemplateConfigs exceeds limit.
    /// - `QuotaExceed.LaunchTemplateConfigs`: %s
    /// - `OperationDenied`: %s
    /// - `VpcMismatch.SecurityGroupAndVSwitch`: Specified security group and virtual switch are not in the same VPC.
    /// - `Forbidden.RAM`: User not authorized to operate on the specified resource, or this API doesn't support RAM.
    /// - `InvalidName.Malformed`: The specified parameter "AutoProvisioningGroupName" is not valid.
    /// - `AutoProvisioningGroup.Unauthorized`: Unauthorized to operate current action.
    /// - `AutoProvisioningGroup.IncorrectStatus`: Current status of AutoProvisioningGroup does not support curren action.
    /// - `InvalidParameter.TargetCapacity`: The Capacity is illegal, TotalTargetCapacity, PayAsYouGoTargetCapacity, SpotTargetCapacity must be specified, meanwhile, the TargetCapacity must be larger than or equal to the sum of SpotCapacity and OnDemandCapacity.
    /// - `InvalidAutoProvisioningGroupId.NotFound`: The specified AutoProvisioningGroupId does not exist.
    /// - `InvalidParameter.MaxPrice`: The specified parameter "MaxSpotPrice" is not valid.
    /// - `InvalidVSwitchId.NotFound`: The specified virtual switch %s  does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_auto_provisioning_group(
        &self,
        req: ModifyAutoProvisioningGroup,
    ) -> impl std::future::Future<Output = crate::Result<ModifyAutoProvisioningGroupResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询弹性供应组的调度任务信息
    ///
    /// 调用DescribeAutoProvisioningGroupHistory查询弹性供应组的调度任务信息。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The specified parameter "AutoProvisioningGroupId" should not be null.
    /// - `MissingParamter.RegionId`: The regionId should not be null.
    /// - `InvalidParameter.periodTime`: The format of startTime or endTime is invalid.
    /// - `Forbidden.RAM`: User not authorized to operate on the specified resource, or this API doesn't support RAM.
    /// - `InvalidAutoProvisioningGroupId.NotFound`: The specified AutoProvisioningGroupId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_auto_provisioning_group_history(
        &self,
        req: DescribeAutoProvisioningGroupHistory,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeAutoProvisioningGroupHistoryResponse>,
    > + Send {
        self.call(req)
    }

    /// # 删除弹性供应组
    ///
    /// 指定参数AutoProvisioningGroupId、TerminateInstances删除一个弹性供应组。
    ///
    /// # Error Codes
    /// - `MissingParameter.InstanceType`: The specified parameter "TerminateInstances" should be not empty.
    /// - `MissingParameter`: The specified parameter "AutoProvisioningGroupId" should not be null.
    /// - `NoPermission`: %s
    /// - `Forbidden.RAM`: User not authorized to operate on the specified resource, or this API doesn't support RAM.
    /// - `AutoProvisioningGroup.Unauthorized`: Unauthorized to operate current action.
    /// - `AutoProvisioningGroup.IncorrectStatus`: Current status of AutoProvisioningGroup does not support curren action.
    /// - `InvalidAutoProvisioningGroupId.NotFound`: The specified AutoProvisioningGroupId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_auto_provisioning_group(
        &self,
        req: DeleteAutoProvisioningGroup,
    ) -> impl std::future::Future<Output = crate::Result<DeleteAutoProvisioningGroupResponse>> + Send
    {
        self.call(req)
    }

    /// # 在指定的地域内创建部署集
    ///
    /// 在指定的地域内创建一个部署集。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The input parameter RegionId that is mandatory for processing this request is not supplied.
    /// - `InvalidDeploymentSetName.Malformed`: Specified deployment set name is not valid.
    /// - `InvalidDescription.Malformed`: The specified parameter Description is not valid.
    /// - `InvalidParameter.Domain`: The specified parameter Domain is not valid.
    /// - `InvalidParameter.Strategy`: The specified parameter Strategy is not valid.
    /// - `InvalidParameter.granularity`: The specified parameter Granularity is not valid.
    /// - `DependencyViolation.domain.granularity`: The DeploymentSet domain and granularity is violation.
    /// - `DependencyViolation.strategy.granularity`: The DeploymentSet strategy and granularity is violation.
    /// - `DeploymentSet.GroupQuotaFull`: The deploymentSet group quota is full.
    /// - `InvalidParameter.GroupCount`: The specified parameter "GroupCount" is not valid.
    /// - `InvalidZoneId.NotFound`: The zoneId provided does not exist in our records.
    /// - `QuotaExceed.DeploymentSet`: The deploymentSet quota is full.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_deployment_set(
        &self,
        req: CreateDeploymentSet,
    ) -> impl std::future::Future<Output = crate::Result<CreateDeploymentSetResponse>> + Send {
        self.call(req)
    }

    /// # 查询支持部署集的实例规格族
    ///
    /// 调用DescribeDeploymentSetSupportedInstanceTypeFamily，并指定RegionId、Strategy参数，查询支持各部署集策略的实例规格族。
    ///
    /// ## 接口说明
    ///
    /// 更多实例规格族的详情，请参见[实例规格族](~~25378~~)。
    ///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_deployment_set_supported_instance_type_family(
        &self,
        req: DescribeDeploymentSetSupportedInstanceTypeFamily,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeDeploymentSetSupportedInstanceTypeFamilyResponse>,
    > + Send {
        self.call(req)
    }

    /// # 查询部署集的属性
    ///
    /// 查询一个或多个部署集的详细信息。
    ///
    /// # Error Codes
    /// - `InvalidDeploymentSetIds.TooManyInput`: The parameter DeploymentSets size should less than 100.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_deployment_sets(
        &self,
        req: DescribeDeploymentSets,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDeploymentSetsResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改实例部署集
    ///
    /// 修改ECS实例的部署集，或迁移ECS实例至专有宿主机。支持在迁移ECS实例的同时变更实例规格。
    ///
    /// 迁移ECS实例至专有宿主机，或在迁移实例同时变更ECS实例规格时，必须满足以下条件：
    ///
    /// - ECS实例必须处于**已停止**（Stopped）状态，迁移后实例自动重启。
    /// - 只支持专有网络VPC类型的ECS实例。
    /// - ECS实例与专有宿主机必须属于同一账号、同一地域和可用区。
    /// - 按量付费ECS实例可以迁移到包年包月专有宿主机上。包年包月ECS实例只能在包年包月专有宿主机之间迁移，且实例到期时间不能超过目标专有宿主机的到期时间。
    /// - 将ECS实例从共享宿主机迁移至专有宿主机时，实例的计费方式只能是按量付费，不支持包年包月实例和抢占式实例。
    /// - ECS实例可以指定专有宿主机集群重新部署。
    ///
    /// # Error Codes
    /// - `OperationDenied.UnstoppedInstance`: Operation denied due to unstopped instance.
    /// - `InvalidDedicatedHostStatus.NotSupport`: Operation denied due to dedicated host status.
    /// - `InvalidPeriod.ExceededDedicatedHost`: Instance expired date can't exceed dedicated host expired date.
    /// - `NoAvaliableDedicatedHost`: There's no enough resource on the specified dedicated host.
    /// - `OperationDenied.LocalDiskInstance`: Operation denied due to instance has local disk.
    /// - `InvalidParameter.Param`: Requested param is invalid.
    /// - `InvalidParam.Tenancy`: The specified Tenancy is invalid.
    /// - `InvalidParam.DedicatedHostId`: The specified dedicated host id is the same with present host id!
    /// - `InvalidDedicatedHost.NotEnoughResource`: There's no available dedicated host to perform the operation.
    /// - `OperationDenied.InvalidInstance`: The specified instance is not dedicated instance.
    /// - `ChargeTypeViolation.PostPaidDedicatedHost`: Prepaid instance onto postpaid dedicated host is not allowed.
    /// - `OperationDenied.NotSupport`: Ecs on dedicatedHost has been migrated.
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist.
    /// - `OperationDenied.CannotPerform`: Live migration cannot be performed.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InvalidParameter.Tenancy`: The specified Tenancy is invalid.
    /// - `InvalidParameter.Affinity`: The specified Affinity is invalid.
    /// - `InvalidInstanceType.NotSupport`: The parameter EcsMigrationType conflict with InstanceType, live migration do not support InstanceType alter on ddh.
    /// - `InvalidParam.InstanceId`: The specified InstanceId should be on dedicatedHost.
    /// - `InvalidDedicatedHostClusterId.NotFound`: The specified DedicatedHostClusterId does not exist.
    /// - `InvalidDedicatedHostClusterId.Invalid`: The specified Dedicated Host Cluster is invalid.
    /// - `InvalidDestinationZone.DeploymentSetMismatch`: Error happened, %s.
    /// - `IncorrectInstanceStatus`: %s
    /// - `OperationDenied.NoStock`: The resource is out of usage.
    /// - `InvalidDeploymentSetId.NoAvailableResources`: There are no available resources for the specified deployment, you can set the parameter force to true to retry, or wait for additional resource to become available.
    /// - `InvalidDeploymentSetId.NotFound`: The specified deployment set does not exist.
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `OperationDenied.UnstoppedInstance`: Operation denied due to unstopped instance.
    /// - `InvalidInstanceNetworkType.NotSupport`: The specified Instance network type not support.
    /// - `InvalidInstanceChargeType.NotSupport`: The Dedicated host not support the specified instance charge type.
    /// - `InvalidInstanceType.NotSupport`: The Dedicated host not support the specified instance type.
    /// - `InvalidParameter.DeploymentSetGroupNo`: Parameter DeploymentSetGroupNo is invalid.
    /// - `InvalidDedicatedHostId.NotSupport`: Cannot choose instance present host as destination host.
    /// - `InvalidDedicatedHost.NotFound`: No available host.
    /// - `InvalidParam.DedicatedHostId`: Parameter dedicated host id must been provided in such operation.
    /// - `InvalidDedicatedHost.ZoneNotMatch`: The specify dedicated host zone location not match the instance zone location.
    /// - `InvalidOperation.NotSupport`: The specified DedicatedHost operation not supported on MPS.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_deployment(
        &self,
        req: ModifyInstanceDeployment,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceDeploymentResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改部署集的名称和描述信息
    ///
    /// 修改一个部署集的名称和描述信息。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The input parameter RegionId that is mandatory for processing this request is not supplied.
    /// - `InvalidDeploymentSetName.Malformed`: Specified deployment set name is not valid.
    /// - `InvalidDescription.Malformed`: The specified parameter Description is not valid.
    /// - `InvalidDeploymentSetId.NotFound`: The specified DeploymentSetId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_deployment_set_attribute(
        &self,
        req: ModifyDeploymentSetAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyDeploymentSetAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除部署集
    ///
    /// 删除一个部署集。
    ///
    /// 在删除部署集之前请确保部署集内没有实例。如果存在实例，必须移出或者释放实例后才能删除部署集，具体操作，请参见[调整实例所属部署集](~~108407~~)和[释放ECS实例](~~25442~~)。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The input parameter "DeploymentSetId" that is mandatory for processing this request is not supplied.
    /// - `DependencyViolation.NotEmpty`: There are still instance(s) in the specified DeploymentSetId.
    /// - `DependencyViolation.ReferByHPC`: The specified deployment set is still referred by an HPC cluster.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_deployment_set(
        &self,
        req: DeleteDeploymentSet,
    ) -> impl std::future::Future<Output = crate::Result<DeleteDeploymentSetResponse>> + Send {
        self.call(req)
    }

    /// # 创建弹性保障服务
    ///
    /// 通过指定弹性保障服务所属地域下的可用区、实例规格、购买时长、是否自动续费等参数创建弹性保障服务。
    ///
    /// 弹性保障服务为您提供了兼顾灵活性和确定性的全新的资源购买和使用方式，是一种能够为按量付费的ECS实例提供确定性保障的资源预定服务。更多信息，请参见[弹性保障概述](~~193630~~)。
    ///
    /// - 购买弹性保障服务后，普通弹性保障服务支持退款，分时弹性保障服务不支持退款。计费请参见[资源保障](~~432502~~)。
    /// - 通过弹性保障服务只能创建计费方式为按量付费的ECS实例。
    /// - 目前弹性保障次数只开放了无限次的模式，即`AssuranceTimes`参数只支持设置为`Unlimited`。无限次模式的弹性保障服务在保障生效后，将自动启动。
    ///
    /// # Error Codes
    /// - `InvalidOperation.PeriodUnitUnsupported`: TimeDivisionElasticityAssurance only supports PeriodUnit of Day.
    /// - `InvalidParameter.RegionId`: The specified RegionId is invalid.
    /// - `OperationDenied`: The specified instanceType or zone is not available or not authorized.
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidStartTime.NotSupported`: The specified StartTime should be within 180 calendar days from the current date, and you must specify a precision to hour.
    /// - `InvalidStartTime.MalFormed`: The specified StartTime is out of the permitted range.
    /// - `Invalid.PrivatePoolOptionsName.MalFormed`: The specified PrivatePoolOptions.Name is not valid.
    /// - `Invalid.ZoneId`: The specified ZoneId is not valid.
    /// - `Invalid.InstanceType`: The specified InstanceType is not valid.
    /// - `DedicatedHostNotSupported`: DedicatedHost is not supported for PrivatePool.
    /// - `SpotNotSupported`: Spot is not supported for PrivatePool.
    /// - `ClassicNetworkNotSupported`: Classic network is not supported for PrivatePool.
    /// - `Invalid.InstanceId`: Instance does not exist.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `Invalid.InstanceChargeType`: The InstanceChargeType does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.status`: The PrivatePool status is not valid.
    /// - `InvalidPlatform.ValueNotSupported`: The Platform does not match the PrivatePool.
    /// - `InvalidAliUid`: The PrivatePool does not belong to the user of the Instance.
    /// - `MissingParameter.PackageType`: The specified parameter "PackageType" can not be empty.
    /// - `MissingParameter.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCount`: The specified parameter "InstanceCpuCoreCount" can not be empty.
    /// - `MissingParameter.InstanceAmount`: The specified parameter "InstanceAmount" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCountOrInstanceAmount`: The specified parameter "InstanceCpuCoreCount" and "InstanceAmount" must not be empty at the same time.
    /// - `Invalid.TooManyPrivatePoolOptions.Ids`: Too many PrivatePoolOptions.Ids in this request.
    /// - `Invalid.TooManyZoneIds`: Too many ZoneIds in the request.
    /// - `Invalid.TooManyInstanceTypes`: Too many InstanceTypes in the request.
    /// - `Invalid.TooManyUnpaidPrivatePool`: Too many PrivatePools create but still unpaid.
    /// - `Invalid.InstanceCpuCoreCountOrInstanceAmount`: Both InstanceCpuCoreCount and InstanceAmount are provided.
    /// - `Invalid.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" exist invalid element Id.
    /// - `Invalid.PackageType`: The specified parameter "PackageType" is invalid.
    /// - `Invalid.PrivatePool.Purchase`: The PrivatePool has already paid.
    /// - `Invalid.AssuranceTimes.NotSupported`: The value of AssuranceTimes is not supported.
    /// - `RepeatStartPrivatePool`: PrivatePool has already been started.
    /// - `Invalid.PeriodUnit`: Only Month or Year is supported for PeriodUnit.
    /// - `AccountForbidden.ProductCreationLimited`: The commodity must be officially operated by Aliyun and in pay-as-you-go billing method.
    /// - `RegionUnauthorized`: There is no authority to create private pool in the specified region.
    /// - `PriceNotFound`: The price of your queried resource is not available now, please try other resources.
    /// - `InvalidRecurrenceRules.CountLimitExceeded`: The count of RecurrenceRules exceeds the limit.
    /// - `InvalidRecurrenceRulesStartHourEndHour.TooShort`: The recurrence hour between RecurrenceRules.StartHour and RecurrenceRules.EndHour is too short.
    /// - `InvalidParameter.RecurrenceRulesStartHourEndHour`: The specified parameter RecurrenceRules.StartHour or RecurrenceRules.EndHour is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceValueMonthly`: The specified parameter RecurrenceRules.RecurrenceValue for Monthly is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceValueWeekly`: The specified parameter RecurrenceRules.RecurrenceValue for Weekly is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceValueDaily`: The specified parameter RecurrenceRules.RecurrenceValue for Daily is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceType`: The specified parameter RecurrenceRules.RecurrenceType is invalid.
    /// - `InvalidAutoRenewPeriod.ValueNotSupported`: The specified autoRenewPeriod is invalid.
    /// - `InvalidOperation.ElasticityAssuranceActiveTimeTooShort`: The total active time of the ElasticityAssurance is too short.
    /// - `Zone.NotOpen`: The specified zone is not granted to you to buy resources yet.
    /// - `InvalidResourceType.NotSupported`: %s
    /// - `OperationDenied.NoStock`: The resource is out of stock in the specified zone. Please try other types, or choose other regions and zones.
    /// - `InvalidInstanceType.NotSupported`: The specified InstanceType is invalid.
    /// - `Invalid.ZoneIds`: At least one of the specified ZoneIds are invalid.
    /// - `Zone.NotOnSale`: The specified zone is not available for purchase.
    /// - `QuotaExceed.ElasticityAssuranceCapacity`: ElasticityAssurance Capacity quota exceeded.
    /// - `InvalidAccount.NotSupportEA`: According to business rules, this account cannot purchase ECS ElasticityAssurance.
    /// - `InvalidZoneId.NotFound`: The specified zoneId does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_elasticity_assurance(
        &self,
        req: CreateElasticityAssurance,
    ) -> impl std::future::Future<Output = crate::Result<CreateElasticityAssuranceResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询弹性保障服务的信息
    ///
    /// 查询弹性保障服务的详细信息。例如弹性保障服务的状态、匹配模式、生效方式、失效时间、已使用的实例的数量等。
    ///
    /// # Error Codes
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidParameter.Name`: The specified PrivatePoolOptions.Name is invalid.
    /// - `InvalidParameter.PrivatePoolOptions.Ids`: The specified PrivatePoolOptions.Ids is invalid.
    /// - `DedicatedHostNotSupported`: DedicatedHost is not supported for PrivatePool.
    /// - `SpotNotSupported`: Spot is not supported for PrivatePool.
    /// - `ClassicNetworkNotSupported`: Classic network is not supported for PrivatePool.
    /// - `Invalid.InstanceId`: Instance does not exist.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `Invalid.InstanceType`: The InstanceType does not match the PrivatePool.
    /// - `Invalid.InstanceChargeType`: The InstanceChargeType does not match the PrivatePool.
    /// - `Invalid.ZoneId`: The ZoneId does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.status`: The PrivatePool has been used up.
    /// - `InvalidPlatform.ValueNotSupported`: The Platform does not match the PrivatePool.
    /// - `InvalidAliUid`: The PrivatePool does not belong to the user of the Instance.
    /// - `MissingParameter.PackageType`: The specified parameter "PackageType" can not be empty.
    /// - `MissingParameter.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCount`: The specified parameter "InstanceCpuCoreCount" can not be empty.
    /// - `MissingParameter.InstanceAmount`: The specified parameter "InstanceAmount" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCountOrInstanceAmount`: The specified parameter "InstanceCpuCoreCount" and "InstanceAmount" must not be empty at the same time.
    /// - `Invalid.TooManyPrivatePoolOptions.Ids`: Too many PrivatePoolOptions.Ids in this request.
    /// - `Invalid.TooManyZoneIds`: Too many ZoneIds in the request.
    /// - `Invalid.TooManyInstanceTypes`: Too many InstanceTypes in the request.
    /// - `Invalid.TooManyUnpaidPrivatePool`: Too many PrivatePools create but still unpaid.
    /// - `Invalid.InstanceCpuCoreCountOrInstanceAmount`: Both InstanceCpuCoreCount and InstanceAmount are provided.
    /// - `Invalid.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" exist invalid element Id.
    /// - `Invalid.PackageType`: The specified parameter "PackageType" is invalid.
    /// - `Invalid.PrivatePool.Purchase`: The PrivatePool has already paid.
    /// - `Invalid.AssuranceTimes.NotSupported`: The value of AssuranceTimes is not supported.
    /// - `RepeatStartPrivatePool`: PrivatePool has already been started.
    /// - `InvalidResourceGroup.NotFound`: The specified resource group is not found.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_elasticity_assurances(
        &self,
        req: DescribeElasticityAssurances,
    ) -> impl std::future::Future<Output = crate::Result<DescribeElasticityAssurancesResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询弹性保障服务已匹配实例列表
    ///
    /// 调用DescribeElasticityAssuranceInstances查询弹性保障服务已匹配的运行状态的实例列表。
    ///
    /// 当弹性保障服务失效后，实例与弹性保障服务对应的私有池的匹配关联数据也会失效。此时调用该接口查询已失效的服务，返回值为空。
    ///
    /// # Error Codes
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id is invalid.
    /// - `DedicatedHostNotSupported`: DedicatedHost is not supported for PrivatePool.
    /// - `SpotNotSupported`: Spot is not supported for PrivatePool.
    /// - `ClassicNetworkNotSupported`: Classic network is not supported for PrivatePool.
    /// - `Invalid.InstanceId`: Instance does not exist.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `Invalid.InstanceType`: The InstanceType does not match the PrivatePool.
    /// - `Invalid.InstanceChargeType`: The InstanceChargeType does not match the PrivatePool.
    /// - `Invalid.ZoneId`: The ZoneId does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.status`: The PrivatePool has been used up.
    /// - `InvalidPlatform.ValueNotSupported`: The Platform does not match the PrivatePool.
    /// - `InvalidAliUid`: The PrivatePool does not belong to the user of the Instance.
    /// - `MissingParameter.PackageType`: The specified parameter "PackageType" can not be empty.
    /// - `MissingParameter.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCount`: The specified parameter "InstanceCpuCoreCount" can not be empty.
    /// - `MissingParameter.InstanceAmount`: The specified parameter "InstanceAmount" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCountOrInstanceAmount`: The specified parameter "InstanceCpuCoreCount" and "InstanceAmount" must not be empty at the same time.
    /// - `Invalid.TooManyPrivatePoolOptions.Ids`: Too many PrivatePoolOptions.Ids in this request.
    /// - `Invalid.TooManyZoneIds`: Too many ZoneIds in the request.
    /// - `Invalid.TooManyInstanceTypes`: Too many InstanceTypes in the request.
    /// - `Invalid.TooManyUnpaidPrivatePool`: Too many PrivatePools create but still unpaid.
    /// - `Invalid.InstanceCpuCoreCountOrInstanceAmount`: Both InstanceCpuCoreCount and InstanceAmount are provided.
    /// - `Invalid.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" exist invalid element Id.
    /// - `Invalid.PackageType`: The specified parameter "PackageType" is invalid.
    /// - `Invalid.PrivatePool.Purchase`: The PrivatePool has already paid.
    /// - `Invalid.AssuranceTimes.NotSupported`: The value of AssuranceTimes is not supported.
    /// - `RepeatStartPrivatePool`: PrivatePool has already been started.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_elasticity_assurance_instances(
        &self,
        req: DescribeElasticityAssuranceInstances,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeElasticityAssuranceInstancesResponse>,
    > + Send {
        self.call(req)
    }

    /// # 修改弹性保障服务信息
    ///
    /// 修改一个弹性保障服务的部分信息，包含名称、描述、容量（暂时只支持缩容）。
    ///
    /// # Error Codes
    /// - `InvalidRecurrenceRules.CountLimitExceeded`: The count of RecurrenceRules exceeds the limit.
    /// - `InvalidRecurrenceRules.Unsupported`: The specified parameter RecurrenceRules does not support for this resource package.
    /// - `InvalidRecurrenceRulesStartHourEndHour.TooShort`: The recurrence hour between RecurrenceRules.StartHour and RecurrenceRules.EndHour is too short.
    /// - `InvalidParameter.RecurrenceRulesStartHourEndHour`: The specified parameter RecurrenceRules.StartHour or RecurrenceRules.EndHour is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceValueMonthly`: The specified parameter RecurrenceRules.RecurrenceValue for Monthly is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceValueWeekly`: The specified parameter RecurrenceRules.RecurrenceValue for Weekly is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceValueDaily`: The specified parameter RecurrenceRules.RecurrenceValue for Daily is invalid.
    /// - `InvalidParameter.RecurrenceRulesRecurrenceType`: The specified parameter RecurrenceRules.RecurrenceType is invalid.
    /// - `InvalidInstanceAmount.ValueNotSupported`: The specified parameter InstanceAmount is not valid.
    /// - `InvalidDescription.ValueNotSupported`: The specified Description is invalid.
    /// - `InvalidEndTime.ValueNotSupported`: The specified EndTime is invalid.
    /// - `InvalidStartTime.ValueNotSupported`: The specified StartTime is invalid.
    /// - `InvalidParameter.PrivatePoolOptions.Name`: The parameter PrivatePoolOptions.Name is invalid.
    /// - `InvalidParameter.ClientToken`: The parameter ClientToken is invalid.
    /// - `InvalidParameter.Description`: The parameter Description is invalid.
    /// - `InvalidUser.Unauthorized`: The user is not authorized.
    /// - `InvalidOperation.ModifyTotalActiveTimeUnsupported`: Not support to modify the total active time of resource package.
    /// - `IncorrectPrivatePoolStatus`: The current status of the private pool does not support this operation.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone; try other types of resources or other regions and zones.
    /// - `InvalidPrivatePoolOptionsName.ValueNotSupported`: The specified PrivatePoolOptions.Name is invalid.
    /// - `InvalidPlatform.ValueNotSupported`: The specified Platform is invalid.
    /// - `OperationDenied.PlatformNotSupported`: The specified private pool does not support this operation.
    /// - `OperationDenied.EndTimeTypeNotSupported`: The specified private pool does not support this operation.
    /// - `OperationDenied.StartTimeNotSupported`: The specified private pool does not support this operation.
    /// - `OperationDenied.InstanceAmountNotSupported`: The specified private pool does not support this operation.
    /// - `InvalidInstanceAmount.ValueNotSupported`: The specified InstanceAmount is invalid.
    /// - `InvalidPrivatePoolOptions.Id`: The specified private pool does not support this operation.
    /// - `InvalidInstanceAmount.LessThanUsedAmount`: The specified parameter InstanceAmount is less than UsedAmount.
    /// - `InvalidOperation.InstanceAmountAndOtherAttributesUnsupported`: Modify InstanceAmount and other attributes simultaneously is not supported.
    /// - `QuotaExceed.ElasticityAssuranceCapacity`: ElasticityAssurance Capacity quota exceeded.
    /// - `InvalidPrivatePoolId.NotFound`: The specified private pool does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_elasticity_assurance(
        &self,
        req: ModifyElasticityAssurance,
    ) -> impl std::future::Future<Output = crate::Result<ModifyElasticityAssuranceResponse>> + Send
    {
        self.call(req)
    }

    /// # 续费弹性保障服务
    ///
    /// 对一个或多个已购买的弹性保障服务进行续费。
    ///
    /// # Error Codes
    /// - `InvalidPeriodUnit.ValueNotSupported`: The specified parameter PeriodUnit is not valid.
    /// - `InvalidChargeType.ValueNotSupported`: ChargeType is not valid.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified parameter PrivatePoolOptions.Id does not exist.
    /// - `InvalidParameter.PeriodUnit`: The specified PeriodUnit is invalid.
    /// - `InvalidParameter.Period`: The specified parameter Period or PeriodUnit is invalid.
    /// - `InvalidParameter.PrivatePoolOptionsId`: The specified parameter PrivatePoolOptions.Id is invalid.
    /// - `InvalidAutoRenewPeriod.ValueNotSupported`: The specified autoRenewPeriod is invalid.
    /// - `InvalidParameter.ResourceOwnerAccount`: ResourceOwnerAccount is Invalid.
    /// - `Account.Arrearage`: Your account has been in arrears.
    /// - `ChargeTypeViolation`: The operation is not permitted due to charge type of the instance.
    /// - `InvalidOperation.PackageTypeUnsupported`: Not support to renew this type of resource package.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `IncorrectPrivatePoolStatus`: The current status of the private pool does not support this operation.
    /// - `InvalidPrivatePoolId.NotFound`: The specified private pool does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn renew_elasticity_assurances(
        &self,
        req: RenewElasticityAssurances,
    ) -> impl std::future::Future<Output = crate::Result<RenewElasticityAssurancesResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改弹性保障服务自动续费
    ///
    /// 修改一个或多个弹性保障服务的自动续费属性。
    ///
    /// # Error Codes
    /// - `Invalid.PrivatePoolOptionsId`: The specified PrivatePoolOptions.Id is invalid.
    /// - `Invalid.TooManyPrivatePoolOptions.Ids`: Too many PrivatePoolOptions.Ids in this request.
    /// - `InvalidParameter.Period`: The specified Period is not valid.
    /// - `InvalidParameter.PeriodUnit`: The specified PeriodUnit is not supported.
    /// - `MissingParameter.PrivatePoolOptionsId`: The specified PrivatePoolOptions.Id should not be null.
    /// - `InvalidParameter.RenewalStatus`: The specified parameter RenewalStatus is not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_elasticity_assurance_auto_renew_attribute(
        &self,
        req: ModifyElasticityAssuranceAutoRenewAttribute,
    ) -> impl std::future::Future<
        Output = crate::Result<ModifyElasticityAssuranceAutoRenewAttributeResponse>,
    > + Send {
        self.call(req)
    }

    /// # 查询弹性保障服务自动续费
    ///
    /// 查询一个或多个弹性保障服务的自动续费属性。
    ///
    /// # Error Codes
    /// - `Invalid.PrivatePoolOptionsId`: The specified PrivatePoolOptions.Id is invalid.
    /// - `Invalid.TooManyPrivatePoolOptions.Ids`: Too many PrivatePoolOptions.Ids in this request.
    /// - `MissingParameter.PrivatePoolOptionsId`: The specified PrivatePoolOptions.Id should not be null.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_elasticity_assurance_auto_renew_attribute(
        &self,
        req: DescribeElasticityAssuranceAutoRenewAttribute,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeElasticityAssuranceAutoRenewAttributeResponse>,
    > + Send {
        self.call(req)
    }

    /// # 购买一个准备完毕的弹性保障服务
    ///
    /// 本接口旨在为用户提供便捷、高效的方式来购买弹性保障服务。当用户存在资源准备完毕，处于未激活状态的弹性保障服务时，可以通过该接口进行购买。
    ///
    /// 请确保在使用该接口前，已充分了解弹性保障产品的收费方式和<props="china">[价格](https://www.aliyun.com/price/product#/ecs/detail)</props><props="intl">[价格](https://www.alibabacloud.com/zh?spm=5176.28117011.nav-v2-dropdown-language.exp-location-zh.9ae4165bF98IHz&_p_lc=1)</props>。
    ///
    /// 购买弹性保障服务前，您可以调用[DescribeElasticityAssurances](~~2679748~~)查询可购买的弹性保障服务。
    ///
    /// # Error Codes
    /// - `InvalidStartTime.MalFormed`: The specified StartTime is out of the permitted range.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `InvalidParameter.PeriodUnit`: The specified PeriodUnit is not supported.
    /// - `InvalidUser.Unauthorized`: The user is not authorized.
    /// - `IncorrectPrivatePoolStatus`: The current status of the private pool does not support this operation.
    /// - `InternalError`: Internal error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn purchase_elasticity_assurance(
        &self,
        req: PurchaseElasticityAssurance,
    ) -> impl std::future::Future<Output = crate::Result<PurchaseElasticityAssuranceResponse>> + Send
    {
        self.call(req)
    }

    /// # 创建容量预定服务
    ///
    /// 指定需要预留的实例规格、总数量，生效方式和可用区等，创建容量预定服务。
    ///
    /// ## 接口说明
    /// 您可以通过容量预定服务，指定可用区、实例规格等属性，系统会以私有池的方式预留属性相匹配的资源。更多信息，请参见[立即生效容量预定概述](~~193633~~)。
    ///
    /// - 目前服务仅支持立即生效模式。购买立即生效容量预定服务后，实例规格即开始遵循按量付费标准计费，不论是否实际创建了按量付费实例，直至您自行手动释放或到期系统自动释放立即生效容量预订。
    ///     - 您可以通过[CreateInstance](~~25499~~)或[RunInstances](~~63440~~)创建实例时设置私有池容量选项，或者通过[ModifyInstanceAttachmentAttributes](~~190006~~)修改实例的私有池容量选项。实例成功匹配私有池容量后，将根据您的实例配置收取实例规格、云盘、公网带宽等相关资源费用。
    ///     - 未实际创建按量付费实例时，仅收取实例规格的费用。
    /// - 立即生效容量预定的匹配的实例和未使用的容量账单支持通过节省计划、地域级预留实例券抵扣小时账单，不支持通过可用区级预留实例券抵扣小时账单。推荐您先购买预留实例券或节省计划，在预留实例券或节省计划的覆盖下使用立即生效容量预定服务，可以免费获取资源的确定性保障。
    ///
    /// > 调用API方式仅支持创建立即生效容量预定。通过ECS控制台可以创建立即生效容量预定或指定时间生效容量预定，更多信息，请参见[资源预定服务](~~193626#section-oil-qh5-xvx~~)。
    ///
    /// # Error Codes
    /// - `InvalidParameter.RegionId`: The specified RegionId is invalid.
    /// - `NoStock`: The stock in the availability zone is insufficient.
    /// - `MissingParameter`: The input parameter StartTime is missing.
    /// - `OperationDenied`: The specified instanceType or zone is not available or not authorized.
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidStartTime.NotSupported`: The specified StartTime should be within 180 calendar days from the current date, and you must specify a precision to hour.
    /// - `InvalidStartTime.MalFormed`: The specified StartTime is out of the permitted range.
    /// - `Invalid.PrivatePoolOptionsName.MalFormed`: The specified PrivatePoolOptions.Name is not valid.
    /// - `Invalid.ZoneId`: The specified ZoneId is not valid.
    /// - `Invalid.InstanceType`: The specified InstanceType is not valid.
    /// - `DedicatedHostNotSupported`: DedicatedHost is not supported for PrivatePool.
    /// - `SpotNotSupported`: Spot is not supported for PrivatePool.
    /// - `ClassicNetworkNotSupported`: Classic network is not supported for PrivatePool.
    /// - `Invalid.InstanceId`: Instance does not exist.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `Invalid.InstanceChargeType`: The InstanceChargeType does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.status`: The PrivatePool has been used up.
    /// - `InvalidPlatform.ValueNotSupported`: The Platform does not match the PrivatePool.
    /// - `InvalidAliUid`: The PrivatePool does not belong to the user of the Instance.
    /// - `MissingParameter.PackageType`: The specified parameter "PackageType" can not be empty.
    /// - `MissingParameter.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCount`: The specified parameter "InstanceCpuCoreCount" can not be empty.
    /// - `MissingParameter.InstanceAmount`: The specified parameter "InstanceAmount" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCountOrInstanceAmount`: The specified parameter "InstanceCpuCoreCount" and "InstanceAmount" must not be empty at the same time.
    /// - `Invalid.TooManyPrivatePoolOptions.Ids`: Too many PrivatePoolOptions.Ids in this request.
    /// - `Invalid.TooManyZoneIds`: Too many ZoneIds in the request.
    /// - `Invalid.TooManyInstanceTypes`: Too many InstanceTypes in the request.
    /// - `Invalid.TooManyUnpaidPrivatePool`: Too many PrivatePools create but still unpaid.
    /// - `Invalid.InstanceCpuCoreCountOrInstanceAmount`: Both InstanceCpuCoreCount and InstanceAmount are provided.
    /// - `Invalid.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" exist invalid element Id.
    /// - `Invalid.PackageType`: The specified parameter "PackageType" is invalid.
    /// - `Invalid.PrivatePool.Purchase`: The PrivatePool has already paid.
    /// - `Invalid.AssuranceTimes.NotSupported`: The value of AssuranceTimes is not supported.
    /// - `RepeatStartPrivatePool`: PrivatePool has already been started.
    /// - `Invalid.TimeSlot`: The param time slot is invalid.
    /// - `Invalid.EndTime`: The specified parameter "EndTime" is not valid.
    /// - `StartTime.NotNeed`: The specified parameter "StartTime" should leave empty.
    /// - `AccountForbidden.ProductCreationLimited`: The commodity must be officially operated by Aliyun and in pay-as-you-go billing method.
    /// - `RegionUnauthorized`: There is no authority to create private pool in the specified region.
    /// - `PriceNotFound`: The price of your queried resource is not available now, please try other resources.
    /// - `Zone.NotOpen`: The specified zone is not granted to you to buy resources yet.
    /// - `InvalidResourceType.NotSupported`: %s
    /// - `OperationDenied.NoStock`: The resource is out of stock in the specified zone. Please try other types, or choose other regions and zones.
    /// - `InvalidInstanceType.NotSupported`: The specified InstanceType is invalid.
    /// - `Invalid.ZoneIds`: At least one of the specified ZoneIds are invalid.
    /// - `Zone.NotOnSale`: The specified zone is not available for purchase.
    /// - `InvalidZoneId.NotFound`: The specified zoneId does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_capacity_reservation(
        &self,
        req: CreateCapacityReservation,
    ) -> impl std::future::Future<Output = crate::Result<CreateCapacityReservationResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询容量预定服务的信息
    ///
    /// 查询一个或多个容量预定服务的详细信息，例如服务的状态、服务的生效与失效时间、私有池的模式和已使用的实例的数量等。
    ///
    /// # Error Codes
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidParameter.Name`: The specified PrivatePoolOptions.Name is invalid.
    /// - `InvalidParameter.PrivatePoolOptions.Ids`: The specified PrivatePoolOptions.Ids is invalid.
    /// - `DedicatedHostNotSupported`: DedicatedHost is not supported for PrivatePool.
    /// - `SpotNotSupported`: Spot is not supported for PrivatePool.
    /// - `ClassicNetworkNotSupported`: Classic network is not supported for PrivatePool.
    /// - `Invalid.InstanceId`: Instance does not exist.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `Invalid.InstanceType`: The InstanceType does not match the PrivatePool.
    /// - `Invalid.InstanceChargeType`: The InstanceChargeType does not match the PrivatePool.
    /// - `Invalid.ZoneId`: The ZoneId does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.status`: The PrivatePool has been used up.
    /// - `InvalidPlatform.ValueNotSupported`: The Platform does not match the PrivatePool.
    /// - `InvalidAliUid`: The PrivatePool does not belong to the user of the Instance.
    /// - `MissingParameter.PackageType`: The specified parameter "PackageType" can not be empty.
    /// - `MissingParameter.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCount`: The specified parameter "InstanceCpuCoreCount" can not be empty.
    /// - `MissingParameter.InstanceAmount`: The specified parameter "InstanceAmount" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCountOrInstanceAmount`: The specified parameter "InstanceCpuCoreCount" and "InstanceAmount" must not be empty at the same time.
    /// - `Invalid.TooManyPrivatePoolOptions.Ids`: Too many PrivatePoolOptions.Ids in this request.
    /// - `Invalid.TooManyZoneIds`: Too many ZoneIds in the request.
    /// - `Invalid.TooManyInstanceTypes`: Too many InstanceTypes in the request.
    /// - `Invalid.TooManyUnpaidPrivatePool`: Too many PrivatePools create but still unpaid.
    /// - `Invalid.InstanceCpuCoreCountOrInstanceAmount`: Both InstanceCpuCoreCount and InstanceAmount are provided.
    /// - `Invalid.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" exist invalid element Id.
    /// - `Invalid.PackageType`: The specified parameter "PackageType" is invalid.
    /// - `Invalid.PrivatePool.Purchase`: The PrivatePool has already paid.
    /// - `Invalid.AssuranceTimes.NotSupported`: The value of AssuranceTimes is not supported.
    /// - `RepeatStartPrivatePool`: PrivatePool has already been started.
    /// - `InvalidParameter.RegionId`: The specified RegionId is not exist.
    /// - `InvalidPermission.ResourceShareAssocoated`: The current resource is associated to a shared relationship and cannot be released.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_capacity_reservations(
        &self,
        req: DescribeCapacityReservations,
    ) -> impl std::future::Future<Output = crate::Result<DescribeCapacityReservationsResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询容量预定服务已匹配的实例列表
    ///
    /// 查询容量预定服务已匹配的实例列表。
    ///
    /// # Error Codes
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id is invalid.
    /// - `DedicatedHostNotSupported`: DedicatedHost is not supported for PrivatePool.
    /// - `SpotNotSupported`: Spot is not supported for PrivatePool.
    /// - `ClassicNetworkNotSupported`: Classic network is not supported for PrivatePool.
    /// - `Invalid.InstanceId`: Instance does not exist.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `Invalid.InstanceType`: The InstanceType does not match the PrivatePool.
    /// - `Invalid.InstanceChargeType`: The InstanceChargeType does not match the PrivatePool.
    /// - `Invalid.ZoneId`: The ZoneId does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.status`: The PrivatePool has been used up.
    /// - `InvalidPlatform.ValueNotSupported`: The Platform does not match the PrivatePool.
    /// - `InvalidAliUid`: The PrivatePool does not belong to the user of the Instance.
    /// - `MissingParameter.PackageType`: The specified parameter "PackageType" can not be empty.
    /// - `MissingParameter.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCount`: The specified parameter "InstanceCpuCoreCount" can not be empty.
    /// - `MissingParameter.InstanceAmount`: The specified parameter "InstanceAmount" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCountOrInstanceAmount`: The specified parameter "InstanceCpuCoreCount" and "InstanceAmount" must not be empty at the same time.
    /// - `Invalid.TooManyPrivatePoolOptions.Ids`: Too many PrivatePoolOptions.Ids in this request.
    /// - `Invalid.TooManyZoneIds`: Too many ZoneIds in the request.
    /// - `Invalid.TooManyInstanceTypes`: Too many InstanceTypes in the request.
    /// - `Invalid.TooManyUnpaidPrivatePool`: Too many PrivatePools create but still unpaid.
    /// - `Invalid.InstanceCpuCoreCountOrInstanceAmount`: Both InstanceCpuCoreCount and InstanceAmount are provided.
    /// - `Invalid.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" exist invalid element Id.
    /// - `Invalid.PackageType`: The specified parameter "PackageType" is invalid.
    /// - `Invalid.PrivatePool.Purchase`: The PrivatePool has already paid.
    /// - `Invalid.AssuranceTimes.NotSupported`: The value of AssuranceTimes is not supported.
    /// - `RepeatStartPrivatePool`: PrivatePool has already been started.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_capacity_reservation_instances(
        &self,
        req: DescribeCapacityReservationInstances,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeCapacityReservationInstancesResponse>,
    > + Send {
        self.call(req)
    }

    /// # 修改一个容量预定服务的部分信息
    ///
    /// 调用ModifyCapacityReservation修改一个容量预定服务的部分信息，包括容量预定服务的名称、描述信息、失效方式以及预留的实例总数量。
    ///
    /// # Error Codes
    /// - `InvalidInstanceAmount.ValueNotSupported`: The specified parameter InstanceAmount is not valid.
    /// - `InvalidDescription.ValueNotSupported`: The specified Description is invalid.
    /// - `InvalidEndTime.ValueNotSupported`: The specified EndTime is invalid.
    /// - `InvalidStartTime.ValueNotSupported`: The specified StartTime is invalid.
    /// - `InvalidUser.Unauthorized`: The user is not authorized.
    /// - `IncorrectPrivatePoolStatus`: The current status of the private pool does not support this operation.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone; try other types of resources or other regions and zones.
    /// - `InvalidPrivatePoolOptionsName.ValueNotSupported`: The specified PrivatePoolOptions.Name is invalid.
    /// - `InvalidPlatform.ValueNotSupported`: The specified Platform is invalid.
    /// - `OperationDenied.PlatformNotSupported`: The specified private pool does not support this operation.
    /// - `OperationDenied.EndTimeTypeNotSupported`: The specified private pool does not support this operation.
    /// - `OperationDenied.StartTimeNotSupported`: The specified private pool does not support this operation.
    /// - `OperationDenied.InstanceAmountNotSupported`: The specified private pool does not support this operation.
    /// - `InvalidInstanceAmount.ValueNotSupported`: The specified InstanceAmount is invalid.
    /// - `InvalidPrivatePoolOptions.Id`: The specified private pool does not support this operation.
    /// - `OperationDenied.InstanceTypeNotAuthorized`: The specified InstanceType is not available or not authorized.
    /// - `InvalidPrivatePoolId.NotFound`: The specified private pool does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_capacity_reservation(
        &self,
        req: ModifyCapacityReservation,
    ) -> impl std::future::Future<Output = crate::Result<ModifyCapacityReservationResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询实例匹配的私有池信息
    ///
    /// 查询实例匹配的私有池信息，例如匹配模式、私有池ID等。
    ///
    /// ## 接口说明
    ///
    /// 私有池是弹性保障服务或容量预定服务在创建后生成的，关联了与私有池匹配的实例信息。您可以在创建实例时设置私有池，实例将会与弹性保障服务或容量预定服务进行匹配。
    ///
    /// 当私有池失效后，实例与私有池的匹配关联数据也会失效。此时调用该接口，返回值的私有池信息将为空。
    ///
    /// # Error Codes
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `DedicatedHostNotSupported`: DedicatedHost is not supported for PrivatePool.
    /// - `SpotNotSupported`: Spot is not supported for PrivatePool.
    /// - `ClassicNetworkNotSupported`: Classic network is not supported for PrivatePool.
    /// - `Invalid.InstanceId`: Instance does not exist.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `Invalid.InstanceType`: The InstanceType does not match the PrivatePool.
    /// - `Invalid.InstanceChargeType`: The InstanceChargeType does not match the PrivatePool.
    /// - `Invalid.ZoneId`: The ZoneId does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.status`: The PrivatePool has been used up.
    /// - `InvalidPlatform.ValueNotSupported`: The Platform does not match the PrivatePool.
    /// - `InvalidAliUid`: The PrivatePool does not belong to the user of the Instance.
    /// - `MissingParameter.PackageType`: The specified parameter "PackageType" can not be empty.
    /// - `MissingParameter.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCount`: The specified parameter "InstanceCpuCoreCount" can not be empty.
    /// - `MissingParameter.InstanceAmount`: The specified parameter "InstanceAmount" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCountOrInstanceAmount`: The specified parameter "InstanceCpuCoreCount" and "InstanceAmount" must not be empty at the same time.
    /// - `Invalid.TooManyPrivatePoolOptions.Ids`: Too many PrivatePoolOptions.Ids in this request.
    /// - `Invalid.TooManyZoneIds`: Too many ZoneIds in the request.
    /// - `Invalid.TooManyInstanceTypes`: Too many InstanceTypes in the request.
    /// - `Invalid.TooManyUnpaidPrivatePool`: Too many PrivatePools create but still unpaid.
    /// - `Invalid.InstanceCpuCoreCountOrInstanceAmount`: Both InstanceCpuCoreCount and InstanceAmount are provided.
    /// - `Invalid.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" exist invalid element Id.
    /// - `Invalid.PackageType`: The specified parameter "PackageType" is invalid.
    /// - `Invalid.PrivatePool.Purchase`: The PrivatePool has already paid.
    /// - `Invalid.AssuranceTimes.NotSupported`: The value of AssuranceTimes is not supported.
    /// - `RepeatStartPrivatePool`: PrivatePool has already been started.
    /// - `InvalidParameter.TooManyInstanceIds`: Instance ids cannot be more than 100.
    /// - `Abs.InvalidInstanceIds.MalFormed`: The specified InstanceIds is not valid.
    /// - `InvalidInstanceIds.NotFound`: The specified InstanceIds does not exist.
    /// - `InvalidParameter`: Invalid parameters.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_attachment_attributes(
        &self,
        req: DescribeInstanceAttachmentAttributes,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeInstanceAttachmentAttributesResponse>,
    > + Send {
        self.call(req)
    }

    /// # 修改实例的私有池的属性
    ///
    /// 修改实例的私有池匹配模式。
    ///
    /// 私有池是弹性保障服务或容量预定服务在创建后生成的，关联了与私有池匹配的实例信息。您可以在创建实例时设置是否使用私有池启动，实例将会与弹性保障服务或容量预定服务进行匹配。
    ///
    /// - 调用该接口修改实例的私有池的属性后，实例不需要重启。
    /// - 当您调用以下接口时，系统会重新匹配实例的私有池。如果实例已匹配了指定的私有池，可能因私有池容量已用完或私有池失效等原因造成调用失败的问题。如果出现调用失败的问题，请先调用ModifyInstanceAttachmentAttributes接口将私有池的匹配模式修改为`Open`。
    ///     - [StartInstance - 重启启用节省停机模式的实例。](~~2679679~~)
    ///     - [ReActivateInstances - 重新启动已过期或欠费回收的实例。](~~2679707~~)
    ///     - [ModifyInstanceChargeType - 修改实例付费类型](~~2679704~~)。
    ///     - [ModifyPrepayInstanceSpec - 升级或降低实例规格](~~2679706~~)。
    ///     - [ReplaceSystemDisk - 更换操作系统](~~2679771~~)。
    ///
    /// # Error Codes
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `MissingParameter.InstanceId`: The specified InstanceId should not be null.
    /// - `InvalidResourcePackage.BizStatus`: The resource package business status is not supported.
    /// - `InvalidInstanceId.MalFormed`: The specified InstanceId is not valid.
    /// - `DedicatedHostNotSupported`: DedicatedHost is not supported for PrivatePool.
    /// - `SpotNotSupported`: Spot is not supported for PrivatePool.
    /// - `ClassicNetworkNotSupported`: Classic network is not supported for PrivatePool.
    /// - `Invalid.InstanceId`: Instance does not exist.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `Invalid.InstanceType`: The InstanceType does not match the PrivatePool.
    /// - `Invalid.InstanceChargeType`: The InstanceChargeType does not match the PrivatePool.
    /// - `Invalid.ZoneId`: The ZoneId does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.NoStock`: The PrivatePool has been used up.
    /// - `InvalidPlatform.ValueNotSupported`: The Platform does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.status`: The PrivatePool is expired or inactive.
    /// - `InvalidAliUid`: The PrivatePool does not belong to the user of the Instance.
    /// - `MissingParameter.PackageType`: The specified parameter "PackageType" can not be empty.
    /// - `MissingParameter.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCount`: The specified parameter "InstanceCpuCoreCount" can not be empty.
    /// - `MissingParameter.InstanceAmount`: The specified parameter "InstanceAmount" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCountOrInstanceAmount`: The specified parameter "InstanceCpuCoreCount" and "InstanceAmount" must not be empty at the same time.
    /// - `Invalid.TooManyPrivatePoolOptions.Ids`: Too many PrivatePoolOptions.Ids in this request.
    /// - `Invalid.TooManyZoneIds`: Too many ZoneIds in the request.
    /// - `Invalid.TooManyInstanceTypes`: Too many InstanceTypes in the request.
    /// - `Invalid.TooManyUnpaidPrivatePool`: Too many PrivatePools create but still unpaid.
    /// - `Invalid.InstanceCpuCoreCountOrInstanceAmount`: Both InstanceCpuCoreCount and InstanceAmount are provided.
    /// - `Invalid.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" exist invalid element Id.
    /// - `Invalid.PackageType`: The specified parameter "PackageType" is invalid.
    /// - `Invalid.PrivatePool.Purchase`: The PrivatePool has already paid.
    /// - `Invalid.AssuranceTimes.NotSupported`: The value of AssuranceTimes is not supported.
    /// - `RepeatStartPrivatePool`: PrivatePool has already been started.
    /// - `InvalidOperation.PrePaidInstanceUnsupported`: Not support to modify the private pool options of prepay instances.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_attachment_attributes(
        &self,
        req: ModifyInstanceAttachmentAttributes,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInstanceAttachmentAttributesResponse>>
    + Send {
        self.call(req)
    }

    /// # 释放容量预定服务
    ///
    /// 调用ReleaseCapacityReservation释放容量预定服务。
    ///
    /// 立即生效的容量预定服务，当释放方式为手动释放时，调用该接口可直接释放容量预定服务。
    ///
    /// # Error Codes
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidParameter.Name`: The specified PrivatePoolOptions.Name is invalid.
    /// - `InvalidParameter.PrivatePoolOptions.Ids`: The specified PrivatePoolOptions.Ids is invalid.
    /// - `DedicatedHostNotSupported`: DedicatedHost is not supported for PrivatePool.
    /// - `SpotNotSupported`: Spot is not supported for PrivatePool.
    /// - `ClassicNetworkNotSupported`: Classic network is not supported for PrivatePool.
    /// - `Invalid.InstanceId`: Instance does not exist.
    /// - `Invalid.PrivatePoolOptions.MatchCriteria`: Target mode does not support this operation.
    /// - `MissingParameter.PrivatePoolOptions.Id`: The specified PrivatePoolOptions.Id should not be null.
    /// - `Invalid.PrivatePoolOptions.Id`: The PrivatePool does not exist.
    /// - `Invalid.InstanceType`: The InstanceType does not match the PrivatePool.
    /// - `Invalid.InstanceChargeType`: The InstanceChargeType does not match the PrivatePool.
    /// - `Invalid.ZoneId`: The ZoneId does not match the PrivatePool.
    /// - `Invalid.PrivatePoolOptions.status`: The PrivatePool has been used up.
    /// - `InvalidPlatform.ValueNotSupported`: The Platform does not match the PrivatePool.
    /// - `InvalidAliUid`: The PrivatePool does not belong to the user of the Instance.
    /// - `MissingParameter.PackageType`: The specified parameter "PackageType" can not be empty.
    /// - `MissingParameter.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCount`: The specified parameter "InstanceCpuCoreCount" can not be empty.
    /// - `MissingParameter.InstanceAmount`: The specified parameter "InstanceAmount" can not be empty.
    /// - `MissingParameter.InstanceCpuCoreCountOrInstanceAmount`: The specified parameter "InstanceCpuCoreCount" and "InstanceAmount" must not be empty at the same time.
    /// - `Invalid.TooManyPrivatePoolOptions.Ids`: Too many PrivatePoolOptions.Ids in this request.
    /// - `Invalid.TooManyZoneIds`: Too many ZoneIds in the request.
    /// - `Invalid.TooManyInstanceTypes`: Too many InstanceTypes in the request.
    /// - `Invalid.TooManyUnpaidPrivatePool`: Too many PrivatePools create but still unpaid.
    /// - `Invalid.InstanceCpuCoreCountOrInstanceAmount`: Both InstanceCpuCoreCount and InstanceAmount are provided.
    /// - `Invalid.PrivatePoolOptions.Ids`: The specified parameter "PrivatePoolOptions.Ids" exist invalid element Id.
    /// - `Invalid.PackageType`: The specified parameter "PackageType" is invalid.
    /// - `Invalid.PrivatePool.Purchase`: The PrivatePool has already paid.
    /// - `Invalid.AssuranceTimes.NotSupported`: The value of AssuranceTimes is not supported.
    /// - `RepeatStartPrivatePool`: PrivatePool has already been started.
    /// - `Invalid.Action.ReleaseCapacityReservation`: Release action is not supported when using Limited endTimeType, please change it to Unlimited first.
    /// - `InvalidOperation.ReleasePrivatePoolUnsupported`: The specified private pool does not support release.
    /// - `InvalidPermission.ResourceShareAssocoated`: The current resource is associated to a shared relationship and cannot be released.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn release_capacity_reservation(
        &self,
        req: ReleaseCapacityReservation,
    ) -> impl std::future::Future<Output = crate::Result<ReleaseCapacityReservationResponse>> + Send
    {
        self.call(req)
    }

    /// # 购买预留实例券
    ///
    /// 本接口用于购买一张预留实例券，支持您购买一张地域级或者可用区级的预留实例券来抵扣对应规格的按量付费实例账单。
    ///
    /// <props="china">
    ///
    /// **请确保在使用该接口前，已充分了解预留实例券的收费方式和[价格](https://www.aliyun.com/price/product#/ecs/detail)。**
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// **请确保在使用该接口前，已充分了解预留实例券的收费方式和[价格](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl)。**
    ///
    /// </props>
    ///
    /// - 请确保在使用该接口前，您已充分了解预留实例券的计费规则。详情请参见[预留实例券](~~100371~~)。
    /// - 在所有地域下，您最多可以持有20张地域级预留实例券。
    /// - 单个可用区下，您最多可以持有20张可用区级预留实例券。
    ///
    /// ## 请求示例
    /// - 在杭州地域下购买一张时长1年的地域级预留实例券，用来抵扣3台实例规格为ecs.g5.large、操作系统为Linux的按量付费实例账单。
    /// ```ignore
    /// "RegionId":"cn-hangzhou", //设置地域为杭州
    /// "InstanceType":"ecs.g5.large", //设置实例规格
    /// "Scope":"Region", //设置预留实例券的范围为地域级
    /// "InstanceAmount":3, //表示预留实例券可以同时匹配同规格按量付费实例的数量为3台
    /// "OfferingType":"All Upfront", //默认值，表示付款类型为全预付
    /// "Platform":"Linux", //实例使用的镜像的操作系统类型为Linux或者类Unix类型的操作系统
    /// "Period":1, //购买预留实例券的时长为1年
    /// "PeriodUnit":"Year", //设置时长单位为年
    /// ```
    ///
    /// - 在杭州地域的可用区 H 下购买一张时长2年的可用区级预留实例券，用来抵扣5台实例规格为ecs.g5.large、操作系统为Windows的按量付费实例账单。
    /// ```ignore
    /// "RegionId":"cn-hangzhou",
    /// "ZoneId":"cn-hangzhou-h", //设置可用区为可用区 H
    /// "InstanceType":"ecs.g5.large",
    /// "Scope":"Zone", //设置预留实例券的范围为可用区级
    /// "InstanceAmount":5, //表示预留实例券可以同时匹配同规格按量付费实例的数量为5台
    /// "OfferingType":"All Upfront",
    /// "Platform":"Windows", //实例使用的镜像的操作系统类型为Windows
    /// "Period":2, //购买预留实例券的时长为2年
    /// "PeriodUnit":"Year", //设置时长单位为年
    /// ```
    ///
    /// # Error Codes
    /// - `InvalidStartTime.ScopeNotMatch`: Zonal reservedInstance not supported for scheduled creating.
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType is not authorized.
    /// - `InvalidDescription.Malformed`: The specified parameter "Description" is not valid.
    /// - `InvalidParameter.Conflict`: The specified region and cluster do not match.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidPeriodUnit.ValueNotSupported`: The specified parameter PeriodUnit is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidChargeType.ValueNotSupported`: ChargeType is not valid.
    /// - `InvalidParameter.Scope`: The specified parameter 'Scope' is invalid.
    /// - `InvalidReservedInstanceStatus.ValueNotSupported`: ReservedInstance status is not supported.
    /// - `InvalidReservedInstanceOfferingType.ValueNotSupported`: The OfferingType is not supported.
    /// - `InvalidReservedInstanceOfferingClass.ValueNotSupported`: The OfferingClass is not supported.
    /// - `MissingParameter.ZoneId`: The specified zoneId should be not empty.
    /// - `MissingParameter.InstanceType`: The instanceType should be not empty.
    /// - `MissingParameter.ReservedInstanceId`: The ids of reservedInstance can not be empty.
    /// - `MissingParameter.ReservedInstanceConfiguration`: The configurations of reservedInstance can not be empty.
    /// - `InvalidParameter.SplitOrMerge`: The Many-to-many of modification is not supported.
    /// - `MissingParameter.InstanceTypeAndAmountBothEmpty`: The instanceType and amount can not be both empty.
    /// - `InvalidReservedInstancePlatform.ValueNotSupported`: The Platform is not supported.
    /// - `InvalidParameter.ReservedInstanceName`: ReservedInstanceName is invalid.
    /// - `InvalidReservedInstanceZone.ValueNotSupported`: The zoneId is not exist.
    /// - `OperationDenied`: The specified InstanceType or Zone is not authorized for current user.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType beyond the permitted range.
    /// - `OperationDenied`: The creation of Host to the specified Zone is not allowed.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone; try other types of resources or other regions and zones.
    /// - `NodeControllerUnavailable`: The Node Controller is temporarily unavailable.
    /// - `InvalidParameter.ResourceOwnerAccount`: ResourceOwnerAccount is Invalid.
    /// - `Zone.NotOpen`: The specified zone is not granted to you to buy resources yet.
    /// - `Zone.NotOnSale`: The specified zone is not available for purchase.
    /// - `Account.Arrearage`: Your account has been in arrears.
    /// - `InvalidStartTime.MalFormed`: The specified StartTime is not valid.
    /// - `InvalidStartTime.NotSupported`: The specified startTime is not supported.
    /// - `RegionUnauthorized`: You are not authorized to perform the operation in the specified region.
    /// - `InvalidZoneId.NotFound`: The ZoneId provided does not exist in our records.
    /// - `PaymentMethodNotFound`: No payment method has been registered on the account.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn purchase_reserved_instances_offering(
        &self,
        req: PurchaseReservedInstancesOffering,
    ) -> impl std::future::Future<Output = crate::Result<PurchaseReservedInstancesOfferingResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询预留实例券详细信息列表
    ///
    /// 本接口主要用于查询指定地域下您已经购买的预留实例券信息列表，支持您根据标签、预留实例券属性等参数获取预留实例券详细信息列表。
    ///
    /// ### 适用场景
    /// - 查询指定地域下所有的预留实例券。
    /// - 根据预留实例券ID或名称查询其详细信息。
    /// - 根据实例规格或者实例规格族过滤查询您已购买的预留实例券。
    /// - 根据预留实例券范围或者状态过滤查询您已购买的预留实例券。
    ///
    /// ### 请求示例
    /// <details>
    /// <summary>示例：查询杭州地域下所有已购买的预留实例券</summary>
    ///
    /// ```ignore
    /// "Region":"cn-hangzhou" //设置地域为杭州
    /// ```
    /// </details>
    /// <details>
    /// <summary>示例：查询杭州地域下ID为ecsri-bp129enntoynwwj5****的预留实例券的详细信息</summary>
    ///
    /// ```ignore
    /// "Region":"cn-hangzhou", //设置地域为杭州
    /// "ReservedInstanceId":"ecsri-bp129enntoynwwj5****" //设置预留实例券ID
    /// ```
    /// </details>
    /// <details>
    /// <summary>示例：查询杭州地域下可以抵扣实例规格为ecs.c5.2xlarge的预留实例券</summary>
    ///
    /// ```ignore
    /// "Region":"cn-hangzhou", //设置地域为杭州
    /// "InstanceType":"ecs.c5.2xlarge" //设置实例规格
    /// ```
    /// </details>
    /// <details>
    /// <summary>示例：查询杭州地域下在有效期中的地域级预留实例券</summary>
    ///
    /// ```ignore
    /// "Region":"cn-hangzhou", //设置地域为杭州
    /// "Scope":"Region", //设置预留实例券范围
    /// "Status":["Active"] //设置状态为在有效期中
    /// ```
    /// </details>
    ///
    /// # Error Codes
    /// - `MissingParamter.RegionId`: The regionId should not be null.
    /// - `InvalidRegion.NotFound`: The specified parameter RegionId is not valid.
    /// - `InvalidZone.NotFound`: The specified parameter ZoneId is not valid.
    /// - `InvalidReservedInstanceOfferingType.ValueNotSupported`: the OfferingType is not supported
    /// - `InvalidReservedInstanceOfferingClass.ValueNotSupported`: the OfferingClass is not supported
    /// - `OperationDenied`: The specified InstanceType or Zone is not authorized for current user.
    /// - `InvalidEndTime.ValueNotSupported`: The specified endTime is out of the permitted range.
    /// - `InvalidReservedInstanceLockReason.ValueNotSupported`: The specified LockReason is not supported.
    /// - `InvalidReservedInstanceStatus.ValueNotSupported`: The specified Status is not supported.
    /// - `InvalidAllocationType.ValueNotSupported`: The specified AllocationType is not supported.
    /// - `RAM.ApiNotSupported`: This call is not supported from ram accessing.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_reserved_instances(
        &self,
        req: DescribeReservedInstances,
    ) -> impl std::future::Future<Output = crate::Result<DescribeReservedInstancesResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改预留实例券配置
    ///
    /// 本接口的主要功能是通过修改实例规格、数量、可用区等预留实例券的配置来对预留实例券进行拆分、合并或范围变更操作。
    ///
    /// 本接口为异步接口，接口调用成功后会返回新产生的预留实例券ID，原来的预留实例券会进入`更新中`状态，最终变为`失效`状态，与此同时，会有一张创建中状态的预留实例券产生，最终变为已生效状态，您可以通过[DescribeReservedInstances](~~2679781~~)进行查询。
    ///
    /// - 预留实例券只有在**已生效**状态下才可以修改配置。
    /// - 请确保修改配置前后预留实例券的[计算力](~~140660#2742f3844abzz~~)不会改变，否则修改请求会失败。
    /// - 预留实例券的拆分、合并、范围变更不能同时进行。
    ///
    /// 更多信息，请参见[拆分、合并或修改预留实例券](~~100375~~)。
    ///
    /// ## 请求示例
    ///
    /// - **拆分**：将一张杭州地域、实例规格为ecs.g5.xlarge、匹配数量为2的预留实例券拆分为两张实例规格为ecs.g5.large、匹配数量为1的预留实例券。
    /// ```ignore
    /// "RegionId":"cn-hangzhou", //设置地域为杭州
    /// "ReservedInstanceId":["ecsri-bp1hd03e9uv19e75****"], //需要拆分的预留实例券ID
    /// "Configuration":[
    ///   {
    ///     "ReservedInstanceName":"testReservedInstanceName1", //修改后的预留实例券名称
    ///     "InstanceType":"ecs.g5.large", //设置修改后的实例规格
    ///     "Scope":"Region", //预留实例券的范围不可改变
    ///     "InstanceAmount":1 //表示预留实例券可以同时匹配同规格按量付费实例的数量为1台
    ///   },
    ///   {
    ///     "ReservedInstanceName":"testReservedInstanceName2",
    ///     "InstanceType":"ecs.g5.large",
    ///     "Scope":"Region",
    ///     "InstanceAmount":1
    ///   }
    /// ]
    ///
    /// ```
    ///
    /// - **合并**：将两张杭州地域可用区 H 、实例规格为ecs.g5.xlarge、匹配数量为4的预留实例券合并为一张实例规格为ecs.g5.4xlarge、匹配数量为2的预留实例券。
    /// ```ignore
    /// "RegionId":"cn-hangzhou", //设置地域为杭州
    /// "ReservedInstanceId":["ecsri-bp1hd03e9uv16b75****",""ecsri-bp1hd03e9uv16b76****""], //需要合并的预留实例券ID
    /// "Configuration":[
    ///   {
    ///     "ReservedInstanceName":"testReservedInstanceName", //修改后的预留实例券名称
    ///     "InstanceType":"ecs.g5.4xlarge", //设置修改后的实例规格
    ///     "Scope":"Zone", //预留实例券的范围不可改变
    ///     "ZoneId":"cn-hangzhou-h", //
    ///     "InstanceAmount":2 //表示预留实例券可以同时匹配同规格按量付费实例的数量为2台
    ///   }
    /// ]
    /// ```
    ///
    /// - **变更范围**：将一张杭州地域可用区 H 、实例规格为ecs.g5.xlarge、匹配数量为6的预留实例券变更为一张杭州地域、实例规格为ecs.g5.2xlarge、匹配数量为3的预留实例券。
    /// ```ignore
    /// "RegionId":"cn-hangzhou", //设置地域为杭州
    /// "ReservedInstanceId":["ecsri-bp1hd03e9uv16b77****"], //需要变更范围的预留实例券ID
    /// "Configuration":[
    ///   {
    ///     "ReservedInstanceName":"testReservedInstanceName", //变更范围后的预留实例券名称
    ///     "InstanceType":"ecs.g5.2xlarge", //设置修改后的实例规格
    ///     "Scope":"Region", //变更后预留实例券的范围
    ///     "InstanceAmount":3 //表示预留实例券可以同时匹配同规格按量付费实例的数量为3台
    ///   }
    /// ]
    /// ```
    ///
    /// # Error Codes
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType is not authorized.
    /// - `InvalidParameter.Conflict`: The specified region and cluster do not match.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidPeriodUnit.ValueNotSupported`: The specified parameter PeriodUnit is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidChargeType.ValueNotSupported`: ChargeType is not valid.
    /// - `OperationDenied`: The specified InstanceType or Zone is not authorized for current user.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone; try other types of resources or other regions and zones.
    /// - `OperationDenied`: Sales of this resource are temporarily suspended in the specified region; please try again later.
    /// - `NodeControllerUnavailable`: The Node Controller is temporarily unavailable.
    /// - `InvalidParameter.ResourceOwnerAccount`: ResourceOwnerAccount is Invalid.
    /// - `Zone.NotOpen`: The specified zone is not granted to you to buy resources yet.
    /// - `Zone.NotOnSale`: The specified zone is not available for purchase.
    /// - `Account.Arrearage`: Your account has been in arrears.
    /// - `InvalidReservedInstanceName.Malformed`: The specified parameter ReservedInstanceName is invalid.
    /// - `InvalidParameter.Scope`: The specified parameter 'Scope' is invalid.
    /// - `InvalidReservedInstanceStatus.ValueNotSupported`: ReservedInstance status is not supported.
    /// - `InvalidReservedInstanceOfferingType.ValueNotSupported`: The OfferingType is not supported.
    /// - `InvalidReservedInstanceOfferingClass.ValueNotSupported`: The OfferingClass is not supported.
    /// - `MissingParameter.ZoneId`: The specified zoneId should be not empty.
    /// - `MissingParameter.InstanceType`: The instanceType should be not empty.
    /// - `MissingParameter.ReservedInstanceId`: The ids of reservedInstance can not be empty.
    /// - `MissingParameter.ReservedInstanceConfiguration`: The configurations of reservedInstance can not be empty.
    /// - `InvalidParameter.SplitOrMerge`: The Many-to-many of modification is not supported.
    /// - `MissingParameter.InstanceTypeAndAmountBothEmpty`: The instanceType and amount can not be both empty.
    /// - `InvalidReservedInstancePlatform.ValueNotSupported`: The Platform is not supported.
    /// - `InvalidParameter.ReservedInstanceName`: The reservedInstanceName is invalid.
    /// - `InvalidReservedInstanceZone.ValueNotSupported`: The zoneId is not exist.
    /// - `InvalidParameter.ValueNotSupported`: The instanceTypeFamily of the instance to be changed must be consistent.
    /// - `IncorrectInstanceStatus`: The status of specified reservedInstance must be active.
    /// - `InvalidPlatform.ValueNotSupported`: The platform of reservedInstance is invalid.
    /// - `InvalidScope.ValueNotSupported`: The scope of reservedInstance is invalid. The valid value is Zone or Region.
    /// - `InvalidConfiguration.ValueNotSupported`: The modification Configuration should not be empty.
    /// - `InvalidZoneId.ValueNotSupported`: The specified zoneId should be same.
    /// - `InvalidParameter`: The parameter is invalid.Please check it.
    /// - `InvalidInstanceAmount.ValueNotSupported`: The instanceAmount is invalid.
    /// - `OperationDenied.OnlyModifyName`: It is not allowed to modify the ReservedInstanceName only.
    /// - `InvalidReservedInstanceId.NotFound`: The specified parameter ReservedInstanceId is invalid.
    /// - `InvalidZoneId.NotFound`: The ZoneId provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_reserved_instances(
        &self,
        req: ModifyReservedInstances,
    ) -> impl std::future::Future<Output = crate::Result<ModifyReservedInstancesResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改预留实例券属性
    ///
    /// 本接口用于修改一张预留实例券的属性信息，包括名称和描述。
    ///
    /// # Error Codes
    /// - `InvalidParameter.ReservedInstanceName`: The reservedInstanceName is invalid.
    /// - `InvalidZoneId.NotFound`: The ZoneId provided does not exist in our records.
    /// - `InvalidReservedInstanceId.NotFound`: The specified ReservedInstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_reserved_instance_attribute(
        &self,
        req: ModifyReservedInstanceAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyReservedInstanceAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 续费预留实例券
    ///
    /// 本接口用于对一张或多张预留实例券进行续费，支持您在续费时设置购买时长和自动续费属性。
    ///
    /// <props="china">
    ///
    /// **请确保在使用该接口前，已充分了解预留实例券的收费方式和[价格](https://www.aliyun.com/price/product#/ecs/detail)。**
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// **请确保在使用该接口前，已充分了解预留实例券的收费方式和[价格](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl)。**
    ///
    /// </props>
    ///
    /// - 预留实例券支持手动续费和自动续费两种续费方式，详细信息请参见[预留实例券续费说明](~~100371#53bfc50b78sta~~)。
    /// - 您可以调用[DescribeReservedInstances](~~100065~~)查询已购买的预留实例券。
    /// - 该接口支持开启自动续费，但不支持取消自动续费，您可以通过[ModifyReservedInstanceAutoRenewAttribute](~~2679786~~)取消自动续费。
    ///
    /// # Error Codes
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType is not authorized.
    /// - `InvalidParameter.Conflict`: The specified region and cluster do not match.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidPeriodUnit.ValueNotSupported`: The specified parameter PeriodUnit is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidChargeType.ValueNotSupported`: ChargeType is not valid.
    /// - `OperationDenied`: The specified InstanceType or Zone is not authorized for current user.
    /// - `InvalidPeriod`: The specified Period or PeriodUnit is not correct.
    /// - `MissingParameter.ReservedInstanceIds`: The specified ReservedInstanceIds does not exist.
    /// - `InvalidParameter.PeriodUnit`: The specified PeriodUnit is invalid.
    /// - `InvalidParameter.Period`: The specified Period is invalid.
    /// - `InvalidParameter.ReservedInstanceIds`: The specified ReservedInstanceIds is invalid.
    /// - `InvalidPeriod.ExceededMaximumExpiration`: The specified renewal period cannot exceed the maximum expiration date. We recommend you try shortening the renewal period at next attempt.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone; try other types of resources or other regions and zones.
    /// - `OperationDenied`: Sales of this resource are temporarily suspended in the specified region; please try again later.
    /// - `NodeControllerUnavailable`: The Node Controller is temporarily unavailable.
    /// - `InvalidParameter.ResourceOwnerAccount`: ResourceOwnerAccount is Invalid.
    /// - `Zone.NotOpen`: The specified zone is not granted to you to buy resources yet.
    /// - `Zone.NotOnSale`: The specified zone is not available for purchase.
    /// - `Account.Arrearage`: Your account has been in arrears.
    /// - `InvalidReservedInstanceName.Malformed`: The specified parameter ReservedInstanceName is invalid.
    /// - `InvalidParameter.Scope`: The specified parameter 'Scope' is invalid.
    /// - `InvalidReservedInstanceStatus.ValueNotSupported`: ReservedInstance status is not supported.
    /// - `InvalidReservedInstanceOfferingType.ValueNotSupported`: The OfferingType is not supported.
    /// - `InvalidReservedInstanceOfferingClass.ValueNotSupported`: The OfferingClass is not supported.
    /// - `MissingParameter.ZoneId`: The specified zoneId should be not empty.
    /// - `MissingParameter.InstanceType`: The instanceType should be not empty.
    /// - `MissingParameter.ReservedInstanceId`: The ids of reservedInstance can not be empty.
    /// - `MissingParameter.ReservedInstanceConfiguration`: The configurations of reservedInstance can not be empty.
    /// - `InvalidParameter.SplitOrMerge`: The Many-to-many of modification is not supported.
    /// - `MissingParameter.InstanceTypeAndAmountBothEmpty`: The instanceType and amount can not be both empty.
    /// - `InvalidReservedInstancePlatform.ValueNotSupported`: The Platform is not supported.
    /// - `InvalidParameter.ReservedInstanceName`: The reservedInstanceName is invalid.
    /// - `InvalidReservedInstanceZone.ValueNotSupported`: The zoneId is not exist.
    /// - `InvalidParameter.ValueNotSupported`: The instanceTypeFamily of the instance to be changed must be consistent.
    /// - `IncorrectInstanceStatus`: The status of specified reservedInstance must be active.
    /// - `InvalidPlatform.ValueNotSupported`: The platform of reservedInstance is invalid.
    /// - `InvalidScope.ValueNotSupported`: The scope of reservedInstance is invalid, The valid value is Zone or Region.
    /// - `InvalidConfiguration.ValueNotSupported`: The modification Configuration should not be empty.
    /// - `InvalidZoneId.ValueNotSupported`: The specified zoneId should be same.
    /// - `InvalidParameter`: The parameter is invalid.Please check it.
    /// - `InvalidInstanceAmount.ValueNotSupported`: The instanceAmount is invalid.
    /// - `OperationDenied.OnlyModifyName`: It is not allowed to modify the ReservedInstanceName only.
    /// - `InvalidReservedInstanceId.NotFound`: The specified parameter ReservedInstanceId is invalid.
    /// - `ChargeTypeViolation`: The operation is not permitted due to charge type of the instance.
    /// - `InvalidZoneId.NotFound`: The ZoneId provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn renew_reserved_instances(
        &self,
        req: RenewReservedInstances,
    ) -> impl std::future::Future<Output = crate::Result<RenewReservedInstancesResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询预留实例券自动续费属性
    ///
    /// 本接口用于查询一个或多个预留实例券自动续费属性，包括自动续费时长和自动续费状态。
    ///
    /// # Error Codes
    /// - `ChargeTypeViolation`: Pay-As-You-Go dedicated host do not support this operation.
    /// - `MissingParamter.InstanceId`: ReservedInstanceId should not be null.
    /// - `InvalidParameter.ToManyInstanceIds`: ReservedInstanceId should be less than 100.
    /// - `InValidParameter`: Parameter invalid.%s
    /// - `ResourceStatusViolation`: The operation is not permitted due to resource status of the instance.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_reserved_instance_auto_renew_attribute(
        &self,
        req: DescribeReservedInstanceAutoRenewAttribute,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeReservedInstanceAutoRenewAttributeResponse>,
    > + Send {
        self.call(req)
    }

    /// # 修改预留实例券自动续费属性
    ///
    /// 本接口主要用于修改一个或多个预留实例券的自动续费属性，支持您取消或者关闭自动续费。
    ///
    /// # Error Codes
    /// - `InvalidParameter.Duration`: The specified parameter Duration is invalid.
    /// - `Abs.MissingParamter.InstanceId`: ReservedInstanceId should not be null.
    /// - `InvalidParameter.ToManyInstanceIds`: ReservedInstanceId should be less than 100.
    /// - `InvalidParameter.PeriodUnit`: The specified parameter PeriodUnit is not valid.
    /// - `InvalidParameter.Period`: The specified parameter Period is not valid.
    /// - `InvalidParameter.RenewalStatus`: The specified parameter RenewalStatus is not valid.
    /// - `InValidParameter`: Parameter invalid.%s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_reserved_instance_auto_renew_attribute(
        &self,
        req: ModifyReservedInstanceAutoRenewAttribute,
    ) -> impl std::future::Future<
        Output = crate::Result<ModifyReservedInstanceAutoRenewAttributeResponse>,
    > + Send {
        self.call(req)
    }

    /// # 购买存储容量单位包
    ///
    /// 本接口用于购买一个或多个存储容量单位包SCU（Storage Capacity Unit）。
    ///
    /// <props="china">
    ///
    /// **请确保在使用该接口前，已充分了解存储容量单位包的[计费方式](~~137897~~)和[价格](https://www.aliyun.com/price/product#/ecs/detail)。**
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// **请确保在使用该接口前，已充分了解存储容量单位包的[计费方式](~~137897~~)和[价格](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl)。**
    ///
    /// </props>
    ///
    /// # Error Codes
    /// - `InvalidParameter.Period`: The specified Period is not valid.
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidParameter.Name`: The specified Name is invalid.
    /// - `InvalidParameter.Capacity`: The specified Capacity is invalid.
    /// - `MissingParameter.Capacity`: The specified Capacity should be not null.
    /// - `InvalidParameter.PeriodUnit`: The specified PeriodUnit is not supported.
    /// - `InvalidParameter.CapacityExceed`: The specified Capacity exceeds the limitation of quota.
    /// - `InvalidStartTime.NotSupported`: The specified StartTime should be within 180 calendar days from the current date, and you must specify a precision to hour.
    /// - `InvalidStartTime.MalFormed`: The specified StartTime is out of the permitted range.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn purchase_storage_capacity_unit(
        &self,
        req: PurchaseStorageCapacityUnit,
    ) -> impl std::future::Future<Output = crate::Result<PurchaseStorageCapacityUnitResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询存储容量单位包详细信息列表
    ///
    /// 本接口用于查询存储容量单位包SCU（Storage Capacity Unit）的详细信息列表，支持根据名称、状态以及容量大小等条件进行查询。
    ///
    /// # Error Codes
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidParameter.Name`: The specified Name is invalid.
    /// - `InvalidParameter.CapacityExceed`: The specified Capacity exceeds the limitation of quota.
    /// - `InvalidAllocationType.ValueNotSupported`: The specified AllocationType is not supported.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_storage_capacity_units(
        &self,
        req: DescribeStorageCapacityUnits,
    ) -> impl std::future::Future<Output = crate::Result<DescribeStorageCapacityUnitsResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改存储容量单位包属性
    ///
    /// 本接口用于修改一个存储容量单位包SCU（Storage Capacity Unit）的名称或者描述信息。
    ///
    /// # Error Codes
    /// - `MissingParameter.RegionId`: The specified RegionId should not be null.
    /// - `InvalidParameter.Name`: The specified Name is invalid.
    /// - `InvalidDescription.Malformed`: The specified Description is wrongly formed.
    /// - `MissingParameter.StorageCapacityUnitId`: The specified StorageCapacityUnitId is not supported.
    /// - `InvalidStorageCapacityUnitId.NotFound`: The specified StorageCapacityUnitId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_storage_capacity_unit_attribute(
        &self,
        req: ModifyStorageCapacityUnitAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyStorageCapacityUnitAttributeResponse>>
    + Send {
        self.call(req)
    }

    /// # 创建并执行云助手命令
    ///
    /// 本接口用于在一台或多台ECS实例中创建并执行云助手命令，支持Shell、PowerShell或者Bat类型的脚本，支持定时执行、自定义参数和实例内容器执行等功能。
    ///
    /// 该接口为异步接口，当前请求发送成功后，您可以通过返回的命令ID或命令执行ID调用[DescribeInvocations](~~2679916~~)或者[DescribeInvocationResults](~~2679916~~)查询执行结果。
    ///
    /// ### 使用须知
    /// - 目标实例的状态为运行中（`Running`），您可以调用[DescribeInstances](~~25506~~)查询。
    /// - 目标实例已经预先安装[云助手Agent](~~64921~~)，您可以通过[InstallCloudAssistant](~~2679925~~)进行安装，并通过[DescribeCloudAssistantStatus](~~2679924~~)查询安装状态。
    ///   > 2017年12月01日之后使用公共镜像创建的ECS实例，默认预装了云助手Agent。
    /// - 执行PowerShell类型的命令时，您需要确保目标ECS实例的Windows操作系统已经配置了PowerShell模块。
    ///
    /// ### 注意事项
    /// - 在单一地域下，最多可以保有500～50,000条云助手命令，您也可以申请提升配额，请参见[配额管理](~~184116~~)。
    /// - 云助手Agent版本需要不低于以下对应的版本才能支持定时任务的新特性（固定时间间隔执行、仅在指定时间执行一次、基于Cron表达式定时执行时指定年份或时区）。如果结果返回`ClientNeedUpgrade`错误码，请参见[升级或禁止升级云助手Agent](~~134383~~)，将客户端更新至最新版本。
    ///
    ///       - Linux：2.2.3.282。
    ///       - Windows：2.1.3.282。
    ///
    /// - 当您基于Cron表达式执行定时任务且指定了时区，时钟定时执行时间设置基准为您指定的时区；当您没有指定时区时，时钟定时执行时间设置基准为ECS实例内的系统时区，且执行时间以实例的系统时间为准。请确保ECS实例的时间或者时区与您预期的时间一致。关于时区的更多信息，请参见[设置Linux实例时区和NTP服务](~~92803~~)或[设置Windows实例NTP服务](~~51890~~)。
    ///
    /// ### 使用建议
    /// - **超时设置**：您可以通过指定参数`Timeout`为命令设置在ECS实例中执行时最大的超时时间，命令执行超时后，云助手Agent会强制终止进程。
    ///     - 单次执行超时后，命令的执行状态（[InvokeRecordStatus](~~64845~~)）变为执行失败（Failed）。
    ///     - 定时执行的超时时间对每一次执行记录均有效，上次执行超时不影响下一次执行。某次执行超时后，执行状态（[InvokeRecordStatus](~~64845~~)）变为执行失败（Failed）。
    /// - **执行失败**：命令可能会因为目标实例的状态异常、网络异常或云助手Agent异常而出现无法执行的情况，无法执行时不会生成执行信息。更多信息，请参见[执行失败常见错误及修复建议](~~87029~~)。
    /// - **自定义参数**：`EnableParameter=true`时会启用自定义参数功能。在设置`CommandContent`时可以通过`{{parameter}}`的形式表示自定义参数，并在运行命令时，传入自定义参数键值对。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `MissingParam.InstanceId`: The parameter instanceId is missing or empty.
    /// - `NumberExceed.Tags`: Ensure the number of tag parameters is not greater than 20.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `MissingParameter.TagKey`: You must specify Tag.N.Key.
    /// - `InvalidContainerId.Malformed`: The specified parameter ContainerId is not valid.
    /// - `InvalidContainerName.Malformed`: The specified parameter ContainerName is not valid.
    /// - `InvalidClientToken.Malformed`: The specified parameter clientToken is not valid.
    /// - `CmdParam.EmptyKey`: Command parameters can not be empty.
    /// - `CmdParam.InvalidParamName`: A command parameter name is invalid.
    /// - `CmdContent.DecodeError`: The CommandContent can not be base64 decoded.
    /// - `InvalidInstance.NotMatch`: The specified instance type does not match the command.
    /// - `MissingParam.Frequency`: The frequency must be specified when you create a timed task.
    /// - `InvalidParam.Frequency`: The specified frequency is invalid.
    /// - `ParameterKey.Duplicate`: The parameter may not contain duplicate keys.
    /// - `Parameter.NotMatched`: The parameters of creation do not match those of invocation.
    /// - `WindowsPasswordName.Missed`: WindowsPasswordName must be specified when you create a Windows task.
    /// - `Parameter.Disabled`: Parameters should not be passed when CreateCommand.EnableParameter is false.
    /// - `InvalidParameter.WorkingDir`: The specified parameter WorkingDir is not valid.
    /// - `NumberExceed.ResourceTags`: The maximum number of ResourceTags is exceeded.
    /// - `MissingParameter.ResourceTagKey`: You must specify ResourceTag.N.Key.
    /// - `InvalidResourceTagKey.Malformed`: The specified ResourceTag key is not valid.
    /// - `InvalidResourceTagValue.Malformed`: The specified ResourceTag value is not valid.
    /// - `Duplicate.ResourceTagKey`: The ResourceTag contains duplicate keys.
    /// - `InvalidResourceTag.InstanceNotFound`: InstanceIds are not found by the specified ResourceTag.
    /// - `InvalidResourceTag.ConflictWithInstanceIds`: The specified param ResourceTag conflicts with InstanceId.
    /// - `InvalidOssOutputDelivery.BucketInOtherRegion`: The OSS bucket specified in the parameter OssOutputDelivery is in another region.
    /// - `InvalidParameter.OssOutputDelivery`: The specified parameter OssOutputDelivery is not valid.
    /// - `InvalidOssOutputDelivery.KeyPrefixMalformed`: The prefix of the OSS key specified in the parameter OssOutputDelivery is not valid.
    /// - `CmdContent.ExceedLimit`: The length of the command content exceeds the upper limit.
    /// - `CmdName.ExceedLimit`: The length of the command name exceeds the upper limit.
    /// - `CmdDesc.ExceedLimit`: The length of the command description exceeds the upper limit.
    /// - `CmdCount.ExceedQuota`: The total number of commands in the current region exceeds the quota.
    /// - `CmdParamCount.ExceedLimit`: You've reached the limit on the count of command parameters.
    /// - `CmdParamName.ExceedLimit`: The length of the command parameter name exceeds the limit.
    /// - `InstanceIds.ExceedLimit`: The number of instance IDs exceeds the upper limit.
    /// - `Invocation.ExceedQuota`: The invocation quota in the current region has been reached for today.
    /// - `ParameterCount.ExceedLimit`: The number of command parameters exceeds the maximum number that can be set.
    /// - `ParameterKey.ExceedLimit`: The length of the specified parameter key exceeds the maximum length that can be set.
    /// - `ParameterType.NotSupported`: The type of parameter value is not supported.
    /// - `Username.ExceedLimit`: The length of the username exceeds the upper limit.
    /// - `WindowsPasswordName.ExceedLimit`: The length of the WindowsPasswordName exceeds the upper limit.
    /// - `ParameterStore.NotSupported`: Parameter Store is not supported in this region.
    /// - `TemporaryAccessKey.Error`: The temporary accessKey is invalid.
    /// - `ParameterStore.InvalidParameters`: The parameter is invalid in Parameter Store.
    /// - `ParameterStore.NoPermission`: You have no access to Parameter Store.
    /// - `OperationDenied.BidOwnResource`: Bid user can not own resource.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `IdempotentParameterMismatch`: The specified parameter has changed while using an already used clientToken.
    /// - `IdempotentProcessing`: The previous idempotent request(s) is still processing.
    /// - `InvalidStatus.ResourceGroup`: You cannot perform an operation on a resource group that is being created or deleted.
    /// - `InvalidParameterCharacter.CommandName`: The command Name contains illegal characters.
    /// - `InvalidParameterCharacter.CommandDescription`: The command Description contains illegal characters.
    /// - `InvalidParameterCharacter.CommandWorkingDir`: The command WorkingDir contains illegal characters.
    /// - `InvalidLauncher.LengthLimitExceeded`: The length of the parameter Launcher exceeds the limit of 1 KB characters.
    /// - `InvalidParameterCharset.Parameters`: The parameter Parameters contains illegal charset.
    /// - `CreateServiceLinkedRole.NoPermission`: You do not have permission to create ServiceLinkedRole for output delivery.
    /// - `InvalidTimeout.ExceedLimit`: The specified parameter Timeout exceeds the upper limit.
    /// - `InvalidCmdType.NotFound`: The specified command type does not exist.
    /// - `InvalidRepeatMode.NotFound`: The specified repeat mode does not exist.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidInstance.NotFound`: The specified instance does not exist.
    /// - `InvalidCmdId.NotFound`: The specified command ID does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InvalidTerminationMode.NotFound`: The specified parameter TerminationMode does not exist.
    /// - `InvalidOssOutputDelivery.BucketNotFound`: The OSS bucket specified in the parameter OssOutputDelivery does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn run_command(
        &self,
        req: RunCommand,
    ) -> impl std::future::Future<Output = crate::Result<RunCommandResponse>> + Send {
        self.call(req)
    }

    /// # 创建云助手命令
    ///
    /// 新建一条Shell、PowerShell或者Bat脚本类型的云助手命令。
    ///
    /// ## 接口说明
    ///
    /// - 您可以创建以下类型的命令：
    ///     - Windows实例适用的Bat脚本（RunBatScript）。
    ///     - Windows实例适用的PowerShell脚本（RunPowerShellScript）。
    ///     - Linux实例适用的Shell脚本（RunShellScript）。
    /// - 您可以通过指定参数Timeout为命令设置在ECS实例中执行时最大的超时时间，命令执行超时后，[云助手Agent](~~64921~~)会强制终止命令进程，即取消命令的PID。
    ///     - 对于单次执行，超时后，该命令针对指定的ECS实例的执行状态（[InvokeRecordStatus](~~64845~~)）变为执行失败（Failed）。  
    ///     - 对于定时执行：
    ///         - 定时执行的超时时间对每一次执行记录均有效。
    ///         - 某次执行超时后，该次执行记录的状态（[InvokeRecordStatus](~~64845~~)）变为执行失败（Failed）。  
    ///         - 上次执行超时与否不影响下一次执行。
    /// - 在一个地域下，您最多可以保有500～50,000条云助手命令，您也可以申请提升配额，关于如何查询及提升配额，请参见[配额管理](~~184116~~)。
    /// - 您可以通过指定参数WorkingDir为命令指定执行路径。对于Linux实例，默认在管理员root用户的home目录下，具体为`/root`目录。对于Windows实例，默认在云助手Agent进程所在目录，例如：`C:\Windows\System32`。
    /// - 您可以通过指定参数EnableParameter=true启用自定义参数功能。在设置CommandContent时可以通过{{parameter}}的形式表示自定义参数，并在运行命令（[InvokeCommand](~~64841~~)）时，传入自定义参数键值对。例如，您在创建命令时，创建了`echo {{name}}`命令，在 InvokeCommand时，通过Parameters参数传入键值对`<name, Jack>`。则自定义参数将自动替换命令，您会得到一条新的命令，并在实例中执行`echo Jack`。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `CmdParam.EmptyKey`: You must specify the parameter names.
    /// - `CmdParam.InvalidParamName`: Invalid parameter name. The name can contain only lowercase letters (a to z), uppercase letters (A to Z), numbers (0 to 9), hyphens (-), and underscores (_).
    /// - `CmdContent.DecodeError`: The CommandContent can not be base64 decoded.
    /// - `InvalidParameter.WorkingDir`: The specified parameter WorkingDir is not valid.
    /// - `CmdContent.ExceedLimit`: The length of the command content exceeds the upper limit.
    /// - `CmdName.ExceedLimit`: The length of the command name exceeds the upper limit.
    /// - `CmdDesc.ExceedLimit`: The length of the command description exceeds the upper limit.
    /// - `CmdCount.ExceedQuota`: The total number of commands in the current region exceeds the quota.
    /// - `CmdParamCount.ExceedLimit`: The maximum number of custom parameters is exceeded.
    /// - `CmdParamName.ExceedLimit`: The maximum length of a parameter name is exceeded.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidStatus.ResourceGroup`: You cannot perform an operation on a resource group that is being created or deleted.
    /// - `InvalidParameterCharacter.CommandName`: The command Name contains illegal characters.
    /// - `InvalidParameterCharacter.CommandDescription`: The command Description contains illegal characters.
    /// - `InvalidParameterCharacter.CommandWorkingDir`: The command WorkingDir contains illegal characters.
    /// - `InvalidLauncher.LengthLimitExceeded`: The length of the parameter Launcher exceeds the limit of 1 KB characters.
    /// - `InvalidTimeout.ExceedLimit`: The specified parameter Timeout exceeds the upper limit.
    /// - `InvalidCmdType.NotFound`: The specified command type does not exist.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_command(
        &self,
        req: CreateCommand,
    ) -> impl std::future::Future<Output = crate::Result<CreateCommandResponse>> + Send {
        self.call(req)
    }

    /// # 执行云助手命令
    ///
    /// 指定CommandId、InstanceId、ResourceGroupId等参数，为一台或多台ECS实例触发一条云助手命令。
    ///
    /// ## 接口说明
    ///
    /// <props="china">
    ///
    /// - 对目标ECS实例有如下限制。选择了多台ECS实例后，若其中某台实例不满足执行条件，您需要重新调用接口。
    ///
    ///     - 状态必须为运行中（`Running`），您可以调用[DescribeInstances](~~25506~~)查询。
    ///
    ///     - 已预先安装[云助手Agent](~~64921~~)。
    ///
    ///     - 执行类型为PowerShell的命令时，实例必须已经配置了PowerShell模块。
    ///
    /// - 单次执行：只执行一次命令。
    /// - 定时执行：
    ///     - 根据参数Frequency指定的时间频率定时执行，上次的执行结果不会对下一次执行产生任何影响。
    ///     - 当您基于Cron表达式执行定时任务且指定了时区，时钟定时执行时间设置基准为您指定的时区；当您没有指定时区时，时钟定时执行时间设置基准为ECS实例内的系统时区，且执行时间以实例的系统时间为准。请确保ECS实例的时间或者时区与您预期的时间一致。更多关于时区的详情，请参见[管理时间同步服务](~~92704~~)。
    ///
    ///      云助手Agent版本不低于以下对应的版本才能支持定时任务的新特性（固定时间间隔执行、仅在指定时间执行一次、基于Cron表达式定时执行时指定年份或时区）。如果结果返回ClientNeedUpgrade错误码，请参见[升级或禁止升级云助手Agent](~~134383~~)，将客户端更新至最新版本。
    ///
    ///     - Linux：2.2.3.282。
    ///     - Windows：2.1.3.282。
    ///
    /// - 命令可能会因为目标实例的状态异常、网络异常或云助手Agent异常而出现无法执行的情况，无法执行时不会生成执行信息。更多信息，请参见[执行失败常见错误及修复建议](~~87029~~)。
    ///
    /// - 当您创建命令时启用了自定义参数功能，需要在执行命令时传入自定义参数（`Parameters`）。
    ///
    /// - 建议您先调用[DescribeCloudAssistantStatus](~~87346~~)查询实例的云助手状态，当CloudAssistantStatus为true时再执行命令，尤其对于新购实例。
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// - 对目标ECS实例有如下限制。选择了多台ECS实例后，若其中某台实例不满足执行条件，您需要重新调用接口。
    ///
    ///     - 状态必须为运行中（`Running`），您可以调用[DescribeInstances](~~25506~~)查询。
    ///
    ///     - 已预先安装[云助手Agent](~~64921~~)。
    ///
    ///     - 执行类型为PowerShell的命令时，实例必须已经配置了PowerShell模块。
    ///
    /// - 单次执行：只执行一次命令。
    /// - 定时执行：
    ///     - 根据参数Frequency指定的时间频率定时执行，上次的执行结果不会对下一次执行产生任何影响。
    ///     - 当您基于Cron表达式执行定时任务且指定了时区，时钟定时执行时间设置基准为您指定的时区；当您没有指定时区时，时钟定时执行时间设置基准为ECS实例内的系统时区，且执行时间以实例的系统时间为准。请确保ECS实例的时间或者时区与您预期的时间一致。更多关于时区的详情，请参见[管理时间同步服务](~~92704~~)。
    ///
    ///      云助手Agent版本不低于以下对应的版本才能支持定时任务的新特性（固定时间间隔执行、仅在指定时间执行一次、基于Cron表达式定时执行时指定年份或时区）。如果结果返回ClientNeedUpgrade错误码，请参见[升级或禁止升级云助手Agent](~~134383~~)，将客户端更新至最新版本。
    ///
    ///     - Linux：2.2.3.282。
    ///     - Windows：2.1.3.282。
    ///
    /// - 命令可能会因为目标实例的状态异常、网络异常或云助手Agent异常而出现无法执行的情况，无法执行时不会生成执行信息。更多信息，请参见[执行失败常见错误及修复建议](~~87029~~)。
    ///
    /// - 当您创建命令时启用了自定义参数功能，需要在执行命令时传入自定义参数（`Parameters`）。
    ///
    /// - 建议您先调用[DescribeCloudAssistantStatus](~~87346~~)查询实例的云助手状态，当CloudAssistantStatus为true时再执行命令，尤其对于新购实例。
    ///
    /// </props>
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `InvalidParameter.WorkingDir`: The specified parameter WorkingDir is not valid.
    /// - `MissingParam.InstanceId`: The parameter instanceId is missing or empty.
    /// - `InvalidContainerId.Malformed`: The specified parameter ContainerId is not valid.
    /// - `InvalidContainerName.Malformed`: The specified parameter ContainerName is not valid.
    /// - `InvalidClientToken.Malformed`: The specified parameter clientToken is not valid.
    /// - `InvalidInstance.NotMatch`: The specified instance type does not match the command.
    /// - `MissingParam.Frequency`: The frequency must be specified when you create a timed task.
    /// - `InvalidParam.Frequency`: The specified frequency is invalid.
    /// - `Parameter.MissingValue`: The parameter value of this command is required.
    /// - `Parameter.Disabled`: Parameters cannot be passed in when the command customization function is disabled.
    /// - `InvalidParameter.Parameters`: The specified parameter Parameters is not valid.
    /// - `NumberExceed.ResourceTags`: The maximum number of ResourceTags is exceeded.
    /// - `MissingParameter.ResourceTagKey`: You must specify ResourceTag.N.Key.
    /// - `InvalidResourceTagKey.Malformed`: The specified ResourceTag key is not valid.
    /// - `InvalidResourceTagValue.Malformed`: The specified ResourceTag value is not valid.
    /// - `Duplicate.ResourceTagKey`: The ResourceTag contains duplicate keys.
    /// - `InvalidResourceTag.InstanceNotFound`: InstanceIds are not found by the specified ResourceTag.
    /// - `InvalidResourceTag.ConflictWithInstanceIds`: The specified param ResourceTag conflicts with InstanceId.
    /// - `InvalidOssOutputDelivery.BucketInOtherRegion`: The OSS bucket specified in the parameter OssOutputDelivery is in another region.
    /// - `InvalidParameter.OssOutputDelivery`: The specified parameter OssOutputDelivery is not valid.
    /// - `InvalidOssOutputDelivery.KeyPrefixMalformed`: The prefix of the OSS key specified in the parameter OssOutputDelivery is not valid.
    /// - `InstanceIds.ExceedLimit`: The number of instance IDs exceeds the upper limit.
    /// - `Invocation.ExceedQuota`: The invocation quota in the current region has been reached for today.
    /// - `ParameterCount.ExceedLimit`: The maximum number of parameters is exceeded.
    /// - `ParameterKey.ExceedLimit`: The maximum length of a parameter name is exceeded.
    /// - `CmdContent.ExceedLimit`: The maximum length of a command is exceeded.
    /// - `ParameterKey.Duplicate`: Parameter names cannot be duplicated.
    /// - `Parameter.NotMatched`: The passed-in parameters do not match the parameters defined when you created the command.
    /// - `ParameterType.NotSupported`: The type of parameter value is not supported.
    /// - `Username.ExceedLimit`: The length of the username exceeds the upper limit.
    /// - `WindowsPasswordName.ExceedLimit`: The length of the WindowsPasswordName exceeds the upper limit.
    /// - `WindowsPasswordName.Missed`: WindowsPasswordName must be specified when you create a Windows task.
    /// - `ParameterStore.NotSupported`: Parameter Store is not supported in this region.
    /// - `TemporaryAccessKey.Error`: The temporary accessKey is invalid.
    /// - `ParameterStore.InvalidParameters`: The parameter is invalid in Parameter Store.
    /// - `ParameterStore.NoPermission`: You have no access to Parameter Store.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `IdempotentParameterMismatch`: The specified parameter has changed while using an already used clientToken.
    /// - `IdempotentProcessing`: The previous idempotent request(s) is still processing.
    /// - `InvalidLauncher.LengthLimitExceeded`: The length of the parameter Launcher exceeds the limit of 1 KB characters.
    /// - `InvalidParameterCharset.Parameters`: The parameter Parameters contains illegal charset.
    /// - `CreateServiceLinkedRole.NoPermission`: You do not have permission to create ServiceLinkedRole for output delivery.
    /// - `InvalidTimeout.ExceedLimit`: The specified parameter Timeout exceeds the upper limit.
    /// - `InvalidRepeatMode.NotFound`: The specified repeat mode does not exist.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidInstance.NotFound`: The specified instance does not exist.
    /// - `InvalidCmdId.NotFound`: The specified command ID does not exist.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InvalidTerminationMode.NotFound`: The specified parameter TerminationMode does not exist.
    /// - `InvalidOssOutputDelivery.BucketNotFound`: The OSS bucket specified in the parameter OssOutputDelivery does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn invoke_command(
        &self,
        req: InvokeCommand,
    ) -> impl std::future::Future<Output = crate::Result<InvokeCommandResponse>> + Send {
        self.call(req)
    }

    /// # 查询云助手命令的执行信息列表
    ///
    /// 调用DescribeInvocations查询云助手命令的执行列表和状态。
    ///
    /// - 当您执行命令后，不代表命令一定成功运行，并且一定有预期的命令效果。您需要通过接口返回值查看实际执行结果，以实际输出结果为准。
    ///
    /// - 您可以查询最近4周的执行信息，执行信息的保留上限为10万条。
    /// - 您可以通过[云助手任务状态事件订阅](~~2669130~~)的方式，通过事件获取任务结果，避免频繁轮询，用以提升效率。
    /// - 分页查询首页时，仅需设置`MaxResults`以限制返回信息的条目数，返回结果中的`NextToken`将作为查询后续页的凭证。查询后续页时，将`NextToken`参数设置为上一次返回结果中获取到的`NextToken`作为查询凭证，并设置`MaxResults`限制返回条目数。
    /// - `DescribeInvocations`和`DescribeInvocationResults`差异点：
    ///     - 当一次`RunCommand`/`InvokeCommand`调用指定有多个实例时：
    ///         - 使用`DescribeInvocations`可以获得任务在各个实例上的执行状态、多个实例任务状态的聚合状态；
    ///         - 使用`DescribeInvocationResults`仅能获得各个实例上的单独的执行状态，不包含多实例的聚合状态；
    ///     - 当一次`RunCommand`/`InvokeCommand`调用指定有一个实例时：
    ///         - `DescribeInvocations`与`DescribeInvocationResults`区别不大，完全可以互相替换。
    ///     - 当需要查看定时性（周期性）任务、开机自动执行任务（`RepeatMode=Period, EveryReboot`）的每一次执行情况时，仅能用`DescribeInvocationResults`可以查询获得执行的过往历史记录（需指定`IncludeHistory=true`），而`DescribeInvocations`仅支持返回最新的任务状态。
    ///     - 当需要查看命令的内容、参数时，仅有`DescribeInvocations`返回`CommandContent`。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `NumberExceed.Tags`: The Tags parameter number is exceed.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `MissingParameter.TagKey`: You must specify Tag.N.Key.
    /// - `InvalidParam.PageNumber`: The specified parameter is invalid.
    /// - `InvalidParam.PageSize`: The specified parameter is invalid.
    /// - `InvalidParameter.NextToken`: The specified parameter NextToken is not valid.
    /// - `InvalidParameter.MaxResults`: The specified parameter MaxResults is not valid.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_invocations(
        &self,
        req: DescribeInvocations,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInvocationsResponse>> + Send {
        self.call(req)
    }

    /// # 查询云助手命令执行结果
    ///
    /// 调用DescribeInvocationResults查看一条或多条云助手命令的执行结果，即在ECS实例中的实际执行结果。
    ///
    /// ## 接口说明
    ///
    /// - 当您执行命令后，不代表命令一定成功执行，并且一定有预期的命令效果。您需要通过本接口查看实际的具体执行结果，以实际输出结果为准。
    /// - 您可以查询最近4周的执行信息，执行信息的保留上限为10万条。
    /// - 您可以通过[云助手任务状态事件订阅](~~2669130~~)的方式，通过事件获取任务结果，避免频繁轮询，用以提升效率。
    /// - 分页查询首页时，仅需设置`MaxResults`以限制返回信息的条目数，返回结果中的`NextToken`将作为查询后续页的凭证。查询后续页时，将`NextToken`参数设置为上一次返回结果中获取到的`NextToken`作为查询凭证，并设置`MaxResults`限制返回条目数。
    ///
    /// - `DescribeInvocations`和`DescribeInvocationResults`差异点：
    ///     - 当一次`RunCommand`/`InvokeCommand`调用指定有多个实例时：
    ///         - 使用`DescribeInvocations`可以获得任务在各个实例上的执行状态、多个实例任务状态的聚合状态；
    ///         - 使用`DescribeInvocationResults`仅能获得各个实例上的单独的执行状态，不包含多实例的聚合状态；
    ///     - 当一次`RunCommand`/`InvokeCommand`调用指定有一个实例时：
    ///         - `DescribeInvocations`与`DescribeInvocationResults`区别不大，完全可以互相替换。
    ///     - 当需要查看定时性（周期性）任务、开机自动执行任务（`RepeatMode=Period, EveryReboot`）的每一次执行情况时，仅能用`DescribeInvocationResults`可以查询获得执行的过往历史记录（需指定`IncludeHistory=true`），而`DescribeInvocations`仅支持返回最新的任务状态。
    ///     - 当需要查看命令的内容、参数时，仅有`DescribeInvocations`返回`CommandContent`。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `NumberExceed.Tags`: The Tags parameter number is exceed.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `MissingParameter.TagKey`: You must specify Tag.N.Key.
    /// - `InvalidParam.PageNumber`: The specified parameter is invalid.
    /// - `InvalidParam.PageSize`: The specified parameter is invalid.
    /// - `InvalidParameter.NextToken`: The specified parameter NextToken is not valid.
    /// - `InvalidParameter.MaxResults`: The specified parameter MaxResults is not valid.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.
    /// - `ServiceUnavailable`: The request has failed due to a temporary failure of the server.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_invocation_results(
        &self,
        req: DescribeInvocationResults,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInvocationResultsResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改云助手命令的执行属性
    ///
    /// 修改云助手定时任务的执行信息，包括命令内容、定时执行方式、添加ECS实例或托管实例到任务。
    ///
    /// - 支持修改以下执行方式的任务（参见[DescribeInvocations](~~2679916~~)返回的`RepeatMode`值）：
    ///     - Period：周期执行。
    ///     - NextRebootOnly：当实例下一次启动时，自动执行命令。
    ///     - EveryReboot：实例每一次启动都将自动执行命令。
    /// - 支持修改以下状态的任务（参见[DescribeInvocations](~~2679916~~)返回的`InvocationStatus`值）：
    ///     - Pending：系统正在校验或发送命令。存在至少一台实例的命令执行状态为Pending，则总执行状态为Pending。
    ///     - Running：命令正在实例上运行。存在至少一台实例的命令执行状态为Running，则总执行状态为Running。
    ///     - Scheduled：定时执行的命令已发送，等待运行。存在至少一台实例的命令执行状态为Scheduled，则总执行状态为Scheduled。
    ///     - Stopping：正在停止任务。存在至少一台实例的命令执行状态为Stopping，则总执行状态为Stopping。
    /// - 修改定时任务执行信息（包括命令内容、自定义参数、执行频率）前，已执行的ECS实例或托管实例的云助手Agent版本需要高于以下对应的版本。
    ///     - Linux：2.2.3.541
    ///     - Windows：2.1.3.541
    ///     - 如果调用结果返回`InvalidOperation.CloudAssistantVersionUnsupported`错误码，请将云助手Agent更新至最新版本。
    /// - 当您执行一个云助手公共命令时，无法修改命令内容`CommandContent`。
    /// - 当您修改了命令内容`CommandContent`，且调用[InvokeCommand](~~64841~~)或调用[RunCommand](~~141751~~)时设置`KeepCommand`为`true`创建任务，将会新增一条命令并长期保留，并占用云助手命令配额；在一个地域下，您最多可以保有500～50,000条云助手命令。您也可以申请提升配额，关于如何查询及提升配额，请参见[配额管理](~~184116~~)。
    ///
    /// # Error Codes
    /// - `InvalidParameter.Frequency`: The specified parameter Frequency is not valid.
    /// - `InvalidParameters.KeyDuplicate`: The key in the parameter Parameters cannot be duplicated.
    /// - `InvalidParameters.KeyNotMatch`: The key in the parameter Parameters do not match those defined when creating the command.
    /// - `InvalidParameters.KeyMalformed`: The key in the parameter Parameters is not valid.
    /// - `InvalidParameters.KeyEmpty`: The key in the parameter Parameters cannot be empty.
    /// - `InvalidCommandContent.DecodeError`: The specified parameter CommandContent can not be Base64 decoded.
    /// - `InvalidInstanceId.OSTypeUnsupported`: The OS type of the instance corresponding to the parameter InstanceId does not support the specified command type.
    /// - `InvalidOperation.RepeatModeUnsupported`: The operation is not supported for current repeat mode of invocation.
    /// - `InvalidOperation.InvokeAlreadyFinished`: The operation is not supported for finished invocation.
    /// - `InvalidOperation.CloudAssistantVersionUnsupported`: The operation is not supported for current CloudAssistant version of instance.
    /// - `InvalidOperation.ModifyPublicCommandUnsupported`: Modification of the content of Public Command is not supported.
    /// - `InvalidCommandContent.LengthLimitExceeded`: The length of the parameter CommandContent exceeds the limit of %s KB characters.
    /// - `InvalidParameters.CountLimitExceeded`: The count of the parameter Parameters exceeds the limit of 10.
    /// - `InvalidParameters.KeyLengthLimitExceeded`: The length of the key in the parameter Parameters exceeds the limit of 64 characters.
    /// - `InvalidInstanceId.CountLimitExceeded`: The count of the parameter InstanceId exceeds the limit of %s.
    /// - `CommandLimitExceeded`: The count of command in current region exceeds the limit of %s.
    /// - `InvalidParameters.ValueTypeUnsupported`: The type of the value in the parameter Parameters is not supported.
    /// - `InvalidInvokeId.NotFound`: The specified parameter InvokeId does not exist.
    /// - `InvalidInstanceId.NotFound`: The specified parameter InstanceId does not exist.
    /// - `InvalidRegionId.NotFound`: The specified parameter RegionId does not exist.
    /// - `InvalidCommandId.NotFound`: The specified CommandId does not exist.
    /// - `InternalError`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_invocation_attribute(
        &self,
        req: ModifyInvocationAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyInvocationAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 停止执行云助手命令
    ///
    /// 调用StopInvocation停止一台或多台ECS实例中一条正在进行中（Running）的云助手命令进程。
    ///
    /// ## 接口说明
    ///
    /// - 停止单次命令进程后，已经开始执行的实例会继续执行，未开始执行的实例将不再执行。
    /// - 停止周期命令进程后，已经开始执行的命令将继续执行，但后续将不会再进行下一次的执行。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `InstanceIds.ExceedLimit`: The number of instance IDs exceeds the upper limit.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidInvokeId.NotFound`: The specified invoke ID does not exist.
    /// - `InvalidInstanceId.NotFound`: The specified parameter InstanceId does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn stop_invocation(
        &self,
        req: StopInvocation,
    ) -> impl std::future::Future<Output = crate::Result<StopInvocationResponse>> + Send {
        self.call(req)
    }

    /// # 查询已创建的云助手命令
    ///
    /// 查询您手动创建的云助手命令或者阿里云提供的公共命令。
    ///
    /// ## 接口说明
    ///
    /// - 只输入参数`Action`和`RegionId`，不输入其他任何请求参数，则默认查询您手动创建的所有可用的命令（`CommandId`）。
    ///
    /// - 分页查询首页时，仅需设置`MaxResults`以限制返回信息的条目数，返回结果中的`NextToken`将作为查询后续页的凭证。查询后续页时，将`NextToken`参数设置为上一次返回结果中获取到的`NextToken`作为查询凭证，并设置`MaxResults`限制返回条目数。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `NumberExceed.Tags`: The Tags parameter number is exceed.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `MissingParameter.TagKey`: You must specify Tag.N.Key.
    /// - `InvalidParam.PageNumber`: The specified parameter is invalid.
    /// - `InvalidParam.PageSize`: The specified parameter is invalid.
    /// - `InvalidParameter.NextToken`: The specified parameter NextToken is not valid.
    /// - `InvalidParameter.MaxResults`: The specified parameter MaxResults is not valid.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidName.LengthLimitExceeded`: The length of the parameter Name exceeds the upper limit.
    /// - `InvalidDescription.LengthLimitExceeded`: The length of the parameter Description exceeds the upper limit.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidCommandType.NotFound`: The specified parameter Type does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.
    /// - `ServiceUnavailable`: The request has failed due to a temporary failure of the server.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_commands(
        &self,
        req: DescribeCommands,
    ) -> impl std::future::Future<Output = crate::Result<DescribeCommandsResponse>> + Send {
        self.call(req)
    }

    /// # 修改云助手命令
    ///
    /// 调用ModifyCommand修改一条云助手命令相关参数。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `InvalidParameter.WorkingDir`: The specified parameter WorkingDir is not valid.
    /// - `CmdName.Readonly`: The command name is readonly after publishing.
    /// - `CmdName.ExceedLimit`: The length of the command name exceeds the upper limit.
    /// - `CmdContent.ExceedLimit`: The length of the command content exceeds the upper limit.
    /// - `CmdDesc.ExceedLimit`: The length of the command description exceeds the upperlimit.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidParameterCharacter.CommandName`: The command Name contains illegal characters.
    /// - `InvalidParameterCharacter.CommandDescription`: The command Description contains illegal characters.
    /// - `InvalidParameterCharacter.CommandWorkingDir`: The command WorkingDir contains illegal characters.
    /// - `InvalidLauncher.LengthLimitExceeded`: The length of the parameter Launcher exceeds the limit of 1 KB characters.
    /// - `InvalidTimeout.ExceedLimit`: The specified parameter Timeout exceeds the upper limit.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidCmdId.NotFound`: The specified command ID does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_command(
        &self,
        req: ModifyCommand,
    ) -> impl std::future::Future<Output = crate::Result<ModifyCommandResponse>> + Send {
        self.call(req)
    }

    /// # 删除一条云助手命令
    ///
    /// 调用DeleteCommand接口，并指定参数RegionId、CommandId删除一条云助手命令。它无法删除正在执行中的命令。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `InvalidStatus.CmdIdInUse`: The specified commandId is in use by some runing Invocation.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidCmdId.NotFound`: The specified command ID does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_command(
        &self,
        req: DeleteCommand,
    ) -> impl std::future::Future<Output = crate::Result<DeleteCommandResponse>> + Send {
        self.call(req)
    }

    /// # 上传本地文件到ECS实例
    ///
    /// 调用SendFile向一台或多台ECS实例下发远程文件。
    ///
    /// ## 接口说明
    ///
    /// - 目标ECS实例的状态必须为运行中（`Running`）。
    /// - 目标ECS实例必须预先安装[云助手Agent](~~64921~~)。
    /// - 云助手Agent版本需要高于以下对应的版本才能支持下发文件。如果结果返回`ClientNeedUpgrade`错误码，请将客户端更新至最新版本。
    ///     - Linux：1.0.2.569
    ///     - Windows：1.0.0.149
    /// - 文件内容在进行Base64编码后，大小不能超过32 KB。
    /// - 文件下发可能会因为目标ECS实例的状态异常、网络异常或云助手Agent异常而出现失败的情况。请调用[DescribeSendFileResults](~~184117~~)，或参考[执行失败常见错误及修复建议](~~87029~~)进行问题排查。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `MissingParam.InstanceId`: The parameter instanceId is missing or empty.
    /// - `NumberExceed.Tags`: The Tags parameter number is exceed.
    /// - `MissingParameter.TagKey`: You must specify Tag.N.Key.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `FileTargetDir.Invalid`: The target directory of file is invalid.
    /// - `FileMode.Invalid`: The mode of file is invalid.
    /// - `FileContent.DecodeError`: The Content can not be base64 decoded.
    /// - `FileContentType.Invalid`: The ContentType of file is invalid.
    /// - `InvalidParameter.FileOwner`: The specified parameter FileOwner is not valid.
    /// - `InvalidParameter.FileGroup`: The specified parameter FileGroup is not valid.
    /// - `FileSize.ExceedLimit`: The length of file content exceeds limit.
    /// - `FileName.ExceedLimit`: The length of file name exceeds limit.
    /// - `FileDesc.ExceedLimit`: The length of file description exceeds limit.
    /// - `InstanceIds.ExceedLimit`: The number of instance IDs exceeds the upper limit.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidTimeout.ExceedLimit`: The specified parameter Timeout exceeds the upper limit.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidInstance.NotFound`: The specified instances not found.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn send_file(
        &self,
        req: SendFile,
    ) -> impl std::future::Future<Output = crate::Result<SendFileResponse>> + Send {
        self.call(req)
    }

    /// # 查询云助手下发文件列表及状态
    ///
    /// 调用DescribeSendFileResults查询云助手下发文件列表及状态。
    ///
    /// ## 接口说明：
    /// - 当您下发文件后，不代表文件一定成功下发。您需要通过接口返回值查看实际下发结果，并以实际输出结果为准。
    /// - 您可以查询最近6周的下发记录。
    /// - 分页查询首页时，仅需设置`MaxResults`以限制返回信息的条目数，返回结果中的`NextToken`将作为查询后续页的凭证。查询后续页时，将`NextToken`参数设置为上一次返回结果中获取到的`NextToken`作为查询凭证，并设置`MaxResults`限制返回条目数。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `NumberExceed.Tags`: The Tags parameter number is exceed.
    /// - `MissingParameter.TagKey`: You must specify Tag.N.Key.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `InvalidParam.PageNumber`: The specified parameter is invalid.
    /// - `InvalidParam.PageSize`: The specified parameter is invalid.
    /// - `InvalidParameter.NextToken`: The specified parameter NextToken is not valid.
    /// - `InvalidParameter.MaxResults`: The specified parameter MaxResults is not valid.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_send_file_results(
        &self,
        req: DescribeSendFileResults,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSendFileResultsResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询云助手安装状态
    ///
    /// 调用DescribeCloudAssistantStatus查询一台或者多台实例是否安装了云助手Agent。如果已安装了云助手，还将查询云助手命令执行的总数量、正在执行的数量以及最近一次命令执行的时间。
    ///
    /// ## 接口说明
    ///
    /// - 建议您先调用该接口查询实例的云助手状态，当CloudAssistantStatus为true时再执行命令或下发文件，尤其对于新购实例。
    /// - 分页查询首页时，仅需设置`MaxResults`以限制返回信息的条目数，返回结果中的`NextToken`将作为查询后续页的凭证。查询后续页时，将`NextToken`参数设置为上一次返回结果中获取到的`NextToken`作为查询凭证，并设置`MaxResults`限制返回条目数。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `MissingParam.InstanceId`: The parameter instanceId is missing or empty.
    /// - `InvalidParam.PageSize`: The specified parameter is invalid.
    /// - `InvalidParam.PageNumber`: The specified parameter is invalid.
    /// - `InvalidParameter.NextToken`: The specified parameter NextToken is not valid.
    /// - `InvalidParameter.MaxResults`: The specified parameter MaxResults is not valid.
    /// - `InstanceIds.ExceedLimit`: The number of instance IDs exceeds the upper limit.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidInstance.NotFound`: The specified instance does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.
    /// - `ServiceUnavailable`: The request has failed due to a temporary failure of the server.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_cloud_assistant_status(
        &self,
        req: DescribeCloudAssistantStatus,
    ) -> impl std::future::Future<Output = crate::Result<DescribeCloudAssistantStatusResponse>> + Send
    {
        self.call(req)
    }

    /// # 为实例安装云助手Agent
    ///
    /// 调用InstallCloudAssistant为一台或多台ECS实例安装云助手Agent。需要重启实例来完成安装云助手Agent的操作。
    ///
    /// ## 接口说明
    ///
    /// 调用InstallCloudAssistant接口后再调用[RebootInstance](~~25502~~)，安装云助手Agent的操作即可生效。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `MissingParam.InstanceId`: The parameter instanceId is missing or empty.
    /// - `InstanceIds.ExceedLimit`: The number of instance IDs exceeds the upper limit.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidInstanceId.OSTypeUnsupported`: The OS type of the instance %s corresponding to the parameter InstanceId does not support the operation.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidInstance.NotFound`: The specified instance does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn install_cloud_assistant(
        &self,
        req: InstallCloudAssistant,
    ) -> impl std::future::Future<Output = crate::Result<InstallCloudAssistantResponse>> + Send
    {
        self.call(req)
    }

    /// # 开始终端会话
    ///
    /// 调用StartTerminalSession基于会话管理功能创建一个会话。您可以通过指定ECS实例ID与该实例建立一个WebSocket会话，通过接口返回的WebSocketUrl可以远程连接到ECS实例。
    ///
    /// ## 接口说明
    ///
    /// 当您通过代码定制化远程连接客户端时，可以调用该接口获取远程连接ECS实例的WebSocketUrl。调用该接口时您需要注意：
    ///
    /// - 指定的ECS实例必须处于运行中（Running）状态。
    /// - 指定的ECS实例必须安装了云助手Agent。您可以调用[DescribeCloudAssistantStatus](~~87346~~)查询ECS实例是否已安装云助手Agent，并可以查询云助手Agent的版本号。
    ///     - 如果您的ECS实例没有安装云助手Agent，请调用[InstallCloudAssistant](~~85916~~)安装。
    ///     - 云助手Agent的版本需要高于以下版本才支持会话管理功能。如果您需要升级云助手Agent版本，请参见[升级或禁止升级云助手Agent](~~134383~~)。
    ///         - Linux操作系统：2.2.3.256
    ///         - Windows操作系统：2.1.3.256
    /// - 成功调用该接口后，WebSocketUrl有效时长为10分钟。
    /// - 在会话建立后，3分钟没有数据传输，云助手会关闭链接。
    /// - 同一地域下，已创建并可用的会话不能超过1000个，单台ECS实例处于连接状态的会话不能超过20个，单个会话连接的带宽限制为200kb/s。
    /// - 端口转发功能，目前只支持TCP端口转发，不支持UDP。
    /// - 若想永久关闭会话，并使WebSocketUrl失效，请调用EndTerminalSession接口。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `PortNumber.Invalid`: The port number is invalid.
    /// - `InvalidParameter.ConnectionType`: The specified parameter ConnectionType is not valid.
    /// - `InstanceIds.ExceedLimit`: The number of instance IDs exceeds the upper limit.
    /// - `SessionCount.ExceedLimit`: The number of sessions exceeds the upper limit.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `PortForwarding.NotSupported`: Port forwarding is not supported currently.
    /// - `UserBehavior.SessionManagerDisabled`: The api is disabled by user behavior.
    /// - `InvalidCommandLine.Conflict`: The parameter PortNumber or TargetServer cannot be specified with parameter CommandLine.
    /// - `InvalidTargetServer.MissingPortNumber`: The parameter PortNumber must be specified with parameter TargetServer.
    /// - `InvalidCommandLine.LengthLimitExceeded`: The length of the parameter CommandLine exceeded the limit of 512 characters.
    /// - `InvalidInstanceIds.CountLimitExceeded`: The count of Instances exceeded the maximum limit of 1 when TargetServer or CommandLine parameter was specified.
    /// - `Username.ExceedLimit`: The length of the username exceeds the upper limit.
    /// - `InvalidOperation.SecurityGroupRuleDenied`: The operation is not allowed by the security group inbound rules of the specified instance.
    /// - `InvalidTargetServer.LengthLimitExceeded`: The length of the parameter TargetServer exceeded the limit of 128 characters.
    /// - `InvalidOperation.ConnectionTypeUnsupported`: The operation is not supported for the parameter ConnectionType.
    /// - `InvalidPasswordName.LengthLimitExceeded`: The length of the parameter PasswordName exceeds the limit of 255 characters.
    /// - `InvalidEncryptionOptionsMode.EncryptionDisabled`: EncryptionOptions.Mode cannot be specified when encryption is disabled.
    /// - `InvalidParameter.EncryptionOptionsKMSKeyId`: The specified parameter EncryptionOptions.KMSKeyId is not valid.
    /// - `InvalidParameter.EncryptionOptionsMode`: The specified parameter EncryptionOptions.Mode is not valid.
    /// - `MissingParameter.EncryptionOptionsKMSKeyId`: The input parameter EncryptionOptions.KMSKeyId that is mandatory for processing this request is not supplied.
    /// - `UnsupportedAgentVersion.Encryption`: The cloud assistant agent version on instance %s do not support encryption.
    /// - `InvalidEncryptionOptions.Conflict`: The parameter PortNumber or TargetServer cannot be specified with parameter EncryptionOptions.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidInstance.NotFound`: The specified instances not found.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn start_terminal_session(
        &self,
        req: StartTerminalSession,
    ) -> impl std::future::Future<Output = crate::Result<StartTerminalSessionResponse>> + Send {
        self.call(req)
    }

    /// # 关闭终端会话
    ///
    /// 永久关闭指定Session的数据连接。
    ///
    /// - 关闭指定Session数据连接，Session不可再使用。
    ///
    /// - Session关联的WebSocket URL也会失效，不可再使用。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `InvalidSessionId.NotFound`: The specified SessionId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn end_terminal_session(
        &self,
        req: EndTerminalSession,
    ) -> impl std::future::Future<Output = crate::Result<EndTerminalSessionResponse>> + Send {
        self.call(req)
    }

    /// # 查看Session Manager会话历史记录
    ///
    /// 查看Session Manager会话历史记录。
    ///
    /// 支持查看4周内创建的Session Manager会话记录。
    ///
    /// # Error Codes
    /// - `InvalidParameter.NextToken`: The specified parameter NextToken is not valid.
    /// - `InvalidParameter.MaxResults`: The specified parameter MaxResults is not valid.
    /// - `InvalidRegionId.NotFound`: The specified parameter RegionId does not exist.
    /// - `InternalError`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_terminal_sessions(
        &self,
        req: DescribeTerminalSessions,
    ) -> impl std::future::Future<Output = crate::Result<DescribeTerminalSessionsResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改云助手服务配置
    ///
    /// 修改云助手服务配置。
    ///
    /// # Error Codes
    /// - `InvalidParameter.SettingType`: The specified parameter SettingType is not valid.
    /// - `InvalidParameter.OssEncryptionType`: The specified parameter OssDeliveryConfig.EncryptionType is not valid.
    /// - `InvalidParameter.OssEncryptionAlgorithm`: The specified parameter OssDeliveryConfig.EncryptionAlgorithm is not valid.
    /// - `InvalidParameter.OssEncryptionKeyId`: The specified parameter OssDeliveryConfig.EncryptionKeyId is not valid.
    /// - `InvalidParameter.OssBucketName`: The specified parameter OssDeliveryConfig.BucketName is not valid.
    /// - `InvalidParameter.OssPrefix`: The specified parameter OssDeliveryConfig.Prefix is not valid.
    /// - `InvalidOssBucketName.InOtherRegion`: The specified parameter OssDeliveryConfig.BucketName is in another region.
    /// - `InvalidParameter.SlsProjectName`: The specified parameter SlsDeliveryConfig.ProjectName is not valid.
    /// - `InvalidParameter.SlsLogstoreName`: The specified parameter SlsDeliveryConfig.LogstoreName is not valid.
    /// - `InvalidParameter.AllowedUpgradeWindow`: The specified parameter AgentUpgradeConfig.AllowedUpgradeWindow is not valid.
    /// - `InvalidAllowedUpgradeWindow.DurationTooShort`: The duration of the specified parameter AgentUpgradeConfig.AllowedUpgradeWindow cannot be less than one hour.
    /// - `InvalidParameter.TimeZone`: The specified parameter AgentUpgradeConfig.TimeZone is not valid.
    /// - `InvalidAllowedUpgradeWindow.Required`: The specified parameter AgentUpgradeConfig.AllowedUpgradeWindow is required.
    /// - `CreateServiceLinkedRole.NoPermission`: You do not have permission to create ServiceLinkedRole.
    /// - `InvalidOperation.OssEncryptionUnsupported`: The configuration of OSS Encryption is not supported.
    /// - `InvalidAllowedUpgradeWindow.CountLimitExceeded`: The count of the parameter AgentUpgradeConfig.AllowedUpgradeWindow exceeds the limit of 5.
    /// - `InvalidOperation.SessionManagerDeliveryUnsupported`: The delivery configuration of Session Manager is not supported.
    /// - `InvalidSlsProjectName.NotFound`: The specified parameter SlsDeliveryConfig.ProjectName does not exist.
    /// - `InvalidSlsLogstoreName.NotFound`: The specified parameter SlsDeliveryConfig.LogstoreName does not exist.
    /// - `InvalidOssBucketName.NotFound`: The specified parameter OssDeliveryConfig.BucketName does not exist.
    /// - `InvalidRegionId.NotFound`: The specified parameter RegionId does not exist.
    /// - `InternalError`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_cloud_assistant_settings(
        &self,
        req: ModifyCloudAssistantSettings,
    ) -> impl std::future::Future<Output = crate::Result<ModifyCloudAssistantSettingsResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询云助手服务配置
    ///
    /// 查询云助手服务配置。
    ///
    /// # Error Codes
    /// - `InvalidParameter.SettingType`: The specified parameter SettingType is not valid.
    /// - `InvalidRegionId.NotFound`: The specified parameter RegionId does not exist.
    /// - `InternalError`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_cloud_assistant_settings(
        &self,
        req: DescribeCloudAssistantSettings,
    ) -> impl std::future::Future<Output = crate::Result<DescribeCloudAssistantSettingsResponse>> + Send
    {
        self.call(req)
    }

    /// # 创建一个激活码
    ///
    /// 该接口用于创建一个激活码，该激活码用于将非阿里云服务器注册为阿里云托管实例。
    ///
    /// ## 接口说明
    ///
    /// 通过激活码将非阿里云服务器注册为阿里云托管实例后，您可以在托管实例中使用阿里云提供的多种在线服务（例如云助手、系统运维管理和云效等服务）。
    ///
    /// 非阿里云服务器的操作系统需要符合以下版本，且服务器可以访问公网，才可以注册为阿里云托管实例。
    ///
    /// - Alibaba Cloud Linux 2/3及更高版本
    /// - CentOS 6/7/8及更高版本
    /// - Debian 8/9/10及更高版本
    /// - Ubuntu 12/14/16/18及更高版本
    /// - CoreOS
    /// - OpenSUSE
    /// - RedHat 5/6/7及更高版本
    /// - SUSE Linux Enterprise Server 11/12/15及更高版本
    /// - Window Server 2012/2016/2019及更高版本
    ///
    /// 在一个阿里云地域下，您最多可以拥有5000条托管实例激活码。当激活码数量超过1000条时，需要激活码使用率大于50%才允许继续创建新的激活码。
    ///
    /// > 您可以在**ECS云助手**页面的**托管实例**页签下，单击**注册新实例**，获取激活码使用数据。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `InstanceName.ExceedLimit`: Default instance name prefix length exceeds.
    /// - `InstanceName.InvalidPattern`: Default instance name prefix pattern invalid.
    /// - `ActivationDesc.ExceedLimit`: Activation description length exceeds.
    /// - `ActivationLimitation.Invalid`: The specified parameter InstanceCount exceeds the limit of %s.
    /// - `AddressRange.InvalidPattern`: Address range should be ipv4 address or cidr.
    /// - `ActivationCount.ExceedLimit`: The count of activation in current region exceeds the limit of %s.
    /// - `ActivationTTL.ExceedLimit`: The specified parameter TimeToLiveInHours exceeds the limit of %s.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `NumberExceed.Tags`: The Tags parameter number is exceed.
    /// - `MissingParameter.TagKey`: You must specify Tag.N.Key.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidStatus.ResourceGroup`: You cannot perform an operation on a resource group that is being created or deleted.
    /// - `RealNameAuthenticationError`: Your account has not passed the real-name authentication yet.
    /// - `ManagedInstanceCountExceedLimit`: The count of managed instance in current region exceeds the limit of %s.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InternalError.Dispatch`: An error occurred when dispatch the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_activation(
        &self,
        req: CreateActivation,
    ) -> impl std::future::Future<Output = crate::Result<CreateActivationResponse>> + Send {
        self.call(req)
    }

    /// # 查询激活码的使用情况
    ///
    /// 调用DescribeActivations查询已创建的激活码以及激活码的使用情况。
    ///
    /// ## 接口说明
    ///
    /// 支持以下两种方式查看返回数据：
    /// - 方式一：分页查询首页时，仅需设置`MaxResults`以限制返回信息的条目数，返回结果中的`NextToken`将作为查询后续页的凭证。查询后续页时，将`NextToken`参数设置为上一次返回结果中获取到的`NextToken`作为查询凭证，并设置`MaxResults`限制返回条目数。
    /// - 方式二：通过`PageSize`设置单页返回的条目数，再通过`PageNumber`设置页码。以上两种方式只能任选其中之一。如果设置了`MaxResults`或`NextToken`参数，则请求参数`PageSize`和`PageNumber`将失效，且返回数据中的`TotalCount`无效。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `InvalidParam.PageNumber`: The specified parameter is invalid.
    /// - `InvalidParam.PageSize`: The specified parameter is invalid.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `NumberExceed.Tags`: The Tags parameter number is exceed.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `MissingParameter.TagKey`: You must specify Tag.N.Key.
    /// - `InvalidParameter.NextToken`: The specified parameter NextToken is not valid.
    /// - `InvalidParameter.MaxResults`: The specified parameter MaxResults is not valid.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_activations(
        &self,
        req: DescribeActivations,
    ) -> impl std::future::Future<Output = crate::Result<DescribeActivationsResponse>> + Send {
        self.call(req)
    }

    /// # 手动禁用指定的激活码
    ///
    /// 调用DisableActivation手动禁用指定的激活码。
    ///
    /// ## 接口说明
    ///
    /// 如果您担心已创建的激活码存在泄露的风险，可以通过该接口禁用激活码。禁用后无法再通过该激活码注册新的托管实例，但不会影响已经注册的托管实例。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `ActivationId.NotFound`: The specified activation id does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn disable_activation(
        &self,
        req: DisableActivation,
    ) -> impl std::future::Future<Output = crate::Result<DisableActivationResponse>> + Send {
        self.call(req)
    }

    /// # 删除一个未被使用的激活码
    ///
    /// 调用DeleteActivation删除一个未被使用的激活码。
    ///
    /// ## 接口说明
    ///
    /// 激活码必须未被使用，即激活码对应注册的托管实例数量为0。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `ActivationId.InUse`: The specified activation id is in use.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `ActivationId.NotFound`: The specified activation id does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_activation(
        &self,
        req: DeleteActivation,
    ) -> impl std::future::Future<Output = crate::Result<DeleteActivationResponse>> + Send {
        self.call(req)
    }

    /// # 获取托管实例
    ///
    /// 调用DescribeManagedInstances查询托管实例列表。
    ///
    /// 分页查询首页时，仅需设置`MaxResults`以限制返回信息的条目数，返回结果中的`NextToken`将作为查询后续页的凭证。查询后续页时，将`NextToken`参数设置为上一次返回结果中获取到的`NextToken`作为查询凭证，并设置`MaxResults`限制返回条目数。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `InvalidParam.PageNumber`: The specified parameter is invalid.
    /// - `InvalidParam.PageSize`: The specified parameter is invalid.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `NumberExceed.Tags`: The Tags parameter number is exceed.
    /// - `MissingParameter.TagKey`: You must specify Tag.N.Key.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidParameter.NextToken`: The specified parameter NextToken is not valid.
    /// - `InvalidParameter.MaxResults`: The specified parameter MaxResults is not valid.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_managed_instances(
        &self,
        req: DescribeManagedInstances,
    ) -> impl std::future::Future<Output = crate::Result<DescribeManagedInstancesResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改托管实例
    ///
    /// 调用ModifyManagedInstance修改一台托管实例的相关信息。
    ///
    /// ## 接口说明
    ///
    /// 目前调用ModifyManagedInstance接口仅支持修改一台托管实例的名称。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `InstanceName.ExceedLimit`: The specified instance name exceed limit.
    /// - `InstanceName.InvalidPattern`: The specified instance name pattern invalid.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidInstance.NotFound`: The specified instances id does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_managed_instance(
        &self,
        req: ModifyManagedInstance,
    ) -> impl std::future::Future<Output = crate::Result<ModifyManagedInstanceResponse>> + Send
    {
        self.call(req)
    }

    /// # 注销托管实例
    ///
    /// 调用DeregisterManagedInstance注销一个托管实例。注销后您将无法再使用云助手向实例发送命令或文件。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `Operation.Forbidden`: The operation is not permitted.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidInstance.NotFound`: The specified instance id does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn deregister_managed_instance(
        &self,
        req: DeregisterManagedInstance,
    ) -> impl std::future::Future<Output = crate::Result<DeregisterManagedInstanceResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询实例中云助手插件的状态
    ///
    /// 调用ListPluginStatus查询实例中云助手插件的状态。
    ///
    /// - 实例的云助手Agent版本不低于以下版本，才可以查询到实例内云助手插件状态：
    ///     - Linux：2.2.3.344。
    ///     - Windows：2.1.3.344。
    /// - 分页查询首页时，仅需设置`MaxResults`以限制返回信息的条目数，返回结果中的`NextToken`将作为查询后续页的凭证。查询后续页时，将`NextToken`参数设置为上一次返回结果中获取到的`NextToken`作为查询凭证，并设置`MaxResults`限制返回条目数。
    ///
    /// # Error Codes
    /// - `RegionId.ApiNotSupported`: The api is not supported in this region.
    /// - `InvalidParam.PageNumber`: The specified parameter PageNumber is invalid.
    /// - `InvalidParam.PageSize`: The specified parameter PageSize is invalid.
    /// - `PluginName.MissingValue`: The plugin name must be specified when the number of InstanceIds is not 1.
    /// - `InstanceIds.ExceedLimit`: The number of instance IDs exceeds the upper limit.
    /// - `InvalidParameter.NextToken`: The specified parameter NextToken is not valid.
    /// - `InvalidParameter.MaxResults`: The specified parameter MaxResults is not valid.
    /// - `InvalidInstance.NotFound`: The specified instance does not exist.
    /// - `InvalidPluginName.NotFound`: The specified plugin name does not exist.
    /// - `InternalError.Dispatch`: An error occurred when you dispatched the request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn list_plugin_status(
        &self,
        req: ListPluginStatus,
    ) -> impl std::future::Future<Output = crate::Result<ListPluginStatusResponse>> + Send {
        self.call(req)
    }

    /// # 查询实例的全部状态信息
    ///
    /// 调用DescribeInstancesFullStatus查询一台或多台ECS实例的全状态信息。全状态信息包括实例状态和实例系统事件状态，其中，实例状态为实例的生命周期状态，实例系统事件为维护事件的健康状态。
    ///
    /// ## 接口说明
    /// 返回结果包括实例状态和待执行（Scheduled）状态的实例系统事件。
    ///
    /// 如果指定一个时间段，则根据时间段筛选事件。
    ///
    /// # Error Codes
    /// - `InvalidParameter`: %s
    /// - `InvalidParameter.TimeEndBeforeStart`: %s
    /// - `OperationDenied.NotInWhiteList`: %s
    /// - `InstanceIdLimitExceeded`: %s
    /// - `EventIdLimitExceeded`: %s
    /// - `MissingParameter`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instances_full_status(
        &self,
        req: DescribeInstancesFullStatus,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstancesFullStatusResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询一块或多块块存储的全部状态信息
    ///
    /// 调用DescribeDisksFullStatus查询一块或多块块存储的全部状态信息。
    ///
    /// -  块存储的全部状态信息包含块存储生命周期（`Status`）、块存储健康状态（`HealthStatus`）和块存储事件类型（`EventType`）。  
    ///
    /// -  由于块存储相关事件的发布时间、事件的计划执行时间以及事件的实际执行时间相同，如果指定一段时间（`EventTime.Start`~`EventTime.End`），则可以查询这段时间中发生过的所有历史事件。目前，您最多可以查询最近一周的历史事件。
    ///
    /// # Error Codes
    /// - `InvalidParameter`: %s
    /// - `DiskIdLimitExceeded`: %s
    /// - `EventIdLimitExceeded`: %s
    /// - `InvalidParameter.TimeEndBeforeStart`: %s
    /// - `OperationDenied.NotInWhiteList`: %s
    /// - `TooManyDiskEvent.DiskIdRequired`: %s
    /// - `MissingParameter`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_disks_full_status(
        &self,
        req: DescribeDisksFullStatus,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDisksFullStatusResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询指定实例系统事件信息
    ///
    /// 调用DescribeInstanceHistoryEvents接口，并可以指定InstanceId、EventType等参数，查询指定实例系统事件信息，默认查询处于非活跃状态的历史系统事件。
    ///
    /// - 您最多可以查询最近30天的已完结历史系统事件。对于未完结的系统事件无查询时间限制。
    ///
    /// - 未指定EventCycleStatus参数和InstanceEventCycleStatus参数时，查询结果默认只包括处于Avoided（事件已避免）、Executed（事件已完成执行）、Canceled（事件已取消）和Failed（事件执行失败）状态的系统事件。
    ///
    /// - 通过指定InstanceEventCycleStatus参数，还可以查询处于Scheduled（等待执行事件）、Executing（事件执行中）和Inquiring（事件问询中）状态的系统事件。
    ///
    /// # Error Codes
    /// - `InvalidParameter`: %s
    /// - `EventIdLimitExceeded`: %s
    /// - `InvalidParameter.TimeEndBeforeStart`: %s
    /// - `OperationDenied.NotInWhiteList`: %s
    /// - `MissingParameter`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_history_events(
        &self,
        req: DescribeInstanceHistoryEvents,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstanceHistoryEventsResponse>> + Send
    {
        self.call(req)
    }

    /// # 为实例预约模拟系统事件
    ///
    /// 为一台或多台ECS实例预约模拟系统事件。模拟系统事件相当于事件演习，不会真正执行事件，也不会对ECS实例产生影响。
    ///
    /// 预约模拟事件后，您可以通过ECS管理控制台、[ECS API](~~63962~~)和云监控服务查看已经预约的模拟系统事件。
    ///
    /// 下表为模拟系统事件的生命周期：
    ///
    /// - Scheduled（计划中）：预约后，模拟系统事件自动切换为Scheduled状态。
    /// - Executed（已完成）：在没有人为干预的情况下，模拟系统事件在指定时间点（NotBefore）自动变成Executed状态。
    /// - Canceled（已取消）：您调用[CancelSimulatedSystemEvents](~~88808~~)取消模拟系统事件后，变成Canceled状态。         
    /// - Avoided（已避免）：对于因系统维护实例重启（SystemMaintenance.Reboot）的模拟系统事件，可以通过在指定时间点前[重启实例](~~25502~~)而变成Avoided状态。
    ///
    /// # Error Codes
    /// - `InvalidParameter`: %s
    /// - `InvalidNotBefore.Passed`: %s
    /// - `SimulatedEventLimitExceeded`: %s
    /// - `InstanceIdLimitExceeded`: %s
    /// - `MissingParameter`: %s
    /// - `InvalidInstanceId.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_simulated_system_events(
        &self,
        req: CreateSimulatedSystemEvents,
    ) -> impl std::future::Future<Output = crate::Result<CreateSimulatedSystemEventsResponse>> + Send
    {
        self.call(req)
    }

    /// # 取消模拟系统事件
    ///
    /// 调用CancelSimulatedSystemEvents取消一件或多件处于Scheduled（计划中）或Executing（执行中）状态的模拟系统事件。取消系统事件后，模拟事件变为Canceled（已取消）状态。
    ///
    /// # Error Codes
    /// - `EventIdLimitExceeded`: %s
    /// - `InvalidParameter`: %s
    /// - `CannotCancelSystemEvent.NotSimulated`: %s
    /// - `InvalidEventId.NotFound`: %s
    /// - `MissingParameter`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn cancel_simulated_system_events(
        &self,
        req: CancelSimulatedSystemEvents,
    ) -> impl std::future::Future<Output = crate::Result<CancelSimulatedSystemEventsResponse>> + Send
    {
        self.call(req)
    }

    /// # 接受并授权执行系统事件操作
    ///
    /// 调用AcceptInquiredSystemEvent接受并授权执行系统事件操作。对问询中（Inquiring）状态的系统事件，接受系统事件的默认操作，授权系统执行默认操作。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `IncorrectInstanceStatus`: Current instance status does not support this operation.
    /// - `OperationConflict`: %s
    /// - `OperationFail.DiskCategoryNotSupported`: %s
    /// - `OperationFail.DiskStatusNotSupported`: %s
    /// - `OperationFail.InstanceStatusNotSupported`: %s
    /// - `OperationDenied.AcceptNotSupported`: Accept is not supported on current event type.
    /// - `SwitchToOffline.OnlineIsolateFail`: Failed to online isolate disk while offline isolation succeeded.
    /// - `SwitchToOffline.OnlineReinitFail`: Failed to online reinitialize disk while offline reinitialization succeeded.
    /// - `Forbidden.RAM`: User not authorized to operate on the specified resource, or this API does not support RAM.
    /// - `OperationFail.AcceptRecoverFail`: Failed to accept system event due to resource constraints.
    /// - `InvalidEventId.NoInquiringEventFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn accept_inquired_system_event(
        &self,
        req: AcceptInquiredSystemEvent,
    ) -> impl std::future::Future<Output = crate::Result<AcceptInquiredSystemEventResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询诊断指标列表
    ///
    /// 调用DescribeDiagnosticMetrics查询诊断指标列表。
    ///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_diagnostic_metrics(
        &self,
        req: DescribeDiagnosticMetrics,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDiagnosticMetricsResponse>> + Send
    {
        self.call(req)
    }

    /// # 创建资源诊断指标集合
    ///
    /// 调用CreateDiagnosticMetricSet创建资源诊断指标集合。您可以根据需要，灵活组合诊断指标。
    ///
    /// # Error Codes
    /// - `InvalidParameter.MetricId`: %s///
    /// # Methods
    /// - POST
    ///
    pub fn create_diagnostic_metric_set(
        &self,
        req: CreateDiagnosticMetricSet,
    ) -> impl std::future::Future<Output = crate::Result<CreateDiagnosticMetricSetResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询资源诊断集合列表
    ///
    /// 调用DescribeDiagnosticMetricSets查询资源诊断集合列表。
    ///
    /// # Error Codes
    /// - `InvalidMetricSetId.NotExist`: The specified MetricSetId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_diagnostic_metric_sets(
        &self,
        req: DescribeDiagnosticMetricSets,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDiagnosticMetricSetsResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改资源诊断指标集合
    ///
    /// 修改资源诊断指标集合。
    ///
    /// # Error Codes
    /// - `InvalidParameter.MetricSetId`: %s
    /// - `InvalidParameter.MetricIds`: %s///
    /// # Methods
    /// - POST
    ///
    pub fn modify_diagnostic_metric_set(
        &self,
        req: ModifyDiagnosticMetricSet,
    ) -> impl std::future::Future<Output = crate::Result<ModifyDiagnosticMetricSetResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除资源诊断指标集合
    ///
    /// 调用DeleteDiagnosticMetricSets删除资源诊断指标集合。
    ///
    /// # Error Codes
    /// - `InvalidMetricSetId.NotExist`: The specified MetricSetId does not exist.///
    /// # Methods
    /// - POST
    ///
    pub fn delete_diagnostic_metric_sets(
        &self,
        req: DeleteDiagnosticMetricSets,
    ) -> impl std::future::Future<Output = crate::Result<DeleteDiagnosticMetricSetsResponse>> + Send
    {
        self.call(req)
    }

    /// # 创建资源诊断报告
    ///
    /// 调用CreateDiagnosticReport创建资源诊断报告。根据您传入诊断指标集合ID，生成多个诊断指标的诊断报告。您可以根据返回的诊断报告ID，调用DescribeDiagnosticReportAttributes查询资源诊断详情。
    ///
    /// # Error Codes
    /// - `InvalidResource.NotExists	`: The specified resource not exists.
    /// - `InvalidParameter`: %s
    /// - `InvalidOperation.CloudAssistantNotReady`: Cloud Assistant is not installed, or the service is unavailable. Install Cloud Assistant or check the status of Cloud Assistant first.
    /// - `InvalidAxt.ServiceNotReady	`: %s
    /// - `Forbidden.CreateSLR`: You are not authorized to do this action.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_diagnostic_report(
        &self,
        req: CreateDiagnosticReport,
    ) -> impl std::future::Future<Output = crate::Result<CreateDiagnosticReportResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询资源诊断报告列表
    ///
    /// 调用DescribeDiagnosticReports查询资源诊断报告列表。
    ///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_diagnostic_reports(
        &self,
        req: DescribeDiagnosticReports,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDiagnosticReportsResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询资源诊断报告详情
    ///
    /// 调用DescribeDiagnosticReportAttributes查询资源诊断详情。
    ///
    /// # Error Codes
    /// - `InvalidParameter.ReportNotExist`: The specified report does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_diagnostic_report_attributes(
        &self,
        req: DescribeDiagnosticReportAttributes,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDiagnosticReportAttributesResponse>>
    + Send {
        self.call(req)
    }

    /// # 删除资源诊断报告
    ///
    /// 调用DeleteDiagnosticReports删除资源诊断报告。
    ///
    /// 不支持删除诊断中的报告。
    ///
    /// # Error Codes
    /// - `InvalidStatus.InProgress`: %s
    /// - `InvalidResource.NotFound`: The specified resource not exists.///
    /// # Methods
    /// - POST
    ///
    pub fn delete_diagnostic_reports(
        &self,
        req: DeleteDiagnosticReports,
    ) -> impl std::future::Future<Output = crate::Result<DeleteDiagnosticReportsResponse>> + Send
    {
        self.call(req)
    }

    /// # 获取实例的截屏信息
    ///
    /// 调用GetInstanceScreenshot获取实例的截屏信息。
    ///
    /// 云服务器ECS返回Base64编码后的JPG图像格式的实例截屏后，您需要自行解码。您可以在排查故障时调用该接口，并请注意：
    ///
    /// - 实例必须处于运行中（Running）状态。
    ///
    /// - [已停售的实例规格](~~55263~~)无法获取截屏信息。
    ///
    /// - 在同一台实例中多次调用该接口时，调用的间隔时间至少10秒，否则将返回错误码`Throttling`。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `IncorrectInstanceStatus`: %s
    /// - `NotSupported`: %s
    /// - `Throttling`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn get_instance_screenshot(
        &self,
        req: GetInstanceScreenshot,
    ) -> impl std::future::Future<Output = crate::Result<GetInstanceScreenshotResponse>> + Send
    {
        self.call(req)
    }

    /// # 获取实例系统命令行输出
    ///
    /// 获取一台实例的系统命令行输出，数据以Base64编码后返回。
    ///
    /// - 云服务器ECS是虚拟化的云上服务，无法接入显示设备，也无法手动截屏。但是阿里云缓存了实例最近一次启动、重启或者关机时的系统命令行输出，您可以调用GetInstanceConsoleOutput获取。
    ///
    /// - [已停售的实例规格](~~55263~~)无法获取系统命令行输出。
    ///
    /// - Windows实例不支持获取系统命令行输出。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `IncorrectInstanceStatus`: %s
    /// - `NotSupported`: %s
    /// - `Throttling`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn get_instance_console_output(
        &self,
        req: GetInstanceConsoleOutput,
    ) -> impl std::future::Future<Output = crate::Result<GetInstanceConsoleOutputResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询云盘监控数据
    ///
    /// 查询一块云盘在指定时间内的使用信息，例如，云盘读IOPS、写IOPS、读带宽（B/s）、写带宽（B/s）、读时延（μs）以及写时延（μs）。
    ///
    /// 调用该接口时，您需要注意以下限制：
    ///
    /// -  只能查询状态为使用中（`In_use`）的云盘使用信息。更多详情，请参见[普通云盘状态表](~~25689~~)。
    ///     > 若查询的信息中出现内容缺失，是因为无法获取该段时间的使用信息，即云盘状态不是使用中（`In_use`）。
    ///
    /// -  一次最多返回400条数据，需满足`（EndTime–StartTime）/Period`小于等于400的条件限制，即返回参数`TotalCount`不能超过400，否则将返回`InvalidParameter.TooManyDataQueried`的错误提示。  
    ///
    /// - 一次最多能查询近30天内的监控信息，即指定的参数`StartTime`距今不能超过30天。
    ///
    ///
    /// ## 请求示例
    ///
    /// 假设您需要查询华东 1（杭州）地域下ID为`d-bp14emm68wx98vjk****`的磁盘，在`2025-02-17T00:00:00Z`至`2025-02-18T10:00:00Z`期间，每600秒内的使用信息。相关配置请求参数如下：
    /// ```ignore
    /// RegionId:"cn-hangzhou", //设置华东 1（杭州）地域
    /// DiskId:"d-bp14emm68wx98vjk****", //设置磁盘ID
    /// StartTime:"2025-02-15T00:00:00Z", //设置查询起始时间
    /// EndTime:"2025-02-17T00:00:00Z", //设置查询结束时间
    /// Period:"600", //设置数据精度
    /// ```
    ///
    /// # Error Codes
    /// - `InvalidStartTime.Malformed`: The specified parameter "StartTime" is not valid.
    /// - `InvalidEndTime.Malformed`: The specified parameter "EndTime" is not valid.
    /// - `InvalidPeriod.ValueNotSupported`: The specified parameter "Period" is not valid.
    /// - `InvalidStartTime.TooEarly`: The specified parameter "StartTime" is too early.
    /// - `InvalidParameter.TooManyDataQueried`: Too many data queried.
    /// - `Throttling`: Request was denied due to request throttling.
    /// - `InvalidInstanceType.NotSupportCredit`: The InstanceType of the specified instance does not support credit.
    /// - `InvalidParameter.EndTime`: The specified parameter EndTime is earlier than StartTime.
    /// - `InvalidDiskId.NotFound`: The DiskId provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_disk_monitor_data(
        &self,
        req: DescribeDiskMonitorData,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDiskMonitorDataResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询实例监控数据
    ///
    /// 调用DescribeInstanceMonitorData查询一台ECS实例的监控信息。可查询的指标包括ECS实例的vCPU使用率、突发性能实例积分、接收的数据流量、发送的数据流量、平均带宽等。
    ///
    /// ## 接口说明
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// -  一次最多返回400条数据，需满足`（EndTime–StartTime）/Period`小于等于400的条件限制，即返回参数`TotalCount`不能超过400，否则将返回`InvalidParameter.TooManyDataQueried`的错误提示。  
    ///
    /// - 一次最多能查询近30天内的监控信息，即指定的参数`StartTime`距今不能超过30天。
    ///
    /// -  当返回信息中缺少部分内容时，可能是系统没有获取到相应的信息。例如，当时实例处于已停止（Stopped）状态。
    ///
    /// -  该接口暂无法获取EBM弹性裸金属实例的CPU基础监控信息，您可通过安装云监控插件获取CPU监控信息。具体操作，请参见[安装云监控插件](~~183482~~)。
    ///
    /// # Error Codes
    /// - `InvalidStartTime.Malformed`: The specified parameter "StartTime" is not valid.
    /// - `InvalidEndTime.Malformed`: The specified parameter "EndTime" is not valid.
    /// - `InvalidPeriod.ValueNotSupported`: The specified parameter "Period" is not valid.
    /// - `InvalidStartTime.TooEarly`: The specified parameter "StartTime" is too early.
    /// - `InvalidParameter.TooManyDataQueried`: Too many data queried.
    /// - `Throttling`: Request was denied due to request throttling.
    /// - `InvalidStartTime.ValueNotSupported`: The specified parameter StartTime is later than EndTime.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_monitor_data(
        &self,
        req: DescribeInstanceMonitorData,
    ) -> impl std::future::Future<Output = crate::Result<DescribeInstanceMonitorDataResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询辅助网卡监控数据
    ///
    /// 调用DescribeEniMonitorData查询一块辅助网卡在指定时间段内使用的流量信息。
    ///
    /// ## 接口说明
    ///
    /// 可查询的辅助网卡流量信息包括辅助网卡收发数据包的数量、内网出入流量、辅助网卡收发丢包的数量。当返回信息中缺少部分内容时，可能是由于系统没有获取到相应的信息。例如，当实例处于已停止（Stopped）状态或者辅助网卡没有挂载到实例上，即处于可用（Available）状态时，无法获取到相应的信息。调用该接口时，您需要注意：
    ///
    /// -  一次最多返回400条数据，需满足`（EndTime–StartTime）/Period`小于等于400的条件限制，即返回参数`TotalCount`不能超过400，否则将返回`InvalidParameter.TooManyDataQueried`的错误提示。  
    ///
    /// - 一次最多能查询近30天内的监控信息，即指定的参数`StartTime`距今不能超过30天。
    ///
    /// # Error Codes
    /// - `InvalidEniId.NotFound`: The specified ENI ID does not exist.
    /// - `InvalidStartTime.Malformed`: The specified parameter "StartTime" is not valid.
    /// - `InvalidEndTime.Malformed`: The specified parameter "EndTime" is not valid.
    /// - `InvalidPeriod.ValueNotSupported`: The specified parameter "Period" is not valid.
    /// - `InvalidStartTime.TooEarly`: The specified parameter "StartTime" is too early.
    /// - `InvalidParameter.TooManyDataQueried`: Too many data queried.
    /// - `Throttling`: Request was denied due to request throttling.
    /// - `InvalidInstanceType.NotSupportCredit`: The InstanceType of the specified instance does not support credit.
    /// - `InvalidParameter.EndTime`: The specified parameter EndTime is earlier than StartTime.
    /// - `InvalidDiskId.NotFound`: The DiskId provided does not exist in our records.
    /// - `InvalidEcsId.NotFound`: The specified instance ID is invalid.
    /// - `InvalidParam.Malformed`: The specified parameter "EniId" and "InstanceId" are not valid///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_eni_monitor_data(
        &self,
        req: DescribeEniMonitorData,
    ) -> impl std::future::Future<Output = crate::Result<DescribeEniMonitorDataResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询近30天内快照容量变化监控数据
    ///
    /// 查询一个地域下近30天内的快照容量变化监控数据。
    ///
    /// ## 接口说明
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// -  一次最多返回400条数据，需满足`（EndTime–StartTime）/Period`小于等于400的条件限制，即返回参数`TotalCount`不能超过400，否则将返回`InvalidParameter.TooManyDataQueried`的错误提示。  
    ///
    /// - 一次最多能查询近30天内的监控信息，即指定的参数`StartTime`距今不能超过30天。
    ///
    /// # Error Codes
    /// - `InvalidStartTime.Malformed`: The specified parameter "StartTime" is not valid.
    /// - `InvalidEndTime.Malformed`: The specified parameter "EndTime" is not valid.
    /// - `InvalidPeriod.ValueNotSupported`: The specified parameter "Period" is not valid.
    /// - `InvalidStartTime.TooEarly`: The specified parameter "StartTime" is too early.
    /// - `InvalidParameter.TooManyDataQueried`: Too many data queried.
    /// - `Throttling`: Request was denied due to request throttling.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_snapshot_monitor_data(
        &self,
        req: DescribeSnapshotMonitorData,
    ) -> impl std::future::Future<Output = crate::Result<DescribeSnapshotMonitorDataResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询实例的维护属性
    ///
    /// 调用DescribeInstanceMaintenanceAttributes查询实例的维护属性。
    ///
    /// 查询已设定的维护策略，策略中主要包括两个维护属性。
    ///
    /// - 维护时间窗口：您指定的一个时间段，运维只会在该时间内进行。
    /// - 维护动作：您指定的实例宕机处理策略。
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InstanceIdLimitExceeded`: %s
    /// - `OperationDenied.NotInWhiteList`: %s
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_instance_maintenance_attributes(
        &self,
        req: DescribeInstanceMaintenanceAttributes,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeInstanceMaintenanceAttributesResponse>,
    > + Send {
        self.call(req)
    }

    /// # 修改实例的维护属性
    ///
    /// 调用ModifyInstanceMaintenanceAttributes修改实例的维护属性。
    ///
    /// 修改实例的维护策略，策略中包含两个维护属性。
    ///
    /// - 维护时间窗口：您指定的一段时间，运维只会在该时间内进行。
    /// - 维护动作：您指定的实例宕机处理策略。
    ///
    /// # Error Codes
    /// - `InvalidParameter`: %s
    /// - `OperationDenied.NotInWhiteList`: %s
    /// - `InvalidInstanceId.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_instance_maintenance_attributes(
        &self,
        req: ModifyInstanceMaintenanceAttributes,
    ) -> impl std::future::Future<
        Output = crate::Result<ModifyInstanceMaintenanceAttributesResponse>,
    > + Send {
        self.call(req)
    }

    /// # 重新部署实例
    ///
    /// 当ECS实例收到系统事件通知时，调用RedeployInstance可以重新部署这台ECS实例。
    ///
    /// ## 接口说明
    ///
    /// RedeployInstance为异步调用接口，会重启并迁移实例。重新部署成功后，实例进入运行中（`Running`）状态。重新部署失败时，实例返回原有的物理服务器，并恢复到重新部署前的状态。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// - 目标实例必须处于运行中或者已停止状态，调用接口后的实例状态变化：
    ///     - 处于运行中（`Running`）的实例会进入停止中（`Stopping`）状态。
    ///     - 处于已停止（`Stopped`）的实例会进入启动中（`Starting`）状态。
    /// - 不支持重新部署专有宿主机上的实例。
    /// - 被安全控制的实例的`OperationLocks`中标记了`"LockReason": "security"`时，不支持重新部署。
    /// - 不支持响应通过CreateSimulatedSystemEvent创建的模拟事件。
    /// - 在隔离本地盘的系统事件流程中，受损本地盘已隔离但尚未发出**因系统维护计划重启并重新初始化坏盘**事件（SystemMaintenance.RebootAndReInitErrorDisk）时，也可以调用RedeployInstance。更多信息，请参见[本地盘实例系统事件概述](~~107693~~)。
    ///
    /// RedeployInstance能响应系统事件类型及事件状态请参见下表。
    ///
    /// | 事件名称及参数 | 事件状态 |
    /// | --- | --- |
    /// | 因系统维护实例重启（SystemMaintenance.Reboot）| Inquiring、Scheduled|
    /// | 因系统维护实例重新部署（SystemMaintenance.Redeploy）| Inquiring、Scheduled |
    /// | 因系统维护重启并更换坏盘（SystemMaintenance.RebootAndIsolateErrorDisk）| Inquiring |
    /// | 因系统维护重启并重新初始化坏盘（SystemMaintenance.RebootAndReInitErrorDisk）| Inquiring |
    /// | 因系统错误实例重新部署（SystemFailure.Redeploy）| Inquiring |
    /// | 仅限使用了本地盘的ECS实例：因系统错误实例重新启动（SystemFailure.Reboot）| Executing |
    /// | 因系统维护隔离坏盘（SystemMaintenance.IsolateErrorDisk） | Inquiring |
    /// | 因系统维护重新初始化坏盘（SystemMaintenance.ReInitErrorDisk） | Inquiring |
    ///
    /// > 重新部署本地盘实例会重新初始化本地盘，存储设备的数据被清空。
    ///
    /// # Error Codes
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `DiskError`: IncorrectDiskStatus.
    /// - `InstanceExpiredOrInArrears`: The specified operation is denied as your prepay instance is expired (prepay mode) or in arrears (afterpay mode).
    /// - `InvalidOperation.RedeployInstance`: %s
    /// - `InvalidInstanceId.NotFound`: The InstanceId provided does not exist in our records.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn redeploy_instance(
        &self,
        req: RedeployInstance,
    ) -> impl std::future::Future<Output = crate::Result<RedeployInstanceResponse>> + Send {
        self.call(req)
    }

    /// # 反馈一台或者多台ECS实例异常问题
    ///
    /// 调用ReportInstancesStatus反馈一台或者多台ECS实例的异常问题。您可以反馈多台ECS实例发生的相同问题，也可以反馈一台ECS实例的多块磁盘发生的相同问题。
    ///
    /// # Error Codes
    /// - `InvalidParameter`: %s
    /// - `InstanceIdLimitExceeded`: %s
    /// - `DiskIdLimitExceeded`: %s
    /// - `InvalidInstanceId.NotFound`: %s
    /// - `MissingParameter`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn report_instances_status(
        &self,
        req: ReportInstancesStatus,
    ) -> impl std::future::Future<Output = crate::Result<ReportInstancesStatusResponse>> + Send
    {
        self.call(req)
    }

    /// # 创建并绑定标签
    ///
    /// 为指定的ECS资源列表统一创建并绑定标签。
    ///
    /// ## 接口说明
    ///
    /// 绑定标签前，阿里云会校验资源已有标签数量。超过限制值后返回报错信息。更多信息，请参见[使用限制](~~25412~~)。
    ///
    /// # Error Codes
    /// - `NumberExceed.ResourceIds`: The ResourceIds parameter's number is exceed , Valid : 50.
    /// - `NumberExceed.Tags`: The Tags parameter's number is exceed , Valid : 20.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `OperationDenied.QuotaExceed`: The quota of tags on resource is beyond permitted range.
    /// - `InvalidTag.Mismatch`: The specified Tag.n.Key and Tag.n.Value are not match.
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `Invalid.Scope`: The specified scope is invalid.
    /// - `PermissionDenied.TagOwnerBid`: The specified operator not have permission to set TagOwnerBid value.
    /// - `PermissionDenied.TagOwnerUid`: The specified operator not have permission to set TagOwnerUid value.
    /// - `PermissionDenied.Scope`: The specified operator not have permission to set Scope value.
    /// - `InvalidResourceId.NotSupported`: The specified ResourceId does not support tagging.
    /// - `NoPermissionKey.Scope`: %s
    /// - `NoPermission.Tag`: The operator is not permission for the tag.
    /// - `QuotaExceed.Tags`: %s
    /// - `TagKey.Duplication`: The TagKey has duplication with others, case-insensitive.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `MissingParameter.ResourceIds`: The parameter - ResourceIds.N should not be null.
    /// - `MissingParameter.TagOwnerUid`: The parameter - TagOwnerUid should not be null.
    /// - `MissingParameter.TagOwnerBid`: The parameter - TagOwnerBid should not be null.
    /// - `MissingParameter.ResourceType`: The parameter - ResourceType should not be null.
    /// - `MissingParameter.Tags`: The parameter - Tags should not be null.
    /// - `MissingParameter.RegionId`: The parameter - RegionId should not be null.
    /// - `InvalidResourceId.NotFound`: The specified ResourceIds are not found in our records.
    /// - `InvalidResourceType.NotFound`: The ResourceType provided does not exist in our records.
    /// - `ServiceUnavailable`: The service is unavailable, please try again later.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn tag_resources(
        &self,
        req: TagResources,
    ) -> impl std::future::Future<Output = crate::Result<TagResourcesResponse>> + Send {
        self.call(req)
    }

    /// # 查询资源已经绑定的标签列表
    ///
    /// 查询一个或多个ECS资源已经绑定的标签列表。
    ///
    /// ## 接口说明
    ///
    /// 请求中至少指定以下任一参数，以确定查询对象。
    ///
    /// - `ResourceId.N`
    /// - `Tag.N`（`Tag.N.Key`与`Tag.N.Value`）
    /// - `TagFilter.N`
    ///
    /// 同时指定下列参数时，返回结果中仅包含同时满足这两个条件的ECS资源。
    ///
    /// - `Tag.N`和`ResourceId.N`
    /// - `TagFilter.N`和`ResourceId.N`
    ///
    /// # Error Codes
    /// - `InvalidDefaultResourceGroup.NotSupported`: The specified parameter Tag is not support for default resource group.
    /// - `InvalidTag.NotSupported`: You can only specify Tag for either resource tag or resource group.
    /// - `NumberExceed.ResourceIds`: The ResourceIds parameter's number is exceed , Valid : 50.
    /// - `NumberExceed.Tags`: The Tags parameter's number is exceed , Valid : 20.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `OperationDenied.QuotaExceed`: The quota of tags on resource is beyond permitted range.
    /// - `InvalidTag.Mismatch`: The specified Tag.n.Key and Tag.n.Value are not match.
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `Invalid.Scope`: The specified scope is invalid.
    /// - `InvalidTags.MalFormed`: The tags must be empty, when the tagFilters is not empty.
    /// - `PermissionDenied.TagOwnerBid`: The specified operator not have permission to set TagOwnerBid value.
    /// - `PermissionDenied.TagOwnerUid`: The specified operator not have permission to set TagOwnerUid value.
    /// - `PermissionDenied.Scope`: The specified operator not have permission to set Scope value.
    /// - `InvalidResourceId.NotSupported`: The specified ResourceId does not support tagging.
    /// - `NoPermission.Tag`: The operator is not permission for the tag.
    /// - `BothEmpty.TagsAndResources`: The specified Tags and ResourcesIds are not allow to both empty.
    /// - `PermissionDenied.TagsFuzzyQuery`: The specified operator has not permission to query fuzzy tags.
    /// - `NumberExceed.TagValues`: The number of the specified TagValues is beyond permitted range, the max is 5.
    /// - `InvalidFilter.Malformed`: The specified Filter is not valid.
    /// - `InvalidTagFilter.Malformed`: The specified TagFilter is not valid.
    /// - `Invalid.NextToken`: The specified NextToken is not valid.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `MissingParameter.ResourceIds`: The parameter - ResourceIds.N should not be null.
    /// - `MissingParameter.TagOwnerUid`: The parameter - TagOwnerUid should not be null.
    /// - `MissingParameter.TagOwnerBid`: The parameter - TagOwnerBid should not be null.
    /// - `MissingParameter.ResourceType`: The parameter - ResourceType should not be null.
    /// - `MissingParameter.Tags`: The parameter - Tags should not be null.
    /// - `MissingParameter.RegionId`: The parameter - RegionId should not be null.
    /// - `InvalidResourceId.NotFound`: The specified ResourceIds are not found in our records.
    /// - `InvalidResourceType.NotFound`: The ResourceType provided does not exist in our records.
    /// - `ServiceUnavailable`: The service is unavailable, please try again later.
    /// - `InternalError`: The process of creating snapshot has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn list_tag_resources(
        &self,
        req: ListTagResources,
    ) -> impl std::future::Future<Output = crate::Result<ListTagResourcesResponse>> + Send {
        self.call(req)
    }

    /// # 为指定资源列表统一解绑标签
    ///
    /// 调用UntagResources为指定的ECS资源列表统一解绑标签。解绑后，如果该标签没有绑定其他任何资源，会被自动删除。
    ///
    /// # Error Codes
    /// - `NumberExceed.ResourceIds`: The ResourceIds parameter's number is exceed , Valid : 50
    /// - `NumberExceed.Tags`: The Tags parameter's number is exceed , Valid : 20
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `OperationDenied.QuotaExceed`: The quota of tags on resource is beyond permitted range.
    /// - `InvalidTag.Mismatch`: The specified Tag.n.Key and Tag.n.Value are not match.
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `Invalid.Scope`: The specified scope is invalid.
    /// - `PermissionDenied.TagOwnerBid`: The specified operator not have permission to set TagOwnerBid value.
    /// - `PermissionDenied.TagOwnerUid`: The specified operator not have permission to set TagOwnerUid value.
    /// - `PermissionDenied.Scope`: The specified operator not have permission to set Scope value.
    /// - `InvalidResourceId.NotSupported`: The specified ResourceId does not support tagging.
    /// - `NoPermissionKey.Scope`: %s
    /// - `NoPermission.Tag`: The operator is not permission for the tag.
    /// - `Param.Conflict`: The specified all is true, but the specified TagKey.N is not empty.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `MissingParameter.ResourceIds`: The parameter - ResourceIds.N should not be null
    /// - `MissingParameter.TagOwnerUid`: The parameter - TagOwnerUid should not be null
    /// - `MissingParameter.TagOwnerBid`: The parameter - TagOwnerBid should not be null
    /// - `MissingParameter.ResourceType`: The parameter - ResourceType should not be null
    /// - `MissingParameter.Tags`: The parameter - Tags should not be null
    /// - `MissingParameter.RegionId`: The parameter - RegionId should not be null
    /// - `InvalidResourceId.NotFound`: The specified ResourceIds are not found in our records.
    /// - `InvalidResourceType.NotFound`: The ResourceType provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn untag_resources(
        &self,
        req: UntagResources,
    ) -> impl std::future::Future<Output = crate::Result<UntagResourcesResponse>> + Send {
        self.call(req)
    }

    /// # 将一个ECS资源或者服务加入一个资源组
    ///
    /// 调用JoinResourceGroup将一个ECS资源或者服务加入一个资源组。
    ///
    /// ## 接口说明
    ///
    /// 资源是您在阿里云创建的云服务实体，例如，一台ECS实例、一个ECS弹性网卡或者一份ECS镜像等都可以是资源。资源组是项目、环境或者栈的基础设施集合，在资源组里管理资源能集中监控和执行任务，免去了您在多种阿里云服务间反复查看的负担。
    ///
    /// # Error Codes
    /// - `EntityExists.AssociatedTransferTasks`: An associated transfer task is in progress. Try again later.
    /// - `MissingParameter`: The input parameter "ResourceId" that is mandatory for processing this request is not supplied.
    /// - `InvalidResourceGroup.Duplicate`: The ResourceId provided has a ResourceGroup in our records.
    /// - `InvalidRegionId.ResourceGroup`: The specified region does not support resource group yet.
    /// - `InvalidStatus.ResourceGroup`: You cannot perform an operation on a resource group that is being created or deleted.
    /// - `InvalidResourceType.NotFound`: The ResourceType provided does not exist in our records.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InvalidResourceId.NotFound`: The ResourceId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn join_resource_group(
        &self,
        req: JoinResourceGroup,
    ) -> impl std::future::Future<Output = crate::Result<JoinResourceGroupResponse>> + Send {
        self.call(req)
    }

    /// # 创建一台或多台按量付费或者包年包月专有宿主机
    ///
    /// 调用AllocateDedicatedHosts创建一台或多台按量付费或者包年包月专有宿主机。专有宿主机是单租户独享的物理机资源，您可以在专有宿主机上自行创建ECS实例和获取物理服务器属性等信息。
    ///
    /// 创建专有宿主机前，您可以调用[DescribeAvailableResource](~~66186~~)查看指定地域或者可用区内的资源供给情况。
    ///
    /// 创建专有宿主机会产生费用，建议您提前了解资源的计费方式。更多详情，请参见[计费概述](~~68978~~)。
    ///
    /// - 单次最多能创建100台包年包月或按量付费专有宿主机。
    /// - 创建成功后，您可以将返回的专有宿主机ID列表作为请求参数，调用[DescribeDedicatedHosts](~~134242~~)查询新建专有宿主机状态。
    /// - 提交创建专有宿主机的请求后，指定的参数值不合规或者库存不足时会报错。具体的报错原因，请参见错误码。
    /// - 创建专有宿主机后，您可以通过[ModifyInstanceDeployment](~~134248~~)将ECS实例从共享宿主机迁移到专有宿主机，也可以在两台专有宿主机上调整实例部署。
    ///
    /// # Error Codes
    /// - `InvalidInstanceType.ValueUnauthorized`: The specified InstanceType is not authorized.
    /// - `InvalidDescription.Malformed`: The specified parameter "Description" is not valid.
    /// - `InvalidParameter.Conflict`: The specified region and cluster do not match.
    /// - `InvalidAutoRenewPeriod.ValueNotSupported`: The specified autoRenewPeriod is not valid.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidDedicatedHostType.ValueNotSupported`: %s
    /// - `RegionUnauthorized`: %s
    /// - `Zone.NotOnSale`: %s
    /// - `OperationDenied`: The specified DedicatedHostType or Zone is not available or not authorized.
    /// - `InvalidPeriodUnit.ValueNotSupported`: The specified parameter PeriodUnit is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `QuotaExceed.AfterpayDedicatedHost`: The maximum number of Pay-As-You-Go DedicatedHosts is exceeded: %s
    /// - `InvalidChargeType.ValueNotSupported`: ChargeType is not valid
    /// - `InvalidParameter.SlbUdpTimeout`: The specified value is invalid.
    /// - `InvalidParameter.UdpTimeout`: The specified value is invalid.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidParameter.Quantity`: The specified Quantity is invalid.
    /// - `InvalidDedicatedHostPrice.NotFound`: The specified Dedicated price is not found.
    /// - `InvalidDedicatedHostType.CpuOverCommitRatioNotSupported`: %s
    /// - `InvalidCpuOverCommitRatio.ValueNotSupported`: %s
    /// - `OperationDenied`: The creation of Host to the specified Zone is not allowed.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone; try other types of resources or other regions and zones.
    /// - `NodeControllerUnavailable`: The Node Controller is temporarily unavailable.
    /// - `InvalidParameter.ResourceOwnerAccount`: ResourceOwnerAccount is Invalid.
    /// - `InvalidUserData.Forbidden`: User not authorized to input the parameter "UserData", please apply for permission "UserData"
    /// - `Zone.NotOpen`: The specified zone is not granted to you to buy resources yet.
    /// - `Zone.NotOnSale`: The specified zone is not available for purchase.
    /// - `InvalidResourceType.NotSupported`: %s
    /// - `InvalidDedicatedHostType.ValueNotSupported`: The specified DedicatedHostType does not exist or beyond the permitted range.
    /// - `InvalidDedicatedHostType.ZoneNotSupported`: The specified zone does not support this dedicatedHostType.
    /// - `InvalidUserData.Base64FormatInvalid`: The specified UserData is not valid
    /// - `InvalidParameter.NotMatch`: %s
    /// - `Account.Arrearage`: Your account has been in arrears.
    /// - `OperationDenied.NoStock`: The requested resource is sold out in the specified zone; try other types of resources or other regions and zones.
    /// - `InvalidZoneId.NotFound`: The ZoneId provided does not exist in our records.
    /// - `OperationDenied`: Another Host has been creating
    /// - `PaymentMethodNotFound`: No payment method has been registered on the account.
    /// - `InvalidDedicatedHostName.Malformed`: The specified parameter DedicatedHostName is not valid.
    /// - `InvalidDedicatedHostClusterId.NotFound`: The specified DedicatedHostClusterId does not exist.
    /// - `InvalidDedicatedHostClusterId.ExceedMaxSize`: The specified Dedicated Host Cluster exceeded max capacity.
    /// - `InvalidParameter.ActionOnMaintenance`: The specified ActionOnMaintenance does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn allocate_dedicated_hosts(
        &self,
        req: AllocateDedicatedHosts,
    ) -> impl std::future::Future<Output = crate::Result<AllocateDedicatedHostsResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询专有宿主机详细信息
    ///
    /// 本接口用于查询一台或多台专有宿主机的详细信息。通过该接口，您可以获取包括专有宿主机的物理性能指标、机器码、使用状态以及已创建的ECS实例列表等信息。您能够根据具体需求，通过指定相关参数，如专有宿主机ID列表、专有宿主机集群ID、宿主机名称、状态等，精准地查询所需的专有宿主机详细信息，为高效管理和优化云计算资源提供有力支持。
    ///
    /// ## 接口说明
    ///
    /// 您可以通过以下任一方式查询一台或多台专有宿主机的详细信息：
    ///
    /// - 指定`DedicatedHostIds`查询专有宿主机的详细信息。
    /// - 指定`DedicatedHostClusterId`查询专有宿主机集群内专有宿主机的详细信息。
    ///
    /// # Error Codes
    /// - `InvalidStatus.ValueNotSupported`: The pecified dedicated host status is not supported.
    /// - `MissingParamter.RegionId`: The regionId should not be null.
    /// - `InvalidParameter.DedicatedHostIds`: The specified parameter dedicatedHostIds is not valid.
    /// - `InvalidRegion.NotFound`: The specified parameter RegionId is not valid.
    /// - `InvalidZone.NotFound`: The specified parameter ZoneId is not valid.
    /// - `InvalidDedicatedHostIds.Malformed`: The amount of specified dedicatedHostIds exceeds the limit.
    /// - `InvalidLockReason.NotFound`: The specified LockReason is not found.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_dedicated_hosts(
        &self,
        req: DescribeDedicatedHosts,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDedicatedHostsResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询专有宿主机规格详细参数
    ///
    /// 调用DescribeDedicatedHostTypes查询指定地域下支持的专有宿主机规格详细参数，或者查询专有宿主机支持的ECS实例规格族。
    ///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_dedicated_host_types(
        &self,
        req: DescribeDedicatedHostTypes,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDedicatedHostTypesResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改专有宿主机部分信息
    ///
    /// 调用ModifyDedicatedHostAttribute修改一台专有宿主机的部分信息，包括专有宿主机的名称、描述和服务不可用属性等。
    ///
    /// ## 接口说明
    ///
    /// - 修改CPU超卖比时，专有宿主机上的ECS实例必须为已停止（`Stopped`）状态。
    /// - 修改CPU超卖比不会影响DDH的运行状态，但需注意DDH中已分配的vCPU数量不能超过修改后的总vCPU数量，否则超出部分的ECS实例将无法启动。
    ///
    /// # Error Codes
    /// - `InvalidDedicatedHostName.Malformed`: The specified parameter DedicatedHostName is not valid.
    /// - `InvalidDescription.Malformed`: The specified parameter Description is not valid.
    /// - `InvalidParameter.SlbUdpTimeout`: The specified value is invalid.
    /// - `InvalidParameter.UdpTimeout`: The specified value is invalid.
    /// - `InvalidDedicatedHostType.CpuOverCommitRatioNotSupported`: %s
    /// - `InvalidCpuOverCommitRatio.ValueNotSupported`: %s
    /// - `InvalidUser.Unauthorized`: The user is not authorized
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist.
    /// - `InvalidDedicatedHostClusterId.NotFound`: The specified DedicatedHostClusterId does not exist.
    /// - `InvalidDedicatedHostClusterId.ExceedMaxSize`: The specified Dedicated Host Cluster exceeded max capacity.
    /// - `InvalidDedicatedHostClusterId.NotMatch`: The specified DedicatedHostCluster does not match request.
    /// - `InvalidParameter.ActionOnMaintenance`: The specified ActionOnMaintenance does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_dedicated_host_attribute(
        &self,
        req: ModifyDedicatedHostAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyDedicatedHostAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改专有宿主机的付费类型
    ///
    /// 调用ModifyDedicatedHostsChargeType修改专有宿主机的付费类型。
    ///
    /// # Error Codes
    /// - `InvalidParameter.InstanceIds`: The specified InstanceIds are invalid.
    /// - `InvalidParameter`: %s
    /// - `InvalidStatus.ValueNotSupported`: %s
    /// - `InvalidInstanceChargeType.ValueNotSupported`: %s
    /// - `InvalidSpotStrategy`: The specified spotStrategy is not valid.
    /// - `ExpiredInstance`: The specified instance has expired.
    /// - `InstancesIdQuotaExceed`: The maximum number of Instances is exceeded.
    /// - `InvalidClientToken.ValueNotSupported`: The ClientToken provided is invalid.
    /// - `InvalidInstance.UnpaidOrder`: The specified instance has unpaid order.
    /// - `ReleaseTimeHaveBeenSet`: The specified instance has been set released time.
    /// - `Throttling`: Request was denied due to request throttling, please try again after 5 minutes.
    /// - `InvalidPeriod.UnitMismatch`: The specified Period must be correlated with the PeriodUnit.
    /// - `InvalidImageType.NotSupported`: %s
    /// - `InvalidPeriod.ExceededDedicatedHost`: Instance expired date can't exceed dedicated host expired date.
    /// - `InvalidSystemDiskCategory.ValueNotSupported`: %s
    /// - `InvalidAccountStatus.PayAmountLimitExceeded`: Your account is being restricted, due to no default payment method is set or you has not being authorized.
    /// - `QuotaExceed.AfterpayInstance`: The maximum number of Pay-As-You-Go instances is exceeded.
    /// - `QuotaExceed.RufundVcpu`: The maximum number of refunded vcpu is exceeded: %s .
    /// - `InvalidInstanceType.ValueNotSupported`: The specified InstanceType does not exist or beyond the permitted range.
    /// - `InstanceType.Offline`: %s
    /// - `InvalidAccountStatus.NotEnoughBalance`: Your account does not have enough balance.
    /// - `Account.Arrearage`: Your account has an outstanding payment.
    /// - `InvalidParameter.NotMatch`: %s
    /// - `InvalidAction`: %s
    /// - `QuotaExceed.PostPaidDisk`: Living postPaid disks quota exceeded.
    /// - `ImageNotSupportInstanceType`: The specified instanceType is not supported by instance with marketplace image.
    /// - `InvalidInstanceType.PhasedOut`: This instanceType is no longer offered.
    /// - `InvalidPeriod.ExceededDedicatedHost`: Instance expired date can't exceed dedicated host expired date.
    /// - `RealNameAuthenticationError`: Your account has not passed the real-name authentication yet.
    /// - `InvalidOperation.NotSupport`: Instance on dedicated host not support modify charge type.
    /// - `InvalidInstanceId.NotFound`: The specified instanceId does not exist.
    /// - `InvalidDedicatedHostId.NotFound`: The specified Dedicated Host does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_dedicated_hosts_charge_type(
        &self,
        req: ModifyDedicatedHostsChargeType,
    ) -> impl std::future::Future<Output = crate::Result<ModifyDedicatedHostsChargeTypeResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询专有宿主机自动续费状态
    ///
    /// 调用DescribeDedicatedHostAutoRenew查询一台或多台包年包月专有宿主机自动续费状态。
    ///
    /// # Error Codes
    /// - `ChargeTypeViolation`: Pay-As-You-Go dedicated host does not support this operation.
    /// - `MissingParameter.DedicatedHostId`: DedicatedHostId should not be null.
    /// - `InvalidParameter.ToManyDedicatedHostIds`: DedicatedHostId should be less than 100.
    /// - `InvalidParameter.InvalidDedicatedHostId`: %s
    /// - `IncorrectDedicatedHostStatus`: The current status of the resource does not support this operation.
    /// - `MissingParamter.InstanceId`: InstanceId should not be null.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_dedicated_host_auto_renew(
        &self,
        req: DescribeDedicatedHostAutoRenew,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDedicatedHostAutoRenewResponse>> + Send
    {
        self.call(req)
    }

    /// # 为专有宿主机设置或取消自动续费
    ///
    /// 调用ModifyDedicatedHostAutoRenewAttribute为一台或多台包年包月专有宿主机设置自动续费，也可以取消已设定的自动续费。
    ///
    /// - 当您的包年包月专有宿主机开启自动续费功能后，到期前九天将自动续费，扣费在08:00:00（UTC +8）时间点自动执行。如果前一日扣费失败，次日继续定时执行。扣费成功或者九天之后专有宿主机到期被锁定后停止自动扣费。期间，您需要保证自己的支付方式使用额度充足即可。
    /// - 包年包月的专有宿主机支持跟随宿主机内的包年包月ECS实例自动续费。详细信息，请参见AutoRenewWithEcs参数说明。
    ///
    /// # Error Codes
    /// - `MissingParameter.DedicatedHostId`: DedicatedHostId should not be null.
    /// - `InvalidParameter.ToManyDedicatedHostIds`: DedicatedHostId should be less than 100.
    /// - `InvalidParameter.InvalidDedicatedHostId`: %s
    /// - `IncorrectHostStatus`: The current status of the resource does not support this operation.
    /// - `ChargeTypeViolation`: Pay-As-You-Go dedicated host do not support this operation.
    /// - `InvalidParameter.Duration`: %s
    /// - `InvalidParameter.RenewalStatus`: %s
    /// - `InvalidPeriodUnit.ValueNotSupported`: The specified parameter PeriodUnit is not valid.
    /// - `InvalidParameter.AutoRenewWithEcs`: The value of parameter AutoRenewWithEcs is invalid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_dedicated_host_auto_renew_attribute(
        &self,
        req: ModifyDedicatedHostAutoRenewAttribute,
    ) -> impl std::future::Future<
        Output = crate::Result<ModifyDedicatedHostAutoRenewAttributeResponse>,
    > + Send {
        self.call(req)
    }

    /// # 续费一台或者多台包年包月专有宿主机
    ///
    /// 续费一台或者多台包年包月的专有宿主机。
    ///
    /// ## 接口说明
    ///
    /// <props="china">续费付款时，优先使用可抵扣的代金券，且您的账号必须支持账号余额支付或信用支付。</props>
    /// <props="intl">续费付款时，优先使用可抵扣的代金券，且您的账号必须支持账号余额支付或信用支付。</props>
    ///
    /// # Error Codes
    /// - `IdempotenceParamNotMatch`: Request uses a client token in a previous request but is not identical to that request.
    /// - `InvalidClientToken.ValueNotSupported`: The ClientToken provided is invalid.
    /// - `InvalidPeriod`: The specified period is not valid.
    /// - `InvalidPeriodUnit.ValueNotSupported`: The specified parameter PeriodUnit is not valid.
    /// - `ChargeTypeViolation`: Pay-As-You-Go dedicated host do not support this operation.
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist.
    /// - `InvalidStatus.Upgrading`: The dedicated host is upgrading, please try it later.
    /// - `LastOrderProcessing`: The previous order is still processing, please try again later.
    /// - `ChargeTypeViolation`: Pay-As-You-Go dedicated host do not support this operation.
    /// - `IncorrectHostStatus`: The current status of the resource does not support this operation.
    /// - `LastTokenProcessing`: The last token request is processing.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn renew_dedicated_hosts(
        &self,
        req: RenewDedicatedHosts,
    ) -> impl std::future::Future<Output = crate::Result<RenewDedicatedHostsResponse>> + Send {
        self.call(req)
    }

    /// # 为专有宿主机设定自动释放时间
    ///
    /// 调用ModifyDedicatedHostAutoReleaseTime为一台按量付费专有宿主机设定自动释放时间，或者取消自动释放一台按量付费专有宿主机。
    ///
    /// ## 接口说明
    /// 到达设置的自动释放时间后，按量付费专有宿主机会被自动释放。请确保您已经不再使用该宿主机，并已按需备份应用数据。
    ///
    /// # Error Codes
    /// - `MissingParameter`: DedicatedHostId should not be null.
    /// - `UnsupportedParameter`: The parameters is unsupported.
    /// - `InvalidAutoReleaseTime.Malformed`: The specified parameter AutoReleaseTime is not valid.
    /// - `ChargeTypeViolation`: The operation is not permitted due to charge type of the dedicated host.
    /// - `NoSuchResource`: The specified resource is not found.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_dedicated_host_auto_release_time(
        &self,
        req: ModifyDedicatedHostAutoReleaseTime,
    ) -> impl std::future::Future<Output = crate::Result<ModifyDedicatedHostAutoReleaseTimeResponse>>
    + Send {
        self.call(req)
    }

    /// # 执行专有宿主机的故障迁移
    ///
    /// 执行专有宿主机的故障迁移。
    ///
    /// DDH状态为报警状态（`UnderAssessment`），即故障潜伏期时，建议您调用该接口执行DDH的故障迁移，避免DDH产生永久性故障。您可以调用API [DescribeDedicatedHosts](~~134242~~)查询专有宿主机的状态信息。
    ///
    /// # Error Codes
    /// - `InvalidDedicatedHostStatus.Malformed`: The specified DedicatedHost is in inValid status to execute redeployment.
    /// - `InvalidInstanceStatus.Unstopped`: There is unstopped instances on DedicatedHost.
    /// - `InvalidUser.Unauthorized`: The user is not authorized.
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn redeploy_dedicated_host(
        &self,
        req: RedeployDedicatedHost,
    ) -> impl std::future::Future<Output = crate::Result<RedeployDedicatedHostResponse>> + Send
    {
        self.call(req)
    }

    /// # 释放专有宿主机
    ///
    /// 本接口用于释放一台按量付费专有宿主机或者到期的包年包月专有宿主机
    ///
    /// 释放按量付费专有宿主机之前，请确保该宿主机上不存在任何ECS实例。
    ///
    /// # Error Codes
    /// - `ChargeTypeViolation`: The operation is not permitted due to charge type of the dedicated host.
    /// - `IncorrectHostStatus.Initializing`: The specified ddh status does not support this operation.
    /// - `InstanceExist`: Instance exists on the dedicated host.
    /// - `OperationDenied.DedicatedHostShared`: The specified ddh is shared to other users. Remove it from the resource share before releasing.
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostId does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn release_dedicated_host(
        &self,
        req: ReleaseDedicatedHost,
    ) -> impl std::future::Future<Output = crate::Result<ReleaseDedicatedHostResponse>> + Send {
        self.call(req)
    }

    /// # 创建专有宿主机组
    ///
    /// 创建一个专有宿主机组。
    ///
    /// # Error Codes
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidResourceGroup.NotFound`: The ResourceGroup provided does not exist in our records.
    /// - `InvalidZone.NotFound`: The ZoneId provided does not exist in our records.
    /// - `QuotaExceed.Region`: The maximum region quota of Dedicated Host Cluster has exceeded.
    /// - `QuotaExceed.Zone`: The maximum zone quota of Dedicated Host Cluster has exceeded.
    /// - `InvalidParam.Zone`: The specified zone not match region.
    /// - `InvalidRegionId.NotFound`: The regionId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_dedicated_host_cluster(
        &self,
        req: CreateDedicatedHostCluster,
    ) -> impl std::future::Future<Output = crate::Result<CreateDedicatedHostClusterResponse>> + Send
    {
        self.call(req)
    }

    /// # 修改专有宿主机组的信息
    ///
    /// 修改一台专有宿主机组的部分信息，包括专有宿主机组的名称、描述信息、属性等。
    ///
    /// # Error Codes
    /// - `InvalidDedicatedHostName.Malformed`: The specified parameter DedicatedHostClusterName is not valid.
    /// - `InvalidDescription.Malformed`: The specified parameter Description is not valid.
    /// - `InvalidUser.Unauthorized`: The user is not authorized
    /// - `InvalidDedicatedHostId.NotFound`: The specified DedicatedHostClusterId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_dedicated_host_cluster_attribute(
        &self,
        req: ModifyDedicatedHostClusterAttribute,
    ) -> impl std::future::Future<
        Output = crate::Result<ModifyDedicatedHostClusterAttributeResponse>,
    > + Send {
        self.call(req)
    }

    /// # 查询专有宿主机组的详情
    ///
    /// 查询一个或多个专有宿主机组的详细信息。
    ///
    /// ## 接口说明
    ///
    /// 请求参数的作用类似于一个过滤器，过滤器为逻辑与（AND）关系。如果某一参数为空，则过滤器不起作用。但是参数`DedicatedHostClusterIds`的值如果是一个空JSON数组，即`[]`，则视为该过滤器有效，且返回值为空。
    ///
    /// # Error Codes
    /// - `MissingParamter.RegionId`: The regionId should not be null.
    /// - `InvalidParameter.DedicatedHostClusterIds`: The specified parameter dedicatedHostClusterIds is not valid.
    /// - `InvalidRegion.NotFound`: The specified parameter RegionId is not valid.
    /// - `InvalidZone.NotFound`: The specified parameter ZoneId is not valid.
    /// - `InvalidDedicatedHostIds.Malformed`: The amount of specified dedicatedHostClusterIds exceeds the limit.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_dedicated_host_clusters(
        &self,
        req: DescribeDedicatedHostClusters,
    ) -> impl std::future::Future<Output = crate::Result<DescribeDedicatedHostClustersResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除专有宿主机组
    ///
    /// 删除一个专有宿主机组，操作前请先将该专有宿主机组下的专有宿主机迁移至其他专有宿主机组。
    ///
    /// # Error Codes
    /// - `DedicatedHostExists`: Dedicated Host exists in the dedicated host cluster.
    /// - `IncompleteParamter`: Parameter DedicatedHostClusterId can not be null in this request.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_dedicated_host_cluster(
        &self,
        req: DeleteDedicatedHostCluster,
    ) -> impl std::future::Future<Output = crate::Result<DeleteDedicatedHostClusterResponse>> + Send
    {
        self.call(req)
    }

    /// # 创建一个HPC集群
    ///
    /// 调用CreateHpcCluster创建一个HPC集群。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The input parameter RegionId that is mandatory for processing this request is not supplied.
    /// - `InvalidHpcClusterName.Malformed`: Specified hpc cluster name is not valid.
    /// - `InvalidHpcClusterDescription.Malformed`: The specified parameter Description is not valid.
    /// - `InvalidRegionId.NotFound`: The specified parameter "RegionId" is not valid.
    /// - `Invalid.Parameter`: Invalid parameters
    /// - `InvalidRegionId.NotFound`: The specified parameter "RegionId" is not valid.
    /// - `InternalError`: Failed to create hpc cluster///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn create_hpc_cluster(
        &self,
        req: CreateHpcCluster,
    ) -> impl std::future::Future<Output = crate::Result<CreateHpcClusterResponse>> + Send {
        self.call(req)
    }

    /// # 查询HPC集群
    ///
    /// 调用DescribeHpcClusters查询您可用的HPC集群。请求参数作为筛选器（Filter）使用，筛选关系为逻辑与关系，参数之间无依赖关系。
    ///
    /// # Error Codes
    /// - `InvalidRegionId.NotFound`: The specified parameter "RegionId" is not valid.
    /// - `MissingParameter.HpcClusterId`: The input parameter HpcClusterId that is mandatory for processing this request is not supplied.
    /// - `InvalidHpcClusterIds.ExceedLimit`: The amount of specified specified hpc cluster ids exceeds the limit.
    /// - `InvalidHpcClusterIds.Malformed`: The amount of specified specified hpc cluster ids is invalid.
    /// - `Invalid.Parameter`: Invalid parameters.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_hpc_clusters(
        &self,
        req: DescribeHpcClusters,
    ) -> impl std::future::Future<Output = crate::Result<DescribeHpcClustersResponse>> + Send {
        self.call(req)
    }

    /// # 修改一个HPC集群的描述信息
    ///
    /// 调用ModifyHpcClusterAttribute修改一个HPC集群的描述信息。
    ///
    /// # Error Codes
    /// - `MissingParameter`: The input parameter RegionId that is mandatory for processing this request is not supplied.
    /// - `InvalidHpcClusterName.Malformed`: Specified hpc cluster name is not valid.
    /// - `InvalidHpcClusterDescription.Malformed`: The specified parameter Description is not valid.
    /// - `InvalidRegionId.NotFound`: The specified parameter "RegionId" is not valid.
    /// - `InvalidModifyInfo`: Modify info is invalid, name/description must not null at the same time.
    /// - `HPC_CLUSTER_MODIFY_FAILED`: Modify failed, possibly this hpc cluster does not exist.
    /// - `Invalid.Parameter`: Invalid parameters.
    /// - `HpcClusterNotExists`: The specified hpc cluster does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn modify_hpc_cluster_attribute(
        &self,
        req: ModifyHpcClusterAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyHpcClusterAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 删除一个HPC集群
    ///
    /// 调用DeleteHpcCluster删除一个HPC集群。
    ///
    /// # Error Codes
    /// - `MissingParameter.RegionId`: The input parameter RegionId that is mandatory for processing this request is not supplied.
    /// - `MissingParameter.HpcClusterId`: The input parameter HpcClusterId that is mandatory for processing this request is not supplied.
    /// - `Invalid.Parameter`: Invalid parameters.
    /// - `InvalidRegionId.NotFound`: The specified parameter "RegionId" is not valid.
    /// - `NotExists.HpcCluster`: The specified hpc cluster does not exist.
    /// - `NotEmpty.HpcCluster`: The specified hpc cluster is not empty, still contains instances.
    /// - `InvalidRegionId.NotFound`: The specified parameter "RegionId" is not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn delete_hpc_cluster(
        &self,
        req: DeleteHpcCluster,
    ) -> impl std::future::Future<Output = crate::Result<DeleteHpcClusterResponse>> + Send {
        self.call(req)
    }

    /// # 查询任务列表
    ///
    /// 调用DescribeTasks查询一个或多个异步请求的进度。
    ///
    /// # Error Codes
    /// - `MissingParameter`: An input parameter "RegionId" that is mandatory for processing the request is not supplied.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_tasks(
        &self,
        req: DescribeTasks,
    ) -> impl std::future::Future<Output = crate::Result<DescribeTasksResponse>> + Send {
        self.call(req)
    }

    /// # 查询任务详细信息
    ///
    /// 调用DescribeTaskAttribute查询异步任务的详细信息。目前，可以查询的异步任务有导入镜像（ImportImage）、导出镜像（ExportImage）及变更云盘类型（ModifyDiskSpec）。
    ///
    /// # Error Codes
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `MissingParameter`: An input parameter "RegionId" that is mandatory for processing the request is not supplied.
    /// - `InvalidTaskId.NotFound`: The specified "TaskId" is not found.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn describe_task_attribute(
        &self,
        req: DescribeTaskAttribute,
    ) -> impl std::future::Future<Output = crate::Result<DescribeTaskAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// # 取消任务
    ///
    /// 调用CancelTask取消一件正在运行的任务。目前，您能取消正在运行的导入镜像任务（ImportImage）和导出镜像任务（ExportImage）。
    ///
    /// # Error Codes
    /// - `MissingParameter`: An input parameter "RegionId" that is mandatory for processing the request is not supplied.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidTaskId.NotFound`: The specified "TaskId" is not found.
    /// - `InvalidTaskId.TaskActionNotSupport`: The specified task action  not support.
    /// - `InvalidTaskId.IncorrectTaskStatus`: The specified task status is invalid.
    /// - `InvalidTaskId.NotFound`: The specified "TaskId" is not found.
    /// - `CancelTaskFailed`: The task is failed to cancel, Please contact the administrator.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn cancel_task(
        &self,
        req: CancelTask,
    ) -> impl std::future::Future<Output = crate::Result<CancelTaskResponse>> + Send {
        self.call(req)
    }

    /// 获取用户级别默认属性
    ///
    /// # Error Codes
    /// - `InvalidParameter`: The specified parameters are not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_user_business_behavior(
        &self,
        req: DescribeUserBusinessBehavior,
    ) -> impl std::future::Future<Output = crate::Result<DescribeUserBusinessBehaviorResponse>> + Send
    {
        self.call(req)
    }

    /// 设置用户级别默认属性
    ///
    /// # Error Codes
    /// - `InvalidAction.UserForbidden`: Specified action is not valid.
    /// - `InvalidParams`: The parameters statusKey or statusValue are not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_user_business_behavior(
        &self,
        req: ModifyUserBusinessBehavior,
    ) -> impl std::future::Future<Output = crate::Result<ModifyUserBusinessBehaviorResponse>> + Send
    {
        self.call(req)
    }

    /// 查询账号限制
    ///
    /// # Error Codes
    /// - `InvalidLimitation.NotFound`: The specified Limitation is not valid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_limitation(
        &self,
        req: DescribeLimitation,
    ) -> impl std::future::Future<Output = crate::Result<DescribeLimitationResponse>> + Send {
        self.call(req)
    }

    /// 查询集群
    ///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_clusters(
        &self,
        req: DescribeClusters,
    ) -> impl std::future::Future<Output = crate::Result<DescribeClustersResponse>> + Send {
        self.call(req)
    }

    /// 删除操作弹性网卡的权限
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidOperation.InvalidEniState`: %s
    /// - `NotBelongUser`: %s
    /// - `InvalidOperation.PermissionExisted`: %s
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `InvalidOperation.PermissionNotExisted`: %s
    /// - `InvalidEniPermissionId.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn delete_network_interface_permission(
        &self,
        req: DeleteNetworkInterfacePermission,
    ) -> impl std::future::Future<Output = crate::Result<DeleteNetworkInterfacePermissionResponse>> + Send
    {
        self.call(req)
    }

    /// DeleteBandwidthPackage
    ///
    /// # Error Codes
    /// - `DependencyViolation.ForwardEntry`: The specified BandwidthPackageId has dependent resource.
    /// - `DependencyViolation.SnatEntry`: The specified BandwidthPackageId has dependent resource.
    /// - `InvalidBandwidth.NotExist`: bandwidth package not exist.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidBandwidthPackageId.NotFound`: The specified BandwidthPackageId does not exist in our records.
    /// - `InvalidNatGateway.NotFound`: The specified natGateway does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn delete_bandwidth_package(
        &self,
        req: DeleteBandwidthPackage,
    ) -> impl std::future::Future<Output = crate::Result<DeleteBandwidthPackageResponse>> + Send
    {
        self.call(req)
    }

    /// ModifyBandwidthPackageSpec
    ///
    /// # Error Codes
    /// - `Forbidden.ChargeTypeIsPrepaid`: It's forbidden to change prepaid CBWP's bandwidth by API.  It can be changed on Aliyun web console.
    /// - `MissingParam.Bandwidth`: The parameter Bandwidth is mandatory.
    /// - `IllegalParam.Bandwidth`: Bandwidth is illegal.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidBandwidthPackageId.NotFound`: The specified BandwidthPackageId does not exist in our records.
    /// - `InvalidBandwidth.ValueNotSupported`: The specified value of Bandwidth not supported.
    /// - `BandwidthPackage.FinancialLocked`: The specified BandwidthPackage has been Financail Lock.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_bandwidth_package_spec(
        &self,
        req: ModifyBandwidthPackageSpec,
    ) -> impl std::future::Future<Output = crate::Result<ModifyBandwidthPackageSpecResponse>> + Send
    {
        self.call(req)
    }

    /// DescribeBandwidthPackages
    ///
    /// # Error Codes
    /// - `InvalidAliuid`: User Id is not valid.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_bandwidth_packages(
        &self,
        req: DescribeBandwidthPackages,
    ) -> impl std::future::Future<Output = crate::Result<DescribeBandwidthPackagesResponse>> + Send
    {
        self.call(req)
    }

    /// CreateVSwitch
    ///
    /// # Error Codes
    /// - `OperationFailed.IdempotentTokenProcessing`: Action is processing.
    /// - `InvalidDescription.Malformed`: Invalid description.
    /// - `InvalidVSwitchName.Malformed`: Specified virtual switch name is not valid.
    /// - `InvalidVSwitchDiscription.Malformed`: Specified  virtual switch description is not valid.
    /// - `ResourceNotAvailable`: Resource you requested is not available in this region or zone.
    /// - `InvalidParameter`: Specified CIDR block is not valid in VPC.
    /// - `InvalidCidrBlock.Overlapped`: Specified CIDR block overlapped with other subnets.
    /// - `QuotaExceeded.VSwitch`: Virtual switch quota exceeded.
    /// - `IncorrectRouteEntryStatus`: Some route entry status blocked this operation.
    /// - `IncorrectVSwitchStatus`: Some virtual switch is modifying within the same VPC.
    /// - `InvalidCirdrBlock.MaskLength`: Specified CIDR block is not valid .
    /// - `IncorrectVpcStatus`: Current VPC status does not support this operation.
    /// - `InvalidCidrBlock.Malformed`: Specified CIDR block is not valid.
    /// - `MissingParameter`: Miss mandatory parameter.
    /// - `TaskConflict`: The operation is too frequent, TaskConflict.
    /// - `RouteConflict.AlreadyExist`: Route conflict exists in routing table.
    /// - `OperationFailed.CidrAcross`: Classic link instance cidr must not across.
    /// - `VPC.SWITCH.RULE.QUOTA.NOT.EXISTS`: vSwitch quota rule not exists.
    /// - `CreateVSwitch.IncorrectStatus.cbnStatus`: Current CBN status does not support this operation.
    /// - `OperationFailed.NotifyCenCreate`: Failed to notify cen when create vswitch.
    /// - `Forbidden.VpcNotFound`: Specified VPC can not found.
    /// - `Duplicated.ClientToken`: %s
    /// - `OperationFailed.DistibuteLock`: Distibute lock fail.
    /// - `IllegalParam.CidrBlock`: The param of CidrBlock [%s] is illegal.
    /// - `Invalid.NotExist`: witch mask rule not exists.
    /// - `InvalidStatus.RouteEntry`: RouteEntry status error.
    /// - `InvalidZoneId.NotFound`: Specified zone does not exist.
    /// - `InvalidVpcId.NotFound`: Specified VPC does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn create_v_switch(
        &self,
        req: CreateVSwitch,
    ) -> impl std::future::Future<Output = crate::Result<CreateVSwitchResponse>> + Send {
        self.call(req)
    }

    /// DeleteVSwitch
    ///
    /// # Error Codes
    /// - `IncorrectVSwitchStatus`: vpc subnet status not working.
    /// - `DependencyViolation`: Specified object has dependent resources.
    /// - `IncorrectRouteEntryStatus`: Some route entry status blocked this operation.
    /// - `DependencyViolation.HaVip`: VSwitch cannot be deleted when there are some HaVip dependent with it.
    /// - `MissingParameter`: Miss mandatory parameter.
    /// - `TaskConflict`: The operation is too frequent, TaskConflict.
    /// - `DependencyViolation.RouteTable`: VSwitch cannot be deleted when associated with route table
    /// - `DependencyViolation.Snat`: VSwitch cannot be deleted when has snat routeEntry.
    /// - `DeleteVSwitch.IncorrectStatus.cbnStatus`: Current CBN status does not support this operation.
    /// - `AttrMismatching.NaclAndBindInstance`: The network acl and resource not in same vpc.
    /// - `InvalidResource.NotBinding`: The resource has not been binded.
    /// - `DependencyViolation.SnatEntry`: VSwitch cannot be deleted when snat entry exist.
    /// - `DependencyViolation.NetworkAcl`: VSwitch cannot be deleted when network acl exist.
    /// - `DependencyViolation.EnhancedNatgw`: VSwitch cannot be deleted when enhanced NAT gateway exists.
    /// - `InvalidVSwitchId.NotFound`: VSwitch not exist.
    /// - `Forbidden.RegionNotFound`: Specified instance is not found during access authentication.
    /// - `IncorrectVSwitchId`: Specified vSwtich instance is not found during access authentication.
    /// - `InvalidVSwitchId.NotFound`: VSwitch not exist.
    /// - `IncorrectStatus`: Vswtich status not stable.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn delete_v_switch(
        &self,
        req: DeleteVSwitch,
    ) -> impl std::future::Future<Output = crate::Result<DeleteVSwitchResponse>> + Send {
        self.call(req)
    }

    /// ModifyVSwitchAttribute
    ///
    /// # Error Codes
    /// - `InvalidDescription.Malformed`: Invalid description.
    /// - `InvalidVSwitchName.Malformed`: Specified virtual switch name is not valid.
    /// - `InvalidVSwitchDiscription.Malformed`: Specified virtual switch description is not valid.
    /// - `Forbidden.VRouterNotFound`: specified virtual switch is not found during access authentication.
    /// - `InvalidVSwitchId.NotFound`: The specified virtual switch does not exists.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_v_switch_attribute(
        &self,
        req: ModifyVSwitchAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyVSwitchAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// DescribeVSwitches
    ///
    /// # Error Codes
    /// - `Forbidden.VpcNotFound`: Specified VPC can not found.
    /// - `IellgalParameter.OwnerAccount`: The specified parameter OwnerAccount is not valid.
    /// - `OperationFailed.Endpoint`: The specified RegionId is unavailable for this endpoint.
    /// - `Mismatch.InstanceIdAndRegionId`: The instanceId and regionId are mismatched.
    /// - `InvalidVSwitchId.NotFound`: VSwitch not exist.
    /// - `InvalidVpcIdNumber.NotSupported`: The number of vpcIds exceeds the limit.
    /// - `InvalidVSwitchIdNumber.NotSupported`: The number of vSwitchIds exceeds the limit.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_v_switches(
        &self,
        req: DescribeVSwitches,
    ) -> impl std::future::Future<Output = crate::Result<DescribeVSwitchesResponse>> + Send {
        self.call(req)
    }

    /// CreatePhysicalConnection
    ///
    /// # Error Codes
    /// - `Invalid.Status`: The device or interface status invalid, or has been used..
    /// - `InvalidAccessPointId.NotEnabled`: Invalid access point status.
    /// - `InvalidType.Malformd`: The Type provided was invalid.
    /// - `InvalidPeerLocation.Malformd`: The PeerLocation provided was invalid.
    /// - `InvalidLineOperator.Malformd`: The LineOperator provided was invalid.
    /// - `InvalidPortType.Malformd`: The PortType provided was invalid.
    /// - `InvalidDescription.Malformed`: The specifid ??Description?? is not valid.
    /// - `InvalidRedundantPhysicalConnectionId.NotFound`: The RedundantPhysicalConnectionId  does not found.
    /// - `InvalidName.Malformed`: The specified ??Name?? is not valid.
    /// - `QuotaExceeded.pConnPerAP`: Physical connection count per ap quota exceed.
    /// - `InvalidBandwidth`: invalid physical connection banwidth.
    /// - `InvalidRedundantPhysicalConnection`: redundant physical connection doesn't belong to current user.
    /// - `InvalidRedundantPhysicalConnectionStatus`: invalid redundant physical connection status.
    /// - `InvalidCircuitCode.Malformed`: circuitCode is illegal.
    /// - `QuotaExceeded.freePconnPerAP`: free physical connections count excceeded.
    /// - `InvalidPhysicalConnectionOperator.Malformed`: Specified PhysicalConnection Operator is not valid.
    /// - `InvalidPhysicalConnectionPortType.Malformed`: Specified PhysicalConnection PortType is not valid.
    /// - `InvalidPhysicalConnectionBandwidth.Malformed`: Specified PhysicalConnection Bandwidth is not valid.
    /// - `IllegalParam.ClientToken`: Token verify failed because client token length too long.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidAccessPointId.NotFound`: The AccessPointId provided does not exist in our records.
    /// - `InvalidPortType.NotFound`: There are no resources with the portType.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn create_physical_connection(
        &self,
        req: CreatePhysicalConnection,
    ) -> impl std::future::Future<Output = crate::Result<CreatePhysicalConnectionResponse>> + Send
    {
        self.call(req)
    }

    /// DeletePhysicalConnection
    ///
    /// # Error Codes
    /// - `Forbidden.NotAllowedInState`: The request does not allow in this state.
    /// - `InvalidPhysicalConnectionId.NotMatched`: instance id not matched.
    /// - `Forbidden.VBRExists`: physical connection owner's vbr still exists.
    /// - `Forbidden.AssociateToVBR`: The physical connection still associate to VBR.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidPhysicalConnectionId.NotFound`: The PhysicalConnectionId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn delete_physical_connection(
        &self,
        req: DeletePhysicalConnection,
    ) -> impl std::future::Future<Output = crate::Result<DeletePhysicalConnectionResponse>> + Send
    {
        self.call(req)
    }

    /// ModifyPhysicalConnectionAttribute
    ///
    /// # Error Codes
    /// - `InvalidLineOperator.Malformd`: The LineOperator provided was invalid.
    /// - `InvalidPeerLocation.Malformd`: The PeerLocation provided was invalid.
    /// - `InvalidPortType.Malformd`: The PortType provided was invalid.
    /// - `InvalidDescription.Malformed`: The specifid ??Description?? is not valid.
    /// - `InvalidName.Malformed`: The specified ??Name?? is not valid.
    /// - `InvalidStatus`: invalid physical connection status.
    /// - `InvalidBandwidth`: invalid physical connection banwidth.
    /// - `InvalidRedundantPhysicalConnection`: redundant physical connection doesn't belong to current user.
    /// - `InvalidRedundantPhysicalConnectionStatus`: invalid redundant physical connection status.
    /// - `InvalidCircuitCode.Malformed`: circuitCode is illegal.
    /// - `InvalidPhysicalConnectionBandwidth.Malformed`: Specified PhysicalConnection Bandwidth is not valid.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidPhysicalConnectionId.NotFound`: The PhysicalConnectionId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_physical_connection_attribute(
        &self,
        req: ModifyPhysicalConnectionAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyPhysicalConnectionAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// EnablePhysicalConnection
    ///
    /// # Error Codes
    /// - `Forbidden.NotAllowedInState`: The request does not allow in this state.
    /// - `INSTANCE.STATUS.NOT.ALLOW`: Instance status not allow
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidPhysicalConnectionId.NotFound`: The PhysicalConnectionId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn enable_physical_connection(
        &self,
        req: EnablePhysicalConnection,
    ) -> impl std::future::Future<Output = crate::Result<EnablePhysicalConnectionResponse>> + Send
    {
        self.call(req)
    }

    /// DescribePhysicalConnections
    ///
    /// # Error Codes
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidFilterKey.ValueNotSupported`: Specified filter key is not supported: Filter.X.key///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_physical_connections(
        &self,
        req: DescribePhysicalConnections,
    ) -> impl std::future::Future<Output = crate::Result<DescribePhysicalConnectionsResponse>> + Send
    {
        self.call(req)
    }

    /// CancelPhysicalConnection
    ///
    /// # Error Codes
    /// - `Forbidden.NotAllowedInState`: The request does not allow in this state.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidPhysicalConnectionId.NotFound`: The PhysicalConnectionId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn cancel_physical_connection(
        &self,
        req: CancelPhysicalConnection,
    ) -> impl std::future::Future<Output = crate::Result<CancelPhysicalConnectionResponse>> + Send
    {
        self.call(req)
    }

    /// TerminatePhysicalConnection
    ///
    /// # Error Codes
    /// - `Forbidden.NotAllowedInState`: The request does not allow in this state.
    /// - `Forbidden.VbrAttached`: Cannot terminate physical connection when virtual border routers are still attached.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidPhysicalConnectionId.NotFound`: The PhysicalConnectionId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn terminate_physical_connection(
        &self,
        req: TerminatePhysicalConnection,
    ) -> impl std::future::Future<Output = crate::Result<TerminatePhysicalConnectionResponse>> + Send
    {
        self.call(req)
    }

    /// CreateVpc
    ///
    /// # Error Codes
    /// - `TOKEN_PROCESSING`: Action is processing.
    /// - `InvokeError`: instance quota rule invoke error.
    /// - `InvalidParameter`: Specified CIDR block is not valid
    /// - `ResourceNotAvailable`: Resource you requested is not available in this region or zone.
    /// - `InvalidVpcName.Malformed`: Specified VPC name is not valid.
    /// - `InvalidVpcDiscription.Malformed`: Specified VPC description is not valid.
    /// - `QuotaExceeded.Vpc`: VPC quota exceeded.
    /// - `ResourceNotAvailable.Vpc`: Resource you requested is not available in this region or zone.
    /// - `InvalidUserCidr.Quota`: Specified  UserCidr number is greater than 3.
    /// - `InvalidUserCidr.Malformed`: Specified  UserCidr  overlapping in of 100.64.0.0/10.
    /// - `System.ServiceBusy`: System is busy, please try later.
    /// - `IllegalParam.UserCidr`: UserCidr is not a valid or strict address.
    /// - `OperationUnsupported.ResourceGroupId`: ResourceGroup is not supported in this region.
    /// - `IllegalParam.EnableIpv6`: %s
    /// - `Forbbiden`: User not authorized to operate on the specified resource.
    /// - `InvalidRegionId.NotFound`: Specified value of "regionId" is not supported.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn create_vpc(
        &self,
        req: CreateVpc,
    ) -> impl std::future::Future<Output = crate::Result<CreateVpcResponse>> + Send {
        self.call(req)
    }

    /// 删除VPC
    ///
    /// # Error Codes
    /// - `DependencyViolation.RouteTable`: VPC cannot be deleted when custom route table exists.
    /// - `IncorrectVpcStatus`: Current VPC status does not support this operation.
    /// - `DependencyViolation.RouteEntry`: Specified object has dependent resources
    /// - `DependencyViolation.Instance`: Specified object has dependent resources
    /// - `DependencyViolation.VSwitch`: Specified object has dependent resources
    /// - `DependencyViolation.SecurityGroup`: Specified object has dependent resources SecurityGroup.
    /// - `DependencyViolation.RouteInterface`: Specified object has dependent route interface .
    /// - `DependencyViolation.Tunnel`: Specified object has dependent tunnel.
    /// - `DependencyViolation.NatGateway`: Specified object has dependent resources NatGateway.
    /// - `DependencyViolation.RouterInterface`: Specified object has dependent resources RouterInterface.
    /// - `Forbidden.VpcNotFound`: Specified VPC can not found.
    /// - `Forbbiden`: Active custom route in vpc.
    /// - `TaskConflict`: The eip operate too frequent, TaskConflict.
    /// - `InvalidAction`: The VPC has been connected to the classic network ECS. Please cancel the connection before proceeding.
    /// - `DependencyViolation.Ipv6Gateway`: %s
    /// - `IncorrectStatus.cbnStatus`: Current CBN status does not support this operation.
    /// - `DependencyViolation.CloudServiceResource`: %s
    /// - `DependencyViolation.ClassicLinkInstance`: Specified object has active classicLink instance.
    /// - `IllegalParam.RegionId`: The specified RegionId is illegal.
    /// - `DependencyViolation.NetworkAcl`: Specified object has dependent resources network acl.
    /// - `InvalidRegionInstance`: The specified InstanceId does not exist in given region.
    /// - `DependencyViolation.Ipv4Gateway`: The VPC cannot be deleted when it has ipv4Gateway.
    /// - `OperationDenied.VpcPeerExists`: The operation is not allowed because the VpcPeer exists.
    /// - `DependencyViolation.GatewayRouteTable`: Specified object has dependent resources gatewayRouteTable.
    /// - `DependencyViolation.DhcpOptionsSet`: The VPC cannot be deleted when it is associated with dhcpOptionsSet.
    /// - `InternalError`: The request processing has failed due to some unknown error
    /// - `DependencyViolation.RouterInterface`: Specified object has dependent resources RouterInterface.
    /// - `OperationDenied`: The operation is not supported in this status.
    /// - `InvalidVpcId.NotFound`: Specified VPC does not exist.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn delete_vpc(
        &self,
        req: DeleteVpc,
    ) -> impl std::future::Future<Output = crate::Result<DeleteVpcResponse>> + Send {
        self.call(req)
    }

    /// 查询VPC
    ///
    /// # Error Codes
    /// - `InvalidAliuid`: User Id is not valid.
    /// - `InvalidResourceGroupId.NotFound`: The Specified ResourceGroupId not exists.
    /// - `OperationUnsupported.ResourceGroupId`: %s
    /// - `InvalidVpcIdNumber.NotSupported`: The number of vpcIds exceeds the limit.
    /// - `InvalidTagKey`: The tag keys are not valid.
    /// - `InvalidTagValue`: The tag values are not valid.
    /// - `IellgalParameter.OwnerAccount`: The specified parameter OwnerAccount is not valid.
    /// - `OperationFailed.Endpoint`: Operation failed because the RegionId is unavailable in this endpoint.
    /// - `InvalidRegionId.NotFound`: The specified RegionId is not found.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_vpcs(
        &self,
        req: DescribeVpcs,
    ) -> impl std::future::Future<Output = crate::Result<DescribeVpcsResponse>> + Send {
        self.call(req)
    }

    /// ModifyVpcAttribute
    ///
    /// # Error Codes
    /// - `InvalidDescription.Malformed`: description not valid..
    /// - `InvalidVpcName.Malformed`: Specified VPC name is not valid.
    /// - `InvalidVpcDiscription.Malformed`: Specified VPC description is not valid.
    /// - `InvalidParameter`: Specified  UserCidr  invalid  format.
    /// - `InvalidUserCidr.Quota`: Specified  UserCidr number is greater than 3.
    /// - `InvalidUserCidr.Malformed`: Specified  UserCidr  overlapping in of 100.64.0.0/10.
    /// - `InvalidRegion.Malformed`: Specified RegionNo is not invaild.
    /// - `IllegalCidrBlock`: Some subnet cidrBlock is not in the cidrBlock.
    /// - `InvalidCidrBlock.Malformed`: Specified CIDR block is not valid.
    /// - `ParamExclusive.EnableIpv6AndCidrBlock`: EnableIpv6 and CidrBlock is mutually exclusive.
    /// - `OperationFailed.ClassicLinkEnabled`: Operation failed because classicLink is enabled.
    /// - `InvalidVpcId.NotFound`: Specified VPC does not exist.
    /// - `InvalidVpcId.NotFound`: Specified VPC does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_vpc_attribute(
        &self,
        req: ModifyVpcAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyVpcAttributeResponse>> + Send {
        self.call(req)
    }

    /// RemoveBandwidthPackageIps
    ///
    /// # Error Codes
    /// - `InvalidIpCount.ValueNotSupported`: Can not remove all ips of the bandwidthPackage.
    /// - `InvalidRemovedIpAddresses.NotFound`: Some of remove ip is not natPublicIp.
    /// - `DependencyViolation.ForwardEntry`: The ip has been used by ForwardEntry.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidBandwidthPackageId.NotFound`: The specified BandwidthPackageId does not exist in our records.
    /// - `invalidRemovedIpAddresses.NotFound`: Some of the specified value of RemovedIpAddress not found in specified BandwidthPackage.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn remove_bandwidth_package_ips(
        &self,
        req: RemoveBandwidthPackageIps,
    ) -> impl std::future::Future<Output = crate::Result<RemoveBandwidthPackageIpsResponse>> + Send
    {
        self.call(req)
    }

    /// CreateHaVip
    ///
    /// # Error Codes
    /// - `InvalidDescription.Malformed`: The specified Description  is wrongly formed.
    /// - `InvalidIPAddress.OutOfRange`: The specified IPAddress is out of VSwitch CIDR.
    /// - `InvalidIPAddress.NotAvailable`: The specified IPAddress is not available because it is a system reserved IPAddress.
    /// - `InvalidIPAddress.AlreadyUsed`: The specified IPAddress is already used by other resource.
    /// - `InvalidIPAddress.Malformed`: The specified IPAddress is not a valid or strict address.
    /// - `InvalidVSwitch.NotFound`: The specified VSwitch does not exist in the specified region.
    /// - `InvalidPrivateIp.NotFound`: The specified private ip is not exist in vswitch.
    /// - `Forbidden.HaVip`: No permissions to perform operations on HAVIPs. Please apply for privilege--vpc_privilege_allow_buy_havip_instance.
    /// - `CountLimitExceed.HaVipInVpc`: Specified Vpc exceeds the quota of max number of ha-vip count.
    /// - `QuotaExceeded.HaVip`: Living HaVip quota exceeded.
    /// - `InvalidRegionId.NotFound`: Specified value of "regionId" is not supported.
    /// - `InvalidVSwitchId.NotFound`: The specified VSwitch does not exist in the specified region.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn create_ha_vip(
        &self,
        req: CreateHaVip,
    ) -> impl std::future::Future<Output = crate::Result<CreateHaVipResponse>> + Send {
        self.call(req)
    }

    /// DeleteHaVip
    ///
    /// # Error Codes
    /// - `IncorrectStatus`: HaVip can be deleted only when it is status is Available.
    /// - `DependencyViolation.HaVipReferedByRouteEntry`: HaVip cannot be deleted when it is refered by a route table entry as next hop.
    /// - `DependencyViolation.HaVipAssociatedWithEIP`: HaVip cannot be deleted when it is associated with  EIP.
    /// - `IncorrectHaVipStatus`: HaVip?s status is invalid.
    /// - `Forbidden.HaVip`: No permissions to perform operations on HAVIPs. Please apply for privilege--vpc_privilege_allow_buy_havip_instance.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidHaVipId.NotFound`: The specified HaVip does not exist in the specified region.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn delete_ha_vip(
        &self,
        req: DeleteHaVip,
    ) -> impl std::future::Future<Output = crate::Result<DeleteHaVipResponse>> + Send {
        self.call(req)
    }

    /// AssociateHaVip
    ///
    /// # Error Codes
    /// - `InvalidVip.Status`: vip invalid status
    /// - `IncorrectHaVipStatus`: HaVip can be operated by this action only when it's status is Available or InUse.
    /// - `IncorrectInstanceStatus`: ECS instance can be operated by this action only when it??s status is Running or Stopped.
    /// - `CountLimitExceed.HaVipOnInstance`: The amount of HaVip associated with the specified Instance reach its limits.
    /// - `CountLimitExceeded.HaVipOnECSInstance`: The amount of Instance associated with the specified HaVip reach its limits.
    /// - `OperationFailed.DistibuteLock`: Distibute lock fail.
    /// - `Forbidden.HaVip`: No permissions to perform operations on HAVIPs. Please apply for privilege--vpc_privilege_allow_buy_havip_instance.
    /// - `OperationUnsupported.BindMultipleType`: You cannot bind HaVip to multiple instance types.
    /// - `InvalidHaVip.Exist`: haVip already bind exist.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidHaVipId.NotFound`: The specified HaVip does not exist in the specified region.
    /// - `InvalidInstanceId.NotFound`: The specified Instance does not exist in the specified region.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn associate_ha_vip(
        &self,
        req: AssociateHaVip,
    ) -> impl std::future::Future<Output = crate::Result<AssociateHaVipResponse>> + Send {
        self.call(req)
    }

    /// ModifyHaVipAttribute
    ///
    /// # Error Codes
    /// - `IncorrectStatus`: HaVip can be deleted only when it's status is Available or InUse.
    /// - `InvalidDescription.Malformed`: The specified Description  is wrongly formed.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidHaVipId.NotFound`: The specified HaVip does not exist in the specified region.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_ha_vip_attribute(
        &self,
        req: ModifyHaVipAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyHaVipAttributeResponse>> + Send {
        self.call(req)
    }

    /// DescribeHaVips
    ///
    /// # Error Codes
    /// - `Forbidden.HaVip`: No permissions to perform operations on HAVIPs. Please apply for privilege--vpc_privilege_allow_buy_havip_instance.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidFilterKey.ValueNotSupported`: Specified filter key is not supported: Filter.X.key///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_ha_vips(
        &self,
        req: DescribeHaVips,
    ) -> impl std::future::Future<Output = crate::Result<DescribeHaVipsResponse>> + Send {
        self.call(req)
    }

    /// UnassociateHaVip
    ///
    /// # Error Codes
    /// - `IncorrectHaVipStatus`: HaVip can be operated by this action only when it's status is InUse.
    /// - `IncorrectInstanceStatus`: ECS instance can be operated by this action only when it's status is Running or Stopped.
    /// - `ResourceNotAssociated`: The HaVip and ECS instance are not associated.
    /// - `Forbidden.UnassociateMaster`: Unassociating a master instance is not allowed unless the parameter Force is True.
    /// - `OperationFailed.DistibuteLock`: Distibute lock fail.
    /// - `Forbidden.HaVip`: No permissions to perform operations on HAVIPs. Please apply for privilege--vpc_privilege_allow_buy_havip_instance.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidHaVipId.NotFound`: The specified HaVip does not exist in the specified region.
    /// - `InvalidInstanceId.NotFound`: The specified Instance does not exist in the specified region.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn unassociate_ha_vip(
        &self,
        req: UnassociateHaVip,
    ) -> impl std::future::Future<Output = crate::Result<UnassociateHaVipResponse>> + Send {
        self.call(req)
    }

    /// CreateVirtualBorderRouter
    ///
    /// # Error Codes
    /// - `InvalidPhysicalConnectionId.NotFound`: The specified PhysicalConnectionId is not found.
    /// - `InvalidVlanId.Used`: The specified VlanId has been used.
    /// - `MissingParameter`: The input parameter 'PhysicalConnectionId' that is mandatory for processing this request is not supplied.
    /// - `InvalidPhysicalConnectionId.NotEnabled`: The specified PhysicalConnectionId is not in Enabled state.
    /// - `InvalidVlanId.Malformed`: The specified VlanId is not valid.
    /// - `InvalidCircuitCode.Malformed`: The specified CircuitCode is not valid.
    /// - `InvalidLocalGatewayIp.Malformed`: The specified LocalGatewayIp is not valid.
    /// - `InvalidPeeringSubnetMask.Malformed`: The specified PeeringSubnetMask is not valid.
    /// - `InvalidName.Malformed`: The specified Name is not valid.
    /// - `InvalidDescription.Malformed`: The specifid Description is not valid.
    /// - `QuotaExceeded.vbrPerpConn`: Virtual boarder router per PhysicalConnection quota exceed.
    /// - `QuotaExceeded.freevbr`: Free virtual boarder router quota exceed.
    /// - `InvalidIp.NotSameSubnet`: Local gateway ip and peer gateway ip are not in the same subnet.
    /// - `TaskConflict`: The operation is too frequent, please wait a moment and try again.
    /// - `QuotaExceeded.CrossUserVBRPerUser`: Cross virtual boarder router per user quota exceed.
    /// - `OperationFailed.VlanIdInUse`: Operation failed because vlanId is in use.
    /// - `Forbidden.LocalGatewayIpNotAllowedByCaller`: The caller is not allowed to specify the LocalGatewayIp parameter.
    /// - `Forbidden.PeerGatewayIpNotAllowedByCaller`: The caller is not allowed to specify the PeerGatewayIp  parameter.
    /// - `Forbidden.PeeringSubnetMaskNotAllowedByCaller`: The caller is not allowed to specify the PeeringSubnetMask parameter.
    /// - `Forbidden.NameNotAllowedByCaller`: The caller is not allowed to specify the Name parameter.
    /// - `Forbidden.DescriptionNotAllowedByCaller`: The caller is not allowed to specify the Description parameter.
    /// - `InvalidRegionId.NotFound`: The specified RegionId is not found.
    /// - `InvalidVbrOwnerId.NotFound`: The specified VbrOwnerId is not valid.
    /// - `OperationFailed.AccessDeviceDisabled`: Access device is disabled and can not create vbr.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn create_virtual_border_router(
        &self,
        req: CreateVirtualBorderRouter,
    ) -> impl std::future::Future<Output = crate::Result<CreateVirtualBorderRouterResponse>> + Send
    {
        self.call(req)
    }

    /// DeleteVirtualBorderRouter
    ///
    /// # Error Codes
    /// - `InvalidOperation.RouterInterfaceNotDeleted`: The specified VirutalBorderRouter still has routerInterface.
    /// - `InvalidOperation.OperationNotAllowedInState`: The specified VirutalBorderRouter is in invalid state.
    /// - `InvalidStatus.NotAllowed`: Invalid virtual border router status.
    /// - `DependencyViolation.RouterInterfaceReferedByRouteEntry`: The specified VirutalBorderRouter is refered by routeEntry.
    /// - `DependencyViolation.BgpGroup`: bgp group exists, cannot delete vbr.
    /// - `DependencyViolation.Nqa`: nqa exists, cannot delete vbr.
    /// - `DependencyViolation.BgpNetwork`: bgp network exists, cannot delete vbr.
    /// - `Forbidden.OperationNotAllowedByUser`: The caller is not allowed to delete the specified VirtualBorderRouter.
    /// - `Forbidden.MultiVlanRi`: Multiple vlan router interfaces are found.
    /// - `Forbidden.NoRiFound`: No vlan router interfaces are found.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidVbrId.NotFound`: The specified VirutalBorderRouter does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn delete_virtual_border_router(
        &self,
        req: DeleteVirtualBorderRouter,
    ) -> impl std::future::Future<Output = crate::Result<DeleteVirtualBorderRouterResponse>> + Send
    {
        self.call(req)
    }

    /// ModifyVirtualBorderRouterAttribute
    ///
    /// # Error Codes
    /// - `InvalidVbrId.NotFound`: The specified VirutalBorderRouter is not found.
    /// - `InvalidVlanId.Used`: The specified VlanId has been used.
    /// - `InvalidCircuitCode.Malformed`: The specified CircuitCode is not valid.
    /// - `InvalidVlanId.Malformed`: The specified VlanId is not valid.
    /// - `InvalidIp.Malformed`: The specified ip address is not valid.
    /// - `InvalidPeeringSubnetMask.Malformed`: The specified PeeringSubnetMask is not valid.
    /// - `InvalidName.Malformed`: The specified Name is not valid.
    /// - `InvalidDescription.Malformed`: The specifid Description is not valid.
    /// - `MissingParameter`: LocalGatewayIp, peerGatewayIp and peeringSubnetMask must not be null.
    /// - `InvalidIp.NotSameSubnet`: Local gateway ip and peer gateway ip are not in the same subnet.
    /// - `InvalidParameter`: %s
    /// - `OperationFailed.VlanIdInUse`: Operation failed because vlanId is in use.
    /// - `Forbidden.CircuitCodeNotAllowedByCaller`: The caller is not allowed to modify.
    /// - `Forbidden.LocalGatewayIpNotAllowedByCaller`: The caller is not allowed to specify the LocalGatewayIp parameter.
    /// - `Forbidden.PeerGatewayIpNotAllowedByCaller`: The caller is not allowed to specify the PeerGatewayIp  parameter.
    /// - `Forbidden.PeeringSubnetMaskNotAllowedByCaller`: The caller is not allowed to specify the PeeringSubnetMask parameter.
    /// - `Forbidden.VlanIdNotAllowedByCaller`: The caller is not allowed to specify the VlanId.
    /// - `Forbidden.NameNotAllowedByCaller`: The caller is not allowed to specify the Name parameter.
    /// - `Forbidden.DescriptionNotAllowedByCaller`: The caller is not allowed to specify the Description parameter.
    /// - `InvalidRegionId.NotFound`: The specified RegionId is not found.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_virtual_border_router_attribute(
        &self,
        req: ModifyVirtualBorderRouterAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyVirtualBorderRouterAttributeResponse>>
    + Send {
        self.call(req)
    }

    /// RecoverVirtualBorderRouter
    ///
    /// # Error Codes
    /// - `InvalidOperation.OperationNotAllowedInState`: The specified VirutalBorderRouter is in invalid state
    /// - `OperationFailed.VlanIdAlreadyInUse`: The specifed vlanId has been used.
    /// - `Forbidden.OperationNotAllowedByUser`: The caller is not allowed to recover the specified VirtualBorderRouter.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidVbrId.NotFound`: The specified VirutalBorderRouter is not found.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn recover_virtual_border_router(
        &self,
        req: RecoverVirtualBorderRouter,
    ) -> impl std::future::Future<Output = crate::Result<RecoverVirtualBorderRouterResponse>> + Send
    {
        self.call(req)
    }

    /// TerminateVirtualBorderRouter
    ///
    /// # Error Codes
    /// - `InvalidOperation.OperationNotAllowedInState`: The specified VirutalBorderRouter is in invalid state.
    /// - `Forbidden.OperationNotAllowedByUser`: The caller is not allowed to terminate the specified VirtualBorderRouter.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidVbrId.NotFound`: The specified VirutalBorderRouter is not found.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn terminate_virtual_border_router(
        &self,
        req: TerminateVirtualBorderRouter,
    ) -> impl std::future::Future<Output = crate::Result<TerminateVirtualBorderRouterResponse>> + Send
    {
        self.call(req)
    }

    /// DescribeVirtualBorderRouters
    ///
    /// # Error Codes
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidFilterKey.ValueNotSupported`: Specified filter key is not supported: Filter.X.key///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_virtual_border_routers(
        &self,
        req: DescribeVirtualBorderRouters,
    ) -> impl std::future::Future<Output = crate::Result<DescribeVirtualBorderRoutersResponse>> + Send
    {
        self.call(req)
    }

    /// DescribeVirtualBorderRoutersForPhysicalConnection
    ///
    /// # Error Codes
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidPhysicalConnectionId.NotFound`: The specified PhysicalConnectionId does not belong to user.
    /// - `IllegalParam.AliUid`: Specified value of aliuid invalid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_virtual_border_routers_for_physical_connection(
        &self,
        req: DescribeVirtualBorderRoutersForPhysicalConnection,
    ) -> impl std::future::Future<
        Output = crate::Result<DescribeVirtualBorderRoutersForPhysicalConnectionResponse>,
    > + Send {
        self.call(req)
    }

    /// CreateRouterInterface
    ///
    /// # Error Codes
    /// - `InvalidPrice.NotFound`: Pricing plan result not found.
    /// - `InvalidAliuid`: Invalid Aliuid.
    /// - `InvalidBandwidth.NotEnough`: bandwdith not enough.
    /// - `InvalidRole.ValueNotSupported`: The specified Role is not valid.
    /// - `InvalidSpec.ValudNotSupported`: The specified Spec is not supported.
    /// - `InvalidRouterType.ValueNotSupported`: The specified RouterType is not valid.
    /// - `InvalidOppositeRouterType.ValueNotSupported`: The specified OppositeRouterType is not valid.
    /// - `ParameterMismatch.Role-Spec`: The specified Spec and Role mismatch.
    /// - `InvalidName.Malformed`: The specified "Name" is not valid.
    /// - `InvalidDescription.Malformed`: The specifid "Description" is not valid.
    /// - `Forbidden.BillsOutstanding`: You cannot create more RouterInterface because you have bills outstanding.
    /// - `QuotaExceed.RouterInterface`: Living RouterInterface quota exceeded.
    /// - `LimitationExceed.InterfaceNumberOnRouter`: Total number of RouterInterfaces on a Router exceeded.
    /// - `InvalidParam.NotFound`: Parameter must not be null,uid, bid,regionNo, remoteRegionNo or routerId
    /// - `InvalidAccessPoint.NotMatch`: The accessPoint id is not matched
    /// - `InvalidAccessPoint.NotExist`: The accessPoint not exit
    /// - `ForbiddenAction`: The user does not supported this action.
    /// - `Forbidden.AcceptRoleNotSupportPrePay`: Acception side ri not support chargetype for prepaid.
    /// - `IllegalParam.HealthcheckIp`: Healthcheck ip cannot equal with instance ip.
    /// - `OperationFailed.HcForInvalidRiType`: Healthchecksourceip and healthchecktargetip is only valid for vr ri that is connected to vbr.
    /// - `OperationFailed.SyncOrderToSub`: SyncOrderToSub error.
    /// - `IllegalParam.CrossBorderBandwidth`: CrossBorder bandwidth error.
    /// - `IllegalParam.VRouterType`: The VRouterType is not supported.
    /// - `IllegalParam.Spec`: The spec is illegal.
    /// - `Forbidden.CrossBorder`: User not authorized to create cross border routerInterface.
    /// - `InvalidRouterId.NotFound`: Param is not valid,this user does not have this router or aliuid bid regionNo and routerId must have something wrong.
    /// - `INVAID_VBR_STATUS`: VBR status must be active
    /// - `InvalidRouterInterfaceSpec.Malformed`: Specified RouterInterface spec is not valid.
    /// - `InvalidCommodity.NotFound`: Commodity is not exist.
    /// - `InvalidRouterInterfaceChargeType.Malformed`: Specified RouterInterface ChargeType is not valid.
    /// - `IllegalParam.RegionId`: The specified regionId is illegal.
    /// - `PAY.MAYI_WITHHOLDING_AGREEMENT_ILLEGAL`: User withhoding argeement is illegal.
    /// - `InvalidRegionId.NotFound`: The regionId provided does not exist in our records.
    /// - `InvalidOppositeRegionId.NotFound`: The oppositeRegionId provided does not exist in our records.
    /// - `InvalidRouterId.NotFound`: The specified RouterId does not exist in our recored.
    /// - `Forbidden.NotInRouterInterfaceCreateWhitelist`: Not in router interface create whitelist.
    /// - `RI_CREATE_ONE_LIMIT_BY_SYNC`: Create ri only one limit by sync.
    /// - `InvalidDescription.Malformed`: The specifid "Description" is not valid.
    /// - `InvalidName.Malformed`: The specified "Name" is not valid.
    /// - `InvalidAccessPoint.ValueNotAllowed`: The non-vbr router interface cannot have access point configured.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn create_router_interface(
        &self,
        req: CreateRouterInterface,
    ) -> impl std::future::Future<Output = crate::Result<CreateRouterInterfaceResponse>> + Send
    {
        self.call(req)
    }

    /// DeleteRouterInterface
    ///
    /// # Error Codes
    /// - `IncorrectStatus`: This openeration would be allowed only when status of this RouterInterface is Idle/Inactive.
    /// - `DependencyViolation.RouterInterfaceReferedByRouteEntry`: RouterInterface cannot be deleted when it is refered by a route table entry as next hop.
    /// - `IllegalParam.InstanceOwner`: The router instance owener error.
    /// - `InvalidRegionId.NotFound`:  
    /// - `InvalidInstanceId.NotFound`: The InstanceId provided does not exist in our records.
    /// - `InvalidRouterInterfaceChargeType.Malformed`: The prepaid routerinterface can not delete.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn delete_router_interface(
        &self,
        req: DeleteRouterInterface,
    ) -> impl std::future::Future<Output = crate::Result<DeleteRouterInterfaceResponse>> + Send
    {
        self.call(req)
    }

    /// ActivateRouterInterface
    ///
    /// # Error Codes
    /// - `IncorrectStatus`: RouterInterface can be operated by this action only when it's status is Inactive.
    /// - `Forbidden.FinancialLocked`: This RouterInterface is financiel locked because of bills outstanding.
    /// - `Forbbiden`: The Router instance owener error
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidRouterInterfaceId.NotFound`: The specified RouterInterfaceId does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn activate_router_interface(
        &self,
        req: ActivateRouterInterface,
    ) -> impl std::future::Future<Output = crate::Result<ActivateRouterInterfaceResponse>> + Send
    {
        self.call(req)
    }

    /// DeactivateRouterInterface
    ///
    /// # Error Codes
    /// - `IncorrectStatus`: RouterInterface can be operated by this action only when it's status is Active.
    /// - `Forbidden.FinancialLocked`: This RouterInterface is financiel locked because of bills outstanding.
    /// - `Forbbiden.InvaildOwner`: The RouterInterface owener error
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidRouterInterfaceId.NotFound`: The specified RouterInterfaceId does not exist in our record.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn deactivate_router_interface(
        &self,
        req: DeactivateRouterInterface,
    ) -> impl std::future::Future<Output = crate::Result<DeactivateRouterInterfaceResponse>> + Send
    {
        self.call(req)
    }

    /// ModifyRouterInterfaceAttribute
    ///
    /// # Error Codes
    /// - `IncorrectStatus`: RouterInterface can be operated by this action only when the status is Active,idle or inactive.
    /// - `Forbidden.FinancialLocked`: This RouterInterface is financiel locked because of bills outstanding.
    /// - `InvalidName.Malformd`: The attribute name is illeagl.
    /// - `InvalidOppositeRouterType.ValueNotSupported`: The specified OppositeRouterType is not valid.
    /// - `InvalidDescription.Malformed`: The Description is illeagl.
    /// - `Forbbiden`: The Router instance owener error
    /// - `LinkRole.NotSupport`: This linkrole is not supported
    /// - `Forbbiden.ModifyIdAndType`: Opposite is VBR, cannot modify the ID and type
    /// - `InvalidParam.ModifyRouterInterface`: Modify routerinterface param invalid
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidRouterInterfaceId.NotFound`: The specified RouterInterfaceId does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_router_interface_attribute(
        &self,
        req: ModifyRouterInterfaceAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyRouterInterfaceAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// ModifyRouterInterfaceSpec
    ///
    /// # Error Codes
    /// - `InvalidSpec.ValudNotSupported`: The specified Spec is not supported.
    /// - `Forbidden.FinancialLocked`: RouterInterface can not be operated by this action when it??s FinancialLocked.
    /// - `InvalidParam.NotFound`: Parameter must not be null,uid, bid,regionNo, remoteRegionNo or routerId
    /// - `InvalidOppositeRegionId.NotFound`: The OppositeRegionId provided does not exist in our records.
    /// - `InvalidInstanceOwner.Error`: The router instance owener error.
    /// - `InvalidInstance.StatusError`: The router instance owener error.
    /// - `InvalidOpposite.NotFound`: The opposite not exit.
    /// - `InvalidRouterInterfaceSpec.Malformed`: Specified RouterInterface spec is not valid.
    /// - `IllegalParam.chargeType`: RouterInterface chargeType different.
    /// - `InvalidRouterInterfaceId.NotFound`: The specified RouterInterfaceId does not exist in our record.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_router_interface_spec(
        &self,
        req: ModifyRouterInterfaceSpec,
    ) -> impl std::future::Future<Output = crate::Result<ModifyRouterInterfaceSpecResponse>> + Send
    {
        self.call(req)
    }

    /// ModifyVRouterAttribute
    ///
    /// # Error Codes
    /// - `InvalidVRouterName.Malformed`: Specified virtual router name is not valid.
    /// - `InvalidVRouterDiscription.Malformed`: Specified virtual router description is not valid.
    /// - `MissingParameter`: Miss mandatory parameter.
    /// - `InvalidDescription.Malformed`: Invalid description.
    /// - `Forbidden.VRouterNotFound`: Specified virtual router is not found during access authentication.
    /// - `InvalidVRouterId.NotFound`: Specified virtual router does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_v_router_attribute(
        &self,
        req: ModifyVRouterAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyVRouterAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// DescribeRouterInterfaces
    ///
    /// # Error Codes
    /// - `InvalidParam.NotNull`: The parameter must not be null.
    /// - `IllegalParam.AliUid`: Specified value of aliuid invalid.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidFilterKey.ValueNotSupported`: Specified filter key is not supported: Filter.X.key
    /// - `InvalidOppositeRegionId.NotFound`: The oppositeRegionId provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_router_interfaces(
        &self,
        req: DescribeRouterInterfaces,
    ) -> impl std::future::Future<Output = crate::Result<DescribeRouterInterfacesResponse>> + Send
    {
        self.call(req)
    }

    /// UnassociateEipAddress
    ///
    /// # Error Codes
    /// - `IncorrectEipStatus`: Current elastic IP status does not support this operation.
    /// - `InvalidInstanceId.NotFound`: Specified instance does not exist.
    /// - `IncorrectInstanceStatus`: The current status of instance does not support this operation.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified value of InstanceType is not supported.
    /// - `IncorrectHaVipStatus`: This operation is denied because satus of the specified HaVip is neither Available nor InUse.
    /// - `OperationDenied`: Eip of default vpc not allow this operation
    /// - `InvalidParameter`: The specified parameter is not valid.
    /// - `Forbbiden`: The eip instance owener error
    /// - `TaskConflict`: The eip operate too frequent, TaskConflict.
    /// - `InvalidBindingStatus`: The eip binding status invalid.
    /// - `Forbidden.FinancialLocked`: The ip business status is invalid.
    /// - `InvalidIpStatus.HasBeenUsedBySnatTable`: The removed ip address has been used by snat table.
    /// - `InvalidIpStatus.HasBeenUsedByForwardEntry`: The specified address has been used by forwardTable.
    /// - `InvalidEIPStatus.BizDisabled`: The EIP has been locked.
    /// - `InvalidStatus.EcsStatusNotSupport`: The special instance status Pending is not support operate
    /// - `InvalidStatus.EniStatusNotSupport`: %s
    /// - `InvalidStatus.SnatOrDnat`: Operation failed because snat or dnat in unstable status.
    /// - `DependencyViolation.SnatEntry`: The specified eip is in ip pool.
    /// - `InvalidInstance.NotVpc`: Bound instance is not vpc instance.
    /// - `InvalidStatus.NotAllow`: Bound instance status is invalid.
    /// - `InvalidAllocationId.NotFound`: Specified allocation ID is not found
    /// - `InvalidHaVip.NotFound`: The specified HaVip does not exist.
    /// - `Forbidden.RegionNotFound`: Specified region is not found during access authentication.
    /// - `OperationUnsupported.ServiceManaged`: Operation of resource is forbidden because this instance belongs to Service manager.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn unassociate_eip_address(
        &self,
        req: UnassociateEipAddress,
    ) -> impl std::future::Future<Output = crate::Result<UnassociateEipAddressResponse>> + Send
    {
        self.call(req)
    }

    /// # 申请弹性公网IP（EIP）
    ///
    /// AllocateEipAddress
    ///
    /// > 该接口已升级，不建议继续使用。新版接口的使用说明，请参见[AllocateEipAddress](~~120192~~)。
    ///
    /// # Error Codes
    /// - `QueryParameter.Illegal`: query parameter illegal
    /// - `COMMODITY_NO_EXIST`: commodity is not exist
    /// - `QuotaExceeded.Eip`: Elastic IP address quota exceeded
    /// - `InvalidParameter`: Specified value of "InternetChargeType" is not valid
    /// - `InsufficientBalance`: Your account does not have enough balance.
    /// - `ReserveIpFail`: Reserve eip failed.
    /// - `InvalidRegion.NotSupport`: The specified region does not support.
    /// - `InvalidBandwidth.Malformed`: The specified Bandwidth is invalid.
    /// - `COMMODITY.INVALID_COMPONENT`: The instance component is invalid.
    /// - `INSTANCE_TYPE_NOT_SUPPORT`: The instance type is invalid.
    /// - `OrderFailed`: The Account failed to create order.
    /// - `QuotaExceeded.LargeSpecEip`: Elastic IP address with large spec quota exceeded.
    /// - `PAYFOR.CREDIT_PAY_INSUFFICIENT_BALANCE`: Your account does not have enough balance.
    /// - `SYSTEM.SALE_VALIDATE_UNEXPECTED_ERROR`: You have arrears and do not meet the purchase conditions.
    /// - `InvalidComponent.EipBandwidthMax`: The eip_bandwidth_max component is invalid.
    /// - `OperationFailed.RiskControl`: Risk control check failed.
    /// - `OperationFailed.SaleValidate`: Validate sale condition with subArticle failed.
    /// - `IllegalParam.OrderParamComponent`: Product order param has invalid component.
    /// - `OperationFailed.SaleExpression`: Get the sales expression exception attached to the item.
    /// - `OperationFailed.SyncOrderToSub`: SyncOrderToSub error.
    /// - `OperationFailed.CompleteUserInfo`: Complete user info failed.
    /// - `OperationFailed.QueryPrice`: Query price failed when create order.
    /// - `OperationFailed.InvokeInnerApi`: Failed to invoke inner api.
    /// - `OperationFailed.AccountMoneyInvalid`: Account money is invalid.
    /// - `OperationFailed.QueryCredtiInfo`: Failed to query credit info.
    /// - `OperationFailed.QueryUserLabel`: Failed to query user label info.
    /// - `FrequentPurchase.EIP`: eip frequent purchase
    /// - `PAY.INSUFFICIENT_BALANCE`: Your account does not have enough balance.
    /// - `ORDER.QUANTITY_INVALID`: User quota has exceeded the limit.
    /// - `PAY.MAYI_WITHHOLDING_AGREEMENT_ILLEGAL`: User withhoding argeement is illegal.
    /// - `OrderError.EIP`: The Account failed to create order.
    /// - `IellgalParameter.OwnerAccount`: The specified parameter OwnerAccount is not valid.
    /// - `Forbbiden`: User not authorized to operate on the specified resource.
    /// - `InvalidRegionId.NotFound`: Specified value of "RegionId" is not supported.
    /// - `OperationConflict`: Request was denied due to conflict with a previos request.
    /// - `InsufficientEipCapacity`: Insufficient EIP capacity to fulfill your request.
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.
    /// - `OrderError.EIP`: The Account failed to create order.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn allocate_eip_address(
        &self,
        req: AllocateEipAddress,
    ) -> impl std::future::Future<Output = crate::Result<AllocateEipAddressResponse>> + Send {
        self.call(req)
    }

    /// ModifyEipAddressAttribute
    ///
    /// # Error Codes
    /// - `InsufficientBalance.Eip`: Your account does not have enough balance.
    /// - `InvalidParameter`: Specified value of "Bandwidth" is not supported.
    /// - `IncorrectEipStatus`: Current elastic IP status does not support this operation.
    /// - `InvalidParam`: The Ecmp routerEntry with router interfaces local vgw vip not match.
    /// - `Forbidden.ChargeTypeIsPrepaid`: It?s forbidden to change prepaid EIP?s bandwidth by API.  It can be changed on Aliyun web console.
    /// - `InvalidBandwidth.OutOfMaxTrafficBindedOnNatgw`:  
    /// - `QuotaExceeded.LargeSpecEip`: Elastic IP address with large spec quota exceeded.
    /// - `InvalidEipAddressName.Malformed`: The specified Name is not valid.
    /// - `ResourceQueryError`: The specified resource is queried error.
    /// - `InvalidDescription.Malformed`: Invalid description.
    /// - `InvalidEIPStatus.BizDisabled`: The EIP has been locked.
    /// - `OperationFailed.SyncOrderToSub`: SyncOrderToSub error.
    /// - `COMMODITY.INVALID_COMPONENT`: The instance component is invalid.
    /// - `OperationFailed.CompleteUserInfo`: Complete user info failed.
    /// - `OperationFailed.ConcurrentRequest`: Operation failed because concurrent request.
    /// - `IncorrectStatus.ResourceStatus`: Resource status is abnormal for renew.
    /// - `OperationFailed.SaleValidate`: Validate sale condition with subArticle failed.
    /// - `InvalidAllocationId.NotFound`: Specified allocation ID is not found
    /// - `Forbidden.InCommonBandwidthPackage`: Specified allocation ID in common bandwidth package.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `SYSTEM.UNKNOWN.ERROR`: The Account failed to create order.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_eip_address_attribute(
        &self,
        req: ModifyEipAddressAttribute,
    ) -> impl std::future::Future<Output = crate::Result<ModifyEipAddressAttributeResponse>> + Send
    {
        self.call(req)
    }

    /// ReleaseEipAddress
    ///
    /// # Error Codes
    /// - `IncorrectEipStatus`: Current elastic IP status does not support this operation.
    /// - `Forbbiden`: The eip instance owener error
    /// - `Forbidden.ChargeTypeIsPrepaid`: It's forbidden to release a prepaid EIP
    /// - `TaskConflict.AssociateGlobalAccelerationInstance`: Operate too frequent.
    /// - `InvalidOperation.DeletionProtection`: The instance cannnot delete because of deletion protecion.
    /// - `OperationUnsupported.ServiceManaged`: Operation is forbidden because this instance belongs to Service manager.
    /// - `InvalidAllocationId.NotFound`: Specified allocation ID is not found
    /// - `Forbidden.RegionNotFound`: Specified region is not found during access authentication.
    /// - `InternalError`: The request processing has failed due to some unknown error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn release_eip_address(
        &self,
        req: ReleaseEipAddress,
    ) -> impl std::future::Future<Output = crate::Result<ReleaseEipAddressResponse>> + Send {
        self.call(req)
    }

    /// AssociateEipAddress
    ///
    /// # Error Codes
    /// - `InvalidAction.Denied`: Action is denied due to unfinished Eip configuration modification.
    /// - `InvalidAssociation.Duplicated`: Specified instance already is associated.
    /// - `OperationDenied`: Specified instance is not in VPC.
    /// - `InvalidParameter.Mismatch`: Specified elastic IP address and ECS instance are not in the same region.
    /// - `IncorrectEipStatus`: Current elastic IP status does not support this operation
    /// - `IncorrectInstanceStatus`: Current instance status does not support this operation.
    /// - `InvalidInstanceType.ValueNotSupported`: The specified value of InstanceType is not supported.
    /// - `IncorrectHaVipStatus`: HaVip can be operated by this action only when it's status is Available or InUse.
    /// - `InvalidParameter`: The specified parameter is not valid.
    /// - `ReserveIpFail`: Reserve eip failed.
    /// - `Forbbiden`: The eip instance owener error
    /// - `TaskConflict`: The eip operate too frequent, TaskConflict.
    /// - `InvalidBindingStatus`: The eip binding status invalid.
    /// - `BIND_INSTANCE_HAVE_PORTMAP_OR_BIND_EIP`: The instance may have portMap or already bind eip.
    /// - `EIP_CAN_NOT_ASSOCIATE_WITH_PUBLIC_IP`: instance already bind natpublicip,cannot bind eip.
    /// - `BIND_INSTANCE_OWENER_ERROR`: Cannot operate the eip.
    /// - `QuotaExceeded.NumberOfTrafficEip`: The number of traffic eip on natgw exceed limitation.
    /// - `QuotaExceeded.NumberOfEip`: Binded eip Quota exceed on this NatGw.
    /// - `InvalidEipBandwidth.OutOfMaxValue`: ""
    /// - `Forbidden.EipCanNotBindGatgw`: Eip can not bind on natgw.
    /// - `Forbidden.InstanceBandwidthNotZero`: Eip can not bind with instance when it's bandwidth is not zero.
    /// - `INSTANCE_TYPE_NOT_SUPPORT`: The instance type is invalid.
    /// - `InvalidStatus.EcsStatusNotSupport`: The special instance status Pending is not support operate
    /// - `NATGATEWAY_FINANCIALLOCKED`: The NatGateway has expire, cannot do bind operation.
    /// - `InvalidParameter.InstanceTypeNotSupport`: The specified instance type is not support.
    /// - `InstanceType.NotSupport`: The instance type is invalid.
    /// - `InvalidParams.NotFound`: instance not found
    /// - `BindInstance.NotSupported`: bind instance type %s is not supported.
    /// - `ServerRegion.Invalid`: Eip bind remote server region invalid.
    /// - `Eni.Attached`: The eni should be detached from ecs when associating with direct eip.
    /// - `Invalid.DirectEip.BindType`: The direct eip can be only associated with eni.
    /// - `InvalidStatus.EniStatusNotSupport`: %s
    /// - `InvalidParameter.EniInstanceId`: %s
    /// - `InvalidNexthop.DirectEni`: The direct Eni cannot be nexthop.
    /// - `InvalidEIPStatus.BizDisabled`: The EIP has been locked.
    /// - `OperationFailed.EniSubIp`: Eni has sub ip can not bind direct eip.
    /// - `InvalidEip.EipQuotaExceeded`: The specified eni assigned eip is more than privateIp.
    /// - `OperationFailed.QueryCommodityInfo`: Operation failed because quey commodity info error.
    /// - `OperationUnsupported.MultiIp`: Multi ip function is not support.
    /// - `InvalidNicOrVm.NotFound`: Bind nic or vm not exist.
    /// - `OperationUnsupported.EipBindModel`: The instance type of ecs does not support MULTI_BINDED model Eip.
    /// - `IncorrectStatus.NatGateway`: %s
    /// - `InvalidParameter.BindingInstanceRegion`: The specified BindingInstanceRegion is not supported.
    /// - `OperationFailed.HavipBoundPortmap`: %s
    /// - `InvalidStatus.NotAllow`: Bound instance status is invalid.
    /// - `InvalidInstance.NotVpc`: Bound instance is not vpc instance.
    /// - `InvalidStatus.InstanceHasBandWidth`: The specified instance bandwidth invalid.
    /// - `OperationDenied.CloudBoxResourceExist`: The operation is not allowed because the resource to be bound is a CloudBox resource.
    /// - `InvalidAllocationId.NotFound`: Specified allocation ID is not found.
    /// - `InvalidInstanId.NotFound`: Specified instance does not exist.
    /// - `InvalidHaVip.NotFound`: The specified HaVip does not exist.
    /// - `Forbidden.RegionNotFound`: Specified region is not found during access authentication.
    /// - `InvalidRegionId.NotFound`: Specified value of InstanceRegionId is not supported.
    /// - `InvalidInstance.NotExist`: Bind instance data not exist.
    /// - `ServiceUnavailable`: The request has failed due to a temporary failure of the server.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn associate_eip_address(
        &self,
        req: AssociateEipAddress,
    ) -> impl std::future::Future<Output = crate::Result<AssociateEipAddressResponse>> + Send {
        self.call(req)
    }

    /// DescribeEipAddresses
    ///
    /// # Error Codes
    /// - `InvalidIAssociatedInstanceType.ValueNotSupported`: The specified value of AssociatedInstanceType is not supported.
    /// - `InvalidChargeType.ValueNotSupported`: The specified ChargeType is not supported.
    /// - `InvalidAliuid`: User Id is not valid.
    /// - `ResourceQueryError`: The specified resource is queried error.
    /// - `InstanceType.Invalid`: InstanceType is not null
    /// - `InvalidParameter`: Parameter exceed max length
    /// - `OperationUnsupported.ResourceGroupId`: ResourceGroup is not supported in this region.
    /// - `IellgalParameter.OwnerAccount`: The specified parameter OwnerAccount is not valid.
    /// - `InvalidResourceGroupId`: The specified ResourceGroupId does not exist.
    /// - `OperationFailed.Endpoint`: Operation failed because the RegionId is unavailable in this endpoint.
    /// - `Forbidden.RegionNotFound`: Specified region is not found during access authentication.
    /// - `InvalidFilterKey.NotFound`:  
    /// - `InvalidFilterValue`:  
    /// - `InvalidLockReason.NotFound`: The specified LockReason is not found
    /// - `InternalError`: The request processing has failed due to some unknown error, exception or failure.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_eip_addresses(
        &self,
        req: DescribeEipAddresses,
    ) -> impl std::future::Future<Output = crate::Result<DescribeEipAddressesResponse>> + Send {
        self.call(req)
    }

    /// DescribeEipMonitorData
    ///
    /// # Error Codes
    /// - `InvalidParameter.TooMany`: monitor parameter too many data required.
    /// - `InvalidStartTime.Malformed`: The specified parameter "StartTime" is not valid.
    /// - `InvalidEndTime.Malformed`: The specified parameter "EndTime" is not valid.
    /// - `InvalidPeriod.ValueNotSupported`: The specified parameter "Period" is not valid.
    /// - `InvalidStartTime.TooEarly`: The specified parameter "StartTime" is too early.
    /// - `InvalidAllocationId.NotFound`: Specified allocation id is not found.
    /// - `InvalidParameter`: Specified value of "Period" is not valid
    /// - `OperationDenied.TooManyDataQueried`: Specified operation is denied as too many data to return.
    /// - `InvalidRegionInstance`: The specified InstanceId does not exist in given region.
    /// - `InvalidIpInstanceId.NotFound`: The specified Eip InstanceId does not exist in our records.
    /// - `InvalidInstanceId.NotFound`: The InstanceId provided does not exist in our records.
    /// - `Forbidden.RegionNotFound`: Specified region is not found during access authentication.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_eip_monitor_data(
        &self,
        req: DescribeEipMonitorData,
    ) -> impl std::future::Future<Output = crate::Result<DescribeEipMonitorDataResponse>> + Send
    {
        self.call(req)
    }

    /// CreateNatGateway
    ///
    /// # Error Codes
    /// - `InvalidVPCStatus`: vpc incorrect status.
    /// - `InvalidNatGatewayName.MalFormed`: NatGateway name is not valid.
    /// - `InvalidNatGatewayDescription.MalFormed`: NatGateway description is not valid.
    /// - `MissingParameter.BandwidthPackage`: only support one BandwidthPackage be created with NatGateway.
    /// - `OperationDenied`: The user cannot allow to create natgw, please call PD to authorize
    /// - `RouterEntryConflict.Duplicated`: A route entry already exists, which CIDR is '0.0.0.0/0'
    /// - `MissingParameter`: Miss mandatory parameter.
    /// - `QuotaExceeded.BandwidthPackageIps`: The specified ipCount exceeded quota.
    /// - `AllocateIpFailed`: Alloc bandwidthPackage ips failed, maybe no available ip.
    /// - `ParameterIllegal`: ipCount,bandwidth parameter invalid
    /// - `ZONE_NO_AVAILABLE_IP`: The Zone have no available ip.
    /// - `InvalidNatGatewayId.NotFound`: The NatGatewayId not exist.
    /// - `InvalidParameter.Spec.ValueNotSupported`: The specified Spec is not valid.
    /// - `COMMODITY.INVALID_COMPONENT`: The instance component is invalid.
    /// - `OperationUnsupported.MultiNatGateway`: More than one natGateway per vpc is unsupported.
    /// - `VswitchStatusError`: The VSwitch is creating .
    /// - `Forbidden.CheckEntryRuleQuota`: Route entry quota rule check error.
    /// - `OperationFailed.UnpaidBillsExist`: The account has unpaid bills. Please pay your overdue bill first.
    /// - `IncorrectStatus.RouteEntry`: Specified routeEntry status error.
    /// - `IncorrectStatus.RouteTableStatus`: %s
    /// - `TaskConflict`: The operation is too frequent, please wait a moment and try again.
    /// - `OperationFailed.TokenVerfiy`: Token verify failed.
    /// - `IllegalParam.Name`: The specified Name is invalid, shorter than 2 characters.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidVpcId.NotFound`: Specified value of VpcId is not found in our record.
    /// - `InvalidZoneId.NotFound`: Specified value of ZoneId is not exists.
    /// - `VPC_ONLY_CAN_CREATE_ONE_NAT_GATEWAY`: NatGateway in one vpc support only one.
    /// - `OperationFailed.CrateEntryTimeOut`: Operation failed because create custom routeEntry timeout.
    /// - `OrderError.NatGateway`: The Account failed to create order.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn create_nat_gateway(
        &self,
        req: CreateNatGateway,
    ) -> impl std::future::Future<Output = crate::Result<CreateNatGatewayResponse>> + Send {
        self.call(req)
    }

    /// DeleteNatGateway
    ///
    /// # Error Codes
    /// - `DependencyViolation.BandwidthPackages`: There are BandwidthPackages on specified NatGateway not deleted.
    /// - `DependencyViolation.EIPS`: There are Eips on specified NatGateway, please unbind it first.
    /// - `Forbidden.PrePaidNatGateway`: The specified NatGateway is PrePaid.
    /// - `TaskConflict`: The operation is too frequent, TaskConflict.
    /// - `INSTANCE_NOT_EXISTS`: Instance not exists.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidNatGatewayId.NotFound`: The specified NatGatewayId does not exist in our records.
    /// - `IncorrectStatus.natgw`: NatGateway status is invalid.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn delete_nat_gateway(
        &self,
        req: DeleteNatGateway,
    ) -> impl std::future::Future<Output = crate::Result<DeleteNatGatewayResponse>> + Send {
        self.call(req)
    }

    /// DescribeNatGateways
    ///
    /// # Error Codes
    /// - `InvalidAliuid`: User Id is not valid.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_nat_gateways(
        &self,
        req: DescribeNatGateways,
    ) -> impl std::future::Future<Output = crate::Result<DescribeNatGatewaysResponse>> + Send {
        self.call(req)
    }

    /// DescribeNewProjectEipMonitorData
    ///
    /// # Error Codes
    /// - `InvalidStartTime.Malformed`: The specified parameter "StartTime" is not valid.
    /// - `InvalidEndTime.Malformed`: The specified parameter "EndTime" is not valid.
    /// - `InvalidPeriod.ValueNotSupported`: The specified parameter "Period" is not valid.
    /// - `InvalidStartTime.TooEarly`: The specified parameter "StartTime" is too early.
    /// - `InvalidAllocationId.NotFound`: Specified allocation id is not found.
    /// - `InvalidParameter`: Specified value of "Period" is not valid
    /// - `OperationDenied.TooManyDataQueried`: Specified operation is denied as too many data to return.
    /// - `InvalidInstanceId.NotFound`: The InstanceId provided does not exist in our records.
    /// - `InvalidAllocationId.NotFound`: Specified allocation ID is not found///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_new_project_eip_monitor_data(
        &self,
        req: DescribeNewProjectEipMonitorData,
    ) -> impl std::future::Future<Output = crate::Result<DescribeNewProjectEipMonitorDataResponse>> + Send
    {
        self.call(req)
    }

    /// DeleteRouteEntry
    ///
    /// # Error Codes
    /// - `MissingParameter`: Miss mandatory parameter.
    /// - `IncorrcetRouteEntryStatus`: Some route entry status blocked this operation.
    /// - `InvalidCidrBlock.Malformed`: Specified CIDR block is not valid.
    /// - `OperationDenied`: Specified operation is denied as route entry type is system.
    /// - `InvalidRouteEntry.NotFound`: Route entry not exists.
    /// - `InvalidVRouter.NotFound`: vRouter not exists.
    /// - `IncorrectRouteEntryStatus`: Some route entry status blocked this operation.
    /// - `Forbbiden`: Specified RouteEntry cannot allowed delete by openApi.
    /// - `InvalidNextHop`: Specified nexthop and nexthop list cannot both null.
    /// - `InvalidRouteEntry`: Specified routeEntry not exist.
    /// - `Forbidden.VRouterNotFound`: pecified virtual switch is not found during access authentication.
    /// - `TaskConflict`: The operation is too frequent, TaskConflict.
    /// - `IncorrectVpcStatus`: Current VPC status does not support this operation.
    /// - `InvalidVpnInstanceId.NotFound`: %s
    /// - `InvalidNextHopList.Size`: Nexthop list size should be between 2 and 16
    /// - `ParamExclusive.NextHopIdAndList`: NextHopId and NextHopList cannot both be not null.
    /// - `OperationFailed.DeleteMultiScopeEntry`: Multi or ecmp scope must delete with force.
    /// - `OperationFailed.DistibuteLock`: Distibute lock fail.
    /// - `InvalidRouteTableId.NotFound`: Specified route table does not exist.
    /// - `InvalidVpcId.NotFound`: Specified value of VpcId is not found in our record.
    /// - `Vpc.Error`: error code 500,Internal server error.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn delete_route_entry(
        &self,
        req: DeleteRouteEntry,
    ) -> impl std::future::Future<Output = crate::Result<DeleteRouteEntryResponse>> + Send {
        self.call(req)
    }

    /// DeleteForwardEntry
    ///
    /// # Error Codes
    /// - `IncorretForwardEntryStatus`: Some Forward entry status blocked this operation..
    /// - `MissingParameter`: Missing mandatory parameter
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidForwardEntryId.NotFound`: Specified forward entry ID does not exist///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn delete_forward_entry(
        &self,
        req: DeleteForwardEntry,
    ) -> impl std::future::Future<Output = crate::Result<DeleteForwardEntryResponse>> + Send {
        self.call(req)
    }

    /// CreateForwardEntry
    ///
    /// # Error Codes
    /// - `OperationUnsupported.ForwardEntry`: Duplicated destination ip port is unsupported.
    /// - `InvalidExternalIp.Malformed`: The specified ExternalIp is not a valid IP address.
    /// - `InvalidInternalIp.Malformed`: The specified InternalIp is not a valid IP address.
    /// - `InvalidExternalPort.Malformed`: The specified ExternalPort is not a valid port.
    /// - `InvalidInternalPort.Malformed`: The specified InternalPort is not a valid port.
    /// - `Forbidden.DestnationIpOutOfVpcCIDR`: The specified Internal Ip is Out of VPC CIDR.
    /// - `InvalidProtocal.ValueNotSupported`: The specified IpProtocol does not support.
    /// - `IncorretForwardEntryStatus`: Some Forward entry status blocked this operation..
    /// - `QuotaExceeded`: Forward entry quota exceeded in this route table.
    /// - `ForwardEntry.Duplicated`: The specified ExternalIp, IpProtocol, ExternalPort,InternalIp, InternalPort  is duplicated.
    /// - `Invalid.natgwNotExist`: The specified natgateway not exist.
    /// - `InvalidIp.NotInNatgw`: The specified ip not belong to natgateway.
    /// - `MissingParameter`: Missing mandatory parameter.
    /// - `OperationFailed.InstacneBindEip`: Private ip instance already bind eip.
    /// - `DuplicatedParam.ExternalPort`: The param of %s is duplicated.
    /// - `DuplicatedParam.InternalPort`: The param of %s is duplicated.
    /// - `UnsupportedFeature.PrivateLinkEnabled`: The feature of PrivateLinkEnabled is not supported.
    /// - `UnsupportedFeature.PortSegment`: The feature of PortSegment is not supported.
    /// - `ExclusiveParam.%sAnd%s`: The param of %s and %s are mutually exclusive.
    /// - `OperationFailed.AnyPortConfig`: Operation failed because any port correspondence any protocol.
    /// - `QuotaExceeded.ForwardEntry`: The quota of %s is exceeded, usage %s/%s.
    /// - `IncorrectStatus.NatIp`: The status of %s [%s] is incorrect.
    /// - `Forbidden.IpHasBeenUsedInSnat`: The source ip can't be used. Because it has been used in snat.
    /// - `Forbidden.DestinationIpOutOfVswitchCIDR`: The specified Internal Ip is Out of VSwitch CIDR.
    /// - `Forbidden.ExternalIp.UsedInSnatTable`: The specified ExternalIp is already used in SnatTable.
    /// - `Forbidden.InternalIpOutOfVpcCIDR`: The specified Internal Ip is Out of VPC CIDR.
    /// - `AnyPort.PortMustBeZero`: Any port port must be zero.
    /// - `InvalidParameter.Name.Malformed`: The specified Name is not valid.
    /// - `IncorrectStatus.ForwardEntry`: The status of %s [%s] is incorrect.
    /// - `Duplicated.DestinationPort`: The specified param DestinationPort is duplicated.
    /// - `OperationUnsupported.EipInBinding`: Create snat entry with eip in associating status is unsupported.
    /// - `QuotaExceeded.ForwardEntrySessionManytoOne`: The dnat session quota is exceed.
    /// - `DuplicatedParam.%s`: The param of %s is duplicated.
    /// - `UnsupportedFeature.%s`: The feature of %s is not supported.
    /// - `Operation.Conflict`: The operation may conflicts with others.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidForwardTableId.NotFound`: Specified forward table does not exist.
    /// - `InvalidExternalIp.NotFound`: Specified External Ip address does not found on the VRouter.
    /// - `ResourceNotFound.NatIp`: The specified resource of %s is not found.
    /// - `InternalError`: The request processing has failed due to some unknown error.
    /// - `System.Error`: ERROR SYSTEM ERROR.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn create_forward_entry(
        &self,
        req: CreateForwardEntry,
    ) -> impl std::future::Future<Output = crate::Result<CreateForwardEntryResponse>> + Send {
        self.call(req)
    }

    /// AddBandwidthPackageIps
    ///
    /// # Error Codes
    /// - `InvalidIpCount.ValueNotSupported`: The specified value of IpCount not supported.
    /// - `QuotaExceeded.BandwidthPackageIps`: The specified ipCount exceeded quota.
    /// - `AllocateIpFailed`: Alloc bandwidthPackage ips failed, maybe no available ip.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidBandwidthPackageId.NotFound`: The specified BandwidthPackageId does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn add_bandwidth_package_ips(
        &self,
        req: AddBandwidthPackageIps,
    ) -> impl std::future::Future<Output = crate::Result<AddBandwidthPackageIpsResponse>> + Send
    {
        self.call(req)
    }

    /// 查询路由器列表
    ///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_v_routers(
        &self,
        req: DescribeVRouters,
    ) -> impl std::future::Future<Output = crate::Result<DescribeVRoutersResponse>> + Send {
        self.call(req)
    }

    /// CreateRouteEntry
    ///
    /// # Error Codes
    /// - `MissingParameter`: Miss mandatory parameter.
    /// - `InvalidCidrBlock.Malformed`: Specified CIDR block is not valid.
    /// - `InvalidCIDRBlock.Duplicate`: Specified CIDR block is already exists.
    /// - `IncorrectVpcStatus`: Current VPC status does not support this operation.
    /// - `QuotaExceeded`: Route entry quota exceeded in this route table.
    /// - `IncorrectRouteEntryStatus`: Some route entry status blocked this operation.
    /// - `InvalidCidrBlock`: Specified CIDR block is not valid.
    /// - `InvalidNextHopType`: Specified parameter "NextHopType" is not valid
    /// - `InvalidNextHop.NotFound`: Specified next hop does not exist.
    /// - `InvalidVRouter.NotFound`: vRouter not exists.
    /// - `InvalidVPC.NotFound`: vpc not exists.
    /// - `InvalidNexthopTypeAndList.BothNull`: both nexthopType and nextHopList are null.
    /// - `InvalidNexthopTypeAndList.BothNotNull`: both nexthopType and nextHopList are not null.
    /// - `InvalidRouterInterface`: invalid router interface.
    /// - `InvalidOppositeRouterType`: nexthop list cannot only contain router interface whose opposite router interface is on vbr.
    /// - `InvalidNexthopListSize`: nexthop size is illegal. Must be between 2 and 4.
    /// - `InvalidEntryRuleQuota.NotFound`: Route entry quota rule not exists.
    /// - `Forbidden.CheckEntryRuleQuota`: Route entry quota rule check error.
    /// - `InvalidVBRStatus`: invalid virtual border router status.
    /// - `InvalidPhysicalConnectionBusinessStatus`: invalid physical connection business status.
    /// - `InvalidRouterType`: Cannot specify nexthop list in vbr's route table.
    /// - `IncorrectHaVipStatus`: This operation is denied because satus of the specified HaVip is neither Available nor InUse.
    /// - `CountLimitExceed.HaVipRouteEntry`: There can be 5 route entry to HaVip at most in one route table.
    /// - `InvalidRouteEntry.Duplicate`: The route entry already exist.
    /// - `InvalidParam`: The Ecmp routerEntry with router interfaces local vgw vip not match.
    /// - `INVALID_WEIGHT_PARAM`: Specified value of weight invalid
    /// - `FORBIDDEN_USE_VPC_AS_INTERNET_GATEWAY`: The Specified CIDR must be in vpc CIDR.
    /// - `InvalidNexthop`: The Specified nexthop illegal.
    /// - `INVALID_VPC_ID`: The Specified VpcId not match.
    /// - `InvalidRouteEntrySize`: The Specified routerEntry size not legal.
    /// - `TaskConflict`: The operation is too frequent, please wait a moment and try again.
    /// - `InvalidRouteEntry`: Specified routeEntry not exist.
    /// - `InvalidDestinationCidrBlock`: The specified destinationCidrBlock must not included in black list cidr.
    /// - `VswitchStatusError`: The VSwitch is creating .
    /// - `Forbidden.PrivateIpNotFound`: Private ip address not exist.
    /// - `RouteConflict.AlreadyExist`: Route conflict exists in routing table.
    /// - `OperationUnsupported.InactiveMode`: Vpc multi scope route only support active standby.
    /// - `IncorrectStatus.MultiScopeRiRouteEntry`: MultiScope ri status must not in idle.
    /// - `OperationUnsupported.MoreThanOneVpnOrHavip`: MultiScope can not support more than one vpn/havip.
    /// - `OperationUnsupported.EcmpRiTypeOrNumber`: Emcp entry not supported if vpc-vbr or vbr-vlan ri does not exist.
    /// - `Duplicated.VpcNextHop`: Route entry nexthop duplicate.
    /// - `OperationUnsupported.SubRouteTableECMP`: Vpc subRouteTable don't support ecmp or multiScope.
    /// - `InvalidNexthop.NotFound`: VRouterEntry nexthop does not exist.
    /// - `IllegalParam.NextHopId`: Instance not exists or not vpc vm.
    /// - `InvalidVpnInstanceId.NotFound`: %s
    /// - `OperationFailed.ScopeActiveRouteEntryType`: %s
    /// - `OperationFailed.ScopeStandbyRouteEntryQuota`: %s
    /// - `OperationFailed.ScopeActiveRouteEntryQuota`: %s
    /// - `OperationUnsupported.ScopeInvalidRouteType`: %s
    /// - `OperationFailed.EcmpInvalidRouterInterfaceOppositeType`: %s
    /// - `QuotaExceeded.HaVipRouteEntry`: Vpc havip route entry quota exceed.
    /// - `OperationFailed.InvalidNexthop`: vpc multi scope route must has a enable nexthop.
    /// - `OperationFailed.NotifyCenDelete`: Failed to notify cen when delete route entry.
    /// - `InvalidNatGateway.NotFound`: Natgateway not exist.
    /// - `OperationFailed.CxpRouteExist`: Cxp route alreay existed.
    /// - `InvalidNexthop.DirectEni`: The direct Eni cannot be nexthop.
    /// - `OperationFailed.NotifyCenCreate`: Failed to notify cen when create route entry.
    /// - `IncorrectStatus.RouteTableStatus`: %s
    /// - `OperationFailed.GetEniInfo`: Failed to get networkInterface info.
    /// - `QuotaExceeded.EcmpRouteEntryNextHopCount`: %s
    /// - `OperationFailed.InvalidNextHopType`: %s
    /// - `OperationUnsupported.InvalidRouterInterfaceType`: Only vpc vbr interface support ecmp route.
    /// - `InvalidHaVip.NotFound`: The specified HaVip does not exist in the specified region.
    /// - `OperationFailed.MultiScopeType`: The specified nexthop type is not support in multiScope.
    /// - `OperationFailed.DistibuteLock`: Distibute lock fail.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InvalidNatGatewayId.NotFound`: Specified value of NatGatewayId is not found in our record.
    /// - `InvalidInstanId.NotFound`: Specified instance does not exist.
    /// - `InvalidNextHopId.NotFound`: Specified next hop does not exist.
    /// - `InvalidRouteTableId.NotFound`: Specified route table does not exist.
    /// - `InvalidHaVipId.NotFound`: The specified HaVip does not exist in the specified VPC.
    /// - `InvalidNetworkInterface.NotFound`: The specified networkInterface does not exist.
    /// - `InvalidVpc.NotFound`: Specified vpc is not found in our record.
    /// - `OperationFailed.InstanceDismatchCurrentVpc`: The specified instance does not exist in current vpc.
    /// - `InvalidIpv6Gateway.NotFound`: Specified Ipv6Gateway does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn create_route_entry(
        &self,
        req: CreateRouteEntry,
    ) -> impl std::future::Future<Output = crate::Result<CreateRouteEntryResponse>> + Send {
        self.call(req)
    }

    /// DescribeForwardTableEntries
    ///
    /// # Error Codes
    /// - `IncorretForwardEntryStatus`: Some Forward entry status blocked this operation..
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidForwardTableId.NotFound`: Specified forwardTableId does not exist///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_forward_table_entries(
        &self,
        req: DescribeForwardTableEntries,
    ) -> impl std::future::Future<Output = crate::Result<DescribeForwardTableEntriesResponse>> + Send
    {
        self.call(req)
    }

    /// ModifyForwardEntry
    ///
    /// # Error Codes
    /// - `InvalidExternalIp.Malformed`: The specified ExternalIp is not a valid IP address.
    /// - `InvalidInternalIp.Malformed`: The specified InternalIp is not a valid IP address.
    /// - `InvalidExternalPort.Malformed`: The specified ExternalPort is not a valid port.
    /// - `InvalidInternalPort.Malformed`: The specified InternalPort is not a valid port.
    /// - `Forbidden.DestnationIpOutOfVpcCIDR`: The specified Destination Ip is Out of VPC CIDR.
    /// - `InvalidProtocal.ValueNotSupported`: The specified IpProtocol does not support.
    /// - `IncorretForwardEntryStatus`: Some Forward entry status blocked this operation..
    /// - `QuotaExceeded`: Forward entry quota exceeded in this route table.
    /// - `ForwardEntry.Duplicated`: The specified ExternalIp, IpProtocol, ExternalPort,InternalIp, InternalPort  is duplicated
    /// - `InvalidIp.NotFound`: The specified ip does not exist.
    /// - `IncorretStatus.ForwardEntry`: The Specified forwardEntry is not stable status, can not operation
    /// - `IllegalParam.AnyPortNotZero`: any port port must be zero.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist in our records.
    /// - `InvalidForwardEntryId.NotFound`: Specified forward entry ID does not exist
    /// - `InvalidExternalIp.NotFound`: Specified External Ip address does not found on the VRouter
    /// - `InvalidForwardTableId.NotFound`: Specified forward table does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn modify_forward_entry(
        &self,
        req: ModifyForwardEntry,
    ) -> impl std::future::Future<Output = crate::Result<ModifyForwardEntryResponse>> + Send {
        self.call(req)
    }

    /// DescribeAccessPoints
    ///
    /// # Error Codes
    /// - `InvalidAccessPointType.NotSupport`: Invalid access point type.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidRegionId.NotSupport`: The RegionId provided does not support in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_access_points(
        &self,
        req: DescribeAccessPoints,
    ) -> impl std::future::Future<Output = crate::Result<DescribeAccessPointsResponse>> + Send {
        self.call(req)
    }

    /// 查询路由表信息列表
    ///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_route_tables(
        &self,
        req: DescribeRouteTables,
    ) -> impl std::future::Future<Output = crate::Result<DescribeRouteTablesResponse>> + Send {
        self.call(req)
    }

    /// ConnectRouterInterface
    ///
    /// # Error Codes
    /// - `IncorrectRole.NotInitiatingSide`: The specified RouterInterface is not InitiatingSide.
    /// - `IncorrectStatus`: RouterInterface can be operated by this action only when it??s status is Idle.
    /// - `IncorrectOppositeInterfaceInfo.NotSet`: OppositeInterfaceId/OppositeRouterId/OppositeRouterType/OppositeInterfaceOwnerId must be all set.
    /// - `IncorrectOppositeInterfaceInfo`: Cannot connect on the same router
    /// - `Forbidden.OnlyOneConnection`: The Specified routers have a connection already
    /// - `Forbidden.BillsOutstanding`: You cannot use this action because you have bills outstanding.
    /// - `InvalidAccount.NotFound`: The specified account is not exists.
    /// - `ErrCode.Invalid`: got error
    /// - `AttrMismatching.AcceptingSideRole`: %s
    /// - `AttrMismatching.AcceptingSideInstanceId`: %s
    /// - `AttrMismatching.AcceptingSideRegionNo`: %s
    /// - `AttrMismatching.AcceptingSideRouterId`: %s
    /// - `AttrMismatching.AcceptingSideRouterType`: %s
    /// - `AttrMismatching.AcceptingSideAliUid`: %s
    /// - `AttrMismatching.AcceptingSideOppositeInterfaceOwnerId`: %s
    /// - `AttrMismatching.AcceptingSideOppositeRegionNo`: %s
    /// - `AttrMismatching.AcceptingSideOppositeInterfaceId`: %s
    /// - `AttrMismatching.AcceptingSideOppositeRouterId`: %s
    /// - `AttrMismatching.AcceptingSideOppositeRouterType`: %s
    /// - `IllegalParam.InstanceOwner`: The router instance owener error.
    /// - `InvalidRegionId.NotFound`: The RegionId provided does not exist in our records.
    /// - `InvalidRouterInterfaceId.NotFound`: The specified RouterInterfaceId does not exist in our record.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn connect_router_interface(
        &self,
        req: ConnectRouterInterface,
    ) -> impl std::future::Future<Output = crate::Result<ConnectRouterInterfaceResponse>> + Send
    {
        self.call(req)
    }

    /// 将快照导出到指定的对象存储
    ///
    /// # Error Codes
    /// - `ExportSnapshotFailed`: Exporting snapshot is failed, Please contact the administrator.
    /// - `SNAPSHOT_IS_EXPORTING`: The specified snapshot is already exporting.
    /// - `InvalidSnapshotId.NotFound`: The specified snapshot is not exists.
    /// - `SNAPSHOT_CREATE_NOT_FINISHED`: The specified snapshot is not finished yet.
    /// - `OSS_AUTHORIZED_FAILED`: ECS service account Have no right to access your OSS. please attach a role of access your oss to ECS service account.
    /// - `InvalidOSSBucket.NotFound`: The specified OSS bucket does not exist in this region.
    /// - `InvalidUser.NotInWhiteList`: The user is not in the white list of exporting snapshot.
    /// - `InvalidOSSBucket.InOtherRegion`: The specified OSS bucket is in another region.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn export_snapshot(
        &self,
        req: ExportSnapshot,
    ) -> impl std::future::Future<Output = crate::Result<ExportSnapshotResponse>> + Send {
        self.call(req)
    }

    /// # 释放公网IP地址
    ///
    /// 释放公网IP。
    ///
    /// # Error Codes
    /// - `OperationDenied`: Specified operation is denied as your instance is in VPC.
    /// - `InvalidIpAddress.NotFound`: The specified parameter "IpAddress" is not found in your records.
    /// - `DryRunOperation`: This is a dryrun request with successful result.
    /// - `IncorrectInstanceStatus`: The current status of the resource does not support this operation.
    /// - `InstanceLockedForSecurity`: The specified operation is denied as your instance is locked for security reasons.
    /// - `InvalidIpAddress.NeedInstanceId`: The specified IpAddress need to release with InstanceId.
    /// - `OperationTimesOverLimit`: The specified operation is denied as release public ip times over the limit.
    /// - `Forbidden.ExceedDuration`: Instance nat public ip can only be released in 6 hours after ecs created.
    /// - `InvalidInstanceId.NotFound`: The specified InstanceId does not exist.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn release_public_ip_address(
        &self,
        req: ReleasePublicIpAddress,
    ) -> impl std::future::Future<Output = crate::Result<ReleasePublicIpAddressResponse>> + Send
    {
        self.call(req)
    }

    /// # 添加或者覆盖一个或者多个标签到云服务器ECS的各项资源上
    ///
    /// 添加或者覆盖一个或者多个标签到云服务器ECS的各项资源上。您可以添加标签到实例、磁盘、快照、镜像、安全组等，便于管理资源。
    ///
    /// 调用该接口时，您需要注意：
    ///
    /// -   单项云服务器ECS资源最多可以添加20个标签。
    /// -   标签键（`Tag.N.Key`）与标签值（`Tag.N.Value`）必须键值匹配。
    /// -   如果标签键（`Tag.N.Key`）在指定的资源上已经存在，则使用新的标签值（`Tag.N.Value`）自动覆盖原标签值。
    ///
    /// # Error Codes
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidTagValue.Malformed`: The specified Tag.n.Value is not valid.
    /// - `OperationDenied.QuotaExceed`: The quota of tags on resource is beyond permitted range.
    /// - `InvalidTag.Mismatch`: The specified Tag.n.Key and Tag.n.Value are not match.
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `Duplicate.TagKey`: The Tag.N.Key contain duplicate key.
    /// - `InvalidResourceId.NotSupported`: The specified ResourceId does not support tagging.
    /// - `QuotaExceed.Tags`: %s
    /// - `TagKey.Duplication`: The TagKey has duplication with others, case-insensitive.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidResourceId.NotFound`: The specified ResourceId is not found in our records.
    /// - `InvalidResourceType.NotFound`: The ResourceType provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn add_tags(
        &self,
        req: AddTags,
    ) -> impl std::future::Future<Output = crate::Result<AddTagsResponse>> + Send {
        self.call(req)
    }

    /// # 根据标签检索资源
    ///
    /// 调用DescribeResourceByTags根据标签检索资源。支持根据标签检索，也支持根据资源类型检索。
    ///
    /// # Error Codes
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidResourceType.NotFound`: The ResourceType provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_resource_by_tags(
        &self,
        req: DescribeResourceByTags,
    ) -> impl std::future::Future<Output = crate::Result<DescribeResourceByTagsResponse>> + Send
    {
        self.call(req)
    }

    /// # 查询可供使用标签
    ///
    /// 查询可以供您使用的标签。您可以根据资源类型、资源ID、标签键或标签值等条件查询标签，筛选条件之间为逻辑与（&amp;&amp;）关系，返回满足所有筛选条件的标签。
    ///
    /// 如果您指定了标签键（Tag.N.Key）但没有指定标签值（Tag.N.Value），我们将查询该标签键对应的所有标签键值对。如果您指定了标签键值对，就查询精确匹配该键值对的标签。
    ///
    /// # Error Codes
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `InvalidTagKey.Malformed`: The parameter Tag.n.Key is illegal.
    /// - `InvalidTagValue.Malformed`: The parameter Tag.n.Value is illegal.
    /// - `Invalid.TagCategory`: The parameter Category is illegal.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidResourceType.NotFound`: The ResourceType provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn describe_tags(
        &self,
        req: DescribeTags,
    ) -> impl std::future::Future<Output = crate::Result<DescribeTagsResponse>> + Send {
        self.call(req)
    }

    /// # 解绑标签
    ///
    /// 调用RemoveTags从实例、磁盘、快照、镜像或者安全组等解绑一个或多个标签。
    ///
    /// # Error Codes
    /// - `InvalidTagCount`: The specified tags are beyond the permitted range.
    /// - `InvalidTagKey.Malformed`: The specified Tag.n.Key is not valid.
    /// - `InvalidResourceType.NotFound`: The specified ResourceType does not exist.
    /// - `InvalidResourceId.NotSupported`: The specified ResourceId does not support tagging.
    /// - `InvalidResourceId.NotFound`: The specified ResourceId is not found in our records.
    /// - `InvalidRegionId.NotFound`: The specified RegionId does not exist.
    /// - `InvalidResourceType.NotFound`: The ResourceType provided does not exist in our records.///
    /// # Methods
    /// - POST
    /// - GET
    ///
    #[deprecated]
    pub fn remove_tags(
        &self,
        req: RemoveTags,
    ) -> impl std::future::Future<Output = crate::Result<RemoveTagsResponse>> + Send {
        self.call(req)
    }

    /// # 启用或修改弹性网卡QoS限速设置
    ///
    /// 启用或修改弹性网卡QoS限速设置
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidParams.EniId`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidParameter.Conflict`: %s
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidVSwitchId.NotFound`: %s
    /// - `InvalidSecurityGroupId.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn enable_network_interface_qo_s(
        &self,
        req: EnableNetworkInterfaceQoS,
    ) -> impl std::future::Future<Output = crate::Result<EnableNetworkInterfaceQoSResponse>> + Send
    {
        self.call(req)
    }

    /// # 禁用弹性网卡QoS限速设置
    ///
    /// 禁用弹性网卡QoS限速设置
    ///
    /// # Error Codes
    /// - `MissingParameter`: %s
    /// - `UnsupportedParameter`: %s
    /// - `InvalidParameter`: %s
    /// - `InvalidInstanceID.Malformed`: %s
    /// - `InvalidParams.EniId`: %s
    /// - `Forbidden.RegionId`: %s
    /// - `InvalidParameter.Conflict`: %s
    /// - `InvalidUserType.NotSupported`: %s
    /// - `Abs.InvalidAccount.NotFound`: %s
    /// - `Forbidden.NotSupportRAM`: %s
    /// - `Forbidden.SubUser`: %s
    /// - `InvalidOperation.AvailabilityZoneMismatch`: %s
    /// - `InvalidOperation.VpcMismatch`: %s
    /// - `InvalidOperation.EniServiceManaged`: %s
    /// - `InvalidOperation.ResourceManagedByCloudProduct`: %s
    /// - `InvalidEniId.NotFound`: %s
    /// - `InvalidVSwitchId.NotFound`: %s///
    /// # Methods
    /// - POST
    /// - GET
    ///
    pub fn disable_network_interface_qo_s(
        &self,
        req: DisableNetworkInterfaceQoS,
    ) -> impl std::future::Future<Output = crate::Result<DisableNetworkInterfaceQoSResponse>> + Send
    {
        self.call(req)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeRegions {
    /// 实例的计费方式，更多信息，请参见[计费概述](~~25398~~)。取值范围：
    ///
    /// - PrePaid：包年包月。此时，请确认自己的账号支持余额支付或者信用支付，否则将报错InvalidPayMethod。
    /// - PostPaid：按量付费。
    /// - SpotWithPriceLimit：设置上限价格。
    /// - SpotAsPriceGo：系统自动出价，最高按量付费价格。
    ///
    /// 默认值：PostPaid。
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 资源类型。取值范围：
    ///
    /// -  instance：ECS实例。
    /// -  disk：磁盘。
    /// -  reservedinstance：预留实例券。
    /// -  scu：存储容量单位包。
    ///
    /// 默认值：instance。
    #[setters(generate = true, strip_option)]
    resource_type: Option<String>,
    /// 根据汉语、英语和日语筛选返回结果。更多详情，请参见[RFC 7231](https://tools.ietf.org/html/rfc7231)。取值范围：  
    ///          
    /// - zh-CN：简体中文。
    /// - zh-TW：繁体中文。
    /// - en-US：英文。
    /// - ja：日文。
    /// - fr：法语。
    /// - de：德语。
    /// - ko：韩语。
    ///
    /// 默认值：zh-CN。
    #[setters(generate = true, strip_option)]
    accept_language: Option<String>,
}

impl sealed::Bound for DescribeRegions {}

impl DescribeRegions {
    pub fn new() -> Self {
        Self {
            instance_charge_type: None,
            resource_type: None,
            accept_language: None,
        }
    }
}
impl crate::ToFormData for DescribeRegions {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeRegions {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeRegions";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeRegionsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.accept_language {
            params.push(("AcceptLanguage".into(), (f).into()));
        }

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.resource_type {
            params.push(("ResourceType".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeZones {
    /// 可用区所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 是否展示详细信息。
    ///
    /// - true：展示。
    /// - false：不展示。
    ///
    /// 默认值：true。
    #[setters(generate = true, strip_option)]
    verbose: Option<bool>,
    /// 可用区里支持的资源计费方式。更多信息，请参见[计费概述](~~25398~~)。取值范围：
    ///
    /// - PrePaid：包年包月。
    /// - PostPaid：按量付费。
    ///
    /// 默认值：PostPaid。
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 按量付费实例的竞价策略。当`InstanceChargeType=PostPaid`时，您可以传入该参数。更多信息，请参见[抢占式实例](~~52088~~)。取值范围：
    ///          
    /// - NoSpot：正常按量付费实例。
    /// - SpotWithPriceLimit：设置上限价格的抢占式实例。
    /// - SpotAsPriceGo：系统自动出价，最高按量付费价格。
    ///
    /// 默认值：NoSpot。
    #[setters(generate = true, strip_option)]
    spot_strategy: Option<String>,
    /// 根据汉语、英语和日语筛选返回结果。更多信息，请参见[RFC 7231](https://tools.ietf.org/html/rfc7231)。取值范围：  
    ///          
    /// - zh-CN：简体中文。
    /// - zh-TW：繁体中文。
    /// - en-US：英文。
    /// - ja：日文。
    /// - fr：法语。
    /// - de：德语。
    /// - ko：韩语。
    ///
    /// 默认值：zh-CN。
    #[setters(generate = true, strip_option)]
    accept_language: Option<String>,
}

impl sealed::Bound for DescribeZones {}

impl DescribeZones {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            verbose: None,
            instance_charge_type: None,
            spot_strategy: None,
            accept_language: None,
        }
    }
}
impl crate::ToFormData for DescribeZones {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeZones {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeZones";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeZonesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.accept_language {
            params.push(("AcceptLanguage".into(), (f).into()));
        }

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.spot_strategy {
            params.push(("SpotStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.verbose {
            params.push(("Verbose".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeAvailableResource {
    /// 目标地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 资源的计费方式。更多信息，请参见[计费概述](~~25398~~)。取值范围：
    ///        
    /// - PrePaid：包年包月。  
    /// - PostPaid：按量付费。
    ///
    /// 默认值：PostPaid。
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 按量付费实例的竞价策略。取值范围：
    ///          
    /// - NoSpot：正常按量付费实例。
    /// - SpotWithPriceLimit：设置上限价格的抢占式实例。
    /// - SpotAsPriceGo：系统自动出价，最高按量付费价格。
    ///
    /// 默认值：NoSpot。
    ///
    /// 当参数`InstanceChargeType`取值为`PostPaid`时，参数`SpotStrategy`才有效。
    #[setters(generate = true, strip_option)]
    spot_strategy: Option<String>,
    /// 抢占式实例的保留时长，单位为小时。 默认值：1。取值范围：
    /// - 1：创建后阿里云会保证实例运行1小时不会被自动释放；超过1小时后，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    /// - 0：创建后，阿里云不保证实例运行1小时，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    ///
    /// 实例回收前5分钟阿里云会通过ECS系统事件向您发送通知。抢占式实例按秒计费，建议您结合具体任务执行耗时来选择合适的保留时长。
    ///
    /// > 当`InstanceChargeType`取值为`PostPaid`，并且`SpotStrategy`值为`SpotWithPriceLimit`或`SpotAsPriceGo`时该参数生效。
    #[setters(generate = true, strip_option)]
    spot_duration: Option<i32>,
    /// 要查询的资源类型。取值范围：
    ///          
    /// - Zone：可用区。
    /// - IoOptimized：I/O优化。
    /// - InstanceType：实例规格。
    /// - Network：网络类型。
    /// - ddh：专有宿主机。
    /// - SystemDisk：系统盘。
    /// - DataDisk：数据盘。
    ///
    /// >当DestinationResource取值为`SystemDisk`时，由于系统盘受实例规格限制，此时必须传入InstanceType。
    ///
    /// 参数DestinationResource的取值方式请参见本文中的**接口说明**。
    destination_resource: String,
    /// 可用区ID。
    ///
    /// 默认值：无。返回该地域（`RegionId`）下所有可用区符合查询条件的资源。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 是否为I/O优化实例。取值范围：
    ///          
    /// - none：非I/O优化实例。
    /// - optimized：I/O优化实例。
    ///
    ///
    /// 默认值：optimized。
    #[setters(generate = true, strip_option)]
    io_optimized: Option<String>,
    /// 专有宿主机ID。
    #[setters(generate = true, strip_option)]
    dedicated_host_id: Option<String>,
    /// 实例规格。更多信息，请参见[实例规格族](~~25378~~)，您也可以调用[DescribeInstanceTypes](~~25620~~)接口获得最新的规格表。
    ///
    /// 参数InstanceType的取值方式请参见本文开头的**接口说明**。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 系统盘类型。取值范围：
    ///          
    /// - cloud：普通云盘。
    /// - cloud_efficiency：高效云盘。
    /// - cloud_ssd：SSD云盘。
    /// - ephemeral_ssd：本地SSD盘。
    /// - cloud_essd：ESSD云盘。
    /// - cloud_auto：ESSD AutoPL云盘。
    /// <props="china">
    /// - cloud_essd_entry：ESSD Entry云盘。
    /// </props>
    ///
    /// 默认值：cloud_efficiency。
    ///
    /// > 参数ResourceType取值为instance、DestinationResource取值为DataDisk时，参数SystemDiskCategory是必选参数。如果未传递参数值，则以默认值生效。
    #[setters(generate = true, strip_option)]
    system_disk_category: Option<String>,
    /// 数据盘类型。取值范围：
    ///          
    /// - cloud：普通云盘。
    /// - cloud_efficiency：高效云盘。
    /// - cloud_ssd：SSD云盘。
    /// - ephemeral_ssd：本地SSD盘。
    /// - cloud_essd：ESSD云盘。
    /// - cloud_auto：ESSD AutoPL云盘。
    /// <props="china">
    /// - cloud_essd_entry：ESSD Entry云盘。
    /// </props>
    #[setters(generate = true, strip_option)]
    data_disk_category: Option<String>,
    /// 网络类型。取值范围：
    ///         
    /// - vpc：专有网络。
    /// - classic：经典网络。
    ///          
    #[setters(generate = true, strip_option)]
    network_category: Option<String>,
    /// 实例规格的vCPU内核数目。取值参见[实例规格族](~~25378~~)。
    ///
    /// 当DestinationResource取值为InstanceType时，Cores才为有效参数。
    #[setters(generate = true, strip_option)]
    cores: Option<i32>,
    /// 实例规格的内存大小，单位为GiB。取值参见[实例规格族](~~25378~~)。
    ///
    /// 当DestinationResource取值为InstanceType时，Memory才为有效参数。
    #[setters(generate = true, strip_option)]
    memory: Option<f32>,
    /// 资源类型。取值范围：
    ///
    /// - instance：ECS实例。
    /// - disk：云盘。
    /// - reservedinstance：预留实例券。
    /// - ddh：专有宿主机。
    #[setters(generate = true, strip_option)]
    resource_type: Option<String>,
    /// 预留实例券的范围。取值范围：
    ///          
    /// - Region：地域级别。
    /// - Zone：可用区级别。
    #[setters(generate = true, strip_option)]
    scope: Option<String>,
}

impl sealed::Bound for DescribeAvailableResource {}

impl DescribeAvailableResource {
    pub fn new(region_id: impl Into<String>, destination_resource: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_charge_type: None,
            spot_strategy: None,
            spot_duration: None,
            destination_resource: destination_resource.into(),
            zone_id: None,
            io_optimized: None,
            dedicated_host_id: None,
            instance_type: None,
            system_disk_category: None,
            data_disk_category: None,
            network_category: None,
            cores: None,
            memory: None,
            resource_type: None,
            scope: None,
        }
    }
}
impl crate::ToFormData for DescribeAvailableResource {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeAvailableResource {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeAvailableResource";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeAvailableResourceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(16);

        if let Some(f) = &self.cores {
            params.push(("Cores".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk_category {
            params.push(("DataDiskCategory".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_id {
            params.push(("DedicatedHostId".into(), (f).into()));
        }
        params.push((
            "DestinationResource".into(),
            (&self.destination_resource).into(),
        ));

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.io_optimized {
            params.push(("IoOptimized".into(), (f).into()));
        }

        if let Some(f) = &self.memory {
            params.push(("Memory".into(), (f).into()));
        }

        if let Some(f) = &self.network_category {
            params.push(("NetworkCategory".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_type {
            params.push(("ResourceType".into(), (f).into()));
        }

        if let Some(f) = &self.scope {
            params.push(("Scope".into(), (f).into()));
        }

        if let Some(f) = &self.spot_duration {
            params.push(("SpotDuration".into(), (f).into()));
        }

        if let Some(f) = &self.spot_strategy {
            params.push(("SpotStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_category {
            params.push(("SystemDiskCategory".into(), (f).into()));
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeAccountAttributes {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 可用区ID。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 查询某类资源在指定地域下的使用配额，N的取值范围为1~8。取值范围：
    ///
    /// - instance-network-type：可选择的网络类型。
    /// - max-security-groups：安全组数量。
    /// - max-elastic-network-interfaces：弹性网卡的数量。
    /// - max-postpaid-instance-vcpu-count：按量付费实例的vCPU核数上限。
    /// - max-spot-instance-vcpu-count：抢占式实例vCPU核数上限。
    /// - used-postpaid-instance-vcpu-count：已使用按量付费实例的vCPU核数。
    /// - used-spot-instance-vcpu-count：已使用抢占式实例vCPU核数。
    /// - max-postpaid-yundisk-capacity：用作数据盘的按量付费云盘的总容量上限。（该参数值已弃用）
    /// - used-postpaid-yundisk-capacity：已使用的用作数据盘的按量付费云盘容量。（该参数值已弃用）
    /// - max-dedicated-hosts：专用宿主机数量。
    /// - supported-postpaid-instance-types：按量付费I/O优化实例规格。
    /// - max-axt-command-count：云助手命令的数量。
    /// - max-axt-invocation-daily：每天可以执行的云助手命令次数。
    /// - real-name-authentication：账号是否完成了实名认证。
    ///
    ///     > 您只有完成了实名认证才可以在中国内地地域中创建ECS实例。
    /// - max-cloud-assistant-activation-count：可创建的云助手托管实例激活码数量上限。
    ///
    /// 默认值为空。
    #[setters(generate = true, strip_option)]
    attribute_name: Option<Vec<String>>,
}

impl sealed::Bound for DescribeAccountAttributes {}

impl DescribeAccountAttributes {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            zone_id: None,
            attribute_name: None,
        }
    }
}
impl crate::ToFormData for DescribeAccountAttributes {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeAccountAttributes {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeAccountAttributes";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeAccountAttributesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.attribute_name {
            crate::FlatSerialize::flat_serialize(f, "AttributeName", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeResourcesModification {
    /// 待变更实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 待变更规格或系统盘类型的实例ID（InstanceId）。
    resource_id: String,
    /// 是否支持跨集群升级实例规格。取值范围：
    ///         
    /// - true：支持。
    /// - false：不支持。
    ///
    /// 默认值：false。
    ///
    /// 当参数MigrateAcrossZone取值为true时，一旦您根据返回信息升级了云服务器，请留意以下注意事项：
    ///          
    /// - 经典网络类型实例：
    ///     - 对于[已停售的实例规格](~~55263~~)，非I/O优化实例变配到I/O优化实例时，实例私网IP地址、云盘设备名和软件授权码会发生变化。对于Linux实例，普通云盘（cloud）会被识别为xvda或者xvdb等，高效云盘（cloud_efficiency）和SSD云盘（cloud_ssd）会被识别为vda或者vdb等。  
    ///     - 对于[正常售卖的实例规格族](~~25378~~)，实例的私网IP地址会发生变化。  
    ///             
    /// - 专有网络VPC类型实例：对于[已停售的实例规格](~~55263~~)，非I/O优化实例变配到I/O优化实例时，云服务器云盘设备名和软件授权码会发生变化。Linux实例的普通云盘（cloud）会被识别为xvda或者xvdb等，高效云盘（cloud_efficiency）和SSD云盘（cloud_ssd）会被识别为vda或者vdb等。   
    #[setters(generate = true, strip_option)]
    migrate_across_zone: Option<bool>,
    /// 待变更的实例资源类型。取值范围：
    ///          
    /// - InstanceType：实例规格。
    /// - SystemDisk：系统盘类型。
    ///
    ///   取值为SystemDisk时，必须同时指定InstanceType参数。表示目标规格要求的云盘类型。
    destination_resource: String,
    /// 更改资源配置的操作类型。
    ///
    /// - 包年包月资源的取值范围：
    ///
    ///     - Upgrade：升级资源。
    ///     - Downgrade：降级资源。
    ///     - RenewDowngrade：续费降配。
    ///     - RenewModify：过期实例的续费变配。
    ///
    /// - 按量付费资源的取值：Upgrade。
    ///
    /// 默认值：Upgrade。
    #[setters(generate = true, strip_option)]
    operation_type: Option<String>,
    /// 目标实例规格。更多信息，请参见[实例规格族](~~25378~~)，也可以调用[DescribeInstanceTypes](~~25620~~) 接口获得最新的规格表。
    ///
    /// 当参数DestinationResource取值为SystemDisk时，必须同时指定InstanceType参数。表示目标规格要求的云盘类型。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 目标实例规格的vCPU内核数目。取值请参见[实例规格族](~~25378~~)。
    ///
    /// 仅当DestinationResource=InstanceType参数有效，Cores为有效参数。
    #[setters(generate = true, strip_option)]
    cores: Option<i32>,
    /// 目标实例规格的内存大小，单位为GiB。取值请参见[实例规格族](~~25378~~)。
    ///
    /// 仅当DestinationResource=InstanceType，Memory才为有效参数。
    #[setters(generate = true, strip_option)]
    memory: Option<f32>,
    /// 目标可用区ID。
    ///
    /// 当需要跨可用区变更实例规格时，需要指定该参数。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 条件列表。
    #[setters(generate = true, strip_option)]
    conditions: Option<Vec<String>>,
}

impl sealed::Bound for DescribeResourcesModification {}

impl DescribeResourcesModification {
    pub fn new(
        region_id: impl Into<String>,
        resource_id: impl Into<String>,
        destination_resource: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            resource_id: resource_id.into(),
            migrate_across_zone: None,
            destination_resource: destination_resource.into(),
            operation_type: None,
            instance_type: None,
            cores: None,
            memory: None,
            zone_id: None,
            conditions: None,
        }
    }
}
impl crate::ToFormData for DescribeResourcesModification {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeResourcesModification {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeResourcesModification";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeResourcesModificationResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.conditions {
            crate::FlatSerialize::flat_serialize(f, "Conditions", &mut params);
        }

        if let Some(f) = &self.cores {
            params.push(("Cores".into(), (f).into()));
        }
        params.push((
            "DestinationResource".into(),
            (&self.destination_resource).into(),
        ));

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.memory {
            params.push(("Memory".into(), (f).into()));
        }

        if let Some(f) = &self.migrate_across_zone {
            params.push(("MigrateAcrossZone".into(), (f).into()));
        }

        if let Some(f) = &self.operation_type {
            params.push(("OperationType".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("ResourceId".into(), (&self.resource_id).into()));

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeRecommendInstanceType {
    /// ECS实例vCPU核数。
    ///
    /// >同时指定`Cores`参数和`Memory`参数会匹配所有满足vCPU核数和内存大小的实例规格。
    #[setters(generate = true, strip_option)]
    cores: Option<i32>,
    /// ECS实例内存大小，单位为GiB。
    ///
    /// >同时指定`Cores`参数和`Memory`参数会匹配所有满足vCPU核数和内存大小的实例规格。
    #[setters(generate = true, strip_option)]
    memory: Option<f32>,
    /// 实例规格族级别。取值范围：
    ///
    /// - EntryLevel：入门级。
    /// - EnterpriseLevel：企业级。
    /// - CreditEntryLevel：积分入门级。详情请参见[突发性能实例](~~59977~~)。
    #[setters(generate = true, strip_option)]
    instance_family_level: Option<String>,
    /// 指定的实例规格。更多详情，请参见[实例规格族](~~25378~~)，也可以调用[DescribeInstanceTypes](~~25620~~)接口获得最新的规格表。
    ///
    /// > 如果您指定了`InstanceType`，则无法指定`Cores`或者`Memory`。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// ECS实例的网络类型。取值范围：
    ///
    /// - classic：经典网络
    /// - vpc：专有网络VPC
    ///
    /// 默认值：vpc
    network_type: String,
    /// ECS实例的计费方式。更多详情，请参见[计费概述](~~25398~~)。取值范围：
    ///
    /// - PrePaid：包年包月
    /// - PostPaid：按量付费
    ///
    /// 默认值：PostPaid
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 抢占式实例的竞价策略。取值范围：
    ///
    /// - NoSpot：正常按量付费实例。
    /// - SpotWithPriceLimit：设置上限价格的抢占式实例。
    /// - SpotAsPriceGo：系统自动出价，最高按量付费价格。
    ///
    /// > 使用`SpotStrategy`时，`InstanceChargerType`必须设置为`PostPaid`。
    ///
    /// 默认值：NoSpot
    #[setters(generate = true, strip_option)]
    spot_strategy: Option<String>,
    /// 是否为I/O优化实例。实例规格只支持非I/O优化时，不能设置IoOptimized参数。取值范围：
    ///
    /// - optimized：I/O优化
    /// - none：非IO优化
    ///
    /// 默认值：optimized
    ///
    /// 如果您设置的是已停售实例规格。默认值：none
    #[setters(generate = true, strip_option)]
    io_optimized: Option<String>,
    /// 优先推荐策略。取值范围：
    ///
    /// - InventoryFirst：库存优先。
    /// - PriceFirst：价格优先，按每小时vCPU单价从低到高排序。
    /// - NewProductFirst：最新产品优先。
    ///
    /// 默认值：InventoryFirst
    #[setters(generate = true, strip_option)]
    priority_strategy: Option<String>,
    /// 按量付费实例或者抢占式实例可接受的每小时最高价格。
    ///
    /// >设置抢占式实例的最高单价时，`SpotStrategy`必须设置为`SpotWithPriceLimit`。
    #[setters(generate = true, strip_option)]
    max_price: Option<f32>,
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 可用区ID。您可以调用[DescribeZones](~~25610~~)查看最新的阿里云可用区列表。
    ///
    /// 建议同时ZoneMatchMode取值为Include（默认值），优先推荐ZoneId指定的可用区中的实例规格，并列出同地域下其他可用区中的实例规格。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 系统盘的云盘种类。取值范围：
    ///
    /// - cloud_efficiency：高效云盘
    /// - cloud_ssd：SSD云盘
    /// - cloud_essd：ESSD云盘
    /// - cloud：普通云盘
    ///
    /// 非I/O优化实例的默认值：cloud
    ///
    /// I/O优化实例的默认值：cloud_efficiency
    #[setters(generate = true, strip_option)]
    system_disk_category: Option<String>,
    /// 是否仅推荐ZoneId指定的可用区中的实例规格。取值范围：
    ///
    /// - Strict：仅推荐ZoneId指定的可用区中的实例规格。
    ///
    /// - Include：推荐同地域下其他可用区中的实例规格。
    ///
    ///
    /// 当指定`ZoneId`时，该参数的默认值为Strict，表示仅推荐ZoneId指定的可用区中的实例规格。
    #[setters(generate = true, strip_option)]
    zone_match_mode: Option<String>,
    /// 在哪种场景下推荐实例规格。取值范围：
    ///
    /// - UPGRADE：升级或降低实例规格。
    /// - CREATE：创建实例。
    ///
    /// 默认值：CREATE
    #[setters(generate = true, strip_option)]
    scene: Option<String>,
    /// 设置备选的实例规格族集合，备选的实例规格会从该参数设置的实例规格族中选择。最多可输入10个实例规格族。
    #[setters(generate = true, strip_option)]
    instance_type_family: Option<Vec<String>>,
}

impl sealed::Bound for DescribeRecommendInstanceType {}

impl DescribeRecommendInstanceType {
    pub fn new(network_type: impl Into<String>, region_id: impl Into<String>) -> Self {
        Self {
            cores: None,
            memory: None,
            instance_family_level: None,
            instance_type: None,
            network_type: network_type.into(),
            instance_charge_type: None,
            spot_strategy: None,
            io_optimized: None,
            priority_strategy: None,
            max_price: None,
            region_id: region_id.into(),
            zone_id: None,
            system_disk_category: None,
            zone_match_mode: None,
            scene: None,
            instance_type_family: None,
        }
    }
}
impl crate::ToFormData for DescribeRecommendInstanceType {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeRecommendInstanceType {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeRecommendInstanceType";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeRecommendInstanceTypeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(16);

        if let Some(f) = &self.cores {
            params.push(("Cores".into(), (f).into()));
        }

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_family_level {
            params.push(("InstanceFamilyLevel".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type_family {
            crate::FlatSerialize::flat_serialize(f, "InstanceTypeFamily", &mut params);
        }

        if let Some(f) = &self.io_optimized {
            params.push(("IoOptimized".into(), (f).into()));
        }

        if let Some(f) = &self.max_price {
            params.push(("MaxPrice".into(), (f).into()));
        }

        if let Some(f) = &self.memory {
            params.push(("Memory".into(), (f).into()));
        }
        params.push(("NetworkType".into(), (&self.network_type).into()));

        if let Some(f) = &self.priority_strategy {
            params.push(("PriorityStrategy".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.scene {
            params.push(("Scene".into(), (f).into()));
        }

        if let Some(f) = &self.spot_strategy {
            params.push(("SpotStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_category {
            params.push(("SystemDiskCategory".into(), (f).into()));
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        if let Some(f) = &self.zone_match_mode {
            params.push(("ZoneMatchMode".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribePrice {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 目标资源的类型。取值范围：
    /// - instance：查询ECS实例的最新价格列表。当取值为`instance`时，必须同时指定参数`InstanceType`。
    /// - disk：查询云盘的最新价格列表。当取值为`disk`时，必须同时指定参数`DataDisk.1.Category`和`DataDisk.1.Size`。
    /// - diskperformance：查询ESSD AutoPL云盘预配置性能的最新价格列表。必须同时指定参数`DataDisk.1.Category`和`DataDisk.1.ProvisionedIops`。
    /// - bandwidth：查询带宽的最新价格列表。
    /// - ddh：查询专有宿主机的最新价格列表。
    /// - ElasticityAssurance：查询弹性保障服务的价格信息。当取值为`ElasticityAssurance`时，必须同时指定参数`InstanceType`。
    /// - CapacityReservation：查询容量预定服务的价格信息。当取值为`CapacityReservation`时，必须同时指定参数`InstanceType`。
    ///
    /// 默认值：instance。
    #[setters(generate = true, strip_option)]
    resource_type: Option<String>,
    /// 仅当参数ResourceType的值为instance时，该参数生效。
    ///
    /// 镜像ID，表示启动实例时希望装载的运行环境。您可以调用[DescribeImages](~~25534~~)查询您可用的镜像资源。如果不指定，默认查询Linux系统镜像的价格。
    #[setters(generate = true, strip_option)]
    image_id: Option<String>,
    /// 实例的资源规格。参数`ResourceType`的值为`instance`时，您必须同时指定该参数。更多详情，请参见[实例规格族](~~25378~~)，也可以调用[DescribeInstanceTypes](~~25620~~)接口获得最新的规格表。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 专有宿主机的规格。您可以调用[DescribeDedicatedHostTypes](~~134240~~)接口获得最新的专有宿主机规格表。
    #[setters(generate = true, strip_option)]
    dedicated_host_type: Option<String>,
    /// 查询的实例是否为I/O优化实例。取值范围：
    ///
    /// - none：非I/O优化。
    /// - optimized：I/O优化。
    ///
    /// 当InstanceType为[系列I](~~55263~~)的规格时，默认值为none。
    ///
    /// 当InstanceType为非[系列I](~~55263~~)的规格时，默认值为optimized。
    #[setters(generate = true, strip_option)]
    io_optimized: Option<String>,
    /// 实例的网络类型。取值范围：
    ///
    /// - classic：实例的网络类型为经典网络（Classic）。
    /// - vpc：实例的网络类型为专有网络（VPC）。
    ///
    /// 默认值：vpc。
    #[setters(generate = true, strip_option)]
    instance_network_type: Option<String>,
    /// 网络带宽计费方式。取值范围：
    ///
    /// - PayByBandwidth：按固定带宽计费。
    /// - PayByTraffic：按带宽流量计费。
    ///
    /// 默认值：PayByTraffic。
    #[setters(generate = true, strip_option)]
    internet_charge_type: Option<String>,
    /// 公网出带宽最大值，单位为Mbit/s（Megabit per second）。取值范围：0~100。
    ///
    /// 默认值：0。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_out: Option<i32>,
    /// 系统盘的云盘种类。取值范围：
    ///
    /// - cloud：普通云盘。
    /// - cloud_efficiency：高效云盘。
    /// - cloud_ssd：SSD云盘。
    /// - ephemeral_ssd：本地SSD盘。
    /// - cloud_essd：ESSD云盘。
    /// - cloud_auto：ESSD AutoPL云盘。
    /// <props="china">
    /// - cloud_essd_entry：ESSD Entry云盘。
    /// </props>
    ///
    /// 参数默认值说明：
    ///
    /// - 当InstanceType为已停售的实例规格，且参数`IoOptimized`取值为`none`时，该参数默认值为`cloud`。
    /// - 其它情况下，该参数默认值为`cloud_efficiency`。
    ///
    /// > 查询系统盘价格时，必须同时指定`ImageId`。
    #[setters(generate = true, strip_option)]
    system_disk_category: Option<String>,
    /// 系统盘大小，单位为GiB。取值范围：
    ///
    /// - 普通云盘：20~500。
    /// - ESSD云盘：
    ///   - PL0：1~2048。
    ///   - PL1：20~2048。
    ///   - PL2：461~2048。
    ///   - PL3：1261~2048。
    /// - ESSD AutoPL 云盘：1~2048。
    /// - 其他云盘类型：20~2048。
    ///
    /// 默认值：max{20, 参数ImageId对应的镜像大小}。
    #[setters(generate = true, strip_option)]
    system_disk_size: Option<i32>,
    /// 系统盘类型为ESSD云盘时，区分性能等级。仅当`SystemDiskCategory=cloud_essd时`该参数有效。取值范围：
    ///
    /// PL0。
    /// PL1（默认）。
    /// PL2。
    /// PL3。
    #[setters(generate = true, strip_option)]
    system_disk_performance_level: Option<String>,
    /// 数据盘容量。
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.Size`参数。
    #[setters(generate = true, strip_option)]
    data_disk1_size: Option<i32>,
    /// 磁盘类型。
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.Category`参数。
    #[setters(generate = true, strip_option)]
    data_disk1_category: Option<String>,
    /// 数据盘的性能等级。
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.PerformanceLevel`参数。
    #[setters(generate = true, strip_option)]
    data_disk1_performance_level: Option<String>,
    /// 数据盘容量。
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.Size`参数。
    #[setters(generate = true, strip_option)]
    data_disk2_size: Option<i32>,
    /// 磁盘类型。
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.Category`参数。
    #[setters(generate = true, strip_option)]
    data_disk2_category: Option<String>,
    /// 数据盘的性能等级
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.PerformanceLevel`参数。
    #[setters(generate = true, strip_option)]
    data_disk2_performance_level: Option<String>,
    /// 数据盘容量。
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.Size`参数。
    #[setters(generate = true, strip_option)]
    data_disk3_size: Option<i32>,
    /// 磁盘类型。
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.Category`参数。
    #[setters(generate = true, strip_option)]
    data_disk3_category: Option<String>,
    /// 数据盘的性能等级。
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.PerformanceLevel`参数。
    #[setters(generate = true, strip_option)]
    data_disk3_performance_level: Option<String>,
    /// 数据盘容量。
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.Size`参数。
    #[setters(generate = true, strip_option)]
    data_disk4_size: Option<i32>,
    /// 磁盘类型。
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.Category`参数。
    #[setters(generate = true, strip_option)]
    data_disk4_category: Option<String>,
    /// 数据盘的性能等级。
    ///
    /// 为提高扩展性，建议您使用`DataDisk.N.PerformanceLevel`参数。
    #[setters(generate = true, strip_option)]
    data_disk4_performance_level: Option<String>,
    /// 云服务器ECS的计费时长。取值范围：
    ///
    /// <props="china">
    /// - 当参数PriceUnit取值为Month时：1~9。
    /// - 当参数PriceUnit取值为Year时：1~5。
    /// - 当参数PriceUnit取值为Hour时：1。
    /// - 当参数PriceUnit取值为Week时：1~4。
    ///
    /// </props>
    ///
    /// <props="intl">
    /// - 当参数PriceUnit取值为Month时：1~9。
    /// - 当参数PriceUnit取值为Year时：1~5。
    /// - 当参数PriceUnit取值为Hour时：1。
    ///
    /// </props>
    ///
    /// 默认值：1。
    ///
    ///
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 查询云服务器ECS不同计费周期的价格。取值范围：
    ///
    /// <props="china">
    /// - Month：按月计费的价格单位。
    /// - Year：按年计费的价格单位。
    /// - Hour（默认）：按小时计费的价格单位。
    /// - Week：按周计费的价格单位。
    ///
    /// </props>
    ///
    /// <props="intl">
    /// - Month：按月计费的价格单位。
    /// - Year：按年计费的价格单位。
    /// - Hour（默认）：按小时计费的价格单位。
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    price_unit: Option<String>,
    /// 查询批量购买某种配置的云服务器ECS的价格。取值范围：1~1000。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    amount: Option<i32>,
    /// 预留实例券的付款类型。取值范围：
    ///
    /// - No Upfront：零预付。
    /// - Partial Upfront：部分预付。
    /// - All Upfront：全预付。
    #[setters(generate = true, strip_option)]
    offering_type: Option<String>,
    /// 在一个实例规格内，需要预留的实例的总数量。
    ///
    /// 取值范围：1~1000。
    #[setters(generate = true, strip_option)]
    instance_amount: Option<i32>,
    /// 预留实例券的范围。取值范围：
    ///    
    /// - Region：地域级别。
    /// - Zone：可用区级别。
    ///
    /// 默认值：Region。
    #[setters(generate = true, strip_option)]
    scope: Option<String>,
    /// 实例使用的镜像的操作系统类型。取值范围：
    /// - Windows：Windows Server类型的操作系统。
    /// - Linux：Linux及类Unix类型的操作系统。
    #[setters(generate = true, strip_option)]
    platform: Option<String>,
    /// 容量大小，单位为GiB。
    #[setters(generate = true, strip_option)]
    capacity: Option<i32>,
    /// 弹性保障的总次数。取值：Unlimited，目前仅支持在服务生效期内的无限次模式。
    ///
    /// 默认值：Unlimited。
    #[setters(generate = true, strip_option)]
    assurance_times: Option<String>,
    /// 弹性保障内支持实例的vCPU总数量。调用API时系统会根据用户指定的InstanceType换算出需要弹性保证内支持实例的数量（向上取整）。
    ///
    /// >当调用API查询弹性保障价格时，参数InstanceCoreCpuCount和InstanceAmount只能指定其中一个。
    #[setters(generate = true, strip_option)]
    instance_cpu_core_count: Option<i32>,
    /// 互联网服务运营商，取值范围：
    /// - cmcc：移动。
    /// - telecom：电信。
    /// - unicom：联通。
    /// - multiCarrier：多线。
    #[setters(generate = true, strip_option)]
    isp: Option<String>,
    /// 实例规格。目前仅支持无限次保障服务设置单个实例规格。
    #[setters(generate = true, strip_option)]
    instance_type_list: Option<Vec<String>>,
    /// 按量付费实例的抢占策略。取值范围：
    /// - NoSpot：正常按量付费实例。
    /// - SpotWithPriceLimit：设置上限价格的抢占式实例。
    /// - SpotAsPriceGo：系统自动出价，最高按量付费价格。
    ///
    /// 默认值：NoSpot。
    ///
    /// > 当`PriceUnit=Hour`、`Period=1`时，该参数才有效。由于`PriceUnit`默认值为`Hour`，`Period`默认值为`1`，因此您在设置该参数值时，无需设置`PriceUnit`和`Period`参数值。
    #[setters(generate = true, strip_option)]
    spot_strategy: Option<SpotStrategy>,
    /// 抢占式实例的保留时长，单位为小时。 默认值：1。取值范围：
    /// - 1：创建后阿里云会保证实例运行1小时不会被自动释放；超过1小时后，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    /// - 0：创建后，阿里云不保证实例运行1小时，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    ///
    /// 实例回收前5分钟阿里云会通过ECS系统事件向您发送通知。抢占式实例按秒计费，建议您结合具体任务执行耗时来选择合适的保留时长。
    ///
    /// > 当SpotStrategy值为SpotWithPriceLimit或SpotAsPriceGo时该参数生效。
    #[setters(generate = true, strip_option)]
    spot_duration: Option<i32>,
    /// 可用区ID。
    ///
    /// > 抢占式实例不同可用区价格可能不同，查询抢占式实例价格时，建议传入ZoneId查询指定可用区的抢占式实例价格。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 数据盘列表集合。
    #[setters(generate = true, strip_option)]
    data_disk: Option<Vec<DescribePriceDataDisk>>,
    /// 仅当参数ResourceType的值为instance时，该参数生效。
    ///
    /// 专有宿主机ID。您可以通过[DescribeDedicatedHosts ](~~134242~~)查询专有宿主机ID列表。
    #[setters(generate = true, strip_option)]
    scheduler_options_dedicated_host_id: Option<String>,
    /// 分时弹性保障服务生效时间。时间格式以 ISO 8601 为标准，需要使用 UTC +0 时间，格式为yyyy-MM-ddTHH:mm:ssZ。更多信息，请参见[ISO 8601](~~25696~~)。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
    /// 弹性保障-分时保障重复规则列表。
    ///
    /// <props="china">
    ///
    /// > 弹性保障-分时保障功能当前仅对部分地域和用户开放，若您有使用需求，请[提交工单](https://selfservice.console.aliyun.com/ticket/createIndex)。
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// > 弹性保障-分时保障功能当前仅对部分地域和用户开放，若您有使用需求，请[提交工单](https://smartservice.console.aliyun.com/service/create-ticket-intl)。
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    recurrence_rules: Option<Vec<PriceRecurrenceRule>>,
    /// 部署集策略。取值范围：
    /// - Availability：高可用策略。
    /// - AvailabilityGroup：部署集组高可用策略。
    /// - LowLatency：网络低时延策略。
    /// - ProximityLooseDispersion：邻近松散部署集策略。
    ///
    /// >仅当策略设置为 ProximityLooseDispersion 时，API响应中会包含 "Resource": "deploymentSet" 对应的价格详情。其他部署集策略免费，故API响应中不会包含"Resource": "deploymentSet" 的价格信息。
    #[setters(generate = true, strip_option)]
    scheduler_options_deployment_set_strategy: Option<String>,
}

impl sealed::Bound for DescribePrice {}

impl DescribePrice {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_type: None,
            image_id: None,
            instance_type: None,
            dedicated_host_type: None,
            io_optimized: None,
            instance_network_type: None,
            internet_charge_type: None,
            internet_max_bandwidth_out: None,
            system_disk_category: None,
            system_disk_size: None,
            system_disk_performance_level: None,
            data_disk1_size: None,
            data_disk1_category: None,
            data_disk1_performance_level: None,
            data_disk2_size: None,
            data_disk2_category: None,
            data_disk2_performance_level: None,
            data_disk3_size: None,
            data_disk3_category: None,
            data_disk3_performance_level: None,
            data_disk4_size: None,
            data_disk4_category: None,
            data_disk4_performance_level: None,
            period: None,
            price_unit: None,
            amount: None,
            offering_type: None,
            instance_amount: None,
            scope: None,
            platform: None,
            capacity: None,
            assurance_times: None,
            instance_cpu_core_count: None,
            isp: None,
            instance_type_list: None,
            spot_strategy: None,
            spot_duration: None,
            zone_id: None,
            data_disk: None,
            scheduler_options_dedicated_host_id: None,
            start_time: None,
            recurrence_rules: None,
            scheduler_options_deployment_set_strategy: None,
        }
    }
}
impl crate::ToFormData for DescribePrice {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribePrice {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribePrice";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribePriceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(44);

        if let Some(f) = &self.amount {
            params.push(("Amount".into(), (f).into()));
        }

        if let Some(f) = &self.assurance_times {
            params.push(("AssuranceTimes".into(), (f).into()));
        }

        if let Some(f) = &self.capacity {
            params.push(("Capacity".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk {
            crate::FlatSerialize::flat_serialize(f, "DataDisk", &mut params);
        }

        if let Some(f) = &self.data_disk1_category {
            params.push(("DataDisk.1.Category".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk1_performance_level {
            params.push(("DataDisk.1.PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk1_size {
            params.push(("DataDisk.1.Size".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk2_category {
            params.push(("DataDisk.2.Category".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk2_performance_level {
            params.push(("DataDisk.2.PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk2_size {
            params.push(("DataDisk.2.Size".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk3_category {
            params.push(("DataDisk.3.Category".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk3_performance_level {
            params.push(("DataDisk.3.PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk3_size {
            params.push(("DataDisk.3.Size".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk4_category {
            params.push(("DataDisk.4.Category".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk4_performance_level {
            params.push(("DataDisk.4.PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk4_size {
            params.push(("DataDisk.4.Size".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_type {
            params.push(("DedicatedHostType".into(), (f).into()));
        }

        if let Some(f) = &self.image_id {
            params.push(("ImageId".into(), (f).into()));
        }

        if let Some(f) = &self.instance_amount {
            params.push(("InstanceAmount".into(), (f).into()));
        }

        if let Some(f) = &self.instance_cpu_core_count {
            params.push(("InstanceCpuCoreCount".into(), (f).into()));
        }

        if let Some(f) = &self.instance_network_type {
            params.push(("InstanceNetworkType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type_list {
            crate::FlatSerialize::flat_serialize(f, "InstanceTypeList", &mut params);
        }

        if let Some(f) = &self.internet_charge_type {
            params.push(("InternetChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_out {
            params.push(("InternetMaxBandwidthOut".into(), (f).into()));
        }

        if let Some(f) = &self.io_optimized {
            params.push(("IoOptimized".into(), (f).into()));
        }

        if let Some(f) = &self.isp {
            params.push(("Isp".into(), (f).into()));
        }

        if let Some(f) = &self.offering_type {
            params.push(("OfferingType".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.platform {
            params.push(("Platform".into(), (f).into()));
        }

        if let Some(f) = &self.price_unit {
            params.push(("PriceUnit".into(), (f).into()));
        }

        if let Some(f) = &self.recurrence_rules {
            crate::FlatSerialize::flat_serialize(f, "RecurrenceRules", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_type {
            params.push(("ResourceType".into(), (f).into()));
        }

        if let Some(f) = &self.scheduler_options_dedicated_host_id {
            params.push(("SchedulerOptions.DedicatedHostId".into(), (f).into()));
        }

        if let Some(f) = &self.scheduler_options_deployment_set_strategy {
            params.push(("SchedulerOptions.DeploymentSetStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.scope {
            params.push(("Scope".into(), (f).into()));
        }

        if let Some(f) = &self.spot_duration {
            params.push(("SpotDuration".into(), (f).into()));
        }

        if let Some(f) = &self.spot_strategy {
            params.push(("SpotStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_category {
            params.push(("SystemDisk.Category".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_performance_level {
            params.push(("SystemDisk.PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_size {
            params.push(("SystemDisk.Size".into(), (f).into()));
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeRenewalPrice {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 查询续费价格的资源类型。取值：instance。
    ///
    /// 默认值：instance。
    #[setters(generate = true, strip_option)]
    resource_type: Option<String>,
    /// 查询续费价格的资源ID。参数`ResourceType`取值为`instance`时，`ResourceId`可以理解为`InstanceId`。
    resource_id: String,
    /// 指定续费时长。取值范围：
    ///
    /// - 当参数`PriceUnit`取值为`Month`时：1~9。
    /// - 当参数`PriceUnit`取值为`Year`时：1~3。
    ///
    /// 默认值：1。
    ///
    /// > 续费时长参数（`Period`、`PeriodUnit`）与统一到期日参数（`ExpectedRenewDay`）不能同时设置。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 指定续费周期。取值范围：
    ///
    /// - Month：续费周期为一个月。
    /// - Year：续费周期为一年。
    ///
    /// 默认值：Month。
    #[setters(generate = true, strip_option)]
    price_unit: Option<String>,
    /// 统一到期日。指定该参数后，将查询实例续费至统一到期日的价格信息。取值范围：1~28。
    ///
    /// 关于统一到期日功能的更多信息，请参见[统一实例到期日](~~108486~~)。
    ///
    /// > 续费时长参数（`Period`、`PeriodUnit`）与统一到期日参数（`ExpectedRenewDay`）不能同时设置。
    #[setters(generate = true, strip_option)]
    expected_renew_day: Option<i32>,
}

impl sealed::Bound for DescribeRenewalPrice {}

impl DescribeRenewalPrice {
    pub fn new(region_id: impl Into<String>, resource_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_type: None,
            resource_id: resource_id.into(),
            period: None,
            price_unit: None,
            expected_renew_day: None,
        }
    }
}
impl crate::ToFormData for DescribeRenewalPrice {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeRenewalPrice {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeRenewalPrice";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeRenewalPriceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.expected_renew_day {
            params.push(("ExpectedRenewDay".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.price_unit {
            params.push(("PriceUnit".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("ResourceId".into(), (&self.resource_id).into()));

        if let Some(f) = &self.resource_type {
            params.push(("ResourceType".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceModificationPrice {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 需要查询升配价格的实例ID。
    instance_id: String,
    /// 实例升配的目标实例规格。建议您先调用[DescribeResourcesModification](~~66187~~)查询指定可用区内可升配的实例规格信息。
    ///
    /// > 查询时，实例规格参数（`InstanceType`）和数据盘参数（`DataDisk.N.*`）不得同时为空，必须至少指定一个。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 系统盘类型。仅当从已停售的实例规格升配至在售实例规格，并将非I/O优化实例规格升级为I/O优化实例规格时，才需要传入参数值。关于实例规格的更多信息，请参见[实例规格族](~~25378~~)以及[已停售的实例规格](~~55263~~)。
    ///
    /// 取值范围：
    ///
    /// - cloud_efficiency：高效云盘。
    /// - cloud_ssd：SSD云盘。
    ///
    /// 默认值：无。
    #[setters(generate = true, strip_option)]
    system_disk_category: Option<String>,
    /// 数据盘类型信息。
    #[setters(generate = true, strip_option)]
    data_disk: Option<Vec<ModificationPriceDataDisk>>,
}

impl sealed::Bound for DescribeInstanceModificationPrice {}

impl DescribeInstanceModificationPrice {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
            instance_type: None,
            system_disk_category: None,
            data_disk: None,
        }
    }
}
impl crate::ToFormData for DescribeInstanceModificationPrice {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceModificationPrice {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceModificationPrice";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceModificationPriceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.data_disk {
            crate::FlatSerialize::flat_serialize(f, "DataDisk", &mut params);
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.system_disk_category {
            params.push(("SystemDisk.Category".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RunInstances {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 镜像ID，启动实例时选择的镜像资源。您可以通过[DescribeImages](~~25534~~)查询您可以使用的镜像资源。如果您不指定`LaunchTemplateId`或`LaunchTemplateName`以确定启动模板，也不通过指定`ImageFamily`选用镜像族系最新可用镜像，则`ImageId`为必选参数。
    #[setters(generate = true, strip_option)]
    image_id: Option<String>,
    /// 镜像族系名称，通过设置该参数来获取当前镜像族系内最新可用镜像来创建实例。
    ///
    /// 镜像族系的名称长度为2~128个字符。镜像族系名称不能以特殊字符、数字、http://、https://开头，只可包含特殊字符中的"."、"_"、"-"和":"。
    ///
    /// 您需要注意：
    ///
    /// - 设置了参数`ImageId`，则不能设置该参数。
    /// - 未设置参数`ImageId`，但指定的`LaunchTemplateId`或`LaunchTemplateName`对应的启动模板设置了`ImageId`，则不能设置该参数。
    /// - 未设置`ImageId`，且指定的`LaunchTemplateId`或`LaunchTemplateName`对应的启动模板未设置`ImageId`，则可以设置该参数。
    /// - 未设置`ImageId`，且未设置`LaunchTemplateId`、`LaunchTemplateName`参数，则可以设置该参数。
    /// > 阿里云官方镜像关联的镜像族系信息请参见[公共镜像概述](~~108393~~)。
    #[setters(generate = true, strip_option)]
    image_family: Option<String>,
    /// 实例的资源规格。如果您不指定`LaunchTemplateId`或`LaunchTemplateName`以确定启动模板，`InstanceType`为必选参数。  
    ///
    /// - 产品选型：参见[实例规格族](~~25378~~)或调用[DescribeInstanceTypes](~~25620~~)查看目标实例规格的性能数据，或者参见[选型配置](~~58291~~)了解如何选择实例规格。
    /// - 查询库存：调用[DescribeAvailableResource](~~66186~~)查看指定地域或者可用区内的资源供给情况。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 新创建实例所属于的安全组ID。同一个安全组内的实例之间可以互相访问，一个安全组能容纳的实例数量视安全组类型而定，具体请参见[使用限制](~~25412#SecurityGroupQuota~~)的安全组章节。
    ///
    /// > `SecurityGroupId`决定了实例的网络类型，例如，如果设置的安全组的网络类型为专有网络VPC，实例则为VPC类型，并同时需要指定参数`VSwitchId`。
    ///
    /// 如果您不设置`LaunchTemplateId`或`LaunchTemplateName`以确定实例启动模板，则安全组ID为必选参数。您需要注意：
    ///
    /// - 您可以通过`SecurityGroupId`设置一个安全组，也可以通过`SecurityGroupIds.N`设置一个或多个安全组，但不支持同时设置`SecurityGroupId`和`SecurityGroupIds.N`。
    ///
    /// - 如果`NetworkInterface.N.InstanceType`取值为`Primary`，则不能设置`SecurityGroupId`或`SecurityGroupIds.N`，只能设置`NetworkInterface.N.SecurityGroupId`或`NetworkInterface.N.SecurityGroupIds.N`。
    #[setters(generate = true, strip_option)]
    security_group_id: Option<String>,
    /// 虚拟交换机ID。如果您创建的是VPC类型ECS实例，必须指定虚拟交换机ID，且安全组和虚拟交换机在同一个专有网络VPC中。您可以调用[DescribeVSwitches](~~35748~~)查询已创建的交换机的相关信息。
    ///
    /// 您需要注意：
    ///
    /// - 如果您设置了`VSwitchId`参数，则设置的`ZoneId`参数必须和交换机所在的可用区保持一致。您也可以不设置`ZoneId`参数，系统将自动选择指定交换机所在的可用区。
    ///
    /// - 如果`NetworkInterface.N.InstanceType`取值为`Primary`，则不能设置`VSwitchId`，只能设置`NetworkInterface.N.VSwitchId`。
    #[setters(generate = true, strip_option)]
    v_switch_id: Option<String>,
    /// 实例名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文等）和数字。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。默认值为实例的`InstanceId`。
    ///
    /// 创建多台ECS实例时，您可以批量设置有序的实例名称，并且可以包含方括号（[]）和逗号（,）。具体操作，请参见[批量设置有序的实例名称或主机名称](~~196048~~)。
    #[setters(generate = true, strip_option)]
    instance_name: Option<String>,
    /// 实例的描述。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 公网入带宽最大值，单位为Mbit/s。取值范围：
    ///
    /// - 当所购公网出带宽小于等于10 Mbit/s时：1~10，默认为10。
    /// - 当所购公网出带宽大于10 Mbit/s时：1~`InternetMaxBandwidthOut`的取值，默认为`InternetMaxBandwidthOut`的取值。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_in: Option<i32>,
    /// 公网出带宽最大值，单位为Mbit/s。取值范围：0~100。
    ///
    /// 默认值：0。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_out: Option<i32>,
    /// 实例主机名称。限制说明如下：
    ///
    /// - 半角句号（.）和短划线（-）不能作为首尾字符，更不能连续使用。
    /// - Windows实例：字符长度为2~15，不支持半角句号（.），不能全是数字。允许包含大小写英文字母、数字和短划线（-）。
    /// - 其他类型实例（Linux等）：
    ///     - 字符长度为2~64，支持多个半角句号（.），点之间为一段，每段允许包含大小写英文字母、数字和短划线（-）。
    ///     - 支持通过占位符`${instance_id}`将实例ID写入`HostName`参数。例如：`HostName=k8s-${instance_id}`，并且创建的ECS实例ID为`i-123abc****`，则该实例的主机名为`k8s-i-123abc****`。
    ///
    /// 创建多台ECS实例时，您可以：
    ///
    /// - 批量设置有序的主机名。具体操作，请参见[批量设置有序的实例名称或主机名称](~~196048~~)。
    /// - 通过`HostNames.N`参数，为多台实例分别设置主机名。需要注意`HostName`参数和`HostNames.N`参数不能同时设置。
    #[setters(generate = true, strip_option)]
    host_name: Option<String>,
    /// 当创建多台实例时，是否为`HostName`和`InstanceName`自动添加有序后缀。有序后缀从001开始递增，最大不能超过999。取值范围：
    /// - true：添加。
    /// - false：不添加。
    ///
    /// 默认值：false。
    ///
    /// 当`HostName`或`InstanceName`按照指定排序格式设置，未设置命名后缀`name_suffix`，即命名格式为`name_prefix[begin_number,bits]`时，`UniqueSuffix`不生效，名称仅按照指定顺序排序。
    ///
    /// 更多信息，请参见[批量设置有序的实例名称或主机名称](~~196048~~)。
    #[setters(generate = true, strip_option)]
    unique_suffix: Option<bool>,
    /// 实例的密码。长度为8至30个字符，必须同时包含大小写英文字母、数字和特殊符号中的三类字符。特殊符号可以是：
    ///
    /// ```ignore
    /// ()`~!@#$%^&*-_+=|{}[]:;'<>,.?/
    /// ```
    ///
    /// 其中，Windows实例不能以正斜线（/）为密码首字符。
    ///
    /// > 如果传入`Password`参数，建议您使用HTTPS协议发送请求，避免密码泄露。
    #[setters(generate = true, strip_option)]
    password: Option<String>,
    /// 是否使用镜像预设的密码。取值范围：
    ///
    /// - true：使用。
    /// - false：不使用。
    ///
    /// 默认值：false。
    ///
    /// > 使用该参数时，Password参数必须为空，同时您需要确保使用的镜像已经设置了密码。
    #[setters(generate = true, strip_option)]
    password_inherit: Option<bool>,
    /// 实例所属的可用区ID，您可以调用[DescribeZones](~~25610~~)获取可用区列表。
    ///
    /// > 如果您指定了`VSwitchId`参数，则指定的`ZoneId`参数必须和交换机所在的可用区保持一致。您也可以不指定`ZoneId`参数，系统将自动选择指定的交换机所在的可用区。
    ///
    /// 默认值：系统自动选择。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 网络计费类型。取值范围：
    ///
    /// - PayByBandwidth：按固定带宽计费。
    /// - PayByTraffic：按使用流量计费。
    ///
    /// 默认值：PayByTraffic。
    ///
    /// > **按使用流量计费**模式下的出入带宽峰值都是带宽上限，不作为业务承诺指标。当出现资源争抢时，带宽峰值可能会受到限制。如果您的业务需要有带宽的保障，请使用**按固定带宽计费**模式。
    #[setters(generate = true, strip_option)]
    internet_charge_type: Option<String>,
    /// 系统盘大小，单位为GiB。取值范围：
    ///
    /// - 普通云盘：20~500。
    /// - ESSD云盘：
    ///   - PL0：1~2048。
    ///   - PL1：20~2048。
    ///   - PL2：461~2048。
    ///   - PL3：1261~2048。
    /// - ESSD AutoPL 云盘：1~2048。
    /// - 其他云盘类型：20~2048。
    ///
    /// 该参数的取值必须大于或者等于 max{1, ImageSize}。
    ///
    /// 默认值：max{40, 参数ImageId对应的镜像大小}。
    #[setters(generate = true, strip_option)]
    system_disk_size: Option<String>,
    /// 系统盘的云盘种类。取值范围：
    ///
    /// - cloud_efficiency：高效云盘。
    /// - cloud_ssd：SSD云盘。
    /// - cloud_essd：ESSD云盘。
    /// - cloud：普通云盘。
    /// - cloud_auto：ESSD AutoPL云盘。
    /// - cloud_essd_entry：ESSD Entry云盘。
    /// >仅当`InstanceType`设置为[通用算力型实例规格族u1](~~457079~~)（`ecs.u1`）或[经济型实例规格族e](~~108489~~)（`ecs.e`）时，该参数支持取`cloud_essd_entry`值。
    ///
    /// 已停售的实例规格且非I/O优化实例默认值为cloud，否则默认值为cloud_efficiency。
    #[setters(generate = true, strip_option)]
    system_disk_category: Option<String>,
    /// 系统盘名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    system_disk_disk_name: Option<String>,
    /// 系统盘的描述。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    #[setters(generate = true, strip_option)]
    system_disk_description: Option<String>,
    /// 创建ESSD云盘作为系统盘使用时，设置云盘的性能等级。取值范围：
    ///
    /// - PL0：单盘最高随机读写IOPS 1万。
    /// - PL1（默认）：单盘最高随机读写IOPS 5万。
    /// - PL2：单盘最高随机读写IOPS 10万。
    /// - PL3：单盘最高随机读写IOPS 100万。
    ///
    /// 有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。
    #[setters(generate = true, strip_option)]
    system_disk_performance_level: Option<String>,
    /// 系统盘采用的自动快照策略ID。
    #[setters(generate = true, strip_option)]
    system_disk_auto_snapshot_policy_id: Option<String>,
    /// 是否为I/O优化实例。[已停售的实例规格](~~55263~~)实例默认值是none，其他实例规格默认值是optimized。取值范围：
    ///
    /// - none：非I/O优化。
    /// - optimized：I/O优化。
    #[setters(generate = true, strip_option)]
    io_optimized: Option<String>,
    /// 实例自定义数据。必须填写已采用Base64编码后的数据，且在进行Base64编码前自定义数据内容的大小不能超过32 KB。
    ///
    /// 有关实例自定义数据的使用限制、格式以及运行频率的详细信息，请参见[实例自定义数据](~~49121~~)。
    ///
    /// >为保证传输过程中UserData的安全性，请避免直接以明文形式传送敏感数据，如密码和私钥。若需传送此类信息，建议先行加密处理，并采用Base64编码方式，随后在实例内部进行解密以确保信息安全。
    #[setters(generate = true, strip_option)]
    user_data: Option<String>,
    /// 密钥对名称。
    /// >Windows实例，忽略该参数。默认为空。即使填写了该参数，仍旧只执行`Password`的内容。
    #[setters(generate = true, strip_option)]
    key_pair_name: Option<String>,
    /// 实例RAM角色名称。您可以使用RAM API [ListRoles](~~28713~~)查询您已创建的实例RAM角色。
    #[setters(generate = true, strip_option)]
    ram_role_name: Option<String>,
    /// 指定创建ECS实例的数量。取值范围：1~100。
    ///
    /// 创建成功的ECS数量与指定的Amount和minAmount数量有关：
    ///
    /// - 不指定minAmount时：按照Amount数量创建，库存不满足则API返回创建失败，同时一台也不会创建。
    ///
    /// - 指定minAmount时：
    ///   - 当ECS库存数量＜minAmount：不会创建ECS，同时API返回创建失败。
    ///   - 当minAmount≤ECS库存数量＜Amount，按照库存数量创建实例，API返回创建成功。
    ///   - 当ECS库存数量≥Amount，按照指定的Amount创建，API返回创建成功。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    amount: Option<i32>,
    /// 指定ECS实例最小购买数量。取值范围：1~100。
    ///
    /// 创建成功的ECS数量与指定的Amount和minAmount数量有关：
    ///
    /// - 不指定minAmount时：按照Amount数量创建，库存不满足则API返回创建失败，同时一台也不会创建。
    ///
    /// - 指定minAmount时：
    ///   - 当ECS库存数量＜minAmount：不会创建ECS，同时API返回创建失败。
    ///   - 当minAmount≤ECS库存数量＜Amount，按照库存数量创建实例，API返回创建成功。
    ///   - 当ECS库存数量≥Amount，按照指定的Amount创建，API返回创建成功。
    #[setters(generate = true, strip_option)]
    min_amount: Option<i32>,
    /// 按量付费实例的自动释放时间。按照[ISO 8601](~~25696~~)标准表示，使用UTC+0时间。格式为：`yyyy-MM-ddTHH:mm:ssZ`。
    ///
    /// - 如果秒（`ss`）取值不是`00`，则自动取为当前分钟（`mm`）开始时。
    ///
    /// - 最短释放时间为当前时间半小时之后。
    ///
    /// - 最长释放时间不能超过当前时间三年。
    #[setters(generate = true, strip_option)]
    auto_release_time: Option<String>,
    /// 按量付费实例的竞价策略。当参数`InstanceChargeType`取值为`PostPaid`时生效。取值范围：
    ///
    /// - NoSpot：正常按量付费实例。
    /// - SpotWithPriceLimit：设置上限价格的抢占式实例。
    /// - SpotAsPriceGo：系统自动出价，跟随当前市场实际价格。
    ///
    /// 默认值：NoSpot。
    #[setters(generate = true, strip_option)]
    spot_strategy: Option<String>,
    /// 抢占式实例的保留时长，单位为小时。 取值：
    /// - 1：创建后阿里云会保证实例运行1小时不会被自动释放；超过1小时后，系统会实时比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    /// - 0：创建后，阿里云不保证实例运行时长，系统会实时比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    ///
    /// 默认值：1。
    /// >
    /// > - 该参数目前只支持设置为0或1。
    /// > - 抢占式实例按秒计费，建议您结合具体任务执行耗时来选择合适的保留时长。
    /// > - 实例回收前5分钟阿里云会通过ECS系统事件向您发送通知。
    #[setters(generate = true, strip_option)]
    spot_duration: Option<i32>,
    /// 设置实例的每小时最高价格。支持最大3位小数，参数`SpotStrategy`取值为`SpotWithPriceLimit`时生效。
    #[setters(generate = true, strip_option)]
    spot_price_limit: Option<f32>,
    /// 抢占实例中断模式。取值范围：
    ///
    /// - Terminate：直接释放实例。
    /// - Stop：实例进入节省停机模式。
    ///
    ///   关于节省停机模式的更多说明，请参见[按量付费实例节省停机模式](~~63353~~)。
    ///
    /// 默认值：Terminate。
    #[setters(generate = true, strip_option)]
    spot_interruption_behavior: Option<String>,
    /// 是否开启安全加固。取值范围：
    ///
    /// - Active：启用安全加固，只对公共镜像生效。
    /// - Deactive：不启用安全加固，对所有镜像类型生效。
    #[setters(generate = true, strip_option)]
    security_enhancement_strategy: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 实例所属的HPC集群ID。
    ///
    /// 创建SCC实例时，该参数为必选参数。您可以参考[CreateHpcCluster](~~109138~~)创建HPC集群。
    #[setters(generate = true, strip_option)]
    hpc_cluster_id: Option<String>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// -  true：发送检查请求，不会创建实例。检查项包括是否填写了必需参数、请求格式、业务限制和ECS库存。如果检查不通过，则返回对应错误。如果检查通过，则返回错误码`DryRunOperation`。
    /// -  false（默认）：发送正常请求，通过检查后直接创建实例。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 专有宿主机ID。
    /// <props="china">您可以通过[DescribeDedicatedHosts](~~134242~~)查询专有宿主机ID列表。</props>
    ///
    /// <props="intl">您可以通过[DescribeDedicatedHosts](~~134242~~)查询专有宿主机ID列表。</props>
    ///
    /// ><notice>专有宿主机不支持创建抢占式实例，指定`DedicatedHostId`参数后，会自动忽略请求中的`SpotStrategy`和`SpotPriceLimit`设置。></notice>
    #[setters(generate = true, strip_option)]
    dedicated_host_id: Option<String>,
    /// 启动模板ID。更多信息，请调用[DescribeLaunchTemplates](~~73759~~)。
    ///
    /// 使用启动模板创建实例时，您必须指定`LaunchTemplateId`或`LaunchTemplateName`确定启动模板。
    #[setters(generate = true, strip_option)]
    launch_template_id: Option<String>,
    /// 启动模板名称。
    ///
    /// 使用启动模板创建实例时，您必须指定`LaunchTemplateId`或`LaunchTemplateName`确定启动模板。
    #[setters(generate = true, strip_option)]
    launch_template_name: Option<String>,
    /// 启动模板版本。如果您指定了`LaunchTemplateId`或`LaunchTemplateName`而不指定启动模板版本号，则采用默认版本。
    #[setters(generate = true, strip_option)]
    launch_template_version: Option<i64>,
    /// 实例所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 购买资源的时长，单位由`PeriodUnit`指定。当参数`InstanceChargeType`取值为`PrePaid`时才生效且为必选值。一旦指定了`DedicatedHostId`，则取值范围不能超过专有宿主机的订阅时长。取值范围：
    ///
    /// <props="china">
    /// - PeriodUnit=Week时，Period取值：1、2、3、4。
    /// - PeriodUnit=Month时，Period取值：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
    ///
    /// </props>
    ///
    /// <props="intl">PeriodUnit=Month时，Period取值：1、2、3、4、5、6、7、8、9、12、24、36、48、60。</props>
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 包年包月计费方式的时长单位。取值范围：
    ///
    /// <props="china">
    /// - Week。
    /// - Month（默认）。
    ///
    /// </props>
    ///
    /// <props="intl">Month（默认）。</props>
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 是否要自动续费。当参数`InstanceChargeType`取值`PrePaid`时才生效。取值范围：
    ///
    /// - true：自动续费。
    /// - false：不自动续费。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    auto_renew: Option<bool>,
    /// 单次自动续费的续费时长。取值范围：
    ///          
    /// <props="china">
    /// - PeriodUnit=Week时：1、2、3。
    /// - PeriodUnit=Month时：1、2、3、6、12、24、36、48、60。
    ///
    /// </props>
    ///
    /// <props="intl">PeriodUnit=Month时：1、2、3、6、12、24、36、48、60。</props>
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    auto_renew_period: Option<i32>,
    /// 实例的付费方式。取值范围：
    ///
    /// -  PrePaid：包年包月。
    /// -  PostPaid：按量付费。
    ///
    /// 默认值：PostPaid。
    ///
    /// <props="china">选择包年包月时，您必须确认自己的账号支持余额支付或者信用支付，否则将返回`InvalidPayMethod`的错误提示。</props>
    ///
    /// <props="intl">选择包年包月时，您必须确认自己的账号支持信用支付，否则将返回`InvalidPayMethod`的错误提示。</props>
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 部署集ID。
    #[setters(generate = true, strip_option)]
    deployment_set_id: Option<String>,
    /// 如果您设置的部署集对应的策略为部署集组高可用策略（AvailabilityGroup），可以通过该参数指定实例在部署集中的分组号。取值范围：1~7。
    #[setters(generate = true, strip_option)]
    deployment_set_group_no: Option<i32>,
    /// 实例私网IP地址。专有网络VPC类型ECS实例设置私网IP地址时，必须从虚拟交换机（`VSwitchId`）的空闲网段中选择。
    ///
    /// 您需要注意：
    ///
    /// - 设置`PrivateIpAddress`后：
    ///     - 如果`Amount`参数取值为1，则表示为创建的一台ECS实例分配私网IP地址。
    ///     - 如果`Amount`参数取值大于1，则表示在批量创建ECS实例时，以指定的私网IP地址为起始地址，依次为多台ECS实例分配连续的私网IP地址，但需要注意，此时不支持再为实例绑定辅助网卡（即不支持再设置`NetworkInterface.N.*`这类参数）。
    ///
    /// -  如果`NetworkInterface.N.InstanceType`取值为`Primary`，则不能设置`PrivateIpAddress`，只能设置`NetworkInterface.N.PrimaryIpAddress`。
    ///
    /// >每个交换机的第1个和最后3个IP地址为系统保留地址，不支持指定。
    /// 例如，交换机的网段为192.168.1.0/24，则192.168.1.0、192.168.1.253、192.168.1.254和192.168.1.255这4个地址是系统保留地址。
    #[setters(generate = true, strip_option)]
    private_ip_address: Option<String>,
    /// 设置突发性能实例的运行模式。取值范围：
    ///
    /// - Standard：标准模式，实例性能请参见[什么是突发性能实例](~~59977~~)下的性能约束模式章节。
    /// - Unlimited：无性能约束模式，实例性能请参见[什么是突发性能实例](~~59977~~)下的无性能约束模式章节。
    #[setters(generate = true, strip_option)]
    credit_specification: Option<String>,
    /// 为主网卡指定随机生成的IPv6地址数量。取值范围：1~10。
    ///          
    /// 您需要注意：
    ///
    /// - 您不能同时设置`Ipv6Address.N`和`Ipv6AddressCount`。
    ///
    /// - 如果`NetworkInterface.N.InstanceType`取值为`Primary`，则不能设置`Ipv6Address.N`或`Ipv6AddressCount`，只能设置`NetworkInterface.N.Ipv6Address.N`或`NetworkInterface.N.Ipv6AddressCount`。
    #[setters(generate = true, strip_option)]
    ipv6_address_count: Option<i32>,
    /// 主网卡队列数。您需要注意：
    ///
    /// - 不能超过实例规格允许的单块网卡最大队列数。
    ///
    /// - 实例的所有网卡累加队列数不能超过实例规格允许的队列数总配额。实例规格的单块网卡最大队列数和总配额可以通过[DescribeInstanceTypes](~~25620~~)接口查询`MaximumQueueNumberPerEni`、`TotalEniQueueQuantity`字段。
    ///
    /// - 如果`NetworkInterface.N.InstanceType`取值为`Primary`，则不能设置`NetworkInterfaceQueueNumber`，只能设置`NetworkInterface.N.QueueNumber`。
    #[setters(generate = true, strip_option)]
    network_interface_queue_number: Option<i32>,
    /// 实例释放保护属性，指定是否支持通过控制台或API（[DeleteInstance](~~25507~~)）释放实例。取值范围：
    ///
    /// -  true：开启实例释放保护。
    /// -  false：关闭实例释放保护。
    ///
    /// 默认值：false。
    ///
    /// > 该属性仅适用于按量付费实例，且只能限制手动释放操作，对系统释放操作不生效。
    #[setters(generate = true, strip_option)]
    deletion_protection: Option<bool>,
    /// >该参数正在邀测中，暂未开放使用。
    #[setters(generate = true, strip_option)]
    hibernation_options_configured: Option<bool>,
    /// 专有宿主机实例是否与专有宿主机关联。取值范围：
    ///
    /// - default：实例不与专有宿主机关联。已启用节省停机模式的实例，停机后再次启动时，若原专有宿主机可用资源不足，则实例被放置在自动部署资源池的其它专有宿主机上。
    ///
    /// - host：实例与专有宿主机关联。已启用节省停机模式的实例，停机后再次启动时，仍放置在原专有宿主机上。若原专有宿主机可用资源不足，则实例重启失败。
    ///
    /// 默认值：default。
    #[setters(generate = true, strip_option)]
    affinity: Option<String>,
    /// 是否在专有宿主机上创建实例。取值范围：
    ///
    /// - default：创建非专有宿主机实例。
    ///
    /// - host：创建专有宿主机实例。若您不指定`DedicatedHostId`，则由阿里云自动选择专有宿主机放置实例。
    ///
    /// 默认值：default。
    #[setters(generate = true, strip_option)]
    tenancy: Option<String>,
    /// 存储集ID。
    #[setters(generate = true, strip_option)]
    storage_set_id: Option<String>,
    /// 存储集中的最大分区数量。取值范围：大于等于1。
    #[setters(generate = true, strip_option)]
    storage_set_partition_number: Option<i32>,
    /// CPU核心数。
    ///
    /// <props="china">默认值：请参见[自定义CPU选项](~~145895~~)。</props>
    #[setters(generate = true, strip_option)]
    cpu_options_core: Option<i32>,
    /// CPU线程数。ECS实例的vCPU数=`CpuOptions.Core`取值*`CpuOptions.ThreadsPerCore`取值。
    ///
    /// - `CpuOptions.ThreadsPerCore=1`表示关闭CPU超线程。
    ///
    /// - 仅部分实例规格支持设置CPU线程数。
    ///
    /// <props="china">取值范围和默认值：请参见[自定义CPU选项](~~145895~~)。</props>
    #[setters(generate = true, strip_option)]
    cpu_options_threads_per_core: Option<i32>,
    /// 该参数已弃用。
    #[setters(generate = true, strip_option)]
    cpu_options_numa: Option<String>,
    /// 实例的Cpu拓扑类型。取值范围：
    ///
    /// - ContinuousCoreToHTMapping：当选择`ContinuousCoreToHTMapping`时，实例的Cpu拓扑中，实例的同一个Core的HT是连续的。
    /// - DiscreteCoreToHTMapping：当选择`DiscreteCoreToHTMapping`时，实例的同一个Core的HT是离散的。
    ///
    /// 默认值：无。
    ///
    /// >仅部分实例规格族支持使用本参数，具体支持实例规格族请参见[查看和修改CPU拓扑结构](~~2636059~~)。
    #[setters(generate = true, strip_option)]
    cpu_options_topology_type: Option<String>,
    /// 可信系统模式。取值：vTPM。
    ///
    /// 目前，可信系统模式支持的实例规格族：
    /// - g7、c7、r7。
    /// - 安全增强型（g7t、c7t、r7t）。
    ///
    /// 当您创建以上实例规格族的ECS实例时，需要设置该参数。具体说明如下：
    ///
    /// - 如果您使用阿里云可信系统，请将该参数值设置为vTPM，在实例启动时即可通过阿里云可信系统完成可信校验。
    /// - 如果您不使用阿里云可信系统，可以不设置该参数值，但您需要注意，如果您所创建的ECS实例使用了Enclave机密计算模式（`SecurityOptions.ConfidentialComputingMode=Enclave`），则该ECS实例也会启用可信系统。
    /// - 通过OpenAPI创建可信系统的ECS实例时，只能调用`RunInstances`实现，`CreateInstance`目前不支持设置`SecurityOptions.TrustedSystemMode`参数。
    /// >如果您在创建实例的时候指定其为可信实例，那么当您更换系统盘时只能使用支持可信系统的镜像。
    ///
    /// 关于可信系统的更多信息，请参见[安全增强型实例可信功能概述](~~201394~~)。
    #[setters(generate = true, strip_option)]
    security_options_trusted_system_mode: Option<String>,
    /// 机密计算模式。取值：Enclave。
    ///
    /// 该参数取值为Enclave时，表示ECS实例使用Enclave构建机密计算环境。目前仅实例规格族c7、g7、r7，支持调用`RunInstances`时指定该参数使用Enclave机密计算。您需要注意：
    ///
    /// - 机密计算功能正在邀测中。
    ///
    /// - 通过OpenAPI创建Enclave机密计算的ECS实例时，只能调用`RunInstances`实现，`CreateInstance`目前不支持设置`SecurityOptions.ConfidentialComputingMode`参数。
    ///
    /// - Enclave机密计算依托可信系统（vTPM）实现，当您指定ECS实例使用Enclave构建机密计算环境时，该实例同时也会启用可信系统。因此，调用该接口时，如果设置了`SecurityOptions.ConfidentialComputingMode=Enclave`，则无论您是否设置了`SecurityOptions.TrustedSystemMode=vTPM`，最终创建的ECS实例均会启用Enclave机密计算模式以及可信系统。
    ///
    /// 关于机密计算的更多信息，请参见[使用Enclave构建机密计算环境](~~203433~~)。
    #[setters(generate = true, strip_option)]
    security_options_confidential_computing_mode: Option<String>,
    /// 是否启用实例元数据的访问通道。取值范围：
    /// - enabled：启用。
    /// - disabled：禁用。
    ///
    /// 默认值：enabled。
    /// >有关实例元数据的信息，请参见[实例元数据概述](~~49122~~)。
    #[setters(generate = true, strip_option)]
    http_endpoint: Option<String>,
    /// 访问实例元数据时是否强制使用加固模式（IMDSv2）。取值范围：
    /// - optional：不强制使用。
    /// - required：强制使用。设置该取值后，普通模式无法访问实例元数据。
    ///
    /// 默认值：optional。
    /// >有关访问实例元数据的模式，请参见[实例元数据访问模式](~~150575~~)。
    #[setters(generate = true, strip_option)]
    http_tokens: Option<String>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    http_put_response_hop_limit: Option<i32>,
    /// 实例启动的私有池容量选项。弹性保障服务或容量预定服务在生效后会生成私有池容量，供实例启动时选择。取值范围：
    ///
    /// - Open：开放模式。将自动匹配开放类型的私有池容量。如果没有符合条件的私有池容量，则使用公共池资源启动。该模式下无需设置`PrivatePoolOptions.Id`参数。
    /// - Target：指定模式。使用指定的私有池容量启动实例，如果该私有池容量不可用，则实例会启动失败。该模式下必须指定私有池ID，即`PrivatePoolOptions.Id`参数为必填项。
    /// - None：不使用模式。实例启动将不使用私有池容量。
    ///
    /// 默认值：None。
    ///
    /// 以下任一场景，实例启动的私有池容量选项只能取值`None`或不传值。
    /// - 创建抢占式实例。
    /// - 创建经典网络类型的ECS实例。
    /// - 在专有宿主机DDH上创建ECS实例。
    #[setters(generate = true, strip_option)]
    private_pool_options_match_criteria: Option<String>,
    /// 私有池ID。即弹性保障服务ID或容量预定服务ID。
    #[setters(generate = true, strip_option)]
    private_pool_options_id: Option<String>,
    /// >该参数正在邀测中，暂未开放使用。
    #[setters(generate = true, strip_option)]
    isp: Option<String>,
    /// 指定ECS实例所属的专有宿主机集群，系统会自动选择该专有宿主机集群中的一台专有宿主机部署ECS实例。
    ///
    /// > 仅在`Tenancy`设置为`host`时生效。
    ///
    /// 在您同时指定了专有宿主机（`DedicatedHostId`）和专有宿主机集群（`SchedulerOptions.DedicatedHostClusterId`）时：
    /// - 如果专有宿主机属于专有宿主机集群，则优先将ECS实例部署在指定的专有宿主机上。
    /// - 如果专有宿主机不属于专有宿主机集群，则ECS实例创建失败。
    ///
    /// <props="china">您可以通过[DescribeDedicatedHostClusters](~~184145~~)查询专有宿主机集群ID列表。</props>
    ///
    /// <props="intl">您可以通过[DescribeDedicatedHostClusters](~~184145~~)查询专有宿主机集群ID列表。</props>
    ///
    /// <props="partner">您可以通过[DescribeDedicatedHostClusters](~~184145~~)查询专有宿主机集群ID列表。</props>
    #[setters(generate = true, strip_option)]
    scheduler_options_dedicated_host_cluster_id: Option<String>,
    /// 将实例同时加入多个安全组。N的取值范围与实例能够加入安全组配额有关。更多信息，请参见[安全组限制](~~101348~~)。
    ///
    /// 您需要注意：
    ///
    /// - 不支持同时设置`SecurityGroupId`和`SecurityGroupIds.N`。
    /// - 如果`NetworkInterface.N.InstanceType`取值为`Primary`，则不能设置`SecurityGroupId`或`SecurityGroupIds.N`，只能设置`NetworkInterface.N.SecurityGroupId`或`NetworkInterface.N.SecurityGroupIds.N`。
    #[setters(generate = true, strip_option)]
    security_group_ids: Option<Vec<String>>,
    /// 创建多台实例时，为每台实例指定不同的主机名。
    #[setters(generate = true, strip_option)]
    host_names: Option<Vec<String>>,
    /// 数据盘信息集合列表。
    #[setters(generate = true, strip_option)]
    data_disk: Option<Vec<InstancesDataDisk>>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    arn: Option<Vec<InstancesArn>>,
    /// 弹性网卡信息。
    #[setters(generate = true, strip_option)]
    network_interface: Option<Vec<InstancesNetworkInterface>>,
    /// 实例、云盘和主网卡的标签信息。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<RunInstancesTag>>,
    /// 为主网卡指定一个或多个IPv6地址。支持设置最多10个IPv6地址，即N的取值范围：1~10。
    ///
    /// 取值示例：`Ipv6Address.1=2001:db8:1234:1a00::***`。
    ///
    /// 您需要注意：
    ///
    /// - 设置了`Ipv6Address.N`时，`Amount`参数取值只能为1，且不能同时设置`Ipv6AddressCount`。
    ///
    /// - 如果`NetworkInterface.N.InstanceType`取值为`Primary`，则不能设置`Ipv6Addresses.N`或`Ipv6AddressCount`，而是需要设置`NetworkInterface.N.Ipv6Addresses.N`或`NetworkInterface.N.Ipv6AddressCount`。
    #[setters(generate = true, strip_option)]
    ipv6_address: Option<Vec<String>>,
    /// 系统盘相关参数，目前专属块存储集群ID（`StorageClusterId`）需要通过该参数设置参数值。
    #[setters(generate = true, strip_option)]
    system_disk: Option<InstancesSystemDisk>,
    /// 镜像相关属性信息。
    #[setters(generate = true, strip_option)]
    image_options: Option<InstancesImageOptions>,
    /// 网络相关属性参数。
    #[setters(generate = true, strip_option)]
    network_options: Option<InstancesNetworkOptions>,
    /// 创建实例时，是否自动支付。取值范围：
    ///
    /// - true：自动支付。
    ///
    ///     > 自动支付时，请确保支付方式余额充足，否则会生成异常订单，只能作废订单。如果您的支付方式余额不足，可以将参数`AutoPay`置为`false`，此时会生成未支付订单，您可以登录ECS管理控制台自行支付。
    ///
    /// - false：只生成订单不扣费。
    ///
    ///     > 当`InstanceChargeType` 取值为`PostPaid`时，`AutoPay`不能设置为`false`。
    ///
    /// 默认值：true。
    ///
    #[setters(generate = true, strip_option)]
    auto_pay: Option<bool>,
    /// 实例的私网域名配置信息集合。
    ///
    ///
    /// 关于私网域名解析，请参见[ECS私网域名解析
    /// ](~~2844797~~)。
    #[setters(generate = true, strip_option)]
    private_dns_name_options: Option<InstancesPrivateDnsNameOptions>,
    /// 实例时钟相关属性参数。
    #[setters(generate = true, strip_option)]
    clock_options: Option<InstancesClockOptions>,
}

impl sealed::Bound for RunInstances {}

impl RunInstances {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_id: None,
            image_family: None,
            instance_type: None,
            security_group_id: None,
            v_switch_id: None,
            instance_name: None,
            description: None,
            internet_max_bandwidth_in: None,
            internet_max_bandwidth_out: None,
            host_name: None,
            unique_suffix: None,
            password: None,
            password_inherit: None,
            zone_id: None,
            internet_charge_type: None,
            system_disk_size: None,
            system_disk_category: None,
            system_disk_disk_name: None,
            system_disk_description: None,
            system_disk_performance_level: None,
            system_disk_auto_snapshot_policy_id: None,
            io_optimized: None,
            user_data: None,
            key_pair_name: None,
            ram_role_name: None,
            amount: None,
            min_amount: None,
            auto_release_time: None,
            spot_strategy: None,
            spot_duration: None,
            spot_price_limit: None,
            spot_interruption_behavior: None,
            security_enhancement_strategy: None,
            client_token: None,
            hpc_cluster_id: None,
            dry_run: None,
            dedicated_host_id: None,
            launch_template_id: None,
            launch_template_name: None,
            launch_template_version: None,
            resource_group_id: None,
            period: None,
            period_unit: None,
            auto_renew: None,
            auto_renew_period: None,
            instance_charge_type: None,
            deployment_set_id: None,
            deployment_set_group_no: None,
            private_ip_address: None,
            credit_specification: None,
            ipv6_address_count: None,
            network_interface_queue_number: None,
            deletion_protection: None,
            hibernation_options_configured: None,
            affinity: None,
            tenancy: None,
            storage_set_id: None,
            storage_set_partition_number: None,
            cpu_options_core: None,
            cpu_options_threads_per_core: None,
            cpu_options_numa: None,
            cpu_options_topology_type: None,
            security_options_trusted_system_mode: None,
            security_options_confidential_computing_mode: None,
            http_endpoint: None,
            http_tokens: None,
            http_put_response_hop_limit: None,
            private_pool_options_match_criteria: None,
            private_pool_options_id: None,
            isp: None,
            scheduler_options_dedicated_host_cluster_id: None,
            security_group_ids: None,
            host_names: None,
            data_disk: None,
            arn: None,
            network_interface: None,
            tag: None,
            ipv6_address: None,
            system_disk: None,
            image_options: None,
            network_options: None,
            auto_pay: None,
            private_dns_name_options: None,
            clock_options: None,
        }
    }
}
impl crate::ToFormData for RunInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RunInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RunInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RunInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(85);

        if let Some(f) = &self.affinity {
            params.push(("Affinity".into(), (f).into()));
        }

        if let Some(f) = &self.amount {
            params.push(("Amount".into(), (f).into()));
        }

        if let Some(f) = &self.arn {
            crate::FlatSerialize::flat_serialize(f, "Arn", &mut params);
        }

        if let Some(f) = &self.auto_pay {
            params.push(("AutoPay".into(), (f).into()));
        }

        if let Some(f) = &self.auto_release_time {
            params.push(("AutoReleaseTime".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew {
            params.push(("AutoRenew".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew_period {
            params.push(("AutoRenewPeriod".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.clock_options {
            crate::FlatSerialize::flat_serialize(f, "ClockOptions", &mut params);
        }

        if let Some(f) = &self.cpu_options_core {
            params.push(("CpuOptions.Core".into(), (f).into()));
        }

        if let Some(f) = &self.cpu_options_numa {
            params.push(("CpuOptions.Numa".into(), (f).into()));
        }

        if let Some(f) = &self.cpu_options_threads_per_core {
            params.push(("CpuOptions.ThreadsPerCore".into(), (f).into()));
        }

        if let Some(f) = &self.cpu_options_topology_type {
            params.push(("CpuOptions.TopologyType".into(), (f).into()));
        }

        if let Some(f) = &self.credit_specification {
            params.push(("CreditSpecification".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk {
            crate::FlatSerialize::flat_serialize(f, "DataDisk", &mut params);
        }

        if let Some(f) = &self.dedicated_host_id {
            params.push(("DedicatedHostId".into(), (f).into()));
        }

        if let Some(f) = &self.deletion_protection {
            params.push(("DeletionProtection".into(), (f).into()));
        }

        if let Some(f) = &self.deployment_set_group_no {
            params.push(("DeploymentSetGroupNo".into(), (f).into()));
        }

        if let Some(f) = &self.deployment_set_id {
            params.push(("DeploymentSetId".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.hibernation_options_configured {
            params.push(("HibernationOptions.Configured".into(), (f).into()));
        }

        if let Some(f) = &self.host_name {
            params.push(("HostName".into(), (f).into()));
        }

        if let Some(f) = &self.host_names {
            crate::FlatSerialize::flat_serialize(f, "HostNames", &mut params);
        }

        if let Some(f) = &self.hpc_cluster_id {
            params.push(("HpcClusterId".into(), (f).into()));
        }

        if let Some(f) = &self.http_endpoint {
            params.push(("HttpEndpoint".into(), (f).into()));
        }

        if let Some(f) = &self.http_put_response_hop_limit {
            params.push(("HttpPutResponseHopLimit".into(), (f).into()));
        }

        if let Some(f) = &self.http_tokens {
            params.push(("HttpTokens".into(), (f).into()));
        }

        if let Some(f) = &self.image_family {
            params.push(("ImageFamily".into(), (f).into()));
        }

        if let Some(f) = &self.image_id {
            params.push(("ImageId".into(), (f).into()));
        }

        if let Some(f) = &self.image_options {
            crate::FlatSerialize::flat_serialize(f, "ImageOptions", &mut params);
        }

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_name {
            params.push(("InstanceName".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.internet_charge_type {
            params.push(("InternetChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_in {
            params.push(("InternetMaxBandwidthIn".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_out {
            params.push(("InternetMaxBandwidthOut".into(), (f).into()));
        }

        if let Some(f) = &self.io_optimized {
            params.push(("IoOptimized".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_address {
            crate::FlatSerialize::flat_serialize(f, "Ipv6Address", &mut params);
        }

        if let Some(f) = &self.ipv6_address_count {
            params.push(("Ipv6AddressCount".into(), (f).into()));
        }

        if let Some(f) = &self.isp {
            params.push(("Isp".into(), (f).into()));
        }

        if let Some(f) = &self.key_pair_name {
            params.push(("KeyPairName".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_id {
            params.push(("LaunchTemplateId".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_name {
            params.push(("LaunchTemplateName".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_version {
            params.push(("LaunchTemplateVersion".into(), (f).into()));
        }

        if let Some(f) = &self.min_amount {
            params.push(("MinAmount".into(), (f).into()));
        }

        if let Some(f) = &self.network_interface {
            crate::FlatSerialize::flat_serialize(f, "NetworkInterface", &mut params);
        }

        if let Some(f) = &self.network_interface_queue_number {
            params.push(("NetworkInterfaceQueueNumber".into(), (f).into()));
        }

        if let Some(f) = &self.network_options {
            crate::FlatSerialize::flat_serialize(f, "NetworkOptions", &mut params);
        }

        if let Some(f) = &self.password {
            params.push(("Password".into(), (f).into()));
        }

        if let Some(f) = &self.password_inherit {
            params.push(("PasswordInherit".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }

        if let Some(f) = &self.private_dns_name_options {
            crate::FlatSerialize::flat_serialize(f, "PrivateDnsNameOptions", &mut params);
        }

        if let Some(f) = &self.private_ip_address {
            params.push(("PrivateIpAddress".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_id {
            params.push(("PrivatePoolOptions.Id".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_match_criteria {
            params.push(("PrivatePoolOptions.MatchCriteria".into(), (f).into()));
        }

        if let Some(f) = &self.ram_role_name {
            params.push(("RamRoleName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.scheduler_options_dedicated_host_cluster_id {
            params.push(("SchedulerOptions.DedicatedHostClusterId".into(), (f).into()));
        }

        if let Some(f) = &self.security_enhancement_strategy {
            params.push(("SecurityEnhancementStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_id {
            params.push(("SecurityGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_ids {
            crate::FlatSerialize::flat_serialize(f, "SecurityGroupIds", &mut params);
        }

        if let Some(f) = &self.security_options_confidential_computing_mode {
            params.push((
                "SecurityOptions.ConfidentialComputingMode".into(),
                (f).into(),
            ));
        }

        if let Some(f) = &self.security_options_trusted_system_mode {
            params.push(("SecurityOptions.TrustedSystemMode".into(), (f).into()));
        }

        if let Some(f) = &self.spot_duration {
            params.push(("SpotDuration".into(), (f).into()));
        }

        if let Some(f) = &self.spot_interruption_behavior {
            params.push(("SpotInterruptionBehavior".into(), (f).into()));
        }

        if let Some(f) = &self.spot_price_limit {
            params.push(("SpotPriceLimit".into(), (f).into()));
        }

        if let Some(f) = &self.spot_strategy {
            params.push(("SpotStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.storage_set_id {
            params.push(("StorageSetId".into(), (f).into()));
        }

        if let Some(f) = &self.storage_set_partition_number {
            params.push(("StorageSetPartitionNumber".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk {
            crate::FlatSerialize::flat_serialize(f, "SystemDisk", &mut params);
        }

        if let Some(f) = &self.system_disk_auto_snapshot_policy_id {
            params.push(("SystemDisk.AutoSnapshotPolicyId".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_category {
            params.push(("SystemDisk.Category".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_description {
            params.push(("SystemDisk.Description".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_disk_name {
            params.push(("SystemDisk.DiskName".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_performance_level {
            params.push(("SystemDisk.PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_size {
            params.push(("SystemDisk.Size".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.tenancy {
            params.push(("Tenancy".into(), (f).into()));
        }

        if let Some(f) = &self.unique_suffix {
            params.push(("UniqueSuffix".into(), (f).into()));
        }

        if let Some(f) = &self.user_data {
            params.push(("UserData".into(), (f).into()));
        }

        if let Some(f) = &self.v_switch_id {
            params.push(("VSwitchId".into(), (f).into()));
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateInstance {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 镜像文件ID，启动实例时选择的镜像资源。如需使用云市场镜像，您可以在云市场镜像商详情页查看`ImageId`。当您不通过指定`ImageFamily`选用镜像族系最新可用镜像时，此参数必选。
    #[setters(generate = true, strip_option)]
    image_id: Option<String>,
    /// 镜像族系名称，通过设置该参数来获取当前镜像族系内最新可用镜像来创建实例。
    /// - 设置了`ImageId`，则不能设置该参数。
    /// - 未设置`ImageId`，则可以设置该参数。
    #[setters(generate = true, strip_option)]
    image_family: Option<String>,
    /// 实例的资源规格。
    ///
    /// - 产品选型：参见[实例规格族](~~25378~~)或调用[DescribeInstanceTypes](~~25620~~)查看目标实例规格的性能数据，或者参见[选型配置](~~58291~~)了解如何选择实例规格。
    /// - 查询库存：调用[DescribeAvailableResource](~~66186~~)查看指定地域或者可用区内的资源供给情况。
    instance_type: String,
    /// 指定新创建实例所属于的安全组ID。
    #[setters(generate = true, strip_option)]
    security_group_id: Option<String>,
    /// 实例的名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文等）和数字。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。如果没有指定该参数，默认值为实例ID。
    #[setters(generate = true, strip_option)]
    instance_name: Option<String>,
    /// 网络计费类型。取值范围：
    ///
    /// - PayByBandwidth：按固定带宽计费。
    /// - PayByTraffic（默认）：按使用流量计费。
    ///
    /// > **按使用流量计费**模式下的出入带宽峰值都是带宽上限，不作为业务承诺指标。当出现资源争抢时，带宽峰值可能会受到限制。如果您的业务需要有带宽的保障，请使用**按固定带宽计费**模式。
    #[setters(generate = true, strip_option)]
    internet_charge_type: Option<String>,
    /// 是否要自动续费。当参数`InstanceChargeType`取值`PrePaid`时才生效。取值范围：
    ///
    /// - true：自动续费。
    /// - false（默认）：不自动续费。
    #[setters(generate = true, strip_option)]
    auto_renew: Option<bool>,
    /// 每次自动续费的时长，当参数AutoRenew取值True时，该参数为必填参数。
    ///
    /// <props="china">PeriodUnit为Week时，AutoRenewPeriod取值：1、2、3。</props>
    ///
    /// PeriodUnit为Month时，AutoRenewPeriod取值：1、2、3、6、12。
    #[setters(generate = true, strip_option)]
    auto_renew_period: Option<i32>,
    /// 公网入带宽最大值，单位为Mbit/s。取值范围：
    ///
    /// - 当所购出网带宽小于等于10 Mbit/s时：1~10。默认值为10。
    /// - 当所购出网带宽大于10 Mbit/s时：1~`InternetMaxBandwidthOut`的取值，默认为`InternetMaxBandwidthOut`的取值。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_in: Option<i32>,
    /// 公网出带宽最大值，单位为Mbit/s。取值范围为0~100。
    ///
    /// 默认值为0。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_out: Option<i32>,
    /// 云服务器的主机名。
    ///
    /// - 半角句号（.）或短划线（-）不能作为首尾字符，更不能连续使用。
    /// - Windows实例：字符长度为2~15，不支持半角句号（.），不能全是数字。允许大小写英文字母、数字和短划线（-）。
    /// - 其他类型实例（Linux等）：字符长度为2~64，支持多个半角句号（.），英文句号之间为一段，每段允许大小写英文字母、数字和短划线（-）。
    #[setters(generate = true, strip_option)]
    host_name: Option<String>,
    /// 实例的密码。长度为8至30个字符，必须同时包含大小写英文字母、数字和特殊符号中的三类字符。特殊符号可以是：
    ///
    /// ```ignore
    /// ()`~!@#$%^&*-_+=|{}[]:;'<>,.?/
    /// ```
    ///
    /// 您需要注意：
    ///
    /// - 如果传入Password参数，建议您使用HTTPS协议发送请求，避免密码泄露。
    /// - Windows实例不能以正斜线（/）为密码首字符。
    /// - 部分操作系统的实例不支持配置密码，仅支持配置密钥对。例如：Others Linux、Fedora CoreOS。
    #[setters(generate = true, strip_option)]
    password: Option<String>,
    /// 是否使用镜像预设的密码。使用该参数时，Password参数必须为空，同时您需要确保使用的镜像已经设置了密码。
    #[setters(generate = true, strip_option)]
    password_inherit: Option<bool>,
    /// 部署集ID。
    #[setters(generate = true, strip_option)]
    deployment_set_id: Option<String>,
    /// 如果您设置的部署集对应的策略为部署集组高可用策略（AvailabilityGroup）时，可以通过该参数指定实例在部署集中的分组号。取值范围为1~7。
    #[setters(generate = true, strip_option)]
    deployment_set_group_no: Option<i32>,
    /// 实例所属的可用区ID。更多信息，请参见[DescribeZones](~~25610~~)获取可用区列表。
    ///
    /// > 如果您指定了`VSwitchId`参数，则指定的`ZoneId`参数必须和交换机所在的可用区保持一致。您也可以不指定`ZoneId`参数，系统将自动选择指定的交换机所在的可用区。
    ///
    /// 默认值：空，系统自动选择。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 实例所在的集群ID。
    ///
    /// >该参数即将被弃用，为提高兼容性，请尽量使用其他参数。
    #[setters(generate = true, strip_option)]
    cluster_id: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 虚拟局域网ID。
    #[setters(generate = true, strip_option)]
    vlan_id: Option<String>,
    /// 实例的内网IP。
    #[setters(generate = true, strip_option)]
    inner_ip_address: Option<String>,
    /// 系统盘大小，单位为GiB。取值范围为：
    ///
    /// -  普通云盘：20~500
    ///
    /// -  其他类型云盘：20~2048
    ///
    /// 该参数的取值必须大于或者等于max{20, ImageSize}。
    ///
    /// 默认值：max{40, ImageSize} 。
    #[setters(generate = true, strip_option)]
    system_disk_size: Option<i32>,
    /// 系统盘的云盘种类。取值范围：
    ///
    /// - cloud_efficiency：高效云盘。
    /// - cloud_ssd：SSD云盘。
    /// - cloud_essd：ESSD云盘。
    /// - cloud：普通云盘。
    /// - cloud_auto：ESSD AutoPL云盘。
    /// - cloud_essd_entry：ESSD Entry云盘。
    /// >仅当`InstanceType`设置为[通用算力型实例规格族u1](~~457079~~)（`ecs.u1`）或[经济型实例规格族e](~~108489~~)（`ecs.e`）时，该参数支持取`cloud_essd_entry`值。
    ///
    /// 已停售的实例规格且非I/O优化实例默认值为cloud，否则默认值为cloud_efficiency。
    #[setters(generate = true, strip_option)]
    system_disk_category: Option<String>,
    /// 系统盘名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    ///
    /// 默认值为空。
    #[setters(generate = true, strip_option)]
    system_disk_disk_name: Option<String>,
    /// 系统盘描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    ///
    /// 默认值为空。
    #[setters(generate = true, strip_option)]
    system_disk_description: Option<String>,
    /// 创建ESSD云盘作为系统盘使用时，设置云盘的性能等级。取值范围：
    ///
    /// - PL0：单盘最高随机读写IOPS 1万。
    /// - PL1（默认）：单盘最高随机读写IOPS 5万。
    /// - PL2：单盘最高随机读写IOPS 10万。
    /// - PL3：单盘最高随机读写IOPS 100万。
    ///
    /// 有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。
    #[setters(generate = true, strip_option)]
    system_disk_performance_level: Option<String>,
    /// >该参数正在邀测中，暂不支持使用。
    #[setters(generate = true, strip_option)]
    node_controller_id: Option<String>,
    /// 实例的描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    ///
    /// 默认值为空。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 如果是创建VPC类型的实例，需要指定交换机ID。您可以调用[DescribeVSwitches](~~35748~~)查询已创建的交换机的相关信息。
    ///
    /// > 如果您指定了`VSwitchId`参数，则指定的`ZoneId`参数必须和交换机所在的可用区保持一致。您也可以不指定`ZoneId`参数，系统将自动选择指定的交换机所在的可用区。
    #[setters(generate = true, strip_option)]
    v_switch_id: Option<String>,
    /// 实例私网IP地址。该IP地址必须为交换机（VSwitchId）网段的空闲地址。
    #[setters(generate = true, strip_option)]
    private_ip_address: Option<String>,
    /// 是否为I/O优化实例。取值范围：
    ///
    /// - none：非I/O优化。
    /// - optimized：I/O优化。
    ///
    /// [已停售的实例规格](~~55263~~)实例默认值是none。
    ///
    /// 其他实例规格默认值是optimized。
    #[setters(generate = true, strip_option)]
    io_optimized: Option<String>,
    /// 是否使用阿里云提供的虚拟机系统配置（Windows：NTP、KMS；Linux：NTP、YUM）。
    #[setters(generate = true, strip_option)]
    use_additional_service: Option<bool>,
    /// 实例的付费方式。取值范围：
    ///
    /// - PrePaid：包年包月。选择该类付费方式时，您必须确认自己的账号支持余额支付/信用支付，否则将返回 `InvalidPayMethod`的错误提示。
    /// - PostPaid（默认）：按量付费。
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 购买资源的时长，单位由`PeriodUnit`指定。当参数`InstanceChargeType`取值为`PrePaid`时才生效且为必选值。一旦指定了`DedicatedHostId`，则取值范围不能超过专有宿主机的订阅时长。取值范围：
    ///
    /// <props="china">
    /// - PeriodUnit=Week时，Period取值：1、2、3、4。
    /// - PeriodUnit=Month时，Period取值：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
    ///
    /// </props>
    ///
    /// <props="intl">PeriodUnit=Month时，Period取值：1、2、3、6、12。</props>
    ///
    /// <props="partner">PeriodUnit=Month时，Period取值：1、2、3、6、12。</props>
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 购买资源的时长。取值范围：
    ///
    /// <props="china">
    /// - Week。
    /// - Month。
    ///
    /// </props>
    ///
    /// <props="intl">Month。</props>
    ///
    /// <props="partner">Month。</props>
    ///
    /// 默认值为Month。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 实例自定义数据，需要以Base64方式编码，原始数据最多为32 KB。
    #[setters(generate = true, strip_option)]
    user_data: Option<String>,
    /// 实例的抢占策略。当参数`InstanceChargeType`取值为`PostPaid`时生效。取值范围：
    ///
    /// - NoSpot（默认）：正常按量付费实例。
    /// - SpotWithPriceLimit：设置上限价格的抢占式实例。
    /// - SpotAsPriceGo：系统自动出价，跟随当前市场实际价格。
    #[setters(generate = true, strip_option)]
    spot_strategy: Option<String>,
    /// 密钥对名称。
    ///
    /// >Windows实例，忽略该参数。默认为空。即使填写了该参数，仍旧只执行`Password`的内容。
    #[setters(generate = true, strip_option)]
    key_pair_name: Option<String>,
    /// 设置实例的每小时最高价格。支持最多3位小数，参数`SpotStrategy`取值为`SpotWithPriceLimit`时生效。
    #[setters(generate = true, strip_option)]
    spot_price_limit: Option<f32>,
    /// 抢占式实例的保留时长，单位为小时。默认值：1。取值范围：
    ///
    /// - 1：创建后阿里云会保证实例运行1小时不会被自动释放；超过1小时后，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    /// - 0：创建后，阿里云不保证实例运行1小时，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    ///
    /// >
    /// > - 该参数目前只支持设置为0或1。
    /// > - 抢占式实例按秒计费，建议您结合具体任务执行耗时来选择合适的保留时长。
    /// > - 实例回收前5分钟阿里云会通过ECS系统事件向您发送通知。
    #[setters(generate = true, strip_option)]
    spot_duration: Option<i32>,
    /// 抢占实例中断模式。取值范围：
    ///
    /// - Terminate：直接释放实例。
    ///
    /// - Stop：实例进入节省停机模式。
    ///
    ///   关于节省停机模式的更多说明，请参见[按量付费实例节省停机模式](~~63353~~)。
    ///
    /// 默认值：Terminate。
    #[setters(generate = true, strip_option)]
    spot_interruption_behavior: Option<String>,
    /// 实例RAM角色名称。您可以使用RAM API [ListRoles](~~28713~~)查询您已创建的实例RAM角色。
    #[setters(generate = true, strip_option)]
    ram_role_name: Option<String>,
    /// 是否开启安全加固。取值范围：
    ///
    /// - Active：启用安全加固，只对系统镜像生效。
    /// - Deactive：不启用安全加固，对所有镜像类型生效。
    #[setters(generate = true, strip_option)]
    security_enhancement_strategy: Option<String>,
    /// 实例所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 实例所属的HPC集群ID。
    #[setters(generate = true, strip_option)]
    hpc_cluster_id: Option<String>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会创建实例。检查项包括是否填写了必需参数、请求格式、业务限制和ECS库存。如果检查不通过，则返回对应错误。如果检查通过，则返回错误码`DryRunOperation`。
    /// - false（默认）：发送正常请求，通过检查后直接创建实例。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 专有宿主机ID。
    /// <props="china">您可以通过[DescribeDedicatedHosts](~~134242~~)查询专有宿主机ID列表。</props>
    ///
    /// <props="intl">您可以通过[DescribeDedicatedHosts](~~134242~~)查询专有宿主机ID列表。</props>
    ///
    /// ><notice>专有宿主机不支持创建抢占式实例，指定`DedicatedHostId`参数后，会自动忽略请求中的`SpotStrategy`和`SpotPriceLimit`设置。></notice>
    #[setters(generate = true, strip_option)]
    dedicated_host_id: Option<String>,
    /// 设置突发性能实例的运行模式。取值范围：
    ///
    /// - Standard：标准模式，实例性能请参见[什么是突发性能实例](~~59977~~)下的性能约束模式章节。
    /// - Unlimited：无性能约束模式，实例性能请参见[什么是突发性能实例](~~59977~~)下的无性能约束模式章节。
    #[setters(generate = true, strip_option)]
    credit_specification: Option<String>,
    /// 实例释放保护属性，指定是否支持通过控制台或API（[DeleteInstance](~~25507~~)）释放实例。
    ///
    /// -   true：开启实例释放保护。
    /// -   false（默认）：关闭实例释放保护。
    ///
    /// > 该属性仅适用于按量付费实例，且只能限制手动释放操作，对系统释放操作不生效。
    #[setters(generate = true, strip_option)]
    deletion_protection: Option<bool>,
    /// >该参数正在邀测中，暂不支持使用。
    #[setters(generate = true, strip_option)]
    hibernation_options_configured: Option<bool>,
    /// 专有宿主机实例是否与专有宿主机关联。取值范围：
    ///
    /// - default：实例不与专有宿主机关联。已启用节省停机模式的实例，停机后再次启动时，若原专有宿主机可用资源不足，则实例被放置在自动部署资源池的其它专有宿主机上。
    ///
    /// - host：实例与专有宿主机关联。已启用节省停机模式的实例，停机后再次启动时，仍放置在原专有宿主机上。若原专有宿主机可用资源不足，则实例重启失败。
    ///
    /// 默认值为default。
    #[setters(generate = true, strip_option)]
    affinity: Option<String>,
    /// 是否在专有宿主机上创建实例。取值范围：
    ///
    /// - default：在非专有宿主机上创建实例。
    ///
    /// - host：在专有宿主机上创建实例。若您不指定`DedicatedHostId`，则由阿里云自动选择专有宿主机部署实例。
    ///
    /// 默认值为default。
    #[setters(generate = true, strip_option)]
    tenancy: Option<String>,
    /// 存储集ID。
    #[setters(generate = true, strip_option)]
    storage_set_id: Option<String>,
    /// 存储集中的最大分区数量。取值范围：大于等于2。
    #[setters(generate = true, strip_option)]
    storage_set_partition_number: Option<i32>,
    /// 是否启用实例元数据的访问通道。取值范围：
    /// - enabled：启用。
    /// - disabled：禁用。
    ///
    /// 默认值为enabled。
    /// >有关实例元数据的信息，请参见[实例元数据概述](~~49122~~)。
    #[setters(generate = true, strip_option)]
    http_endpoint: Option<String>,
    /// 访问实例元数据时是否强制使用加固模式（IMDSv2）。取值范围：
    /// - optional：不强制使用。
    /// - required：强制使用。设置该取值后，普通模式无法访问实例元数据。
    ///
    /// 默认值为optional。
    /// >有关访问实例元数据的模式，请参见[实例元数据访问模式](~~150575~~)。
    #[setters(generate = true, strip_option)]
    http_tokens: Option<String>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    http_put_response_hop_limit: Option<i32>,
    /// 实例启动的私有池容量选项。弹性保障服务或容量预定服务在生效后会生成私有池容量，供实例启动时选择。取值范围：
    ///
    /// - Open：开放模式。将自动匹配开放类型的私有池容量。如果没有符合条件的私有池容量，则使用公共池资源启动。该模式下无需设置`PrivatePoolOptions.Id`参数。
    /// - Target：指定模式。使用指定的私有池容量启动实例，如果该私有池容量不可用，则实例会启动失败。该模式下必须指定私有池ID，即`PrivatePoolOptions.Id`参数为必填项。
    /// - None：不使用模式。实例启动将不使用私有池容量。
    ///
    /// 默认值为None。
    ///
    /// 以下任一场景，实例启动的私有池容量选项只能取值`None`或不传值。
    /// - 创建抢占式实例。
    /// - 创建经典网络类型的ECS实例。
    /// - 在专有宿主机DDH上创建ECS实例。
    #[setters(generate = true, strip_option)]
    private_pool_options_match_criteria: Option<String>,
    /// 私有池ID。即弹性保障服务ID或容量预定服务ID。
    #[setters(generate = true, strip_option)]
    private_pool_options_id: Option<String>,
    /// 数据盘列表。
    #[setters(generate = true, strip_option)]
    data_disk: Option<Vec<InstanceDataDisk>>,
    /// >该参数正在邀测中，暂不支持使用。
    #[setters(generate = true, strip_option)]
    arn: Option<Vec<InstanceArn>>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<CreateInstanceTag>>,
    /// 系统盘相关参数，目前专属块存储集群ID（`StorageClusterId`）需要通过该参数设置参数值。
    #[setters(generate = true, strip_option)]
    system_disk: Option<InstanceSystemDisk>,
}

impl sealed::Bound for CreateInstance {}

impl CreateInstance {
    pub fn new(region_id: impl Into<String>, instance_type: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_id: None,
            image_family: None,
            instance_type: instance_type.into(),
            security_group_id: None,
            instance_name: None,
            internet_charge_type: None,
            auto_renew: None,
            auto_renew_period: None,
            internet_max_bandwidth_in: None,
            internet_max_bandwidth_out: None,
            host_name: None,
            password: None,
            password_inherit: None,
            deployment_set_id: None,
            deployment_set_group_no: None,
            zone_id: None,
            cluster_id: None,
            client_token: None,
            vlan_id: None,
            inner_ip_address: None,
            system_disk_size: None,
            system_disk_category: None,
            system_disk_disk_name: None,
            system_disk_description: None,
            system_disk_performance_level: None,
            node_controller_id: None,
            description: None,
            v_switch_id: None,
            private_ip_address: None,
            io_optimized: None,
            use_additional_service: None,
            instance_charge_type: None,
            period: None,
            period_unit: None,
            user_data: None,
            spot_strategy: None,
            key_pair_name: None,
            spot_price_limit: None,
            spot_duration: None,
            spot_interruption_behavior: None,
            ram_role_name: None,
            security_enhancement_strategy: None,
            resource_group_id: None,
            hpc_cluster_id: None,
            dry_run: None,
            dedicated_host_id: None,
            credit_specification: None,
            deletion_protection: None,
            hibernation_options_configured: None,
            affinity: None,
            tenancy: None,
            storage_set_id: None,
            storage_set_partition_number: None,
            http_endpoint: None,
            http_tokens: None,
            http_put_response_hop_limit: None,
            private_pool_options_match_criteria: None,
            private_pool_options_id: None,
            data_disk: None,
            arn: None,
            tag: None,
            system_disk: None,
        }
    }
}
impl crate::ToFormData for CreateInstance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateInstance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateInstance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateInstanceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(63);

        if let Some(f) = &self.affinity {
            params.push(("Affinity".into(), (f).into()));
        }

        if let Some(f) = &self.arn {
            crate::FlatSerialize::flat_serialize(f, "Arn", &mut params);
        }

        if let Some(f) = &self.auto_renew {
            params.push(("AutoRenew".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew_period {
            params.push(("AutoRenewPeriod".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.cluster_id {
            params.push(("ClusterId".into(), (f).into()));
        }

        if let Some(f) = &self.credit_specification {
            params.push(("CreditSpecification".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk {
            crate::FlatSerialize::flat_serialize(f, "DataDisk", &mut params);
        }

        if let Some(f) = &self.dedicated_host_id {
            params.push(("DedicatedHostId".into(), (f).into()));
        }

        if let Some(f) = &self.deletion_protection {
            params.push(("DeletionProtection".into(), (f).into()));
        }

        if let Some(f) = &self.deployment_set_group_no {
            params.push(("DeploymentSetGroupNo".into(), (f).into()));
        }

        if let Some(f) = &self.deployment_set_id {
            params.push(("DeploymentSetId".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.hibernation_options_configured {
            params.push(("HibernationOptions.Configured".into(), (f).into()));
        }

        if let Some(f) = &self.host_name {
            params.push(("HostName".into(), (f).into()));
        }

        if let Some(f) = &self.hpc_cluster_id {
            params.push(("HpcClusterId".into(), (f).into()));
        }

        if let Some(f) = &self.http_endpoint {
            params.push(("HttpEndpoint".into(), (f).into()));
        }

        if let Some(f) = &self.http_put_response_hop_limit {
            params.push(("HttpPutResponseHopLimit".into(), (f).into()));
        }

        if let Some(f) = &self.http_tokens {
            params.push(("HttpTokens".into(), (f).into()));
        }

        if let Some(f) = &self.image_family {
            params.push(("ImageFamily".into(), (f).into()));
        }

        if let Some(f) = &self.image_id {
            params.push(("ImageId".into(), (f).into()));
        }

        if let Some(f) = &self.inner_ip_address {
            params.push(("InnerIpAddress".into(), (f).into()));
        }

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_name {
            params.push(("InstanceName".into(), (f).into()));
        }
        params.push(("InstanceType".into(), (&self.instance_type).into()));

        if let Some(f) = &self.internet_charge_type {
            params.push(("InternetChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_in {
            params.push(("InternetMaxBandwidthIn".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_out {
            params.push(("InternetMaxBandwidthOut".into(), (f).into()));
        }

        if let Some(f) = &self.io_optimized {
            params.push(("IoOptimized".into(), (f).into()));
        }

        if let Some(f) = &self.key_pair_name {
            params.push(("KeyPairName".into(), (f).into()));
        }

        if let Some(f) = &self.node_controller_id {
            params.push(("NodeControllerId".into(), (f).into()));
        }

        if let Some(f) = &self.password {
            params.push(("Password".into(), (f).into()));
        }

        if let Some(f) = &self.password_inherit {
            params.push(("PasswordInherit".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }

        if let Some(f) = &self.private_ip_address {
            params.push(("PrivateIpAddress".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_id {
            params.push(("PrivatePoolOptions.Id".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_match_criteria {
            params.push(("PrivatePoolOptions.MatchCriteria".into(), (f).into()));
        }

        if let Some(f) = &self.ram_role_name {
            params.push(("RamRoleName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_enhancement_strategy {
            params.push(("SecurityEnhancementStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_id {
            params.push(("SecurityGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.spot_duration {
            params.push(("SpotDuration".into(), (f).into()));
        }

        if let Some(f) = &self.spot_interruption_behavior {
            params.push(("SpotInterruptionBehavior".into(), (f).into()));
        }

        if let Some(f) = &self.spot_price_limit {
            params.push(("SpotPriceLimit".into(), (f).into()));
        }

        if let Some(f) = &self.spot_strategy {
            params.push(("SpotStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.storage_set_id {
            params.push(("StorageSetId".into(), (f).into()));
        }

        if let Some(f) = &self.storage_set_partition_number {
            params.push(("StorageSetPartitionNumber".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk {
            crate::FlatSerialize::flat_serialize(f, "SystemDisk", &mut params);
        }

        if let Some(f) = &self.system_disk_category {
            params.push(("SystemDisk.Category".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_description {
            params.push(("SystemDisk.Description".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_disk_name {
            params.push(("SystemDisk.DiskName".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_performance_level {
            params.push(("SystemDisk.PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_size {
            params.push(("SystemDisk.Size".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.tenancy {
            params.push(("Tenancy".into(), (f).into()));
        }

        if let Some(f) = &self.use_additional_service {
            params.push(("UseAdditionalService".into(), (f).into()));
        }

        if let Some(f) = &self.user_data {
            params.push(("UserData".into(), (f).into()));
        }

        if let Some(f) = &self.v_switch_id {
            params.push(("VSwitchId".into(), (f).into()));
        }

        if let Some(f) = &self.vlan_id {
            params.push(("VlanId".into(), (f).into()));
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct StartInstance {
    /// 指定启动的实例ID。
    instance_id: String,
    /// 当本地盘出现故障时，可通过此参数指定启动实例时，是否将实例恢复到最初的健康状态。适用于实例规格族d1、i1或者i2等包含本地盘的实例。取值范围：
    ///
    /// - true：将实例恢复到最初的健康状态。
    /// ><warning>实例原有本地盘中的数据将会丢失。></warning>
    ///
    /// - false：不做任何处理，维持现状。
    ///
    /// 默认值为false。
    #[setters(generate = true, strip_option)]
    init_local_disk: Option<bool>,
    /// 是否只预检查此次请求。取值范围：
    ///
    /// - true：仅检查此次请求，不会启动实例。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，会返回错误码DryRunOperation。
    /// - false：发送正常请求，请求通过检查后，返回2XX的HTTP状态码并直接启动实例。
    ///
    /// 默认值为false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for StartInstance {}

impl StartInstance {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            init_local_disk: None,
            dry_run: None,
        }
    }
}
impl crate::ToFormData for StartInstance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for StartInstance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "StartInstance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<StartInstanceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.init_local_disk {
            params.push(("InitLocalDisk".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct StartInstances {
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会启动实例。检查项包括是否填写了必需参数、请求格式、实例状态。如果检查不通过，则返回对应错误。如果检查通过，则返回`DRYRUN.SUCCESS`。
    /// > 如果参数`BatchOptimization`被设置为`SuccessFirst`，对应的`DryRun=true`的预检结果只会返回`DRYRUN.SUCCESS`。
    ///
    /// - false：发送正常请求，通过检查后直接启动实例。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 实例所在的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 设置批量操作模式。取值范围：
    ///
    /// - AllTogether：该模式下，如果实例全部启动成功，则返回成功信息；如果任意一个实例校验不通过，则所有实例启动失败，并返回失败信息。
    ///
    /// - SuccessFirst：该模式下，分别启动每个实例，返回结果包含每个实例的操作结果信息。
    ///
    /// 默认值：AllTogether。
    #[setters(generate = true, strip_option)]
    batch_optimization: Option<String>,
    /// 实例ID数组。数组长度：1~100。
    instance_id: Vec<String>,
}

impl sealed::Bound for StartInstances {}

impl StartInstances {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<Vec<String>>) -> Self {
        Self {
            dry_run: None,
            region_id: region_id.into(),
            batch_optimization: None,
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for StartInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for StartInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "StartInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<StartInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.batch_optimization {
            params.push(("BatchOptimization".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }
        crate::FlatSerialize::flat_serialize(&self.instance_id, "InstanceId", &mut params);

        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct StopInstance {
    /// 指定的实例ID。
    instance_id: String,
    /// 该参数即将被弃用，为提高兼容性暂作保留。您在调用该接口时请忽略该参数。
    #[setters(generate = true, strip_option)]
    confirm_stop: Option<bool>,
    /// 停止实例时的是否强制关机策略。取值范围：
    ///
    /// - true：强制关机。相当于典型的断电操作，所有未写入存储设备的缓存数据会丢失。
    /// - false：正常关机流程。
    ///
    /// 默认值为false。
    #[setters(generate = true, strip_option)]
    force_stop: Option<bool>,
    /// 停止按量付费ECS实例时，设置的停止模式。取值：
    ///
    ///   - StopCharging：节省停机模式。开启节省停机模式后：
    ///     - 计算资源(vCPU、内存、GPU)、镜像License费用、固定公网IP的固定带宽模式暂停计费。
    ///     - 系统盘、数据盘、弹性公网 IP 的固定带宽模式持续计费。
    ///     - 由于计算资源被回收，启动时可能因库存不足导致启动失败，请您稍后再试或更换实例规格。
    ///     - 如果实例停止前绑定了弹性公网 IP 地址，重启后 IP 地址不变；否则，固定公网 IP 地址可能会变，但私网 IP 地址不会变。
    ///
    ///     更多信息，请参见[节省停机模式](~~63353~~)。
    ///     ><notice>
    /// 如实例自身不支持节省停机模式，API侧不会进行报错拦截，优先保证实例停机。不支持节省停机的实例类型：经典网络实例、本地盘实例、包年包月实例等。
    ///     ></notice>
    ///
    ///   - KeepCharging：普通停机模式。实例停止后仍继续收费。
    ///
    /// 默认值：如果您在ECS控制台上开启VPC内实例节省停机模式（更多信息，请参见[打开默认启用节省停机模式](~~63353#default~~)），并符合开启条件，则默认值为`StopCharging`。否则，默认值为`KeepCharging`。
    #[setters(generate = true, strip_option)]
    stopped_mode: Option<String>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会停止实例。检查项包括是否填写了必选参数、请求格式、业务限制和ECS库存。如果检查不通过，则返回对应错误。如果检查通过，则返回错误码`DryRunOperation`。
    /// - false：发送正常请求，通过检查后直接停止实例。
    ///
    /// 默认值为false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// >该参数正在邀测中，暂不支持使用。
    #[setters(generate = true, strip_option)]
    hibernate: Option<bool>,
}

impl sealed::Bound for StopInstance {}

impl StopInstance {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            confirm_stop: None,
            force_stop: None,
            stopped_mode: None,
            dry_run: None,
            hibernate: None,
        }
    }
}
impl crate::ToFormData for StopInstance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for StopInstance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "StopInstance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<StopInstanceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.confirm_stop {
            params.push(("ConfirmStop".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.force_stop {
            params.push(("ForceStop".into(), (f).into()));
        }

        if let Some(f) = &self.hibernate {
            params.push(("Hibernate".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.stopped_mode {
            params.push(("StoppedMode".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct StopInstances {
    /// 是否发送预检请求。取值范围：
    ///
    /// - true：发送检查请求，不会停止实例。检查项包括是否填写了必需参数、请求格式、实例状态。如果检查不通过，则返回对应错误。如果检查通过，则返回`DRYRUN.SUCCESS`。
    /// > 如果参数`BatchOptimization`被设置为`SuccessFirst`，对应的`DryRun=true`的预检结果只会返回`DRYRUN.SUCCESS`。
    ///
    /// - false：发送正常请求，通过检查后直接停止实例。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 实例所在的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 是否强制关机。取值范围：
    ///
    /// - true：强制关机。
    ///   ><warning>强制停止等同于断电处理，可能丢失实例操作系统中未写入磁盘的数据，请谨慎选择。></warning>
    /// - false：正常关机。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    force_stop: Option<bool>,
    /// 停止模式。取值：
    ///   - StopCharging：节省停机模式。开启节省停机模式后：
    ///     - 计算资源(vCPU、内存、GPU)、镜像License费用、固定公网IP的固定带宽模式暂停计费。
    ///     - 系统盘、数据盘、弹性公网 IP 的固定带宽模式持续计费。
    ///     - 由于计算资源被回收，启动时可能因库存不足导致启动失败，请您稍后再试或更换实例规格。
    ///     - 如果实例停止前绑定了弹性公网 IP 地址，重启后 IP 地址不变；否则，固定公网 IP 地址可能会变，但私网 IP 地址不会变。
    ///
    ///     更多信息，请参见[节省停机模式](~~63353~~)。
    ///     ><notice>
    /// 如实例自身不支持节省停机模式，API侧不会进行报错拦截，优先保证实例停机。不支持节省停机的实例类型：经典网络实例、本地盘实例、包年包月实例等。
    ///     ></notice>
    ///
    ///   - KeepCharging：普通停机模式。停止实例后保留实例的资源并继续收费，并为您保留 ECS 实例规格库存和公网 IP 地址。如果您停止实例是为了更换操作系统、重新初始化云盘、更改实例规格、修改私网 IP 等操作，建议您选择该模式，以避免启动失败。
    ///
    /// 默认值：如果您[开启VPC内实例节省停机模式](~~63353#default~~)并符合开启条件，则默认值为`StopCharging`；否则，默认值为`KeepCharging`。
    #[setters(generate = true, strip_option)]
    stopped_mode: Option<String>,
    /// 设置批量操作模式。取值范围：
    ///
    /// - AllTogether：所有操作必须全部成功才能确认整个批量操作的成功。如果任何一个操作失败，整个批量操作都会被视为失败，所有已执行的操作都会被回滚，恢复到操作前的状态。
    ///
    /// - SuccessFirst：允许批量操作中的每个操作独立执行。如果某个操作失败，其他操作仍然可以继续执行并确认成功。这种模式下，成功的操作会被提交，失败的操作会被标记为失败，但不会影响其他操作的执行结果。
    ///
    /// 默认值：AllTogether。
    #[setters(generate = true, strip_option)]
    batch_optimization: Option<String>,
    /// 实例ID数组。数组长度：1~100。
    instance_id: Vec<String>,
}

impl sealed::Bound for StopInstances {}

impl StopInstances {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<Vec<String>>) -> Self {
        Self {
            dry_run: None,
            region_id: region_id.into(),
            force_stop: None,
            stopped_mode: None,
            batch_optimization: None,
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for StopInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for StopInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "StopInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<StopInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.batch_optimization {
            params.push(("BatchOptimization".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.force_stop {
            params.push(("ForceStop".into(), (f).into()));
        }
        crate::FlatSerialize::flat_serialize(&self.instance_id, "InstanceId", &mut params);

        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.stopped_mode {
            params.push(("StoppedMode".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RebootInstance {
    /// 指定实例的ID。
    instance_id: String,
    /// 重启ECS实例前，是否强制关机。取值范围：
    ///
    /// -   true：强制关机。相当于典型的断电操作，所有未写入存储设备的缓存数据会丢失。
    ///
    /// -   false：正常关机。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    force_stop: Option<bool>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会重启实例。检查项包括是否填写了必选参数、请求格式、业务限制和ECS库存。如果检查不通过，则返回对应错误。如果检查通过，则返回错误码`DryRunOperation`。
    /// - false：发送正常请求，通过检查后直接重启实例。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for RebootInstance {}

impl RebootInstance {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            force_stop: None,
            dry_run: None,
        }
    }
}
impl crate::ToFormData for RebootInstance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RebootInstance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RebootInstance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RebootInstanceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.force_stop {
            params.push(("ForceStop".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RebootInstances {
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会重启实例。检查项包括是否填写了必需参数、请求格式、实例状态。如果检查不通过，则返回对应错误。如果检查通过，则返回`DRYRUN.SUCCESS`。
    /// > 如果参数`BatchOptimization`被设置为`SuccessFirst`，对应的`DryRun=true`的预检结果只会返回`DRYRUN.SUCCESS`。
    ///
    /// - false：发送正常请求，通过检查后直接重启实例。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 实例所在的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 是否强制重启。取值范围：
    ///
    /// -   true：强制重启。相当于典型的断电操作，所有未写入存储设备的缓存数据会丢失。
    ///
    /// -   false：正常重启。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    force_reboot: Option<bool>,
    /// 设置批量操作模式。取值范围：
    ///
    /// - AllTogether：该模式下，如果实例全部重启成功，则返回成功信息；如果任意一个实例校验不通过，则所有实例重启失败，并返回失败信息。
    ///
    /// - SuccessFirst：该模式下，分别重启每个实例，返回结果包含每个实例的操作结果信息。
    ///
    /// 默认值：AllTogether。
    #[setters(generate = true, strip_option)]
    batch_optimization: Option<String>,
    /// 实例ID数组。数组长度：1~100。
    instance_id: Vec<String>,
}

impl sealed::Bound for RebootInstances {}

impl RebootInstances {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<Vec<String>>) -> Self {
        Self {
            dry_run: None,
            region_id: region_id.into(),
            force_reboot: None,
            batch_optimization: None,
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for RebootInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RebootInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RebootInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RebootInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.batch_optimization {
            params.push(("BatchOptimization".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.force_reboot {
            params.push(("ForceReboot".into(), (f).into()));
        }
        crate::FlatSerialize::flat_serialize(&self.instance_id, "InstanceId", &mut params);

        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteInstance {
    /// 实例ID。
    instance_id: String,
    /// 是否强制释放**运行中**（`Running`）的实例。
    ///
    /// - true：强制释放**运行中**（`Running`）的实例。
    /// - false：正常释放实例，此时实例必须处于**已停止**（`Stopped`）状态。
    ///
    /// 默认值：false。
    /// ><warning>强制释放相当于断电，实例内存以及存储中的临时数据都会被擦除，无法恢复。></warning>
    #[setters(generate = true, strip_option)]
    force: Option<bool>,
    /// 释放**运行中**（`Running`）的实例时的是否采取强制关机策略。仅当`Force=true`时生效。取值范围：
    ///
    /// - true：强制关机并释放实例。相当于典型的断电操作，实例会直接进入资源释放流程。
    /// ><warning>强制释放相当于断电，实例内存以及存储中的临时数据都会被擦除，无法恢复。></warning>
    /// - false：在实例释放前，系统将优先执行标准关机流程，该模式会导致实例释放动作持续几分钟。用户在操作系统关机时，配置一些业务排水动作，从而减少业务系统的噪声。
    ///
    /// 默认值：true。
    #[setters(generate = true, strip_option)]
    force_stop: Option<bool>,
    /// 是否释放已到期的包年包月实例。
    ///
    /// - true：释放。
    /// - false：不释放。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    terminate_subscription: Option<bool>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会释放实例。检查项包括是否填写了必需参数、请求格式、业务限制和 ECS 库存。如果检查不通过，则返回对应错误。如果检查通过，则返回错误码`DryRunOperation`。
    /// - false（默认）：发送正常请求，通过检查后直接删除实例。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for DeleteInstance {}

impl DeleteInstance {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            force: None,
            force_stop: None,
            terminate_subscription: None,
            dry_run: None,
        }
    }
}
impl crate::ToFormData for DeleteInstance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteInstance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteInstance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteInstanceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.force {
            params.push(("Force".into(), (f).into()));
        }

        if let Some(f) = &self.force_stop {
            params.push(("ForceStop".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.terminate_subscription {
            params.push(("TerminateSubscription".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteInstances {
    /// 是否只预检此次请求。
    ///
    /// - true：发送检查请求，不会查询资源状况。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，会返回错误码DRYRUN.SUCCESS。
    /// - false：发送正常请求，通过检查后返回2XX HTTP状态码并直接查询资源状况。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 是否强制释放**运行中**（`Running`）的ECS实例。
    ///
    /// - true：强制释放**运行中**（`Running`）的实例。
    /// - false：正常释放实例，此时实例必须处于**已停止**（`Stopped`）状态。
    ///
    /// 默认值：false。
    /// ><warning>强制释放相当于断电，实例内存以及存储中的临时数据都会被擦除，无法恢复。></warning>
    #[setters(generate = true, strip_option)]
    force: Option<bool>,
    /// 释放**运行中**（`Running`）的实例时的是否采取强制关机策略。仅当`Force=true`时生效。取值范围：
    ///
    /// - true：强制关机并释放实例。相当于典型的断电操作，实例会直接进入资源释放流程。
    /// ><warning>强制释放相当于断电，实例内存以及存储中的临时数据都会被擦除，无法恢复。></warning>
    /// - false：在实例释放前，系统将优先执行标准关机流程，该模式会导致实例释放动作持续几分钟。用户在操作系统关机时，配置一些业务排水动作，从而减少业务系统的噪声。
    ///
    /// 默认值：true。
    #[setters(generate = true, strip_option)]
    force_stop: Option<bool>,
    /// 是否释放已到期的包年包月实例。
    ///
    /// - true：释放。
    /// - false：不释放。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    terminate_subscription: Option<bool>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID数组。数组长度：1~100。
    instance_id: Vec<String>,
}

impl sealed::Bound for DeleteInstances {}

impl DeleteInstances {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<Vec<String>>) -> Self {
        Self {
            dry_run: None,
            force: None,
            force_stop: None,
            terminate_subscription: None,
            client_token: None,
            region_id: region_id.into(),
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.force {
            params.push(("Force".into(), (f).into()));
        }

        if let Some(f) = &self.force_stop {
            params.push(("ForceStop".into(), (f).into()));
        }
        crate::FlatSerialize::flat_serialize(&self.instance_id, "InstanceId", &mut params);

        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.terminate_subscription {
            params.push(("TerminateSubscription".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceStatus {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例所属可用区。您可以调用[DescribeZones](~~25610~~)查看最新的阿里云可用区列表。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 实例所属的集群ID。
    ///
    /// ><notice>该参数已废弃，不建议使用！></notice>
    #[setters(generate = true, strip_option)]
    cluster_id: Option<String>,
    /// 实例状态列表的页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。取值范围：1~50。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 实例ID数组。数组长度：1~100。
    ///
    /// 示例值：["i-bp1j4i2jdf3owlhe****", "i-bp1j4i2jdf3o1234****"]。
    #[setters(generate = true, strip_option)]
    instance_id: Option<Vec<String>>,
}

impl sealed::Bound for DescribeInstanceStatus {}

impl DescribeInstanceStatus {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            zone_id: None,
            cluster_id: None,
            page_number: None,
            page_size: None,
            instance_id: None,
        }
    }
}
impl crate::ToFormData for DescribeInstanceStatus {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceStatus {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceStatus";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceStatusResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.cluster_id {
            params.push(("ClusterId".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            crate::FlatSerialize::flat_serialize(f, "InstanceId", &mut params);
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstances {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 专有网络VPC ID。
    #[setters(generate = true, strip_option)]
    vpc_id: Option<String>,
    /// 交换机ID。
    #[setters(generate = true, strip_option)]
    v_switch_id: Option<String>,
    /// 可用区ID。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 实例网络类型。取值范围：
    ///
    /// - classic：经典网络。
    /// - vpc：专有网络VPC。
    #[setters(generate = true, strip_option)]
    instance_network_type: Option<String>,
    /// 实例所属的安全组。
    #[setters(generate = true, strip_option)]
    security_group_id: Option<String>,
    /// 实例ID。取值可以由多个实例ID组成一个JSON数组，最多支持100个ID，ID之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    instance_ids: Option<String>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 查询凭证（Token），取值为上一次API调用返回的`NextToken`参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。最大值为100。
    ///
    /// 默认值：
    ///
    /// - 当不设置值或设置的值小于10时，默认值为10。
    /// - 当设置的值大于100时，默认值为100。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 经典网络类型实例的内网IP列表。当InstanceNetworkType=classic时生效，取值可以由多个IP组成一个JSON数组，最多支持100个IP，IP之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    inner_ip_addresses: Option<String>,
    /// VPC网络类型实例的私有IP。当InstanceNetworkType=vpc时生效，取值可以由多个IP组成一个JSON数组，最多支持100个IP，IP之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    private_ip_addresses: Option<String>,
    /// 实例的公网IP列表。取值可以由多个IP组成一个JSON数组，最多支持100个IP，IP之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    public_ip_addresses: Option<String>,
    /// 实例的弹性公网IP列表。当InstanceNetworkType=vpc时该参数生效，取值可以由多个IP组成一个JSON数组，最多支持100个IP，IP之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    eip_addresses: Option<String>,
    /// 实例的计费方式。取值范围：
    ///          
    /// - PostPaid：按量付费。
    /// - PrePaid：包年包月。
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 公网带宽计费方式。取值范围：
    ///
    /// - PayByBandwidth：按固定带宽计费。
    /// - PayByTraffic：按使用流量计费。
    ///
    /// > **按使用流量计费**模式下的出入带宽峰值都是带宽上限，不作为业务承诺指标。当出现资源争抢时，带宽峰值可能会受到限制。如果您的业务需要有带宽的保障，请使用**按固定带宽计费**模式。
    #[setters(generate = true, strip_option)]
    internet_charge_type: Option<String>,
    /// 实例名称，支持使用通配符*进行模糊搜索。
    #[setters(generate = true, strip_option)]
    instance_name: Option<String>,
    /// 镜像ID。
    #[setters(generate = true, strip_option)]
    image_id: Option<String>,
    /// 实例状态。取值范围：
    ///
    /// - Pending：创建中。
    /// - Running：运行中。
    /// - Starting：启动中。
    /// - Stopping：停止中。
    /// - Stopped：已停止。
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// 资源被锁定的原因。取值范围：
    ///
    /// - financial：因欠费被锁定。
    ///
    /// - security：因安全原因被锁定。
    ///
    /// - Recycling：抢占式实例的待释放锁定状态。
    ///
    /// - dedicatedhostfinancial：因为专有宿主机欠费导致ECS实例被锁定。
    ///
    /// - refunded：因退款被锁定。
    #[setters(generate = true, strip_option)]
    lock_reason: Option<String>,
    /// 查询资源时的筛选键，取值必须为`CreationStartTime`。同时设置`Filter.1.Key`和`Filter.1.Value`可以查询在指定时间点后创建的资源信息。
    #[setters(generate = true, strip_option)]
    filter1_key: Option<String>,
    /// 查询资源时的筛选键，取值必须为`CreationEndTime`。同时设置`Filter.2.Key`和`Filter.2.Value`可以查询在指定时间点前创建的资源信息。
    #[setters(generate = true, strip_option)]
    filter2_key: Option<String>,
    /// 查询资源时的筛选键，取值必须为`ExpiredStartTime`。同时设置`Filter.3.Key`和`Filter.3.Value`可以查询在指定时间点后到期的资源信息。
    #[setters(generate = true, strip_option)]
    filter3_key: Option<String>,
    /// 查询资源时的筛选键，取值必须为`ExpiredEndTime`。同时设置`Filter.4.Key`和`Filter.4.Value`可以查询在指定时间点前到期的资源信息。
    #[setters(generate = true, strip_option)]
    filter4_key: Option<String>,
    /// 查询资源时的筛选值。指定该参数时必须同时指定`Filter.1.Key`参数，格式为：`yyyy-MM-ddTHH:mmZ`，采用UTC +0时区。
    #[setters(generate = true, strip_option)]
    filter1_value: Option<String>,
    /// 查询资源时的筛选值。指定该参数时必须同时指定`Filter.2.Key`参数，格式为：`yyyy-MM-ddTHH:mmZ`，采用UTC +0时区。
    #[setters(generate = true, strip_option)]
    filter2_value: Option<String>,
    /// 查询资源时的筛选值。指定该参数时必须同时指定`Filter.3.Key`参数，格式为：`yyyy-MM-ddTHH:mmZ`，采用UTC +0时区。
    #[setters(generate = true, strip_option)]
    filter3_value: Option<String>,
    /// 查询资源时的筛选值。指定该参数时必须同时指定`Filter.4.Key`参数，格式为：`yyyy-MM-ddTHH:mmZ`，采用UTC +0时区。
    #[setters(generate = true, strip_option)]
    filter4_value: Option<String>,
    /// >该参数正在邀测中，暂不支持使用。
    #[setters(generate = true, strip_option)]
    device_available: Option<bool>,
    /// 是否是I/O优化型实例。取值范围：
    ///
    /// - true：是。
    /// - false：否。
    #[setters(generate = true, strip_option)]
    io_optimized: Option<bool>,
    /// >该参数正在邀测中，暂不支持使用。
    #[setters(generate = true, strip_option)]
    need_sale_cycle: Option<bool>,
    /// 实例的规格。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 实例的规格族。
    #[setters(generate = true, strip_option)]
    instance_type_family: Option<String>,
    /// 实例使用的SSH密钥对名称。
    #[setters(generate = true, strip_option)]
    key_pair_name: Option<String>,
    /// 实例所在的企业资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 实例所在的HPC集群ID。
    #[setters(generate = true, strip_option)]
    hpc_cluster_id: Option<String>,
    /// HPC实例的RDMA网络IP。
    #[setters(generate = true, strip_option)]
    rdma_ip_addresses: Option<String>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会查询资源状况。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，会返回错误码DryRunOperation。  
    /// - false：发送正常请求，通过检查后返回2XX HTTP状态码并直接查询资源状况。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 是否启用实例元数据的访问通道。取值范围：
    /// - enabled：启用。
    /// - disabled：禁用。
    ///
    /// 默认值：enabled。
    /// >有关实例元数据的更多信息，请参见[实例元数据概述](~~49122~~)。
    #[setters(generate = true, strip_option)]
    http_endpoint: Option<String>,
    /// 访问实例元数据时是否强制使用加固模式（IMDSv2）。取值范围：
    /// - optional：不强制使用。
    /// - required：强制使用。设置该取值后，普通模式无法访问实例元数据。
    ///
    /// 默认值：optional。
    /// >有关访问实例元数据模式的更多信息，请参见[实例元数据访问模式](~~150575~~)。
    #[setters(generate = true, strip_option)]
    http_tokens: Option<String>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    http_put_response_hop_limit: Option<i32>,
    /// 为弹性网卡指定的IPv6地址。
    #[setters(generate = true, strip_option)]
    ipv6_address: Option<Vec<String>>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<DescribeInstancesTag>>,
    /// 实例其他属性列表。
    #[setters(generate = true, strip_option)]
    additional_attributes: Option<Vec<String>>,
}

impl sealed::Bound for DescribeInstances {}

impl DescribeInstances {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            vpc_id: None,
            v_switch_id: None,
            zone_id: None,
            instance_network_type: None,
            security_group_id: None,
            instance_ids: None,
            page_number: None,
            page_size: None,
            next_token: None,
            max_results: None,
            inner_ip_addresses: None,
            private_ip_addresses: None,
            public_ip_addresses: None,
            eip_addresses: None,
            instance_charge_type: None,
            internet_charge_type: None,
            instance_name: None,
            image_id: None,
            status: None,
            lock_reason: None,
            filter1_key: None,
            filter2_key: None,
            filter3_key: None,
            filter4_key: None,
            filter1_value: None,
            filter2_value: None,
            filter3_value: None,
            filter4_value: None,
            device_available: None,
            io_optimized: None,
            need_sale_cycle: None,
            instance_type: None,
            instance_type_family: None,
            key_pair_name: None,
            resource_group_id: None,
            hpc_cluster_id: None,
            rdma_ip_addresses: None,
            dry_run: None,
            http_endpoint: None,
            http_tokens: None,
            http_put_response_hop_limit: None,
            ipv6_address: None,
            tag: None,
            additional_attributes: None,
        }
    }
}
impl crate::ToFormData for DescribeInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(45);

        if let Some(f) = &self.additional_attributes {
            crate::FlatSerialize::flat_serialize(f, "AdditionalAttributes", &mut params);
        }

        if let Some(f) = &self.device_available {
            params.push(("DeviceAvailable".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.eip_addresses {
            params.push(("EipAddresses".into(), (f).into()));
        }

        if let Some(f) = &self.filter1_key {
            params.push(("Filter.1.Key".into(), (f).into()));
        }

        if let Some(f) = &self.filter1_value {
            params.push(("Filter.1.Value".into(), (f).into()));
        }

        if let Some(f) = &self.filter2_key {
            params.push(("Filter.2.Key".into(), (f).into()));
        }

        if let Some(f) = &self.filter2_value {
            params.push(("Filter.2.Value".into(), (f).into()));
        }

        if let Some(f) = &self.filter3_key {
            params.push(("Filter.3.Key".into(), (f).into()));
        }

        if let Some(f) = &self.filter3_value {
            params.push(("Filter.3.Value".into(), (f).into()));
        }

        if let Some(f) = &self.filter4_key {
            params.push(("Filter.4.Key".into(), (f).into()));
        }

        if let Some(f) = &self.filter4_value {
            params.push(("Filter.4.Value".into(), (f).into()));
        }

        if let Some(f) = &self.hpc_cluster_id {
            params.push(("HpcClusterId".into(), (f).into()));
        }

        if let Some(f) = &self.http_endpoint {
            params.push(("HttpEndpoint".into(), (f).into()));
        }

        if let Some(f) = &self.http_put_response_hop_limit {
            params.push(("HttpPutResponseHopLimit".into(), (f).into()));
        }

        if let Some(f) = &self.http_tokens {
            params.push(("HttpTokens".into(), (f).into()));
        }

        if let Some(f) = &self.image_id {
            params.push(("ImageId".into(), (f).into()));
        }

        if let Some(f) = &self.inner_ip_addresses {
            params.push(("InnerIpAddresses".into(), (f).into()));
        }

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_ids {
            params.push(("InstanceIds".into(), (f).into()));
        }

        if let Some(f) = &self.instance_name {
            params.push(("InstanceName".into(), (f).into()));
        }

        if let Some(f) = &self.instance_network_type {
            params.push(("InstanceNetworkType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type_family {
            params.push(("InstanceTypeFamily".into(), (f).into()));
        }

        if let Some(f) = &self.internet_charge_type {
            params.push(("InternetChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.io_optimized {
            params.push(("IoOptimized".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_address {
            crate::FlatSerialize::flat_serialize(f, "Ipv6Address", &mut params);
        }

        if let Some(f) = &self.key_pair_name {
            params.push(("KeyPairName".into(), (f).into()));
        }

        if let Some(f) = &self.lock_reason {
            params.push(("LockReason".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.need_sale_cycle {
            params.push(("NeedSaleCycle".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }

        if let Some(f) = &self.private_ip_addresses {
            params.push(("PrivateIpAddresses".into(), (f).into()));
        }

        if let Some(f) = &self.public_ip_addresses {
            params.push(("PublicIpAddresses".into(), (f).into()));
        }

        if let Some(f) = &self.rdma_ip_addresses {
            params.push(("RdmaIpAddresses".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_id {
            params.push(("SecurityGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.v_switch_id {
            params.push(("VSwitchId".into(), (f).into()));
        }

        if let Some(f) = &self.vpc_id {
            params.push(("VpcId".into(), (f).into()));
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceTypeFamilies {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例规格族的系列信息。更多信息，请参见[实例规格族](~~25378~~)。取值范围：
    ///
    /// - ecs-1：系列I实例规格，上线时间较早，性价比高。
    ///
    /// - ecs-2：系列II实例规格族，第二次软硬件升级，实例性能增强。
    ///
    /// - ecs-3：系列III实例规格族，实例性能优良，能承载不同业务需求。
    ///
    /// - ecs-4：系列IV实例规格族，包含常见的企业级实例规格（g5、c5、r5等）、弹性裸金属服务器实例规格（ebmc5s、ebmg5s、ebmr5s等）、突发性能实例规格（t5）等，具有强大的场景适应性，能承载海量热门业务需求，延迟更低。
    ///
    /// - ecs-5：系列V实例规格族，包含常见的企业级实例规格（g6、c6、r6等）、弹性裸金属服务器实例规格（ebmg6、ebmg6e、ebmc6等）、存储增强型实例规格（g6e）等，响应更快，性能更优越。
    ///
    /// - ecs-6：系列VI实例规格族，包含企业级实例规格（hfc7、hfg7、hfr7等）、弹性裸金属服务器实例规格（ebmhfg7等），该系列实例规格族正在邀测中。
    #[setters(generate = true, strip_option)]
    generation: Option<String>,
}

impl sealed::Bound for DescribeInstanceTypeFamilies {}

impl DescribeInstanceTypeFamilies {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            generation: None,
        }
    }
}
impl crate::ToFormData for DescribeInstanceTypeFamilies {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceTypeFamilies {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceTypeFamilies";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceTypeFamiliesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);

        if let Some(f) = &self.generation {
            params.push(("Generation".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceTypes {
    /// 实例规格所属的实例规格族。取值请参见[DescribeInstanceTypeFamilies](~~25621~~)。
    ///
    /// 关于实例规格族的更多信息，请参见[实例规格族](~~25378~~)。
    #[setters(generate = true, strip_option)]
    instance_type_family: Option<String>,
    /// 指定的实例规格数组。数组长度：1~10。当该参数不传值时，默认查询所有实例规格的信息。
    #[setters(generate = true, strip_option)]
    instance_types: Option<Vec<String>>,
    /// 查询实例规格时，期望最小vCPU内核的数目。取值范围：正整数。
    ///
    /// >查询到实例规格的vCPU内核数目小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_cpu_core_count: Option<i32>,
    /// 查询实例规格时，期望最大vCPU内核的数目。取值范围：正整数。
    ///
    /// >查询到实例规格的vCPU内核数目大于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    maximum_cpu_core_count: Option<i32>,
    /// 查询实例规格时，期望最小内存。单位：GiB。
    ///
    /// >查询到实例规格的内存大小小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_memory_size: Option<f32>,
    /// 查询实例规格时，期望最大内存。单位：GiB。
    ///
    /// >查询到实例规格的内存大小大于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    maximum_memory_size: Option<f32>,
    /// 查询实例规格时，期望最小GPU数目。取值范围：正整数。
    ///
    /// >查询到实例规格的GPU数目小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_gpu_amount: Option<i32>,
    /// 查询实例规格时，期望最大GPU数目。取值范围：正整数。
    ///
    /// >查询到实例规格的GPU数目大于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    maximum_gpu_amount: Option<i32>,
    /// GPU类型。
    /// >支持模糊匹配，如某规格的GPU类型为NVIDIA V100，输入NVIDIA也可查询到该规格信息。
    #[setters(generate = true, strip_option)]
    gpu_spec: Option<String>,
    /// 实例规格分类。取值范围：
    ///
    /// - General-purpose： 通用型。
    /// - Compute-optimized：计算型。
    /// - Memory-optimized：内存型。
    /// - Big data：大数据型。
    /// - Local SSDs ：本地SSD型。
    /// - High Clock Speed ：高主频型。
    /// - Enhanced ：增强型。
    /// - Shared：共享型。
    /// - Compute-optimized with GPU ：GPU计算型。
    /// - Visual Compute-optimized ：视觉计算型。
    /// - Heterogeneous Service ：异构服务型。
    /// - Compute-optimized with FPGA ：FPGA计算型。
    /// - Compute-optimized with NPU ：NPU计算型。
    /// - ECS Bare Metal ：弹性裸金属服务器。
    /// - Super Computing Cluster：超级计算集群。
    /// - High Performance Compute：高性能计算型。
    #[setters(generate = true, strip_option)]
    instance_category: Option<DescribeInstanceTypesInstanceCategory>,
    /// CPU架构。取值范围：
    /// - X86。
    /// - ARM。
    #[setters(generate = true, strip_option)]
    cpu_architecture: Option<DescribeInstanceTypesCpuArchitecture>,
    /// 查询实例规格时，期望最小主频。
    ///
    /// >查询到实例规格的主频小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_cpu_speed_frequency: Option<f32>,
    /// 查询实例规格时，期望最大主频。
    ///
    /// >查询到实例规格的主频大于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    maximum_cpu_speed_frequency: Option<f32>,
    /// 查询实例规格时，期望最小睿频。
    ///
    /// >查询到实例规格的睿频小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_cpu_turbo_frequency: Option<f32>,
    /// 查询实例规格时，期望最大睿频。
    ///
    /// >查询到实例规格的睿频大于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    maximum_cpu_turbo_frequency: Option<f32>,
    /// 处理器型号。
    /// >支持模糊匹配，如某规格的处理器型号为Intel Xeon(Ice Lake) Platinum 8369B，输入Intel也可查询到该规格信息。
    #[setters(generate = true, strip_option)]
    physical_processor_model: Option<String>,
    /// 实例规格族级别。取值范围：
    /// - EntryLevel：入门级（共享型）。
    /// - EnterpriseLevel：企业级。
    /// - CreditEntryLevel：积分入门级。
    #[setters(generate = true, strip_option)]
    instance_family_level: Option<FamilyLevel>,
    /// 查询实例规格时，期望最小内网入方向网络收发包能力。单位：pps。
    ///
    /// >查询到实例规格的内网入方向网络收发包能力小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_instance_pps_rx: Option<i64>,
    /// 查询实例规格时，期望最小内网出方向网络收发包能力。单位：pps。
    ///
    /// >查询到实例规格的内网出方向网络收发包能力小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_instance_pps_tx: Option<i64>,
    /// 查询实例规格时，期望最小内网入方向带宽限制，单位：kbit/s。
    ///
    /// >查询到实例规格的内网入方向带宽限制小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_instance_bandwidth_rx: Option<i32>,
    /// 查询实例规格时，期望最小内网出方向带宽限制，单位：kbit/s。
    ///
    /// >查询到实例规格的内网出方向带宽限制小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_instance_bandwidth_tx: Option<i32>,
    /// 查询实例规格时，期望最小主网卡默认队列数。
    ///
    /// >查询到实例规格的主网卡默认队列数小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_primary_eni_queue_number: Option<i32>,
    /// 查询实例规格时，期望最小辅助弹性网卡默认队列数。
    ///
    /// >查询到实例规格的辅助弹性网卡默认队列数小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_secondary_eni_queue_number: Option<i32>,
    /// 查询实例规格时，期望最小支持挂载的弹性网卡上限。
    ///
    /// >查询到实例规格的支持挂载的弹性网卡上限小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_eni_quantity: Option<i32>,
    /// 查询实例规格时，期望最小单块弹性RDMA网卡（ERI）的QP（QueuePair）队列数上限。
    ///
    /// >查询到实例规格的单块弹性RDMA网卡（ERI）的QP（QueuePair）队列数上限小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_queue_pair_number: Option<i32>,
    /// 查询实例规格时，期望最小弹性RDMA网卡（ERI）数量。
    ///
    /// >查询到实例规格的弹性RDMA网卡（ERI）数量小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_eri_quantity: Option<i32>,
    /// 查询实例规格时，期望最小单块弹性网卡的IPv4地址上限。
    ///
    /// >查询到实例规格的单块弹性网卡的IPv4地址上限小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_eni_private_ip_address_quantity: Option<i32>,
    /// 查询实例规格时，期望最小单块弹性网卡的IPv6地址上限。
    ///
    /// >查询到实例规格的单块弹性网卡的IPv6地址上限小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_eni_ipv6_address_quantity: Option<i32>,
    /// 查询实例规格时，期望最小实例挂载的本地盘的数量。
    ///
    /// >查询到实例规格的实例挂载的本地盘的数量小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_local_storage_amount: Option<i32>,
    /// 实例挂载的本地盘的单盘容量。单位：GiB
    #[setters(generate = true, strip_option)]
    minimum_local_storage_capacity: Option<i64>,
    /// 查询实例规格时，期望最小支持挂载的云盘数量上限。
    ///
    /// >查询到实例规格的支持挂载的云盘数量上限小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_disk_quantity: Option<i32>,
    /// 本地盘类型。更多信息，请参见[本地盘](~~63138#section_n2w_8yc_5u1~~)。取值范围：
    ///
    /// - local\_hdd\_pro：实例规格族d1ne和d1搭载的SATA HDD本地盘。
    /// - local\_ssd\_pro：实例规格族i2、i2g、i1、ga1和gn5等搭载的NVMe SSD本地盘。
    #[setters(generate = true, strip_option)]
    local_storage_category: Option<DescribeInstanceTypesLocalStorageCategory>,
    /// 实例规格所挂载的云盘是否支持NVMe。取值范围：
    ///
    /// - required：支持。表示云盘以NVMe的方式挂载。
    /// - unsupported：不支持。表示云盘不以NVMe的方式挂载。
    #[setters(generate = true, strip_option)]
    nvme_support: Option<NvmeSupport>,
    /// 查询实例规格时，期望最小突发性能实例t5、t6的基准vCPU计算性能（所有vCPU之和）。
    ///
    /// >查询到实例规格的突发性能实例t5、t6的基准vCPU计算性能（所有vCPU之和）小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_baseline_credit: Option<i32>,
    /// 查询实例规格时，期望最小突发性能实例t5、t6的初始vCPU积分值。
    ///
    /// >查询到实例规格的突发性能实例t5、t6的初始vCPU积分值小于设定值时，系统不会返回其实例规格的信息。
    #[setters(generate = true, strip_option)]
    minimum_initial_credit: Option<i32>,
    /// 指定查询的实例规格族数组。数组长度：1~10。
    #[setters(generate = true, strip_option)]
    instance_type_families: Option<Vec<String>>,
    /// 指定查询的GPU类型数组。数组长度：1~10。
    #[setters(generate = true, strip_option)]
    gpu_specs: Option<Vec<String>>,
    /// 指定查询的实例规格分类数组。数组长度：1~10。
    #[setters(generate = true, strip_option)]
    instance_categories: Option<Vec<DescribeInstanceTypesInstanceCategoriesItem>>,
    /// 指定查询的CPU架构数组。数组长度：1~2。
    #[setters(generate = true, strip_option)]
    cpu_architectures: Option<Vec<DescribeInstanceTypesCpuArchitecturesItem>>,
    /// 指定查询的处理器型号数组。数组长度：1~10。
    #[setters(generate = true, strip_option)]
    physical_processor_models: Option<Vec<String>>,
    /// 指定的本地盘类型数组。数组长度：1~2。
    #[setters(generate = true, strip_option)]
    local_storage_categories: Option<Vec<DescribeInstanceTypesLocalStorageCategoriesItem>>,
    /// 分页查询时每页的最大条目数。最大值：1600
    ///
    /// 默认值：1600
    #[setters(generate = true, strip_option)]
    max_results: Option<i64>,
    /// 查询凭证（Token）。取值为上一次调用该接口返回的NextToken参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 指定需要返回的规格高级特性列表。
    #[setters(generate = true, strip_option)]
    additional_attributes: Option<Vec<String>>,
}

impl sealed::Bound for DescribeInstanceTypes {}

impl DescribeInstanceTypes {
    pub fn new() -> Self {
        Self {
            instance_type_family: None,
            instance_types: None,
            minimum_cpu_core_count: None,
            maximum_cpu_core_count: None,
            minimum_memory_size: None,
            maximum_memory_size: None,
            minimum_gpu_amount: None,
            maximum_gpu_amount: None,
            gpu_spec: None,
            instance_category: None,
            cpu_architecture: None,
            minimum_cpu_speed_frequency: None,
            maximum_cpu_speed_frequency: None,
            minimum_cpu_turbo_frequency: None,
            maximum_cpu_turbo_frequency: None,
            physical_processor_model: None,
            instance_family_level: None,
            minimum_instance_pps_rx: None,
            minimum_instance_pps_tx: None,
            minimum_instance_bandwidth_rx: None,
            minimum_instance_bandwidth_tx: None,
            minimum_primary_eni_queue_number: None,
            minimum_secondary_eni_queue_number: None,
            minimum_eni_quantity: None,
            minimum_queue_pair_number: None,
            minimum_eri_quantity: None,
            minimum_eni_private_ip_address_quantity: None,
            minimum_eni_ipv6_address_quantity: None,
            minimum_local_storage_amount: None,
            minimum_local_storage_capacity: None,
            minimum_disk_quantity: None,
            local_storage_category: None,
            nvme_support: None,
            minimum_baseline_credit: None,
            minimum_initial_credit: None,
            instance_type_families: None,
            gpu_specs: None,
            instance_categories: None,
            cpu_architectures: None,
            physical_processor_models: None,
            local_storage_categories: None,
            max_results: None,
            next_token: None,
            additional_attributes: None,
        }
    }
}
impl crate::ToFormData for DescribeInstanceTypes {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceTypes {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceTypes";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceTypesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(44);

        if let Some(f) = &self.additional_attributes {
            crate::FlatSerialize::flat_serialize(f, "AdditionalAttributes", &mut params);
        }

        if let Some(f) = &self.cpu_architecture {
            params.push(("CpuArchitecture".into(), (f).into()));
        }

        if let Some(f) = &self.cpu_architectures {
            crate::FlatSerialize::flat_serialize(f, "CpuArchitectures", &mut params);
        }

        if let Some(f) = &self.gpu_spec {
            params.push(("GPUSpec".into(), (f).into()));
        }

        if let Some(f) = &self.gpu_specs {
            crate::FlatSerialize::flat_serialize(f, "GpuSpecs", &mut params);
        }

        if let Some(f) = &self.instance_categories {
            crate::FlatSerialize::flat_serialize(f, "InstanceCategories", &mut params);
        }

        if let Some(f) = &self.instance_category {
            params.push(("InstanceCategory".into(), (f).into()));
        }

        if let Some(f) = &self.instance_family_level {
            params.push(("InstanceFamilyLevel".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type_families {
            crate::FlatSerialize::flat_serialize(f, "InstanceTypeFamilies", &mut params);
        }

        if let Some(f) = &self.instance_type_family {
            params.push(("InstanceTypeFamily".into(), (f).into()));
        }

        if let Some(f) = &self.instance_types {
            crate::FlatSerialize::flat_serialize(f, "InstanceTypes", &mut params);
        }

        if let Some(f) = &self.local_storage_categories {
            crate::FlatSerialize::flat_serialize(f, "LocalStorageCategories", &mut params);
        }

        if let Some(f) = &self.local_storage_category {
            params.push(("LocalStorageCategory".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.maximum_cpu_core_count {
            params.push(("MaximumCpuCoreCount".into(), (f).into()));
        }

        if let Some(f) = &self.maximum_cpu_speed_frequency {
            params.push(("MaximumCpuSpeedFrequency".into(), (f).into()));
        }

        if let Some(f) = &self.maximum_cpu_turbo_frequency {
            params.push(("MaximumCpuTurboFrequency".into(), (f).into()));
        }

        if let Some(f) = &self.maximum_gpu_amount {
            params.push(("MaximumGPUAmount".into(), (f).into()));
        }

        if let Some(f) = &self.maximum_memory_size {
            params.push(("MaximumMemorySize".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_baseline_credit {
            params.push(("MinimumBaselineCredit".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_cpu_core_count {
            params.push(("MinimumCpuCoreCount".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_cpu_speed_frequency {
            params.push(("MinimumCpuSpeedFrequency".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_cpu_turbo_frequency {
            params.push(("MinimumCpuTurboFrequency".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_disk_quantity {
            params.push(("MinimumDiskQuantity".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_eni_ipv6_address_quantity {
            params.push(("MinimumEniIpv6AddressQuantity".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_eni_private_ip_address_quantity {
            params.push(("MinimumEniPrivateIpAddressQuantity".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_eni_quantity {
            params.push(("MinimumEniQuantity".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_eri_quantity {
            params.push(("MinimumEriQuantity".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_gpu_amount {
            params.push(("MinimumGPUAmount".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_initial_credit {
            params.push(("MinimumInitialCredit".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_instance_bandwidth_rx {
            params.push(("MinimumInstanceBandwidthRx".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_instance_bandwidth_tx {
            params.push(("MinimumInstanceBandwidthTx".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_instance_pps_rx {
            params.push(("MinimumInstancePpsRx".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_instance_pps_tx {
            params.push(("MinimumInstancePpsTx".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_local_storage_amount {
            params.push(("MinimumLocalStorageAmount".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_local_storage_capacity {
            params.push(("MinimumLocalStorageCapacity".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_memory_size {
            params.push(("MinimumMemorySize".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_primary_eni_queue_number {
            params.push(("MinimumPrimaryEniQueueNumber".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_queue_pair_number {
            params.push(("MinimumQueuePairNumber".into(), (f).into()));
        }

        if let Some(f) = &self.minimum_secondary_eni_queue_number {
            params.push(("MinimumSecondaryEniQueueNumber".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.nvme_support {
            params.push(("NvmeSupport".into(), (f).into()));
        }

        if let Some(f) = &self.physical_processor_model {
            params.push(("PhysicalProcessorModel".into(), (f).into()));
        }

        if let Some(f) = &self.physical_processor_models {
            crate::FlatSerialize::flat_serialize(f, "PhysicalProcessorModels", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceAttribute {
    /// 指定实例的ID。
    instance_id: String,
}

impl sealed::Bound for DescribeInstanceAttribute {}

impl DescribeInstanceAttribute {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeInstanceAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(1);
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceAttribute {
    /// 实例ID。
    instance_id: String,
    /// 实例的密码。支持长度为8~30个字符，必须同时包含大小写英文字母、数字和特殊符号中的三类字符。特殊符号可以是：**()`~!@#$%^&*-_+=|{}[]:;'<>,.?/**
    /// 。Windows实例不能以斜线号（/）为密码首字符。使用该参数时请注意：
    ///
    /// - 实例不能处于启动中（`Starting`）状态。
    /// - 重启实例后生效。您可以在ECS控制台重启（具体操作，请参见[重启实例](~~25440~~)）或者调用[RebootInstance](~~25502~~)重启，在操作系统内部重启不能生效。
    ///
    /// > 如果传入`Password`参数，建议您使用HTTPS协议发送请求，避免密码泄露。
    #[setters(generate = true, strip_option)]
    password: Option<String>,
    /// 操作系统的主机名。使用该参数时请注意：
    ///
    /// - 实例不能处于创建中（`Pending`）或启动中（`Starting`）的状态，否则可能出现主机名以及`/etc/hosts`配置失效等情况。您可以调用[DescribeInstances](~~25506~~)查询实例当前的状态信息。
    ///
    /// - 重启实例后生效。您可以在ECS控制台重启（具体操作，请参见[重启实例](~~25440~~)）或者调用[RebootInstance](~~25502~~)重启，在操作系统内部重启不能生效。
    ///
    ///
    /// 不同操作系统主机名存在以下限制：
    ///
    /// - Windows Server系统：长度为2-15个字符，允许使用大小写字母、数字或短划线（-）。不能以短划线（-）开头或结尾，不能连续使用短划线（-），也不能仅使用数字。
    ///
    /// - 其他类型实例（Linux等）：长度为2-64个字符，允许使用半角句号（.）分隔字符成多段，每段允许使用大小写字母、数字或连字符（-），但不能连续使用半角句号（.）或短划线（-）。不能以半角句号（.）或短划线（-）开头或结尾。
    #[setters(generate = true, strip_option)]
    host_name: Option<String>,
    /// 实例名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`或`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    instance_name: Option<String>,
    /// 实例描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 实例自定义数据，建议Base64编码后传入。使用该参数时请注意：
    ///
    /// - 实例必须满足自定义数据使用限制。更多信息，请参见[生成实例自定义数据](~~49121~~)。
    /// - 重启实例后，实例上将展示新的自定义数据，但不会运行数据。
    ///
    /// > 编码前，原始数据不能超过32 KB。建议不要明文传入敏感信息，例如密码和私钥等。如果必须传入敏感信息，建议您加密后再以Base64编码传入，在实例内部以同样的方式解密。
    #[setters(generate = true, strip_option)]
    user_data: Option<String>,
    /// >该参数正在邀测中，暂不开放使用。
    #[setters(generate = true, strip_option)]
    recyclable: Option<bool>,
    /// 修改突发性能实例的运行模式。取值范围：
    ///
    /// - Standard：标准模式。
    /// - Unlimited：无性能约束模式。
    ///
    /// 关于突发性能实例运行模式的更多信息，请参见[什么是突发性能实例](~~59977~~)。
    #[setters(generate = true, strip_option)]
    credit_specification: Option<String>,
    /// 实例释放保护属性。指定是否支持通过控制台或API（[DeleteInstance](~~25507~~)）释放实例。
    ///
    /// > 该属性仅适用于按量付费实例，且只能限制手动释放操作，对系统释放操作不生效。
    #[setters(generate = true, strip_option)]
    deletion_protection: Option<bool>,
    /// 主网卡队列数。使用该参数时请注意：
    /// - 实例必须为已停止（`Stopped`）状态。
    /// - 不能超过实例规格允许的单块网卡最大队列数，实例的所有网卡累加队列数不能超过实例规格允许的队列数总配额。实例规格的单块网卡最大队列数和总配额可以通过[DescribeInstanceTypes](~~25620~~)查询。
    /// - 当取值为-1时，将重置主网卡队列数为对应实例规格的默认值。实例规格的弹性网卡默认队列数可以通过[DescribeInstanceTypes](~~25620~~)查询。
    #[setters(generate = true, strip_option)]
    network_interface_queue_number: Option<i32>,
    /// 实例重新加入的安全组ID数组。使用该参数时请注意：
    ///
    /// - 数组内的安全组ID不能重复，数组长度与实例能够加入安全组配额有关。更多信息，请参见[使用限制](~~25412#SecurityGroupQuota1~~)。
    /// - 实例会离开当前的安全组，如需保留设置，您需要在数组中添加当前的安全组ID。
    /// - 支持切换安全组类型，但设置的安全组列表中不能同时包含普通安全组和企业安全组。
    /// - 安全组必须和实例属于同一个VPC。
    /// - 不支持经典网络类型实例。
    ///
    /// > 修改安全组后很快会生效于对应的实例，但可能有较小的延迟。
    #[setters(generate = true, strip_option)]
    security_group_ids: Option<Vec<String>>,
    /// >该参数正在邀测中，暂不开放使用。
    #[setters(generate = true, strip_option)]
    remote_connection_options: Option<ConnectionOptions>,
    /// 实例MTU是否开启Jumbo frame通信模式，取值范围：
    ///
    /// - true：开启。
    /// - false：不开启。
    ///
    /// 使用该参数时请注意：
    /// - 实例必须处于运行中（`Running`）或者已停止（`Stopped`）状态。
    /// - 实例必须为虚拟专有网络（Virtual Private Cloud, VPC）下的ECS实例。
    /// - 开启Jumbo Frame特性后，实例的MTU值将变为8500，关闭后则回退为1500 。
    /// 目前仅部分规格支持开启Jumbo frame。更多信息，请参见[ECS实例MTU](~~200512~~)。
    #[setters(generate = true, strip_option)]
    enable_jumbo_frame: Option<bool>,
    /// CPU核心数。该参数不支持自定义设置，只能采用默认值。
    ///
    /// <props="china">默认值：请参见[自定义CPU选项](~~145895~~)。</props>
    #[setters(generate = true, strip_option)]
    cpu_options_core: Option<i32>,
    /// CPU线程数。ECS实例的vCPU数=`CpuOptions.Core`取值*`CpuOptions.ThreadsPerCore`取值。
    ///
    /// - `CpuOptions.ThreadsPerCore=1`表示关闭CPU超线程。
    ///
    /// - 仅部分实例规格支持设置CPU线程数。
    ///
    /// <props="china">取值范围和默认值：请参见[自定义CPU选项](~~145895~~)。</props>
    #[setters(generate = true, strip_option)]
    cpu_options_threads_per_core: Option<i32>,
    /// 实例的Cpu拓扑类型。取值范围：
    ///
    /// - ContinuousCoreToHTMapping：实例的Cpu拓扑中，实例的同一个Core的HT是连续的。
    /// - DiscreteCoreToHTMapping：实例的同一个Core的HT是离散的。
    ///
    /// 默认值：无。
    ///
    /// 使用该参数时请注意：
    /// - 实例必须为已停止（`Stopped`）状态。
    ///
    /// > 仅部分实例规格族支持使用本参数，具体支持实例规格族请参见[查看和修改CPU拓扑结构](~~2636059~~)。
    #[setters(generate = true, strip_option)]
    cpu_options_topology_type: Option<String>,
    /// 实例的私网域名配置信息集合。
    ///
    ///
    /// 关于私网域名解析，请参见[ECS私网域名解析
    /// ](~~2844797~~)。
    #[setters(generate = true, strip_option)]
    private_dns_name_options: Option<AttributePrivateDnsNameOptions>,
    /// 开启/关闭VPC网络流量加密，可能值：
    ///
    /// - true：开启。
    /// - false：关闭。
    /// > 该参数正在邀测中，暂未开放使用。
    #[setters(generate = true, strip_option)]
    enable_network_encryption: Option<bool>,
}

impl sealed::Bound for ModifyInstanceAttribute {}

impl ModifyInstanceAttribute {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            password: None,
            host_name: None,
            instance_name: None,
            description: None,
            user_data: None,
            recyclable: None,
            credit_specification: None,
            deletion_protection: None,
            network_interface_queue_number: None,
            security_group_ids: None,
            remote_connection_options: None,
            enable_jumbo_frame: None,
            cpu_options_core: None,
            cpu_options_threads_per_core: None,
            cpu_options_topology_type: None,
            private_dns_name_options: None,
            enable_network_encryption: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(18);

        if let Some(f) = &self.cpu_options_core {
            params.push(("CpuOptions.Core".into(), (f).into()));
        }

        if let Some(f) = &self.cpu_options_threads_per_core {
            params.push(("CpuOptions.ThreadsPerCore".into(), (f).into()));
        }

        if let Some(f) = &self.cpu_options_topology_type {
            params.push(("CpuOptions.TopologyType".into(), (f).into()));
        }

        if let Some(f) = &self.credit_specification {
            params.push(("CreditSpecification".into(), (f).into()));
        }

        if let Some(f) = &self.deletion_protection {
            params.push(("DeletionProtection".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.enable_jumbo_frame {
            params.push(("EnableJumboFrame".into(), (f).into()));
        }

        if let Some(f) = &self.enable_network_encryption {
            params.push(("EnableNetworkEncryption".into(), (f).into()));
        }

        if let Some(f) = &self.host_name {
            params.push(("HostName".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.instance_name {
            params.push(("InstanceName".into(), (f).into()));
        }

        if let Some(f) = &self.network_interface_queue_number {
            params.push(("NetworkInterfaceQueueNumber".into(), (f).into()));
        }

        if let Some(f) = &self.password {
            params.push(("Password".into(), (f).into()));
        }

        if let Some(f) = &self.private_dns_name_options {
            crate::FlatSerialize::flat_serialize(f, "PrivateDnsNameOptions", &mut params);
        }

        if let Some(f) = &self.recyclable {
            params.push(("Recyclable".into(), (f).into()));
        }

        if let Some(f) = &self.remote_connection_options {
            crate::FlatSerialize::flat_serialize(f, "RemoteConnectionOptions", &mut params);
        }

        if let Some(f) = &self.security_group_ids {
            crate::FlatSerialize::flat_serialize(f, "SecurityGroupIds", &mut params);
        }

        if let Some(f) = &self.user_data {
            params.push(("UserData".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceClockOptions {
    /// 幂等参数
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// ECS实例所在的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID。
    instance_id: String,
    /// PTP 状态值。取值范围：
    ///
    /// - enabled：打开 PTP。
    ///
    /// - disabled：关闭 PTP。
    ///
    /// 默认值：disabled。
    #[setters(generate = true, strip_option)]
    ptp_status: Option<String>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会查询资源状况。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，会返回错误码`DryRunOperation`。
    ///
    /// - false：发送正常请求，通过检查后返回2XX的HTTP状态码并直接查询资源状况。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for ModifyInstanceClockOptions {}

impl ModifyInstanceClockOptions {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<String>) -> Self {
        Self {
            client_token: None,
            region_id: region_id.into(),
            instance_id: instance_id.into(),
            ptp_status: None,
            dry_run: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceClockOptions {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceClockOptions {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceClockOptions";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceClockOptionsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.ptp_status {
            params.push(("PtpStatus".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceNetworkOptions {
    /// 待修改网络带宽权重的实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 带宽权重。
    ///
    /// 不同规格支持设置的值不一样，您可以通过[DescribeInstanceTypes](~~2679699~~)查询当前实例规格支持的带宽权重值。
    #[setters(generate = true, strip_option)]
    bandwidth_weighting: Option<String>,
}

impl sealed::Bound for ModifyInstanceNetworkOptions {}

impl ModifyInstanceNetworkOptions {
    pub fn new() -> Self {
        Self {
            instance_id: None,
            bandwidth_weighting: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceNetworkOptions {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceNetworkOptions {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceNetworkOptions";
    const URL_PATH: &'static str = "";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceNetworkOptionsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);

        if let Some(f) = &self.bandwidth_weighting {
            params.push(("BandwidthWeighting".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceChargeType {
    /// 实例ID。取值可以由多台实例ID组成一个JSON数组，最多支持20个ID，ID之间用半角逗号（,）隔开。
    instance_ids: String,
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 包年包月续费时长。如果ECS实例的宿主机为专有宿主机DDH，则取值范围不能超过专有宿主机的订阅时长。取值范围：
    ///
    /// <props="china">
    /// - `PeriodUnit=Week`时，`Period`取值：1、2、3、4。
    /// - `PeriodUnit=Month`时，`Period`取值：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
    ///
    /// </props>
    /// <props="intl">`PeriodUnit=Month`时，`Period`取值：1、2、3、4、5、6、7、8、9、12。</props>
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 续费时长的时间单位，即参数`Period`的单位。取值范围：
    ///
    /// <props="china">
    /// - Week：周。
    /// - Month：月。
    /// - Year：年。
    /// </props>
    /// <props="intl">Month：月。</props>
    ///
    /// 默认值：Month。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 是否将实例挂载的所有按量付费数据盘一起转换为包年包月数据盘。
    ///
    /// - true：是。
    /// - false：否。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    include_data_disks: Option<bool>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会查询资源状况。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，会返回错误码`DryRunOperation`。
    ///
    /// - false：发送正常请求，通过检查后返回2XX的HTTP状态码并直接查询资源状况。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 是否自动支付。取值范围：
    ///
    /// - true：自动支付。您需要确保账户余额充足，如果账户余额不足会生成异常订单，只能作废订单。
    ///
    /// - false：只生成订单不扣费。
    ///
    /// 默认值：true。
    ///
    /// > 如果您的支付方式余额不足，可以将参数AutoPay设置为false，此时会生成未支付订单，您可以登录ECS管理控制台自行支付。
    #[setters(generate = true, strip_option)]
    auto_pay: Option<bool>,
    /// 实例需要修改的目标计费方式。取值范围：
    ///
    /// - PrePaid：将按量付费实例转换为包年包月实例。
    ///
    /// - PostPaid：将包年包月实例转换为按量付费实例。
    ///
    /// 默认值：PrePaid。
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 包年包月转换为按量计费时，是否返回订单费用详情。取值范围：
    ///
    /// - true：是。
    /// - false：否。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    is_detail_fee: Option<bool>,
}

impl sealed::Bound for ModifyInstanceChargeType {}

impl ModifyInstanceChargeType {
    pub fn new(instance_ids: impl Into<String>, region_id: impl Into<String>) -> Self {
        Self {
            instance_ids: instance_ids.into(),
            region_id: region_id.into(),
            period: None,
            period_unit: None,
            include_data_disks: None,
            dry_run: None,
            auto_pay: None,
            instance_charge_type: None,
            client_token: None,
            is_detail_fee: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceChargeType {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceChargeType {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceChargeType";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceChargeTypeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.auto_pay {
            params.push(("AutoPay".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.include_data_disks {
            params.push(("IncludeDataDisks".into(), (f).into()));
        }

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }
        params.push(("InstanceIds".into(), (&self.instance_ids).into()));

        if let Some(f) = &self.is_detail_fee {
            params.push(("IsDetailFee".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceSpec {
    /// 指定的实例ID。
    instance_id: String,
    /// 实例的目标规格。更多信息，请参见[实例规格族](~~25378~~)，也可以调用[DescribeInstanceTypes](~~25620~~)接口获得最新的规格表。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 公网出带宽最大值，单位为Mbit/s（Megabit per second）。取值范围：0~100。
    ///
    /// > **按使用流量计费**模式下的出入带宽峰值都是带宽上限，不作为业务承诺指标。当出现资源争抢时，带宽峰值可能会受到限制。如果您的业务需要有带宽的保障，请使用**按固定带宽计费**模式。
    ///
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_out: Option<i32>,
    /// 公网入带宽最大值，单位为Mbit/s（Megabit per second）。取值范围：
    ///
    /// - 当所购公网出带宽小于等于10 Mbit/s时：1~10，默认为10。
    /// - 当所购公网出带宽大于10 Mbit/s时：1~`InternetMaxBandwidthOut`的取值，默认为`InternetMaxBandwidthOut`的取值。
    ///
    /// > **按使用流量计费**模式下的出入带宽峰值都是带宽上限，不作为业务承诺指标。当出现资源争抢时，带宽峰值可能会受到限制。如果您的业务需要有带宽的保障，请使用**按固定带宽计费**模式。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_in: Option<i32>,
    /// >该参数正在邀测中，暂未开放使用。
    #[setters(generate = true, strip_option)]
    temporary_start_time: Option<String>,
    /// >该参数正在邀测中，暂未开放使用。
    #[setters(generate = true, strip_option)]
    temporary_end_time: Option<String>,
    /// >该参数正在邀测中，暂未开放使用。
    #[setters(generate = true, strip_option)]
    temporary_internet_max_bandwidth_out: Option<i32>,
    /// 是否提交异步请求。取值范围：
    /// - true：是。
    /// - false：否。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option, rename = "r#async")]
    r#async: Option<bool>,
    /// 是否支持跨集群升级实例规格。
    /// - true：是。
    /// - false：否。
    ///
    /// 默认值：false。
    ///
    /// 当参数`AllowMigrateAcrossZone`取值为true时，一旦您根据返回信息升级了云服务器，请留意以下注意事项：
    ///
    /// 经典网络类型实例：
    ///     
    /// * 对于[已停售的实例规格](~~55263~~)，非I/O优化实例变配到I/O优化实例时，实例私网IP地址、磁盘设备名和软件授权码会发生变化。对于Linux实例，普通云盘（`cloud`）会被识别为**xvda**或者**xvdb**等，高效云盘（`cloud_efficiency`）和SSD云盘（`cloud_ssd`）会被识别为**vda**或者**vdb**等。
    ///     
    /// * 对于[正常售卖的实例规格族](~~25378~~)，实例的私网IP地址会发生变化。
    ///
    /// 专有网络VPC类型实例：对于[已停售的实例规格](~~55263~~)，非I/O优化实例变配到I/O优化实例时，云服务器磁盘设备名和软件授权码会发生变化。Linux实例的普通云盘（`cloud`）会被识别为**xvda**或者**xvdb**等，高效云盘（`cloud_efficiency`）和SSD云盘（`cloud_ssd`）会被识别为**vda**或者**vdb**等。
    #[setters(generate = true, strip_option)]
    allow_migrate_across_zone: Option<bool>,
    /// 更换系统盘类型。取值范围：
    ///
    /// - cloud_efficiency：高效云盘
    ///
    /// - cloud_ssd：SSD云盘
    ///
    /// >该参数只有在从[已停售的实例规格](~~55263~~)升级到[正常售卖的实例规格族](~~25378~~)，并将非I/O优化实例规格升级为I/O优化实例规格时有效。
    #[setters(generate = true, strip_option)]
    system_disk_category: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    modify_mode: Option<ModifyInstanceSpecModifyMode>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    disk: Option<Vec<ModifyInstanceSpecDisk>>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会调整实例的实例规格和公网带宽大小。检查项包括是否填写了必需参数、请求格式、业务限制和 ECS 库存。如果检查不通过，则返回对应错误。如果检查通过，则返回错误码`DryRunOperation`。
    /// - false（默认）：发送正常请求，通过检查后直接调整实例的实例规格和公网带宽大小。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for ModifyInstanceSpec {}

impl ModifyInstanceSpec {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            instance_type: None,
            internet_max_bandwidth_out: None,
            internet_max_bandwidth_in: None,
            temporary_start_time: None,
            temporary_end_time: None,
            temporary_internet_max_bandwidth_out: None,
            r#async: None,
            allow_migrate_across_zone: None,
            system_disk_category: None,
            client_token: None,
            modify_mode: None,
            disk: None,
            dry_run: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceSpec {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceSpec {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceSpec";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceSpecResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(14);

        if let Some(f) = &self.allow_migrate_across_zone {
            params.push(("AllowMigrateAcrossZone".into(), (f).into()));
        }

        if let Some(f) = &self.r#async {
            params.push(("Async".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.disk {
            crate::FlatSerialize::flat_serialize(f, "Disk", &mut params);
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_in {
            params.push(("InternetMaxBandwidthIn".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_out {
            params.push(("InternetMaxBandwidthOut".into(), (f).into()));
        }

        if let Some(f) = &self.modify_mode {
            params.push(("ModifyMode".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_category {
            params.push(("SystemDisk.Category".into(), (f).into()));
        }

        if let Some(f) = &self.temporary_end_time {
            params.push(("Temporary.EndTime".into(), (f).into()));
        }

        if let Some(f) = &self.temporary_internet_max_bandwidth_out {
            params.push(("Temporary.InternetMaxBandwidthOut".into(), (f).into()));
        }

        if let Some(f) = &self.temporary_start_time {
            params.push(("Temporary.StartTime".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyPrepayInstanceSpec {
    /// 实例ID。
    instance_id: String,
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 需要变配的目标实例规格。取值请参见[实例规格族](~~25378~~)或者调用[DescribeInstanceTypes](~~25620~~)。
    instance_type: String,
    /// 操作类型。取值范围：
    /// >该参数可无需上传，系统可自动判断升配还是降配；如要上传，请按照下面的逻辑规则操作。
    ///
    /// - upgrade：升级实例规格。请确保您的账户支付方式余额充足。
    ///
    /// - downgrade：降配实例规格。当`InstanceType`设置的实例规格低于当前实例规格时，设置`OperatorType=downgrade`。
    ///
    /// >升级或降低实例规格的注意事项请参见上文接口说明章节。
    #[setters(generate = true, strip_option)]
    operator_type: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。ClientToken只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 升级实例规格时，是否自动支付。取值范围：
    ///
    /// - true：自动支付。
    /// - false：只生成订单不扣费。
    ///
    /// 默认值：true。
    /// > - 自动支付时，您需要确保支付方式余额充足，否则会生成异常订单，只能作废订单。
    /// > - 如果您的支付方式余额不足，可以将参数`AutoPay`置为`false`，此时会生成未支付订单，您可以登录ECS管理控制台自行支付。
    /// > - 当参数`OperatorType`被置为`downgrade`时，将忽略参数`AutoPay`。
    #[setters(generate = true, strip_option)]
    auto_pay: Option<bool>,
    /// 是否支持跨集群升级实例规格。取值范围：
    /// - true：是。
    /// - false：否。
    ///
    /// 默认值：false。
    ///
    /// 当参数`MigrateAcrossZone`取值为`true`时，一旦您根据返回信息升级了云服务器，请留意以下注意事项：
    ///
    /// 经典网络类型实例：
    /// - 对于[已停售的实例规格](~~55263~~)，非I/O优化实例变配到I/O优化实例时，实例私网IP地址、磁盘设备名和软件授权码会发生变化。对于Linux实例，普通云盘（cloud）会被识别为xvda或者xvdb等，高效云盘（cloud_efficiency）和SSD云盘（cloud_ssd）会被识别为vda或者vdb等。
    /// - 对于[正常售卖的实例规格族](~~25378~~)，实例的私网IP地址会发生变化。
    ///
    /// 专有网络VPC类型实例：对于[已停售的实例规格](~~55263~~)，非I/O优化实例变配到I/O优化实例时，云服务器磁盘设备名和软件授权码会发生变化。Linux实例的普通云盘（cloud）会被识别为xvda或者xvdb等，高效云盘（cloud_efficiency）和SSD云盘（cloud_ssd）会被识别为vda或者vdb等。
    #[setters(generate = true, strip_option)]
    migrate_across_zone: Option<bool>,
    /// 更换系统盘类型。取值范围：
    ///
    /// - cloud_efficiency：高效云盘。
    /// - cloud_ssd：SSD云盘。
    /// >该参数仅支持从[已停售的实例规格](~~55263~~)升级到[正常售卖的实例规格族](~~25378~~)，并将非I/O优化实例规格升级为I/O优化实例规格时有效。
    #[setters(generate = true, strip_option)]
    system_disk_category: Option<String>,
    /// 实例的重启时间。按照[ISO 8601](~~25696~~)标准表示，使用UTC+0时间。格式为：yyyy-MM-ddTHH:mmZ。
    #[setters(generate = true, strip_option)]
    reboot_time: Option<String>,
    /// 临时变更的终止时间。按照[ISO 8601](~~25696~~)标准表示，使用UTC+0时间。格式为：yyyy-MM-ddTHH:mmZ。
    #[setters(generate = true, strip_option)]
    end_time: Option<String>,
    /// 实例变配结束后是否立即重启。取值范围：
    ///
    /// - true：是。
    /// - false：否。
    ///
    /// 默认值为false。
    ///
    /// > 若实例处于**已停止**状态，即使您设置了`RebootWhenFinished=true`，也会保持原状态不变，并不会执行任何操作。
    #[setters(generate = true, strip_option)]
    reboot_when_finished: Option<bool>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    modify_mode: Option<PrepayInstanceSpecModifyMode>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    disk: Option<Vec<PrepayInstanceSpecDisk>>,
}

impl sealed::Bound for ModifyPrepayInstanceSpec {}

impl ModifyPrepayInstanceSpec {
    pub fn new(
        instance_id: impl Into<String>,
        region_id: impl Into<String>,
        instance_type: impl Into<String>,
    ) -> Self {
        Self {
            instance_id: instance_id.into(),
            region_id: region_id.into(),
            instance_type: instance_type.into(),
            operator_type: None,
            client_token: None,
            auto_pay: None,
            migrate_across_zone: None,
            system_disk_category: None,
            reboot_time: None,
            end_time: None,
            reboot_when_finished: None,
            modify_mode: None,
            disk: None,
        }
    }
}
impl crate::ToFormData for ModifyPrepayInstanceSpec {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyPrepayInstanceSpec {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyPrepayInstanceSpec";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyPrepayInstanceSpecResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(13);

        if let Some(f) = &self.auto_pay {
            params.push(("AutoPay".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.disk {
            crate::FlatSerialize::flat_serialize(f, "Disk", &mut params);
        }

        if let Some(f) = &self.end_time {
            params.push(("EndTime".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("InstanceType".into(), (&self.instance_type).into()));

        if let Some(f) = &self.migrate_across_zone {
            params.push(("MigrateAcrossZone".into(), (f).into()));
        }

        if let Some(f) = &self.modify_mode {
            params.push(("ModifyMode".into(), (f).into()));
        }

        if let Some(f) = &self.operator_type {
            params.push(("OperatorType".into(), (f).into()));
        }

        if let Some(f) = &self.reboot_time {
            params.push(("RebootTime".into(), (f).into()));
        }

        if let Some(f) = &self.reboot_when_finished {
            params.push(("RebootWhenFinished".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.system_disk_category {
            params.push(("SystemDisk.Category".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceAutoReleaseTime {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    /// 需要自动释放的ECS实例ID。
    instance_id: String,
    /// 自动释放时间。按照[ISO 8601](~~25696~~)标准表示，并使用UTC+0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    ///
    /// - 如果秒（`ss`）取值不是`00`，则自动取为当前分钟（`mm`）开始时。
    ///
    /// - 最短释放时间为当前时间半小时之后。
    ///
    /// - 最长释放时间不能超过当前时间三年。
    ///
    /// 如果不传入参数`AutoReleaseTime`，表示自动释放功能已取消，ECS实例不再自动释放。
    #[setters(generate = true, strip_option)]
    auto_release_time: Option<String>,
}

impl sealed::Bound for ModifyInstanceAutoReleaseTime {}

impl ModifyInstanceAutoReleaseTime {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            region_id: None,
            instance_id: instance_id.into(),
            auto_release_time: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceAutoReleaseTime {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceAutoReleaseTime {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceAutoReleaseTime";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceAutoReleaseTimeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.auto_release_time {
            params.push(("AutoReleaseTime".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AttachInstanceRamRole {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例RAM角色名称。您可以使用RAM API [ListRoles](~~28713~~)查询您已创建的实例RAM角色。
    ram_role_name: String,
    /// 实例ID数组。数组长度：1~100。
    instance_ids: String,
    /// 额外权限策略。可以指定一个额外的权限策略，以进一步限制RAM角色的权限。更多信息，请参见[权限策略概览](~~93732~~)。长度为1~1024个字符。
    #[setters(generate = true, strip_option)]
    policy: Option<String>,
}

impl sealed::Bound for AttachInstanceRamRole {}

impl AttachInstanceRamRole {
    pub fn new(
        region_id: impl Into<String>,
        ram_role_name: impl Into<String>,
        instance_ids: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            ram_role_name: ram_role_name.into(),
            instance_ids: instance_ids.into(),
            policy: None,
        }
    }
}
impl crate::ToFormData for AttachInstanceRamRole {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AttachInstanceRamRole {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AttachInstanceRamRole";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AttachInstanceRamRoleResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("InstanceIds".into(), (&self.instance_ids).into()));

        if let Some(f) = &self.policy {
            params.push(("Policy".into(), (f).into()));
        }
        params.push(("RamRoleName".into(), (&self.ram_role_name).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceRamRole {
    /// 查询接口返回资源信息列表的页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页展示响应信息时设置的每页行数，单位：行。
    ///
    /// 最大值：50。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 实例RAM角色所在的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 指定查询的实例ID的集合。最多支持一次查询50台实例。
    /// > `InstanceIds`与`RamRoleName`参数必须至少填写一个。
    #[setters(generate = true, strip_option)]
    instance_ids: Option<String>,
    /// 查询赋予了某一实例RAM角色的所有ECS实例。您可以使用RAM API [ListRoles](~~28713~~)查询您已创建的实例RAM角色。
    /// > `InstanceIds`与`RamRoleName`参数必须至少填写一个。
    #[setters(generate = true, strip_option)]
    ram_role_name: Option<String>,
}

impl sealed::Bound for DescribeInstanceRamRole {}

impl DescribeInstanceRamRole {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            page_number: None,
            page_size: None,
            region_id: region_id.into(),
            instance_ids: None,
            ram_role_name: None,
        }
    }
}
impl crate::ToFormData for DescribeInstanceRamRole {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceRamRole {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceRamRole";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceRamRoleResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.instance_ids {
            params.push(("InstanceIds".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }

        if let Some(f) = &self.ram_role_name {
            params.push(("RamRoleName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DetachInstanceRamRole {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 指定收回的实例RAM角色名称。您可以使用RAM API [ListRoles](~~28713~~)查询您已创建的实例RAM角色名称。
    #[setters(generate = true, strip_option)]
    ram_role_name: Option<String>,
    /// 指定收回的实例ID数组。数组长度：1~100。
    instance_ids: String,
}

impl sealed::Bound for DetachInstanceRamRole {}

impl DetachInstanceRamRole {
    pub fn new(region_id: impl Into<String>, instance_ids: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            ram_role_name: None,
            instance_ids: instance_ids.into(),
        }
    }
}
impl crate::ToFormData for DetachInstanceRamRole {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DetachInstanceRamRole {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DetachInstanceRamRole";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DetachInstanceRamRoleResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("InstanceIds".into(), (&self.instance_ids).into()));

        if let Some(f) = &self.ram_role_name {
            params.push(("RamRoleName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceVncUrl {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID。
    instance_id: String,
}

impl sealed::Bound for DescribeInstanceVncUrl {}

impl DescribeInstanceVncUrl {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeInstanceVncUrl {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceVncUrl {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceVncUrl";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceVncUrlResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceVncPasswd {
    /// 实例ID。
    instance_id: String,
    /// ECS实例所在的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// VNC登录的新密码。
    vnc_password: String,
}

impl sealed::Bound for ModifyInstanceVncPasswd {}

impl ModifyInstanceVncPasswd {
    pub fn new(
        instance_id: impl Into<String>,
        region_id: impl Into<String>,
        vnc_password: impl Into<String>,
    ) -> Self {
        Self {
            instance_id: instance_id.into(),
            region_id: region_id.into(),
            vnc_password: vnc_password.into(),
        }
    }
}
impl crate::ToFormData for ModifyInstanceVncPasswd {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceVncPasswd {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceVncPasswd";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceVncPasswdResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("VncPassword".into(), (&self.vnc_password).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceMetadataOptions {
    /// 实例所在地域的ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 指定的实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 是否启用实例元数据的访问通道。取值范围：
    /// - enabled：启用。
    /// - disabled：禁用。
    ///
    /// 默认值：enabled。
    /// > 有关实例元数据的更多信息，请参见[实例元数据概述](~~49122~~)。
    http_endpoint: String,
    /// 访问实例元数据时是否强制使用加固模式。取值范围：
    /// - optional：不强制使用。
    /// - required：强制使用。设置该取值后，普通模式无法访问实例元数据。
    ///
    /// 默认值：optional。
    /// > 有关实例元数据访问模式的更多信息，请参见[实例元数据访问模式](~~150575~~)。
    #[setters(generate = true, strip_option)]
    http_tokens: Option<String>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    http_put_response_hop_limit: Option<i32>,
    /// 是否启用实例元数据的访问标签能力。取值范围：
    /// - enabled：启用。
    /// - disabled：禁用。
    ///
    /// 默认值：disabled。
    /// <notice>
    /// 标签键需为字母、数字、@、半角冒号（:）、下划线（_）、短划线（-）、句点（.）、等号（=）、半角逗号（,）的组合，且不能为"."或者".."，否则无法在元数据中访问。
    /// </notice>
    #[setters(generate = true, strip_option)]
    instance_metadata_tags: Option<String>,
}

impl sealed::Bound for ModifyInstanceMetadataOptions {}

impl ModifyInstanceMetadataOptions {
    pub fn new(region_id: impl Into<String>, http_endpoint: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: None,
            http_endpoint: http_endpoint.into(),
            http_tokens: None,
            http_put_response_hop_limit: None,
            instance_metadata_tags: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceMetadataOptions {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceMetadataOptions {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceMetadataOptions";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceMetadataOptionsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);
        params.push(("HttpEndpoint".into(), (&self.http_endpoint).into()));

        if let Some(f) = &self.http_put_response_hop_limit {
            params.push(("HttpPutResponseHopLimit".into(), (f).into()));
        }

        if let Some(f) = &self.http_tokens {
            params.push(("HttpTokens".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.instance_metadata_tags {
            params.push(("InstanceMetadataTags".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeUserData {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 指定查询的实例ID。
    instance_id: String,
}

impl sealed::Bound for DescribeUserData {}

impl DescribeUserData {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeUserData {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeUserData {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeUserData";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeUserDataResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RenewInstance {
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 需要续费的实例ID。
    instance_id: String,
    /// 包年包月续费时长。一旦指定了`DedicatedHostId`，则取值范围不能超过专有宿主机的订阅时长。取值范围：
    ///
    /// <props="china">
    /// - PeriodUnit=Week时，Period取值：1、2、3、4。
    /// - PeriodUnit=Month时，Period取值：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
    ///
    /// </props>
    ///
    /// <props="intl">PeriodUnit=Month时，Period取值：1、2、3、4、5、6、7、8、9、12。</props>
    ///
    /// > 您必须指定续费时长参数（`Period`、`PeriodUnit`）或统一到期日参数（`ExpectedRenewDay`）的其中一个，但不能同时设置。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 续费时长的时间单位，即参数Period的单位。取值范围：
    ///
    /// <props="china">
    /// - Week。
    /// - Month。
    ///
    /// </props>
    ///
    /// <props="intl">Month。</props>
    ///
    /// 默认值：Month。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 用于续费实例至[统一到期日](~~63396~~)。取值范围：1~28。
    ///
    /// 使用该参数，您需要[设置ECS实例统一到期日](~~63396#694cb636c0rp6~~)，该参数值必须与您已设置的统一到期日保持一致，否则将调用失败。
    ///
    /// > 您必须指定续费时长参数（`Period`、`PeriodUnit`）或统一到期日参数（`ExpectedRenewDay`）的其中一个，但不能同时设置。
    #[setters(generate = true, strip_option)]
    expected_renew_day: Option<i32>,
}

impl sealed::Bound for RenewInstance {}

impl RenewInstance {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            client_token: None,
            instance_id: instance_id.into(),
            period: None,
            period_unit: None,
            expected_renew_day: None,
        }
    }
}
impl crate::ToFormData for RenewInstance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RenewInstance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RenewInstance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RenewInstanceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.expected_renew_day {
            params.push(("ExpectedRenewDay".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceAutoRenewAttribute {
    /// 实例ID。支持最多100台包年包月实例批量查询，多个实例ID以半角逗号分隔。
    ///
    /// > `InstanceId`与`RenewalStatus`参数至少需要填写一个。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例的自动续费状态。取值范围：
    ///
    /// - AutoRenewal：设置为自动续费。
    ///
    /// - Normal：取消自动续费。
    ///
    /// - NotRenewal：不再续费，系统不再发送到期提醒，只在到期前第三天发送不续费提醒。不再续费的ECS实例可以通过[ModifyInstanceAutoRenewAttribute](~~52843~~)更改成待续费（`Normal`）后，再自行续费或设置为自动续费。
    #[setters(generate = true, strip_option)]
    renewal_status: Option<String>,
    /// 分页展示响应信息时设置的每页行数，单位：行。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<String>,
    /// 查询接口返回资源信息列表的页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<String>,
}

impl sealed::Bound for DescribeInstanceAutoRenewAttribute {}

impl DescribeInstanceAutoRenewAttribute {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            instance_id: None,
            region_id: region_id.into(),
            renewal_status: None,
            page_size: None,
            page_number: None,
        }
    }
}
impl crate::ToFormData for DescribeInstanceAutoRenewAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceAutoRenewAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceAutoRenewAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceAutoRenewAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.renewal_status {
            params.push(("RenewalStatus".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceAutoRenewAttribute {
    /// 实例ID。支持批量设置最多100个包年包月实例，多个实例ID以英文逗号分隔。
    instance_id: String,
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 设置实例自动续费时长。
    ///
    /// <props="china">
    /// - `PeriodUnit`为`Year`（年）时，`Duration`的取值范围为：{"1", "2", "3", "4", "5"}
    /// - `PeriodUnit`为`Month`（月）时，`Duration`的取值范围为：{"1", "2", "3", "6", "12", "24", "36", "48", "60"}
    /// - `PeriodUnit`为`Week`（周）时，`Duration`的取值范围为：{"1", "2", "3", "4"}
    ///
    /// </props>
    ///
    /// <props="intl">
    /// - `PeriodUnit`为`Year`（年）时，`Duration`的取值范围为：{"1", "2", "3", "4", "5"}
    /// - `PeriodUnit`为`Month`（月）时，`Duration`的取值范围为：{"1", "2", "3", "6", "12", "24", "36", "48", "60"}
    ///
    /// </props>
    ///
    /// <props="partner">
    /// - `PeriodUnit`为`Year`（年）时，`Duration`的取值范围为：{"1", "2", "3", "4", "5"}
    /// - `PeriodUnit`为`Month`（月）时，`Duration`的取值范围为：{"1", "2", "3", "6", "12", "24", "36", "48", "60"}
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    duration: Option<i32>,
    /// 实例到期前是否自动续费。
    ///
    /// - true：是。
    /// - false：否。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    auto_renew: Option<bool>,
    /// 实例的自动续费状态。取值范围：
    ///
    /// - AutoRenewal：设置为自动续费。
    ///
    /// - Normal：取消自动续费。
    ///
    /// - NotRenewal：不再续费。传入该值后，系统不再发送到期提醒，只在到期前第三天发送不续费提醒。不再续费的ECS实例可以更改成待续费（`Normal`）后，再自行续费或设置为自动续费。
    ///
    /// > 参数`RenewalStatus`的优先级高于参数`AutoRenew`。如果不传入参数`RenewalStatus`，则默认以参数`AutoRenew`为准。
    #[setters(generate = true, strip_option)]
    renewal_status: Option<String>,
    /// 续费时长的时间单位，即参数`Duration`的单位。取值范围：
    ///
    /// <props="china">
    /// - Week
    /// - Month（默认）
    /// - Year
    ///
    /// </props>
    ///
    /// <props="intl">
    /// - Month（默认）
    /// - Year
    ///
    /// </props>
    ///
    /// <props="partner">
    /// - Month（默认）
    /// - Year
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
}

impl sealed::Bound for ModifyInstanceAutoRenewAttribute {}

impl ModifyInstanceAutoRenewAttribute {
    pub fn new(instance_id: impl Into<String>, region_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            region_id: region_id.into(),
            duration: None,
            auto_renew: None,
            renewal_status: None,
            period_unit: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceAutoRenewAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceAutoRenewAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceAutoRenewAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceAutoRenewAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.auto_renew {
            params.push(("AutoRenew".into(), (f).into()));
        }

        if let Some(f) = &self.duration {
            params.push(("Duration".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.renewal_status {
            params.push(("RenewalStatus".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ReActivateInstances {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    /// 需要重开机的实例ID。
    instance_id: String,
}

impl sealed::Bound for ReActivateInstances {}

impl ReActivateInstances {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            region_id: None,
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for ReActivateInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ReActivateInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ReActivateInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ReActivateInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSpotPriceHistory {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 可用区ID。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 抢占式实例网络类型。取值范围：
    ///
    /// - classic：表示抢占式实例的网络类型为经典网络。
    ///
    /// - vpc：表示抢占式实例的网络类型为专有网络。
    network_type: String,
    /// 实例规格。
    instance_type: String,
    /// 抢占式实例的保留时长，单位为小时。 默认值：1。取值范围：
    /// - 1：创建后阿里云会保证实例运行1小时不会被自动释放；超过1小时后，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    /// - 0：创建后，阿里云不保证实例运行1小时，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    ///
    /// 实例回收前5分钟阿里云会通过ECS系统事件向您发送通知。抢占式实例按秒计费，建议您结合具体任务执行耗时来选择合适的保留时长。
    ///
    /// > 当SpotStrategy值为SpotWithPriceLimit或SpotAsPriceGo时该参数生效。
    #[setters(generate = true, strip_option)]
    spot_duration: Option<i32>,
    /// 是否为I/O优化实例。取值范围：
    ///
    /// - optimized：表示抢占式实例为I/O优化实例。
    ///
    /// - none：表示抢占式实例为非I/O优化实例。
    ///
    /// 系列I实例默认值：none。
    ///
    /// 其余实例规格族默认值：optimized。
    #[setters(generate = true, strip_option)]
    io_optimized: Option<String>,
    /// 查询抢占式实例历史价格的起始时间，最大值不得超过指定的结束时间30天。按照[ISO 8601](~~25696~~)标准表示，并使用UTC +0时间，格式为`yyyy-MM-ddTHH:mm:ssZ`。
    ///
    /// 默认值：空，空代表结束时间前3小时。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
    /// 查询抢占式实例历史价格的结束时间。按照[ISO 8601](~~25696~~)标准表示，并使用UTC +0时间，格式为`yyyy-MM-ddTHH:mm:ssZ`。
    ///
    /// 默认值：空，空表示当前时间。
    #[setters(generate = true, strip_option)]
    end_time: Option<String>,
    /// 操作系统的发行平台类型。取值范围：
    ///
    /// - linux。
    /// - windows。
    #[setters(generate = true, strip_option)]
    os_type: Option<String>,
    /// 查询开始行。
    ///
    /// 默认值：0。
    #[setters(generate = true, strip_option)]
    offset: Option<i32>,
}

impl sealed::Bound for DescribeSpotPriceHistory {}

impl DescribeSpotPriceHistory {
    pub fn new(
        region_id: impl Into<String>,
        network_type: impl Into<String>,
        instance_type: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            zone_id: None,
            network_type: network_type.into(),
            instance_type: instance_type.into(),
            spot_duration: None,
            io_optimized: None,
            start_time: None,
            end_time: None,
            os_type: None,
            offset: None,
        }
    }
}
impl crate::ToFormData for DescribeSpotPriceHistory {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSpotPriceHistory {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSpotPriceHistory";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSpotPriceHistoryResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.end_time {
            params.push(("EndTime".into(), (f).into()));
        }
        params.push(("InstanceType".into(), (&self.instance_type).into()));

        if let Some(f) = &self.io_optimized {
            params.push(("IoOptimized".into(), (f).into()));
        }
        params.push(("NetworkType".into(), (&self.network_type).into()));

        if let Some(f) = &self.os_type {
            params.push(("OSType".into(), (f).into()));
        }

        if let Some(f) = &self.offset {
            params.push(("Offset".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.spot_duration {
            params.push(("SpotDuration".into(), (f).into()));
        }

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSpotAdvice {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例规格的vCPU数量。取值请参见[实例规格族](~~25378~~)。
    #[setters(generate = true, strip_option)]
    cores: Option<i32>,
    /// 实例规格的内存大小。单位：GiB。取值请参见[实例规格族](~~25378~~)。
    #[setters(generate = true, strip_option)]
    memory: Option<f32>,
    /// 实例规格的vCPU数量的最小值。取值请参见[实例规格族](~~25378~~)。
    #[setters(generate = true, strip_option)]
    min_cores: Option<i32>,
    /// 实例规格的内存大小的最小值。取值请参见[实例规格族](~~25378~~)。
    #[setters(generate = true, strip_option)]
    min_memory: Option<f32>,
    /// 可用区ID。
    ///
    /// 默认值：无，即查询指定地域下的所有可用区。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 实例规格族。取值请参见[实例规格族](~~25378~~)。
    #[setters(generate = true, strip_option)]
    instance_type_family: Option<String>,
    /// 实例规格族级别。取值范围：
    ///
    /// - EntryLevel：入门级。
    /// - EnterpriseLevel：企业级。
    /// - CreditEntryLevel：积分入门级。更多信息，请参见[突发性能实例](~~59977~~)。
    ///
    /// 默认值：无，即查询所有级别。
    #[setters(generate = true, strip_option)]
    instance_family_level: Option<String>,
    /// GPU计算卡的类型。取值范围：
    ///
    /// - NVIDIA P4
    /// - NVIDIA T4
    /// - NVIDIA P100
    /// - NVIDIA V100
    ///
    /// 默认值：无，即查询所有类型。更多信息，请参见[GPU计算型实例概述](~~108496~~)。
    #[setters(generate = true, strip_option)]
    gpu_spec: Option<String>,
    /// GPU实例对应的GPU数量。取值请参见[GPU计算型实例概述](~~108496~~)。
    #[setters(generate = true, strip_option)]
    gpu_amount: Option<i32>,
    /// 实例规格列表。最多可输入10个实例规格。
    #[setters(generate = true, strip_option)]
    instance_types: Option<Vec<String>>,
}

impl sealed::Bound for DescribeSpotAdvice {}

impl DescribeSpotAdvice {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            cores: None,
            memory: None,
            min_cores: None,
            min_memory: None,
            zone_id: None,
            instance_type_family: None,
            instance_family_level: None,
            gpu_spec: None,
            gpu_amount: None,
            instance_types: None,
        }
    }
}
impl crate::ToFormData for DescribeSpotAdvice {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSpotAdvice {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSpotAdvice";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSpotAdviceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(11);

        if let Some(f) = &self.cores {
            params.push(("Cores".into(), (f).into()));
        }

        if let Some(f) = &self.gpu_amount {
            params.push(("GpuAmount".into(), (f).into()));
        }

        if let Some(f) = &self.gpu_spec {
            params.push(("GpuSpec".into(), (f).into()));
        }

        if let Some(f) = &self.instance_family_level {
            params.push(("InstanceFamilyLevel".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type_family {
            params.push(("InstanceTypeFamily".into(), (f).into()));
        }

        if let Some(f) = &self.instance_types {
            crate::FlatSerialize::flat_serialize(f, "InstanceTypes", &mut params);
        }

        if let Some(f) = &self.memory {
            params.push(("Memory".into(), (f).into()));
        }

        if let Some(f) = &self.min_cores {
            params.push(("MinCores".into(), (f).into()));
        }

        if let Some(f) = &self.min_memory {
            params.push(("MinMemory".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateImage {
    /// 镜像所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 用于创建自定义镜像的快照ID。
    ///
    /// > 如果仅使用实例的系统盘快照创建自定义镜像时，您可以使用该参数，也可以选用参数`DiskDeviceMapping.N.SnapshotId`。如果增加数据盘快照，只能使用`DiskDeviceMapping.N.SnapshotId`参数指定快照。
    #[setters(generate = true, strip_option)]
    snapshot_id: Option<String>,
    /// 实例ID。根据实例创建自定义镜像时，必须指定该参数。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 镜像名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以http://和https://开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    image_name: Option<String>,
    /// 镜像族系名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以aliyun和acs:开头，不能包含http://或者https://。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    image_family: Option<String>,
    /// 镜像版本。
    ///
    /// > 当您指定了实例ID（`InstanceId`），并且该实例的镜像是云市场镜像或者来自云市场镜像创建的自定义镜像时，该参数必须和当前实例镜像的`ImageVersion`相同或置为空。
    #[setters(generate = true, strip_option)]
    image_version: Option<String>,
    /// 镜像的描述信息。长度为2~256个英文或中文字符，不能以http://或https://开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 操作系统，指定数据盘快照做镜像的系统盘后，需要通过Platform确定系统盘的操作系统发行版。取值范围：
    ///
    /// - Aliyun
    /// - Anolis
    /// - CentOS
    /// - Ubuntu
    /// - CoreOS
    /// - SUSE
    /// - Debian
    /// - OpenSUSE
    /// - FreeBSD
    /// - RedHat
    /// - Kylin
    /// - UOS
    /// - Fedora
    /// - Fedora CoreOS
    /// - CentOS Stream
    /// - AlmaLinux
    /// - Rocky Linux
    /// - Gentoo
    /// - Customized Linux
    /// - Others Linux
    /// - Windows Server 2022
    /// - Windows Server 2019
    /// - Windows Server 2016
    /// - Windows Server 2012
    /// - Windows Server 2008
    /// - Windows Server 2003
    ///
    /// 默认值：Others Linux。
    #[setters(generate = true, strip_option)]
    platform: Option<String>,
    /// 修改镜像的启动模式。取值范围：
    ///
    /// - BIOS：BIOS启动模式。
    /// - UEFI：UEFI启动模式。
    /// - （默认）UEFI-Preferred：双启动模式。  
    ///
    /// <notice>
    ///
    /// 为了避免使用镜像不支持的启动模式导致实例无法正常启动，请您务必在选择该参数之前了解目标镜像支持的启动模式。镜像启动模式详情，请参见[镜像启动模式](~~2244655#b9caa9b8bb1wf~~)。
    ///
    /// </notice>
    #[setters(generate = true, strip_option)]
    boot_mode: Option<String>,
    /// 系统架构，指定数据盘快照做镜像的系统盘后，需要通过Architecture确定系统盘的系统架构。取值范围：
    ///
    /// - i386。
    /// - x86_64。
    /// - arm64。
    ///
    /// 默认值：x86_64。
    #[setters(generate = true, strip_option)]
    architecture: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 自定义镜像所在的资源组ID。如果不设置该参数值，创建的镜像属于默认资源组。
    ///
    /// > 如果您使用RAM用户调用该接口，且`ResourceGroupId`取值为空，您需要注意，当RAM用户没有默认资源组权限时，调用接口会返回报错信息`Forbidden: User not authorized to operate on the specified resource`。请设置RAM用户支持的资源组ID或者通过相应阿里云账号为该RAM用户授予默认资源组权限后，再次调用该接口。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 创建自定义镜像使用的云盘和快照信息集合。如果需要根据系统盘快照和数据盘快照创建自定义镜像，请使用该参数指定快照。
    #[setters(generate = true, strip_option)]
    disk_device_mapping: Option<Vec<CreateImageDiskDeviceMapping>>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<CreateImageTag>>,
    /// 镜像检测策略，不配置此参数时不触发检测。仅支持标准（Standard）检测模式。
    ///
    /// > 目前已支持大部分的Linux/Windows版本，关于镜像检测项与操作系统限制说明，请参见[镜像检测概述](~~439819~~)和[镜像检测操作系统限制](~~475800~~)。
    #[setters(generate = true, strip_option)]
    detection_strategy: Option<String>,
    /// 镜像特性相关属性。
    #[setters(generate = true, strip_option)]
    features: Option<CreateImageFeatures>,
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for CreateImage {}

impl CreateImage {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            snapshot_id: None,
            instance_id: None,
            image_name: None,
            image_family: None,
            image_version: None,
            description: None,
            platform: None,
            boot_mode: None,
            architecture: None,
            client_token: None,
            resource_group_id: None,
            disk_device_mapping: None,
            tag: None,
            detection_strategy: None,
            features: None,
            dry_run: None,
        }
    }
}
impl crate::ToFormData for CreateImage {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateImage {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateImage";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateImageResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(17);

        if let Some(f) = &self.architecture {
            params.push(("Architecture".into(), (f).into()));
        }

        if let Some(f) = &self.boot_mode {
            params.push(("BootMode".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.detection_strategy {
            params.push(("DetectionStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.disk_device_mapping {
            crate::FlatSerialize::flat_serialize(f, "DiskDeviceMapping", &mut params);
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.features {
            crate::FlatSerialize::flat_serialize(f, "Features", &mut params);
        }

        if let Some(f) = &self.image_family {
            params.push(("ImageFamily".into(), (f).into()));
        }

        if let Some(f) = &self.image_name {
            params.push(("ImageName".into(), (f).into()));
        }

        if let Some(f) = &self.image_version {
            params.push(("ImageVersion".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.platform {
            params.push(("Platform".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.snapshot_id {
            params.push(("SnapshotId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeImages {
    /// 镜像所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 查询指定状态的镜像，如果不配置此参数，默认只返回Available状态的镜像。取值范围：
    ///
    /// - Creating：镜像正在创建中。
    /// - Waiting：多任务排队中。
    /// - Available（默认）：您可以使用的镜像。
    /// - UnAvailable：您不能使用的镜像。
    /// - CreateFailed：创建失败的镜像。
    /// - Deprecated：已弃用的镜像。
    ///
    /// 默认值：Available。当前参数支持同时取多个值，值之间以半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// 镜像ID。
    ///
    /// <details>
    /// <summary>镜像ID的命名规则</summary>
    ///
    /// - 公共镜像：以操作系统版本号、架构、语言和发布日期命名。例如，Windows Server 2008 R2企业版、64位英文系统的镜像ID为win2008r2_64_ent_sp1_en-us_40G_alibase_20190318.vhd。
    ///
    /// - 自定义镜像、共享镜像、云市场镜像、社区镜像的镜像：以m开头。
    ///
    /// </details>
    #[setters(generate = true, strip_option)]
    image_id: Option<String>,
    /// 订阅型镜像是否已经超过使用期限。
    #[setters(generate = true, strip_option)]
    show_expired: Option<bool>,
    /// 根据某一快照ID创建的自定义镜像。
    #[setters(generate = true, strip_option)]
    snapshot_id: Option<String>,
    /// 镜像名称。支持模糊搜索。
    #[setters(generate = true, strip_option)]
    image_name: Option<String>,
    /// 镜像族系名称，查询镜像时可通过设置该参数来过滤当前族系对应的镜像。
    ///
    /// 默认值：空。
    /// > 阿里云官方镜像关联的镜像族系信息请参见[公共镜像概述](~~108393~~)。
    #[setters(generate = true, strip_option)]
    image_family: Option<String>,
    /// 镜像来源。取值范围：
    ///
    /// - system：阿里云官方提供的，且不是通过云市场发布的镜像，和控制台中的“公共镜像”概念不同。
    /// - self：您创建的自定义镜像。
    /// - others：包含共享镜像（其他阿里云用户直接共享给您的镜像）和社区镜像（任意阿里云用户将其自定义镜像完全公开共享后的镜像）。您需要注意：
    ///     - 查找社区镜像时，IsPublic必须为true。
    ///     - 查找共享镜像时，IsPublic需要设置为false或者不传值。
    /// - marketplace：阿里云或者第三方供应商ISV在云市场发布的镜像，需要和ECS一起购买。请自行留意云市场镜像的收费详情。
    ///
    /// 默认值：空。
    ///
    /// >空表示返回取值为system、self以及others的结果。
    #[setters(generate = true, strip_option)]
    image_owner_alias: Option<String>,
    /// 为指定的实例规格查询可以使用的镜像。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 镜像是否可以运行在I/O优化实例上。
    #[setters(generate = true, strip_option)]
    is_support_io_optimized: Option<bool>,
    /// 镜像是否支持cloud-init。
    #[setters(generate = true, strip_option)]
    is_support_cloudinit: Option<bool>,
    /// 镜像的操作系统类型。取值范围：
    ///
    /// - windows。
    /// - linux。
    #[setters(generate = true, strip_option)]
    os_type: Option<String>,
    /// 镜像的体系架构。取值范围：
    ///
    /// - i386。
    /// - x86_64。
    /// - arm64。
    #[setters(generate = true, strip_option)]
    architecture: Option<String>,
    /// 镜像资源列表的页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 镜像是否已经运行在ECS实例中。取值范围：
    ///
    /// - instance：镜像处于运行状态，有ECS实例使用。
    /// - none：镜像处于闲置状态，暂无ECS实例使用。
    #[setters(generate = true, strip_option)]
    usage: Option<String>,
    /// 是否只预检此次请求。
    ///          
    /// - true：发送检查请求，不会查询资源状况。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，会返回错误码DryRunOperation。  
    /// - false：发送正常请求，通过检查后返回2XX HTTP状态码并直接查询资源状况。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 镜像需要被使用到的场景。取值范围：
    ///
    /// - CreateEcs（默认）：创建实例。
    /// - ChangeOS：更换系统盘/更换操作系统。
    #[setters(generate = true, strip_option)]
    action_type: Option<String>,
    /// 自定义镜像所在的企业资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ImagesTag>>,
    /// 查询资源时的筛选条件列表。
    #[setters(generate = true, strip_option)]
    filter: Option<Vec<ImagesFilter>>,
    /// 是否查询已发布的社区镜像。取值范围：
    ///
    /// - true：查询已发布的社区镜像。当您指定该参数值为true时，ImageOwnerAlias必须为others。
    /// - false：查询除社区镜像的其他镜像类型，具体以ImageOwnerAlias参数值为准。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    is_public: Option<bool>,
    /// 镜像所属的阿里云账号ID。该参数仅在查询共享镜像以及社区镜像时生效。
    ///
    #[setters(generate = true, strip_option)]
    image_owner_id: Option<i64>,
}

impl sealed::Bound for DescribeImages {}

impl DescribeImages {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            status: None,
            image_id: None,
            show_expired: None,
            snapshot_id: None,
            image_name: None,
            image_family: None,
            image_owner_alias: None,
            instance_type: None,
            is_support_io_optimized: None,
            is_support_cloudinit: None,
            os_type: None,
            architecture: None,
            page_number: None,
            page_size: None,
            usage: None,
            dry_run: None,
            action_type: None,
            resource_group_id: None,
            tag: None,
            filter: None,
            is_public: None,
            image_owner_id: None,
        }
    }
}
impl crate::ToFormData for DescribeImages {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeImages {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeImages";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeImagesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(23);

        if let Some(f) = &self.action_type {
            params.push(("ActionType".into(), (f).into()));
        }

        if let Some(f) = &self.architecture {
            params.push(("Architecture".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.filter {
            crate::FlatSerialize::flat_serialize(f, "Filter", &mut params);
        }

        if let Some(f) = &self.image_family {
            params.push(("ImageFamily".into(), (f).into()));
        }

        if let Some(f) = &self.image_id {
            params.push(("ImageId".into(), (f).into()));
        }

        if let Some(f) = &self.image_name {
            params.push(("ImageName".into(), (f).into()));
        }

        if let Some(f) = &self.image_owner_alias {
            params.push(("ImageOwnerAlias".into(), (f).into()));
        }

        if let Some(f) = &self.image_owner_id {
            params.push(("ImageOwnerId".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.is_public {
            params.push(("IsPublic".into(), (f).into()));
        }

        if let Some(f) = &self.is_support_cloudinit {
            params.push(("IsSupportCloudinit".into(), (f).into()));
        }

        if let Some(f) = &self.is_support_io_optimized {
            params.push(("IsSupportIoOptimized".into(), (f).into()));
        }

        if let Some(f) = &self.os_type {
            params.push(("OSType".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.show_expired {
            params.push(("ShowExpired".into(), (f).into()));
        }

        if let Some(f) = &self.snapshot_id {
            params.push(("SnapshotId".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.usage {
            params.push(("Usage".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyImageAttribute {
    /// 自定义镜像所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 自定义镜像的ID。
    image_id: String,
    /// 自定义镜像的名称。长度为2~128个字符。必须以大小字母或中文开头，不能以aliyun或acs:开头，不能包含http://或者https://。可以包含数字、半角句号（.）、半角冒号（:）、下划线（_）或者短划线（-）。
    ///
    /// 默认值：空，表示保持原有名称不变。
    #[setters(generate = true, strip_option)]
    image_name: Option<String>,
    /// 镜像状态，取值范围：
    ///
    /// - Deprecated：将镜像设置为弃用状态。如果您已经共享的自定义镜像，必须先取消共享才能修改为弃用状态。对处于弃用状态镜像，不能共享和复制镜像。但是可以使用镜像创建实例或更换系统盘。
    /// - Available：将镜像设置为可用状态。您可以将弃用状态的镜像恢复可用。
    ///
    /// > 如果您需要回滚镜像族系中的自定义镜像至上一个版本，可以将最新可用的自定义镜像设置为弃用状态，但如果该镜像为镜像族系中唯一一个可用状态的自定义镜像，则弃用镜像以后该镜像族系将无可用状态自定义镜像用来创建实例，因此请谨慎操作。
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// 镜像族系名称。长度为2~128个字符。必须以大小字母或中文开头，不能以aliyun或acs:开头，不能包含http://或者https://。可以包含数字、半角句号（.）、半角冒号（:）、下划线（_）或者短划线（-）。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    image_family: Option<String>,
    /// 修改镜像的启动模式。取值范围：
    /// - BIOS：BIOS启动模式。
    /// - UEFI：UEFI启动模式。
    /// - UEFI-Preferred：双启动模式。
    ///
    ///
    /// <notice>
    ///
    ///    为了避免使用镜像不支持的启动模式导致实例无法正常启动，请您务必在修改之前了解目标镜像支持的启动模式。镜像启动模式详情，请参见[镜像启动模式](~~2244655#b9caa9b8bb1wf~~)。
    ///
    /// </notice>
    #[setters(generate = true, strip_option)]
    boot_mode: Option<String>,
    /// 导入镜像后，激活操作系统采用的许可证类型。当前仅支持BYOL。
    ///
    /// BYOL：源操作系统自带的许可证。采用BYOL时，您必须确保您的许可证密钥支持在阿里云使用。
    ///
    ///
    #[setters(generate = true, strip_option)]
    license_type: Option<String>,
    /// 自定义镜像的描述信息。长度为2~256个字符。不能以http://或https://开头。
    ///
    /// 默认值：空，表示保持原有描述信息不变。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 镜像特性相关属性。
    #[setters(generate = true, strip_option)]
    features: Option<AttributeFeatures>,
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for ModifyImageAttribute {}

impl ModifyImageAttribute {
    pub fn new(region_id: impl Into<String>, image_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_id: image_id.into(),
            image_name: None,
            status: None,
            image_family: None,
            boot_mode: None,
            license_type: None,
            description: None,
            features: None,
            dry_run: None,
        }
    }
}
impl crate::ToFormData for ModifyImageAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyImageAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyImageAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyImageAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.boot_mode {
            params.push(("BootMode".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.features {
            crate::FlatSerialize::flat_serialize(f, "Features", &mut params);
        }

        if let Some(f) = &self.image_family {
            params.push(("ImageFamily".into(), (f).into()));
        }
        params.push(("ImageId".into(), (&self.image_id).into()));

        if let Some(f) = &self.image_name {
            params.push(("ImageName".into(), (f).into()));
        }

        if let Some(f) = &self.license_type {
            params.push(("LicenseType".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteImage {
    /// 自定义镜像所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 镜像ID。如果指定的自定义镜像不存在，则请求将被忽略。
    image_id: String,
    /// 是否执行强制删除。取值范围：
    ///          
    /// - true：强制删除自定义镜像，忽略当前镜像是否被其他实例使用。
    /// - false：正常删除自定义镜像，删除前检查当前镜像是否被其他实例使用。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    force: Option<bool>,
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for DeleteImage {}

impl DeleteImage {
    pub fn new(region_id: impl Into<String>, image_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_id: image_id.into(),
            force: None,
            dry_run: None,
        }
    }
}
impl crate::ToFormData for DeleteImage {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteImage {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteImage";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteImageResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.force {
            params.push(("Force".into(), (f).into()));
        }
        params.push(("ImageId".into(), (&self.image_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeImageFromFamily {
    /// 镜像所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 镜像族系名称。
    ///
    /// 自定义镜像、公共镜像、社区镜像、共享镜像均已支持镜像族系，使用方法及介绍请参见[镜像族系概述](~~174241~~)。
    image_family: String,
}

impl sealed::Bound for DescribeImageFromFamily {}

impl DescribeImageFromFamily {
    pub fn new(region_id: impl Into<String>, image_family: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_family: image_family.into(),
        }
    }
}
impl crate::ToFormData for DescribeImageFromFamily {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeImageFromFamily {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeImageFromFamily";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeImageFromFamilyResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("ImageFamily".into(), (&self.image_family).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeImageSupportInstanceTypes {
    /// 镜像所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 镜像ID。
    #[setters(generate = true, strip_option)]
    image_id: Option<String>,
    /// 使用镜像的场景。取值范围：
    ///
    /// - CreateEcs（默认）：创建实例。
    /// - ChangeOS：更换系统盘/更换操作系统。
    #[setters(generate = true, strip_option)]
    action_type: Option<String>,
    /// 查询资源时的筛选条件列表。
    #[setters(generate = true, strip_option)]
    filter: Option<Vec<TypesFilter>>,
}

impl sealed::Bound for DescribeImageSupportInstanceTypes {}

impl DescribeImageSupportInstanceTypes {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_id: None,
            action_type: None,
            filter: None,
        }
    }
}
impl crate::ToFormData for DescribeImageSupportInstanceTypes {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeImageSupportInstanceTypes {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeImageSupportInstanceTypes";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeImageSupportInstanceTypesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.action_type {
            params.push(("ActionType".into(), (f).into()));
        }

        if let Some(f) = &self.filter {
            crate::FlatSerialize::flat_serialize(f, "Filter", &mut params);
        }

        if let Some(f) = &self.image_id {
            params.push(("ImageId".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeImageSharePermission {
    /// 自定义镜像所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 自定义镜像ID。
    image_id: String,
    /// 查询结果显示的页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 查询结果显示的每页的信息条目数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeImageSharePermission {}

impl DescribeImageSharePermission {
    pub fn new(region_id: impl Into<String>, image_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_id: image_id.into(),
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeImageSharePermission {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeImageSharePermission {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeImageSharePermission";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeImageSharePermissionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("ImageId".into(), (&self.image_id).into()));

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyImageSharePermission {
    /// 自定义镜像所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 被共享的自定义镜像ID。
    ///
    /// ><notice>不再支持共享使用服务密钥加密的镜像，仅支持共享使用用户主密钥 CMK 加密的镜像，使用服务密钥加密的镜像在共享时将会报错。></notice>
    image_id: String,
    /// >该参数正在邀测中，暂不支持使用。
    #[setters(generate = true, strip_option)]
    launch_permission: Option<String>,
    /// 授权共享镜像的阿里云账号ID。N的取值范围：1~10，若一次提交超过10个阿里云账号，系统将只处理前10个，忽略多余的账号。
    #[setters(generate = true, strip_option)]
    add_account: Option<Vec<String>>,
    /// 删除镜像共享的阿里云账号ID。N的取值范围：1~10，若一次提交超过10个阿里云账号，系统将只处理前10个，忽略多余的账号。
    #[setters(generate = true, strip_option)]
    remove_account: Option<Vec<String>>,
    /// 是否发布或下架社区镜像。取值范围：
    ///
    /// - true：发布该镜像为社区镜像。
    /// - false：下架该镜像为普通镜像，若该镜像本身是普通镜像，则不做改变。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    is_public: Option<bool>,
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for ModifyImageSharePermission {}

impl ModifyImageSharePermission {
    pub fn new(region_id: impl Into<String>, image_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_id: image_id.into(),
            launch_permission: None,
            add_account: None,
            remove_account: None,
            is_public: None,
            dry_run: None,
        }
    }
}
impl crate::ToFormData for ModifyImageSharePermission {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyImageSharePermission {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyImageSharePermission";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyImageSharePermissionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.add_account {
            crate::FlatSerialize::flat_serialize(f, "AddAccount", &mut params);
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }
        params.push(("ImageId".into(), (&self.image_id).into()));

        if let Some(f) = &self.is_public {
            params.push(("IsPublic".into(), (f).into()));
        }

        if let Some(f) = &self.launch_permission {
            params.push(("LaunchPermission".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.remove_account {
            crate::FlatSerialize::flat_serialize(f, "RemoveAccount", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyImageShareGroupPermission {
    region_id: String,
    image_id: String,
    #[setters(generate = true, strip_option)]
    add_group1: Option<String>,
    #[setters(generate = true, strip_option)]
    remove_group1: Option<String>,
}

impl sealed::Bound for ModifyImageShareGroupPermission {}

impl ModifyImageShareGroupPermission {
    pub fn new(region_id: impl Into<String>, image_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_id: image_id.into(),
            add_group1: None,
            remove_group1: None,
        }
    }
}
impl crate::ToFormData for ModifyImageShareGroupPermission {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyImageShareGroupPermission {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyImageShareGroupPermission";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyImageShareGroupPermissionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.add_group1 {
            params.push(("AddGroup.1".into(), (f).into()));
        }
        params.push(("ImageId".into(), (&self.image_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.remove_group1 {
            params.push(("RemoveGroup.1".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ImportImage {
    /// 源自定义镜像的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 镜像名称。长度为2~128个字符。必须以大小写字母或中文开头，不能以`aliyun`或`acs:`开头，不能包含`http://`或者`https://`。可以包含数字、半角句号（.）、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    image_name: Option<String>,
    /// 镜像的描述信息。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 系统架构。取值范围：
    ///
    /// - i386。
    /// - x86_64。
    /// - arm64。
    ///
    /// 默认值：x86_64。
    #[setters(generate = true, strip_option)]
    architecture: Option<String>,
    /// 操作系统类型。取值范围：
    ///
    /// - windows。
    /// - linux。
    ///
    /// 默认值：linux。
    #[setters(generate = true, strip_option)]
    os_type: Option<String>,
    /// 操作系统版本。取值范围：
    /// - Aliyun
    /// - Anolis
    /// - CentOS
    /// - Ubuntu
    /// - CoreOS
    /// - SUSE
    /// - Debian
    /// - OpenSUSE
    /// - FreeBSD
    /// - RedHat
    /// - Kylin
    /// - UOS
    /// - Fedora
    /// - Fedora CoreOS
    /// - CentOS Stream
    /// - AlmaLinux
    /// - Rocky Linux
    /// - Gentoo
    /// - Customized Linux
    /// - Others Linux
    /// - Windows Server 2022
    /// - Windows Server 2019
    /// - Windows Server 2016
    /// - Windows Server 2012
    /// - Windows Server 2008
    /// - Windows Server 2003
    /// - Other Windows
    ///
    /// 默认值：Others Linux。
    #[setters(generate = true, strip_option)]
    platform: Option<String>,
    /// 修改镜像的启动模式。取值范围：
    ///
    /// - BIOS：BIOS启动模式。
    /// - UEFI：UEFI启动模式。
    ///
    /// 默认值：BIOS。如果`Architecture=arm64`，则该参数默认值为UEFI，且只能设置为UEFI。
    ///
    /// <notice>
    ///
    /// 为了避免使用镜像不支持的启动模式导致实例无法正常启动，请您务必在选择该参数之前了解目标镜像支持的启动模式。镜像启动模式详情，请参见[镜像启动模式](~~2244655#b9caa9b8bb1wf~~)。
    ///
    /// </notice>
    #[setters(generate = true, strip_option)]
    boot_mode: Option<String>,
    /// 导入镜像时，使用的RAM角色名称。
    #[setters(generate = true, strip_option)]
    role_name: Option<String>,
    /// 导入镜像后，激活操作系统采用的许可证类型。取值范围：
    ///
    /// - Auto：由阿里云检测源操作系统并分配许可证。自动模式下，系统优先搜索您设置的`Platform`是否有阿里云官方渠道的许可证并分配给导入的镜像，如果缺乏该类许可，会切换成BYOL（Bring Your Own License）方式。
    /// - Aliyun：根据您设置的`Platform`采用阿里云官方渠道的许可证。
    /// - BYOL：源操作系统自带的许可证。采用BYOL时，您必须确保您的许可证密钥支持在阿里云使用。
    ///
    /// 默认值：Auto。
    ///
    #[setters(generate = true, strip_option)]
    license_type: Option<String>,
    /// 导入镜像所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 创建的自定义镜像信息列表。
    #[setters(generate = true, strip_option)]
    disk_device_mapping: Option<Vec<ImportImageDiskDeviceMapping>>,
    /// 镜像的标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ImportImageTag>>,
    /// 镜像检测策略，不配置此参数时不触发检测。仅支持标准（Standard）检测模式。
    ///
    /// >目前已支持大部分的Linux/Windows版本，关于镜像检测项与操作系统限制说明，请参见[镜像检测概述](~~439819~~)和[镜像检测操作系统限制](~~475800~~)。
    #[setters(generate = true, strip_option)]
    detection_strategy: Option<String>,
    /// 指定云盒的资源名称（ARN），用于唯一标识云端存储位置。
    ///
    /// >仅当您需要从OSS ON云盒中导入镜像文件时，才需提供此参数的值。如果您使用的存储服务不是OSS ON云盒，则无需设置此参数。更多信息，请参见[什么是OSS ON云盒](~~430190~~)。
    ///
    /// 正确的ARN格式应遵循：`arn:acs:cloudbox:{RegionId}:{AliUid}:cloudbox/{CloudBoxId}`的模式，其中`{RegionId}`应替换为云盒实际所在的地域ID，`{AliUid}`是阿里云账号（主账号）ID，而`{CloudBoxId}`是云盒ID。
    #[setters(generate = true, strip_option)]
    storage_location_arn: Option<String>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会查询资源状况。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，则返回错误码`DryRunOperation`。
    /// - false：发送正常请求，通过检查后返回 2XX HTTP状态码并直接查询资源状况。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 镜像特性相关属性。
    #[setters(generate = true, strip_option)]
    features: Option<ImportImageFeatures>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for ImportImage {}

impl ImportImage {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_name: None,
            description: None,
            architecture: None,
            os_type: None,
            platform: None,
            boot_mode: None,
            role_name: None,
            license_type: None,
            resource_group_id: None,
            disk_device_mapping: None,
            tag: None,
            detection_strategy: None,
            storage_location_arn: None,
            dry_run: None,
            features: None,
            client_token: None,
        }
    }
}
impl crate::ToFormData for ImportImage {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ImportImage {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ImportImage";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ImportImageResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(17);

        if let Some(f) = &self.architecture {
            params.push(("Architecture".into(), (f).into()));
        }

        if let Some(f) = &self.boot_mode {
            params.push(("BootMode".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.detection_strategy {
            params.push(("DetectionStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.disk_device_mapping {
            crate::FlatSerialize::flat_serialize(f, "DiskDeviceMapping", &mut params);
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.features {
            crate::FlatSerialize::flat_serialize(f, "Features", &mut params);
        }

        if let Some(f) = &self.image_name {
            params.push(("ImageName".into(), (f).into()));
        }

        if let Some(f) = &self.license_type {
            params.push(("LicenseType".into(), (f).into()));
        }

        if let Some(f) = &self.os_type {
            params.push(("OSType".into(), (f).into()));
        }

        if let Some(f) = &self.platform {
            params.push(("Platform".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.role_name {
            params.push(("RoleName".into(), (f).into()));
        }

        if let Some(f) = &self.storage_location_arn {
            params.push(("StorageLocationArn".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ExportImage {
    /// 自定义镜像的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 自定义镜像ID。
    image_id: String,
    /// 保存导出镜像的OSS bucket。
    oss_bucket: String,
    /// 您的OSS  Object的前缀。可以由数字或者字母组成，字符长度为1~30。
    #[setters(generate = true, strip_option)]
    oss_prefix: Option<String>,
    /// 镜像文件的导出格式。取值范围：
    /// - raw。
    /// - vhd。
    /// - qcow2。
    /// - vmdk。
    /// - vdi。
    ///
    /// 默认值：raw。
    #[setters(generate = true, strip_option)]
    image_format: Option<String>,
    /// 导出镜像时使用的RAM角色名称。
    #[setters(generate = true, strip_option)]
    role_name: Option<String>,
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for ExportImage {}

impl ExportImage {
    pub fn new(
        region_id: impl Into<String>,
        image_id: impl Into<String>,
        oss_bucket: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            image_id: image_id.into(),
            oss_bucket: oss_bucket.into(),
            oss_prefix: None,
            image_format: None,
            role_name: None,
            dry_run: None,
        }
    }
}
impl crate::ToFormData for ExportImage {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ExportImage {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ExportImage";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ExportImageResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.image_format {
            params.push(("ImageFormat".into(), (f).into()));
        }
        params.push(("ImageId".into(), (&self.image_id).into()));
        params.push(("OSSBucket".into(), (&self.oss_bucket).into()));

        if let Some(f) = &self.oss_prefix {
            params.push(("OSSPrefix".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.role_name {
            params.push(("RoleName".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CopyImage {
    /// 复制后的镜像的名称。长度为2~128个字符。必须以大小写字母或中文开头，也不能以`aliyun`或`acs:`开头，不能包含`http://`或者`https://`。可以包含数字、半角句号（.）、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    destination_image_name: Option<String>,
    /// 复制后的镜像的描述信息。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    destination_description: Option<String>,
    /// 源自定义镜像的ID。
    image_id: String,
    /// 源自定义镜像的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 复制到目标地域的ID。
    #[setters(generate = true, strip_option)]
    destination_region_id: Option<String>,
    /// 是否加密复制后的镜像。
    ///
    /// - true：加密。
    /// - false：不加密。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    encrypted: Option<bool>,
    /// 加密镜像使用的密钥ID。
    #[setters(generate = true, strip_option)]
    kms_key_id: Option<String>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    encrypt_algorithm: Option<String>,
    /// 复制后的镜像的资源组ID。如果不设置该参数值，复制后的镜像属于默认资源组。
    ///
    /// > 如果您当前使用的是RAM用户调用该接口，且`ResourceGroupId`取值为空，您需要注意，当RAM用户没有默认资源组权限时，调用接口会返回报错信息`Forbidden: User not authorized to operate on the specified resource`。请您设置RAM用户支持的资源组ID或者通过相应阿里云账号为该RAM用户授予默认资源组权限后，再次调用该接口。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<CopyImageTag>>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送预检请求。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数等。如果检查不通过，则返回对应错误信息。如果检查通过，则返回错误码`DryRunOperation`。
    /// - false：发送正常请求，通过检查后返回 2XX HTTP状态码并直接操作资源。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for CopyImage {}

impl CopyImage {
    pub fn new(image_id: impl Into<String>, region_id: impl Into<String>) -> Self {
        Self {
            destination_image_name: None,
            destination_description: None,
            image_id: image_id.into(),
            region_id: region_id.into(),
            destination_region_id: None,
            encrypted: None,
            kms_key_id: None,
            encrypt_algorithm: None,
            resource_group_id: None,
            tag: None,
            dry_run: None,
            client_token: None,
        }
    }
}
impl crate::ToFormData for CopyImage {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CopyImage {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CopyImage";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CopyImageResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(12);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.destination_description {
            params.push(("DestinationDescription".into(), (f).into()));
        }

        if let Some(f) = &self.destination_image_name {
            params.push(("DestinationImageName".into(), (f).into()));
        }

        if let Some(f) = &self.destination_region_id {
            params.push(("DestinationRegionId".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.encrypt_algorithm {
            params.push(("EncryptAlgorithm".into(), (f).into()));
        }

        if let Some(f) = &self.encrypted {
            params.push(("Encrypted".into(), (f).into()));
        }
        params.push(("ImageId".into(), (&self.image_id).into()));

        if let Some(f) = &self.kms_key_id {
            params.push(("KMSKeyId".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CancelCopyImage {
    /// 目标镜像所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 正在被复制的镜像ID。
    image_id: String,
}

impl sealed::Bound for CancelCopyImage {}

impl CancelCopyImage {
    pub fn new(region_id: impl Into<String>, image_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_id: image_id.into(),
        }
    }
}
impl crate::ToFormData for CancelCopyImage {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CancelCopyImage {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CancelCopyImage";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CancelCopyImageResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("ImageId".into(), (&self.image_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateImageComponent {
    /// 所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ComponentTag>>,
    /// 组件名称。长度为2~128个字符，必须以大小写字母或中文开头，不能以http://和https://开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    ///
    /// > 不设置`Name`时，默认使用`ImageComponentId`返回值。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// 描述信息。长度为2~256个英文或中文字符，不能以http://和https://开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 组件支持的操作系统。
    ///
    /// 取值范围：
    /// - Linux
    /// - Windows
    ///
    /// 默认值：Linux。
    #[setters(generate = true, strip_option)]
    system_type: Option<String>,
    /// 组件类型。支持镜像构建组件和测试组件。
    ///
    /// 取值范围：
    /// - Build
    /// - Test
    ///
    /// 默认值：Build。
    /// > 构建组件只能在构建模板中使用，测试组件只能在测试模板中使用。
    #[setters(generate = true, strip_option)]
    component_type: Option<String>,
    /// 组件内容。由多条命令组成，命令内容不能超过16KB。支持的命令和命令格式详情，请参见[镜像构建服务支持的命令说明](~~200206~~)。
    #[setters(generate = true, strip_option)]
    content: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 组件版本号，与组件名称配合使用，格式为major.minor.patch，均为非负整数。
    ///
    /// 默认值：(x+1).0.0，x为当前组件最大的major版本号。
    #[setters(generate = true, strip_option)]
    component_version: Option<String>,
}

impl sealed::Bound for CreateImageComponent {}

impl CreateImageComponent {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            tag: None,
            name: None,
            description: None,
            system_type: None,
            component_type: None,
            content: None,
            client_token: None,
            component_version: None,
        }
    }
}
impl crate::ToFormData for CreateImageComponent {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateImageComponent {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateImageComponent";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateImageComponentResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.component_type {
            params.push(("ComponentType".into(), (f).into()));
        }

        if let Some(f) = &self.component_version {
            params.push(("ComponentVersion".into(), (f).into()));
        }

        if let Some(f) = &self.content {
            params.push(("Content".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.system_type {
            params.push(("SystemType".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeImageComponents {
    /// 所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ComponentsTag>>,
    /// 镜像组件名称。仅支持精确查找。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// 查询凭证（Token）。取值为上一次调用该接口返回的`NextToken`参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。取值范围：1~500
    ///
    /// 默认值：50。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 镜像组件类型。取值范围：
    ///
    /// - SELF：您创建的自定义镜像组件。
    /// - ALIYUN：阿里云提供的系统组件。
    #[setters(generate = true, strip_option)]
    owner: Option<String>,
    /// 待查询的镜像组件ID。N取值范围：1~20
    #[setters(generate = true, strip_option)]
    image_component_id: Option<Vec<String>>,
    /// 组件类型。
    ///
    /// 取值范围：
    /// - Build
    /// - Test
    #[setters(generate = true, strip_option)]
    component_type: Option<String>,
    /// 组件支持的操作系统。
    ///
    /// 取值范围：
    /// - Linux
    /// - Windows
    #[setters(generate = true, strip_option)]
    system_type: Option<String>,
    /// 组件版本号，格式为major.minor.patch，均为非负整数，也支持使用通配符“*”来替代其中一位进行模糊匹配版本。
    /// >仅当指定Name时该参数生效。
    #[setters(generate = true, strip_option)]
    component_version: Option<String>,
}

impl sealed::Bound for DescribeImageComponents {}

impl DescribeImageComponents {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            tag: None,
            name: None,
            next_token: None,
            max_results: None,
            owner: None,
            image_component_id: None,
            component_type: None,
            system_type: None,
            component_version: None,
        }
    }
}
impl crate::ToFormData for DescribeImageComponents {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeImageComponents {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeImageComponents";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeImageComponentsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(11);

        if let Some(f) = &self.component_type {
            params.push(("ComponentType".into(), (f).into()));
        }

        if let Some(f) = &self.component_version {
            params.push(("ComponentVersion".into(), (f).into()));
        }

        if let Some(f) = &self.image_component_id {
            crate::FlatSerialize::flat_serialize(f, "ImageComponentId", &mut params);
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.owner {
            params.push(("Owner".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.system_type {
            params.push(("SystemType".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteImageComponent {
    /// 所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 需要删除的镜像组件ID。
    image_component_id: String,
}

impl sealed::Bound for DeleteImageComponent {}

impl DeleteImageComponent {
    pub fn new(region_id: impl Into<String>, image_component_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_component_id: image_component_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteImageComponent {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteImageComponent {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteImageComponent";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteImageComponentResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("ImageComponentId".into(), (&self.image_component_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateImagePipeline {
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<PipelineTag>>,
    /// 所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 目标镜像共享的阿里云账号ID。N的取值范围：1~20。
    #[setters(generate = true, strip_option)]
    add_account: Option<Vec<i64>>,
    /// 目标镜像待分发的地域列表。N的取值范围：1~20。
    ///
    /// 不设置参数值时，默认只在当前地域创建镜像。
    #[setters(generate = true, strip_option)]
    to_region_id: Option<Vec<String>>,
    /// 源镜像类型。取值范围：
    ///
    /// - IMAGE：镜像。
    /// - IMAGE_FAMILY：镜像族系。
    /// - OSS：OSS对象。
    base_image_type: String,
    /// 源镜像。
    /// - 当`BaseImageType=IMAGE`时，该参数取值为镜像ID。
    /// - 当`BaseImageType=IMAGE_FAMILY`时，该参数取值为镜像族系名称。
    /// - 当`BaseImageType=OSS`时，无需设置该参数。
    #[setters(generate = true, strip_option)]
    base_image: Option<String>,
    /// 模板名称。长度为2~128个字符，必须以大小写字母或中文开头，不能以`http://`和`https://`开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    ///
    /// >不设置`Name`时，默认使用`ImagePipelineId`返回值。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// 描述信息。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 目标镜像名称前缀。
    /// <notice>
    /// 该参数已弃用。请使用ImageOptions.ImageName。
    /// </notice>
    #[setters(generate = true, strip_option)]
    image_name: Option<String>,
    /// VPC的交换机ID。
    ///
    /// 不设置参数值时，默认创建新的VPC与交换机，请确保您账号下VPC资源配额充足，更多信息，请参见[使用限制](~~27750~~)。
    #[setters(generate = true, strip_option)]
    v_switch_id: Option<String>,
    /// 实例规格。您可以调用[DescribeInstanceTypes](~~25620~~)查询不同的实例规格。
    ///
    /// 不设置参数值时，默认按vCPU和内存最小的原则，自动设置实例规格，并受实例规格的库存影响。例如，默认选择ecs.g6.large实例规格，如果库存不足，将选择ecs.g6.xlarge实例规格。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 中转实例的系统盘大小。单位：GiB。取值范围：20~500。
    ///
    /// 默认值：40。
    #[setters(generate = true, strip_option)]
    system_disk_size: Option<i32>,
    /// 中转实例的公网出带宽大小。单位：Mbit/s。取值范围：0~100。
    ///
    /// 默认值：0。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_out: Option<i32>,
    /// 镜像构建失败后是否释放中转实例。取值范围：
    ///
    /// - true：释放。
    /// - false：不释放。
    ///
    /// 默认值：true。
    ///
    /// > 中转实例如果没有成功启动，则实例默认不保留。
    ///
    #[setters(generate = true, strip_option)]
    delete_instance_on_failure: Option<bool>,
    /// 镜像构建模板内容。内容大小不能超过16 KB，具体支持的命令请参见[镜像构建服务支持的命令说明](~~200206~~)。
    #[setters(generate = true, strip_option)]
    build_content: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 镜像模版中的修复选项。
    ///
    /// 取值范围：
    /// - Standard：标准模式。
    ///
    ///   当前Linux系统的检测项包含
    ///   - GUESTOS.CloudInit
    ///   - GUESTOS.Dhcp
    ///   - GUESTOS.Virtio
    ///   - GUESTOS.OnlineResizeFS
    ///   - GUESTOS.Grub
    ///   - GUESTOS.Fstab
    ///
    ///   Windows系统的检测项包含
    ///   - GUESTOS.Virtio
    ///   - GUESTOS.Update
    ///   - GUESTOS.Hotfix
    ///   - GUESTOS.Server
    /// >随着检测修复能力的不断提升，包含的修复项可能会增加。修复项具体含义，请参见[镜像检测概述](~~439819~~)。
    #[setters(generate = true, strip_option)]
    repair_mode: Option<String>,
    /// 目标镜像族系。
    /// <notice>
    /// 该参数已弃用。请使用ImageOptions.ImageFamily。
    /// </notice>
    #[setters(generate = true, strip_option)]
    image_family: Option<String>,
    /// 镜像测试模板内容。内容大小不能超过16 KB，具体支持的命令请参见[镜像构建服务支持的命令说明](~~200206~~)。
    #[setters(generate = true, strip_option)]
    test_content: Option<String>,
    /// 导入镜像的属性和设置。当`BaseImageType=OSS`时，需要设置。
    #[setters(generate = true, strip_option)]
    import_image_options: Option<PipelineImportImageOptions>,
    /// 构建的目标镜像是否支持 NVMe。
    /// <notice>
    /// 该参数已弃用。请使用ImageOptions. ImageFeatures.NvmeSupport。
    /// </notice>
    #[setters(generate = true, strip_option)]
    nvme_support: Option<String>,
    /// 高级设置。
    #[setters(generate = true, strip_option)]
    advanced_options: Option<PipelineAdvancedOptions>,
    /// 目标镜像属性。
    #[setters(generate = true, strip_option)]
    image_options: Option<PipelineImageOptions>,
}

impl sealed::Bound for CreateImagePipeline {}

impl CreateImagePipeline {
    pub fn new(region_id: impl Into<String>, base_image_type: impl Into<String>) -> Self {
        Self {
            tag: None,
            region_id: region_id.into(),
            resource_group_id: None,
            add_account: None,
            to_region_id: None,
            base_image_type: base_image_type.into(),
            base_image: None,
            name: None,
            description: None,
            image_name: None,
            v_switch_id: None,
            instance_type: None,
            system_disk_size: None,
            internet_max_bandwidth_out: None,
            delete_instance_on_failure: None,
            build_content: None,
            client_token: None,
            repair_mode: None,
            image_family: None,
            test_content: None,
            import_image_options: None,
            nvme_support: None,
            advanced_options: None,
            image_options: None,
        }
    }
}
impl crate::ToFormData for CreateImagePipeline {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateImagePipeline {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateImagePipeline";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateImagePipelineResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(24);

        if let Some(f) = &self.add_account {
            crate::FlatSerialize::flat_serialize(f, "AddAccount", &mut params);
        }

        if let Some(f) = &self.advanced_options {
            crate::FlatSerialize::flat_serialize(f, "AdvancedOptions", &mut params);
        }

        if let Some(f) = &self.base_image {
            params.push(("BaseImage".into(), (f).into()));
        }
        params.push(("BaseImageType".into(), (&self.base_image_type).into()));

        if let Some(f) = &self.build_content {
            params.push(("BuildContent".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.delete_instance_on_failure {
            params.push(("DeleteInstanceOnFailure".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.image_family {
            params.push(("ImageFamily".into(), (f).into()));
        }

        if let Some(f) = &self.image_name {
            params.push(("ImageName".into(), (f).into()));
        }

        if let Some(f) = &self.image_options {
            crate::FlatSerialize::flat_serialize(f, "ImageOptions", &mut params);
        }

        if let Some(f) = &self.import_image_options {
            crate::FlatSerialize::flat_serialize(f, "ImportImageOptions", &mut params);
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_out {
            params.push(("InternetMaxBandwidthOut".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.nvme_support {
            params.push(("NvmeSupport".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.repair_mode {
            params.push(("RepairMode".into(), (f).into()));
        }

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_size {
            params.push(("SystemDiskSize".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.test_content {
            params.push(("TestContent".into(), (f).into()));
        }

        if let Some(f) = &self.to_region_id {
            crate::FlatSerialize::flat_serialize(f, "ToRegionId", &mut params);
        }

        if let Some(f) = &self.v_switch_id {
            params.push(("VSwitchId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeImagePipelines {
    /// 所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 企业资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<PipelinesTag>>,
    /// 模板名称。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// 查询凭证（Token）。取值为上一次调用该接口返回的`NextToken`参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。取值范围：1~500。
    ///
    /// 默认值：50。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 镜像模板ID。N取值范围：1~20。
    #[setters(generate = true, strip_option)]
    image_pipeline_id: Option<Vec<String>>,
}

impl sealed::Bound for DescribeImagePipelines {}

impl DescribeImagePipelines {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            tag: None,
            name: None,
            next_token: None,
            max_results: None,
            image_pipeline_id: None,
        }
    }
}
impl crate::ToFormData for DescribeImagePipelines {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeImagePipelines {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeImagePipelines";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeImagePipelinesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.image_pipeline_id {
            crate::FlatSerialize::flat_serialize(f, "ImagePipelineId", &mut params);
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteImagePipeline {
    /// 所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 镜像模板ID。
    image_pipeline_id: String,
}

impl sealed::Bound for DeleteImagePipeline {}

impl DeleteImagePipeline {
    pub fn new(region_id: impl Into<String>, image_pipeline_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            image_pipeline_id: image_pipeline_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteImagePipeline {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteImagePipeline {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteImagePipeline";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteImagePipelineResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("ImagePipelineId".into(), (&self.image_pipeline_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct StartImagePipelineExecution {
    /// 所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    template_tag: Option<Vec<StartImagePipelineExecutionTemplateTag>>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ExecutionTag>>,
    /// 镜像模板ID。
    image_pipeline_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for StartImagePipelineExecution {}

impl StartImagePipelineExecution {
    pub fn new(region_id: impl Into<String>, image_pipeline_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            template_tag: None,
            tag: None,
            image_pipeline_id: image_pipeline_id.into(),
            client_token: None,
        }
    }
}
impl crate::ToFormData for StartImagePipelineExecution {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for StartImagePipelineExecution {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "StartImagePipelineExecution";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<StartImagePipelineExecutionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("ImagePipelineId".into(), (&self.image_pipeline_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.template_tag {
            crate::FlatSerialize::flat_serialize(f, "TemplateTag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeImagePipelineExecutions {
    /// 所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ExecutionsTag>>,
    /// 镜像模板ID。
    #[setters(generate = true, strip_option)]
    image_pipeline_id: Option<String>,
    /// 镜像构建任务ID。
    #[setters(generate = true, strip_option)]
    execution_id: Option<String>,
    /// 镜像构建任务的状态。支持同时设置多个值，每个值之间以半角逗号（,）间隔，格式示例为`BUILDING,DISTRIBUTING`。取值范围：
    ///
    /// - PREPARING：准备中。创建临时中转实例等资源。
    /// - REPAIRING：修复中。修复源镜像。
    /// - BUILDING：构建中。执行用户自定义命令以及创建镜像。
    /// - TESTING：测试中。执行用户自定义测试命令。
    /// - DISTRIBUTING：分发中。执行镜像复制以及共享。
    /// - RELEASING：资源回收中。构建过程中生成的临时资源。
    /// - SUCCESS：成功。构建成功。
    /// - PARTITION_SUCCESS：部分成功。镜像已构建成功，但可能在分发或者资源清理等步骤出现了异常。
    /// - FAILED：失败。构建镜像失败。
    /// - TEST_FAILED：测试失败。镜像创建成功，但测试失败。
    /// - CANCELLING：取消中。正在取消构建流程。
    /// - CANCELLED：已取消。构建流程已取消。
    ///
    /// > 当参数值为空时，默认查询所有状态的镜像构建任务
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// 查询凭证（Token）。取值为上一次调用该接口返回的`NextToken`参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。取值范围：1~500。
    ///
    /// 默认值：50。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
}

impl sealed::Bound for DescribeImagePipelineExecutions {}

impl DescribeImagePipelineExecutions {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            tag: None,
            image_pipeline_id: None,
            execution_id: None,
            status: None,
            next_token: None,
            max_results: None,
        }
    }
}
impl crate::ToFormData for DescribeImagePipelineExecutions {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeImagePipelineExecutions {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeImagePipelineExecutions";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeImagePipelineExecutionsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.execution_id {
            params.push(("ExecutionId".into(), (f).into()));
        }

        if let Some(f) = &self.image_pipeline_id {
            params.push(("ImagePipelineId".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CancelImagePipelineExecution {
    /// 所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    template_tag: Option<Vec<CancelImagePipelineExecutionTemplateTag>>,
    /// 构建任务ID。
    execution_id: String,
}

impl sealed::Bound for CancelImagePipelineExecution {}

impl CancelImagePipelineExecution {
    pub fn new(region_id: impl Into<String>, execution_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            template_tag: None,
            execution_id: execution_id.into(),
        }
    }
}
impl crate::ToFormData for CancelImagePipelineExecution {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CancelImagePipelineExecution {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CancelImagePipelineExecution";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CancelImagePipelineExecutionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("ExecutionId".into(), (&self.execution_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.template_tag {
            crate::FlatSerialize::flat_serialize(f, "TemplateTag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateDisk {
    /// 所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 在指定可用区内创建一块按量付费磁盘。
    ///
    /// - 如果您不设置InstanceId，则ZoneId为必填参数。
    /// - 您不能同时指定ZoneId和InstanceId。
    ///
    ///
    /// > `cloud_regional_disk_auto`类型的磁盘无需设置 ZoneId。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 创建云盘使用的快照ID。2013年7月15日及以前的快照不能用来创建云盘。
    ///
    /// `SnapshotId`参数和`Size`参数存在以下限制：
    ///
    /// - 如果`SnapshotId`参数对应的快照容量大于设置的`Size`参数值，实际创建的云盘大小为指定快照的大小。
    /// - 如果`SnapshotId`参数对应的快照容量小于设置的`Size`参数值，实际创建的云盘大小为指定的`Size`参数值。
    /// - 不支持使用快照创建弹性临时盘。
    #[setters(generate = true, strip_option)]
    snapshot_id: Option<String>,
    /// 磁盘名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文等），ASCII数字（0-9）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。必须以Unicode中letter分类下的字符开头。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    disk_name: Option<String>,
    /// 容量大小。单位：GiB。您必须为该参数传入参数值。取值范围：
    ///
    /// -   cloud：5~2,000。
    /// -   cloud_efficiency：20~32,768。
    /// -   cloud_ssd：20~32,768。
    /// -   cloud_essd：具体取值范围与`PerformanceLevel`的取值有关。
    ///     - PL0：1~65,536。
    ///     - PL1：20~65,536。
    ///     - PL2：461~65,536。
    ///     - PL3：1,261~65,536。
    /// - cloud_auto：1~65,536。
    /// - cloud_essd_entry：10~32,768。
    /// - cloud_regional_disk_auto：10~65,536。
    /// - elastic_ephemeral_disk_standard：64～8,192。
    /// - elastic_ephemeral_disk_premium：64～8,192。
    ///
    /// 如果您指定了`SnapshotId`参数，`SnapshotId`参数和`Size`参数存在以下限制：
    ///
    /// - 如果`SnapshotId`参数对应的快照容量大于设置的`Size`参数值，实际创建的云盘大小为指定快照的大小。
    /// - 如果`SnapshotId`参数对应的快照容量小于设置的`Size`参数值，实际创建的云盘大小为指定的`Size`参数值。
    #[setters(generate = true, strip_option)]
    size: Option<i32>,
    /// 数据盘的磁盘种类。取值范围：
    ///
    /// - cloud：普通云盘。
    /// - cloud_efficiency：高效云盘。
    /// - cloud_ssd：SSD云盘。
    /// - cloud_essd：ESSD云盘。
    /// - cloud_auto：ESSD AutoPL云盘。
    /// - cloud_essd_entry：ESSD Entry云盘。
    /// - cloud_regional_disk_auto：ESSD同城冗余云盘。
    /// - elastic_ephemeral_disk_standard：弹性临时盘-标准版。
    /// - elastic_ephemeral_disk_premium：弹性临时盘-高级版。
    ///
    /// 默认值：cloud。
    #[setters(generate = true, strip_option)]
    disk_category: Option<String>,
    /// 磁盘描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 是否加密云盘。取值范围：
    ///
    /// - true：是。
    /// - false：否。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    encrypted: Option<bool>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 创建一块包年包月磁盘，并自动挂载到指定的包年包月实例（InstanceId）上。
    ///
    /// - 设置实例ID后，会忽略您设置的ResourceGroupId、Tag.N.Key、Tag.N.Value、ClientToken和KMSKeyId参数。
    /// - 您不能同时指定ZoneId和InstanceId。
    ///
    /// 默认值：空，代表创建的是按量付费云盘，云盘所属地由RegionId和ZoneId确定。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 磁盘所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 云盘使用的KMS密钥ID。
    #[setters(generate = true, strip_option)]
    kms_key_id: Option<String>,
    /// 创建一块ESSD云盘时，设置云盘的性能等级。取值范围：
    ///
    /// - PL0：单盘最高随机读写IOPS 1万。
    /// - PL1：单盘最高随机读写IOPS 5万。
    /// - PL2：单盘最高随机读写IOPS 10万。
    /// - PL3：单盘最高随机读写IOPS 100万。
    ///
    /// 默认值：PL1。
    ///
    /// 有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。
    #[setters(generate = true, strip_option)]
    performance_level: Option<String>,
    /// 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    advanced_features: Option<String>,
    /// 存储集ID。
    ///
    /// > 存储集相关参数（`StorageSetId`、`StorageSetPartitionNumber`）与专属块存储集群参数（`StorageClusterId`）只能选择其中之一设置。如果同时设置，那么调用接口将会失败。
    #[setters(generate = true, strip_option)]
    storage_set_id: Option<String>,
    /// 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    encrypt_algorithm: Option<String>,
    /// 存储集分区数。取值范围：大于等于2，最高不能超过调用[DescribeAccountAttributes](~~73772~~)后显示的权益配额限制。
    ///
    /// 默认值：2。
    #[setters(generate = true, strip_option)]
    storage_set_partition_number: Option<i32>,
    /// 专属块存储集群ID。如果您需要在指定的专属块存储集群中创建云盘，请指定该参数。
    ///
    /// > 存储集相关参数（`StorageSetId`、`StorageSetPartitionNumber`）与专属块存储集群参数（`StorageClusterId`）只能选择其中之一设置。如果同时设置，那么调用接口将会失败。
    #[setters(generate = true, strip_option)]
    storage_cluster_id: Option<String>,
    /// 是否开启多重挂载特性。取值范围：
    ///
    /// - Disabled: 不开启。
    /// - Enabled : 开启。目前仅ESSD云盘支持设置为`Enabled`。
    ///
    /// 默认值：Disabled。
    ///
    /// > 开启多重挂载特性的云盘只支持按量付费的计费方式。因此`MultiAttach=Enabled `时，不能同时设置`InstanceId`参数。您可以在创建云盘后调用[AttachDisk](~~25515~~)进行挂载，但需要注意开启多重挂载功能的云盘只能作为数据盘进行挂载。
    #[setters(generate = true, strip_option)]
    multi_attach: Option<String>,
    /// 磁盘的标签信息列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<DiskTag>>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    arn: Option<Vec<CreateDiskArn>>,
    /// ESSD AutoPL云盘（单盘）预配置性能的读写IOPS。可能值：
    ///
    /// - 容量（GiB）<=3：不支持设置预配置性能。
    ///
    /// - 容量（GiB）>=4：[0，min{(1,000
    ///
    ///  IOPS/GiB*容量-基准IOPS)，50,000}]
    ///
    ///
    /// 基准性能=max{min{1,800+50*容量，50,000}, 3,000}。
    ///
    ///
    /// >当`DiskCategory` = `cloud_auto`时才支持设置该参数。更多信息，请参见[ESSD AutoPL云盘](~~368372~~)。
    #[setters(generate = true, strip_option)]
    provisioned_iops: Option<i64>,
    /// 是否开启Burst（性能突发）。取值范围：
    ///
    /// - true：是。
    /// - false：否。
    ///
    /// >当`DiskCategory`取值为`cloud_auto`时才支持设置该参数。更多信息，请参见[ESSD AutoPL云盘](~~368372~~)。
    #[setters(generate = true, strip_option)]
    bursting_enabled: Option<bool>,
}

impl sealed::Bound for CreateDisk {}

impl CreateDisk {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            zone_id: None,
            snapshot_id: None,
            disk_name: None,
            size: None,
            disk_category: None,
            description: None,
            encrypted: None,
            client_token: None,
            instance_id: None,
            resource_group_id: None,
            kms_key_id: None,
            performance_level: None,
            advanced_features: None,
            storage_set_id: None,
            encrypt_algorithm: None,
            storage_set_partition_number: None,
            storage_cluster_id: None,
            multi_attach: None,
            tag: None,
            arn: None,
            provisioned_iops: None,
            bursting_enabled: None,
        }
    }
}
impl crate::ToFormData for CreateDisk {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateDisk {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateDisk";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateDiskResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(23);

        if let Some(f) = &self.advanced_features {
            params.push(("AdvancedFeatures".into(), (f).into()));
        }

        if let Some(f) = &self.arn {
            crate::FlatSerialize::flat_serialize(f, "Arn", &mut params);
        }

        if let Some(f) = &self.bursting_enabled {
            params.push(("BurstingEnabled".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.disk_category {
            params.push(("DiskCategory".into(), (f).into()));
        }

        if let Some(f) = &self.disk_name {
            params.push(("DiskName".into(), (f).into()));
        }

        if let Some(f) = &self.encrypt_algorithm {
            params.push(("EncryptAlgorithm".into(), (f).into()));
        }

        if let Some(f) = &self.encrypted {
            params.push(("Encrypted".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.kms_key_id {
            params.push(("KMSKeyId".into(), (f).into()));
        }

        if let Some(f) = &self.multi_attach {
            params.push(("MultiAttach".into(), (f).into()));
        }

        if let Some(f) = &self.performance_level {
            params.push(("PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.provisioned_iops {
            params.push(("ProvisionedIops".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.size {
            params.push(("Size".into(), (f).into()));
        }

        if let Some(f) = &self.snapshot_id {
            params.push(("SnapshotId".into(), (f).into()));
        }

        if let Some(f) = &self.storage_cluster_id {
            params.push(("StorageClusterId".into(), (f).into()));
        }

        if let Some(f) = &self.storage_set_id {
            params.push(("StorageSetId".into(), (f).into()));
        }

        if let Some(f) = &self.storage_set_partition_number {
            params.push(("StorageSetPartitionNumber".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDisks {
    /// 块存储所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 可用区ID。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 云盘、本地盘或弹性临时盘ID。一个带有格式的JSON数组，最多支持100个ID，用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    disk_ids: Option<String>,
    /// 云盘、本地盘或弹性临时盘挂载的实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 要查询的云盘、本地盘或弹性临时盘类型。取值范围：
    ///          
    /// - all：同时查询系统盘与数据盘。
    /// - system：只查询系统盘。
    /// - data：只查询数据盘。
    ///
    /// 默认值：all。
    /// >弹性临时盘不支持作为系统盘。
    #[setters(generate = true, strip_option)]
    disk_type: Option<String>,
    /// 磁盘种类。取值范围：
    ///          
    /// - all：所有云盘以及本地盘和弹性临时盘。
    /// - cloud：普通云盘。
    /// - cloud_efficiency：高效云盘。
    /// - cloud_ssd：SSD盘。
    /// - cloud_essd：ESSD云盘。
    /// - cloud_auto：ESSD AutoPL云盘。
    /// - cloud_regional_disk_auto：ESSD 同城冗余云盘。
    /// - cloud_essd_entry：ESSD Entry云盘。
    /// - elastic_ephemeral_disk_standard：弹性临时盘-标准版。
    /// - elastic_ephemeral_disk_premium：弹性临时盘-高级版。
    /// - local_ssd_pro：I/O密集型本地盘。
    /// - local_hdd_pro：吞吐密集型本地盘。
    /// - ephemeral：（已停售）本地盘。
    /// - ephemeral_ssd：（已停售）本地SSD盘。
    ///
    /// 默认值：all。
    #[setters(generate = true, strip_option)]
    category: Option<String>,
    /// 磁盘状态。更多信息，请参见[云盘状态](~~25689~~)。取值范围：
    /// -   In_use：使用中。
    /// -   Available：待挂载。
    /// -   Attaching：挂载中 。
    /// -   Detaching：卸载中。
    /// -   Creating：创建中。
    /// -   ReIniting：初始化中。
    /// -   All：所有状态。
    ///
    /// 默认值：All。
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// 创建云盘时使用的快照ID。
    #[setters(generate = true, strip_option)]
    snapshot_id: Option<String>,
    /// 磁盘是否支持卸载。取值范围：
    ///
    /// -   true：支持。可以独立存在，且可以在可用区内自由挂载和卸载。
    ///
    /// -   false：不支持。不可以独立存在，且不可以在可用区内自由挂载和卸载。
    ///
    /// 以下类型块存储的`Portable`属性都为`false`，生命周期与实例等同：
    ///
    /// -   本地盘。
    /// -   本地SSD盘。
    /// -   包年包月数据盘。
    #[setters(generate = true, strip_option)]
    portable: Option<bool>,
    /// 磁盘是否设置了随实例释放。取值范围：
    ///
    /// -   true：磁盘随实例一起释放。
    /// -   false：磁盘保留不释放，转为按量付费数据盘而保留下来。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    delete_with_instance: Option<bool>,
    /// 释放云盘时，是否会同时释放自动快照。
    ///
    /// - true：是。
    ///
    /// - false：否。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    delete_auto_snapshot: Option<bool>,
    /// > 该参数即将下线，推荐您使用参数 `NextToken `与 `MaxResults `完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// >该参数即将下线，推荐您使用参数 `NextToken `与 `MaxResults `完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 查询凭证（Token），取值为上一次调用API返回的`NextToken`参数值。
    ///
    /// 有关本接口查看返回数据的设置方式，请参见上文接口说明部分。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 返回的最大数。取值范围：10~500。
    ///
    /// 默认值：
    /// - 当不设置值或者设置的值小于10，默认值为10。
    /// - 当设置的值大于500时，默认值为500。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 磁盘的名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    disk_name: Option<String>,
    /// 根据自动快照策略ID查询云盘。
    #[setters(generate = true, strip_option)]
    auto_snapshot_policy_id: Option<String>,
    /// 云盘是否启用自动快照策略功能。
    ///
    /// - true：启用。
    /// - false：未启用。
    ///
    /// > 该参数已弃用。创建后的云盘默认启用自动快照策略功能，您只需要为云盘绑定自动快照策略即可正常使用。
    #[setters(generate = true, strip_option)]
    enable_auto_snapshot: Option<bool>,
    /// 云盘是否设置了自动快照策略。
    /// - true：已设置。
    /// - false：未设置。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    enable_automated_snapshot_policy: Option<bool>,
    /// 磁盘的计费方式。取值范围：
    ///
    /// - PrePaid：包年包月。
    /// - PostPaid：按量付费。
    #[setters(generate = true, strip_option)]
    disk_charge_type: Option<String>,
    /// 磁盘被锁定的原因。取值范围：
    ///
    /// - financial：因欠费被锁定。
    /// - security：因安全原因被锁定。
    #[setters(generate = true, strip_option)]
    lock_reason: Option<String>,
    /// 查询资源时的筛选键，取值必须为`CreationStartTime`。同时设置`Filter.1.Key`和`Filter.1.Value`可以查询在指定时间点后创建的资源信息。
    #[setters(generate = true, strip_option)]
    filter1_key: Option<String>,
    /// 查询资源时的筛选键，取值必须为`CreationEndTime`。同时设置`Filter.2.Key`和`Filter.2.Value`可以查询在指定时间点前创建的资源信息。
    #[setters(generate = true, strip_option)]
    filter2_key: Option<String>,
    /// 查询资源时的筛选值。指定该参数时必须同时指定`Filter.1.Key`参数，格式为：`yyyy-MM-ddTHH:mmZ`，采用UTC +0时区。
    #[setters(generate = true, strip_option)]
    filter1_value: Option<String>,
    /// 查询资源时的筛选值。指定该参数时必须同时指定`Filter.2.Key`参数，格式为：`yyyy-MM-ddTHH:mmZ`，采用UTC +0时区。
    #[setters(generate = true, strip_option)]
    filter2_value: Option<String>,
    /// 磁盘所在的企业资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 是否是共享块存储。
    #[setters(generate = true, strip_option)]
    enable_shared: Option<bool>,
    /// 是否只筛选出加密云盘。
    ///
    /// - true：是。
    ///
    /// - false：否
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    encrypted: Option<bool>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// -   true：发送检查请求，不会查询资源状况。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，会返回错误码`DryRunOperation`。
    /// -   false：发送正常请求，通过检查后返回2XX HTTP状态码并直接查询资源状况。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 云盘使用的KMS密钥ID。
    #[setters(generate = true, strip_option)]
    kms_key_id: Option<String>,
    /// 是否开启了多重挂载特性。取值范围：
    ///
    /// - Disabled：未开启。
    /// - Enabled：已开启。
    /// - LegacyShared：用于查询共享块存储。
    #[setters(generate = true, strip_option)]
    multi_attach: Option<String>,
    /// 磁盘标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<DisksTag>>,
    /// 其他属性值列表。目前仅支持传入值为`Placement`，表示查询当前磁盘的数据存放地。
    ///
    /// > 目前仅同城冗余类型的磁盘有数据存放地。
    #[setters(generate = true, strip_option)]
    additional_attributes: Option<Vec<String>>,
}

impl sealed::Bound for DescribeDisks {}

impl DescribeDisks {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            zone_id: None,
            disk_ids: None,
            instance_id: None,
            disk_type: None,
            category: None,
            status: None,
            snapshot_id: None,
            portable: None,
            delete_with_instance: None,
            delete_auto_snapshot: None,
            page_number: None,
            page_size: None,
            next_token: None,
            max_results: None,
            disk_name: None,
            auto_snapshot_policy_id: None,
            enable_auto_snapshot: None,
            enable_automated_snapshot_policy: None,
            disk_charge_type: None,
            lock_reason: None,
            filter1_key: None,
            filter2_key: None,
            filter1_value: None,
            filter2_value: None,
            resource_group_id: None,
            enable_shared: None,
            encrypted: None,
            dry_run: None,
            kms_key_id: None,
            multi_attach: None,
            tag: None,
            additional_attributes: None,
        }
    }
}
impl crate::ToFormData for DescribeDisks {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDisks {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDisks";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDisksResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(33);

        if let Some(f) = &self.additional_attributes {
            crate::FlatSerialize::flat_serialize(f, "AdditionalAttributes", &mut params);
        }

        if let Some(f) = &self.auto_snapshot_policy_id {
            params.push(("AutoSnapshotPolicyId".into(), (f).into()));
        }

        if let Some(f) = &self.category {
            params.push(("Category".into(), (f).into()));
        }

        if let Some(f) = &self.delete_auto_snapshot {
            params.push(("DeleteAutoSnapshot".into(), (f).into()));
        }

        if let Some(f) = &self.delete_with_instance {
            params.push(("DeleteWithInstance".into(), (f).into()));
        }

        if let Some(f) = &self.disk_charge_type {
            params.push(("DiskChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.disk_ids {
            params.push(("DiskIds".into(), (f).into()));
        }

        if let Some(f) = &self.disk_name {
            params.push(("DiskName".into(), (f).into()));
        }

        if let Some(f) = &self.disk_type {
            params.push(("DiskType".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.enable_auto_snapshot {
            params.push(("EnableAutoSnapshot".into(), (f).into()));
        }

        if let Some(f) = &self.enable_automated_snapshot_policy {
            params.push(("EnableAutomatedSnapshotPolicy".into(), (f).into()));
        }

        if let Some(f) = &self.enable_shared {
            params.push(("EnableShared".into(), (f).into()));
        }

        if let Some(f) = &self.encrypted {
            params.push(("Encrypted".into(), (f).into()));
        }

        if let Some(f) = &self.filter1_key {
            params.push(("Filter.1.Key".into(), (f).into()));
        }

        if let Some(f) = &self.filter1_value {
            params.push(("Filter.1.Value".into(), (f).into()));
        }

        if let Some(f) = &self.filter2_key {
            params.push(("Filter.2.Key".into(), (f).into()));
        }

        if let Some(f) = &self.filter2_value {
            params.push(("Filter.2.Value".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.kms_key_id {
            params.push(("KMSKeyId".into(), (f).into()));
        }

        if let Some(f) = &self.lock_reason {
            params.push(("LockReason".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.multi_attach {
            params.push(("MultiAttach".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }

        if let Some(f) = &self.portable {
            params.push(("Portable".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.snapshot_id {
            params.push(("SnapshotId".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AttachDisk {
    /// 待挂载ECS实例的ID。
    instance_id: String,
    /// 待挂载的磁盘ID。磁盘（`DiskId`）和实例（`InstanceId`）必须在同一个可用区。
    ///
    /// > 支持挂载数据盘和系统盘，相关约束条件请参见上文接口说明部分。
    disk_id: String,
    /// 磁盘设备名称。
    ///
    /// > 该参数即将被弃用，为提高兼容性，建议您尽量使用其他参数标识磁盘。
    #[setters(generate = true, strip_option)]
    device: Option<String>,
    /// 释放实例时，该磁盘是否随实例一起释放。取值范围：
    ///
    /// - true：释放。
    /// - false：不释放。磁盘会转换成按量付费数据盘而被保留下来。
    ///
    /// 默认值：false。
    ///
    /// 设置该参数时，您需要注意：
    ///
    /// - 将`DeleteWithInstance`置为`false`后，一旦ECS实例被安全控制，即`OperationLocks`中标记了`"LockReason" : "security"`，释放ECS实例时会忽略磁盘的该属性，被同时释放。
    ///
    /// - 若您需要挂载的目标磁盘为`弹性临时盘`，则必须将`DeleteWithInstance`参数设置为`true`。
    ///
    /// - 开启多重挂载特性的云盘，不支持设置该参数。
    #[setters(generate = true, strip_option)]
    delete_with_instance: Option<bool>,
    /// 是否作为系统盘挂载。取值范围：
    ///
    /// - true：是。
    ///
    /// - false：否。
    ///
    /// 默认值：false。
    ///
    /// > 设置为`Bootable=true`时，目标ECS实例必须处于无系统盘状态。
    #[setters(generate = true, strip_option)]
    bootable: Option<bool>,
    /// 挂载系统盘时，设置实例的用户名密码，仅对administrator和root用户名生效，其他用户名不生效。长度为8至30个字符，必须同时包含大小写英文字母、数字和特殊符号中的三类字符。特殊符号可以是：
    ///
    /// ```ignore
    /// ()`~!@#$%^&*-_+=|{}[]:;'<>,.?/
    /// ```
    /// 其中，Windows实例不能以斜线号（/）为密码首字符。
    ///
    /// > 如果传入`Password`参数，建议您使用HTTPS协议发送请求，避免密码泄露。
    #[setters(generate = true, strip_option)]
    password: Option<String>,
    /// 挂载系统盘时，为Linux系统ECS实例绑定的SSH密钥对的名称。
    ///
    /// - Windows Server系统：不支持SSH密钥对。即使填写了该参数，只执行`Password`的配置。
    ///
    /// - Linux系统：密码登录方式会被初始化成禁止。
    #[setters(generate = true, strip_option)]
    key_pair_name: Option<String>,
    /// 是否是强制挂载请求。取值范围：
    ///
    /// - true：是。
    /// - false：否。
    ///
    /// 默认值：false。
    ///
    ///
    /// > 当前仅 ESSD 同城冗余类型（cloud_regional_disk_auto）支持设置该字段为 true。
    #[setters(generate = true, strip_option)]
    force: Option<bool>,
}

impl sealed::Bound for AttachDisk {}

impl AttachDisk {
    pub fn new(instance_id: impl Into<String>, disk_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            disk_id: disk_id.into(),
            device: None,
            delete_with_instance: None,
            bootable: None,
            password: None,
            key_pair_name: None,
            force: None,
        }
    }
}
impl crate::ToFormData for AttachDisk {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AttachDisk {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AttachDisk";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AttachDiskResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.bootable {
            params.push(("Bootable".into(), (f).into()));
        }

        if let Some(f) = &self.delete_with_instance {
            params.push(("DeleteWithInstance".into(), (f).into()));
        }

        if let Some(f) = &self.device {
            params.push(("Device".into(), (f).into()));
        }
        params.push(("DiskId".into(), (&self.disk_id).into()));

        if let Some(f) = &self.force {
            params.push(("Force".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.key_pair_name {
            params.push(("KeyPairName".into(), (f).into()));
        }

        if let Some(f) = &self.password {
            params.push(("Password".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DetachDisk {
    /// 待卸载的磁盘所绑定的ECS实例ID。
    instance_id: String,
    /// 待卸载的磁盘ID。
    ///
    /// - 磁盘必须已经挂载到实例上，状态为使用中（`In_use`)。
    ///
    /// - 卸载数据盘时，所挂载的实例必须处于运行中（`Running`）或者已停止（`Stopped`）状态。
    ///
    /// - 卸载系统盘时，所挂载的实例必须处于已停止（`Stopped`）状态。
    disk_id: String,
    /// 卸载系统盘或数据盘时，设置自动释放属性。表示释放ECS实例时，是否同时释放该系统盘或数据盘。
    ///
    /// - true：释放。
    /// - false：不释放。云盘被转换为按量付费数据盘被保留下来。
    ///
    /// 默认值：true
    ///
    /// 您需要注意：
    ///
    /// - 开启多重挂载特性的云盘，不支持设置该参数。
    /// - 如果卸载的是数据盘，默认值为`false`。
    /// - 若您需要卸载的目标磁盘为`弹性临时盘`，则必须将`DeleteWithInstance`参数设置为`true`。
    #[setters(generate = true, strip_option)]
    delete_with_instance: Option<bool>,
}

impl sealed::Bound for DetachDisk {}

impl DetachDisk {
    pub fn new(instance_id: impl Into<String>, disk_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            disk_id: disk_id.into(),
            delete_with_instance: None,
        }
    }
}
impl crate::ToFormData for DetachDisk {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DetachDisk {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DetachDisk";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DetachDiskResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.delete_with_instance {
            params.push(("DeleteWithInstance".into(), (f).into()));
        }
        params.push(("DiskId".into(), (&self.disk_id).into()));
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ResizeDisk {
    /// 磁盘ID。您可以调用[DescribeDisks](~~25514~~)查询磁盘ID。
    disk_id: String,
    /// 扩容磁盘的方式。取值范围：
    ///
    /// - offline（默认）：离线扩容。扩容后，您必须在控制台[重启实例](~~25440~~)或者调用API [RebootInstance](~~25502~~)使操作生效。
    ///  
    /// - online：在线扩容，无需重启实例即可完成扩容。磁盘类型支持高效云盘、SSD云盘、ESSD云盘和弹性临时盘。
    #[setters(generate = true, strip_option, rename = "r#type")]
    r#type: Option<String>,
    /// 希望扩容到的磁盘容量大小。单位为GiB。取值范围：
    /// - 系统盘：
    ///   - 普通云盘：20~500。
    ///   - ESSD云盘：
    ///     - PL0：1~2048。
    ///     - PL1：20~2048。
    ///     - PL2：461~2048。
    ///     - PL3：1261~2048。
    ///   - ESSD AutoPL 云盘：1~2048。
    ///   - 其他云盘类型：20~2048。
    ///
    /// - 数据盘：
    ///     - 高效云盘（cloud_efficiency）：20~32768。
    ///     - SSD云盘（cloud_ssd）：20~32768。
    ///     - ESSD云盘（cloud_essd）：具体取值范围与`PerformanceLevel`的取值有关。可以调用[DescribeDisks](~~25514~~)查询云盘信息，再根据查询结果中的`PerformanceLevel`参数查看取值。
    ///         - PL0：1~65536。
    ///         - PL1：20~65536。
    ///         - PL2：461~65536。
    ///         - PL3：1261~65536。
    ///     - 普通云盘（cloud）：5~2000。
    ///     - ESSD AutoPL云盘（cloud_auto）：1~65536。
    /// <props="china">
    ///     - ESSD Entry云盘（cloud_essd_entry）：10~32768。
    /// </props>
    ///   - 弹性临时盘-标准版（elastic_ephemeral_disk_standard）：64～8,192。
    ///   - 弹性临时盘-高级版（elastic_ephemeral_disk_premium）：64～8,192。
    ///
    /// >指定的新磁盘容量必须比原磁盘容量大，否则调用接口将报错。
    new_size: i32,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for ResizeDisk {}

impl ResizeDisk {
    pub fn new(disk_id: impl Into<String>, new_size: impl Into<i32>) -> Self {
        Self {
            disk_id: disk_id.into(),
            r#type: None,
            new_size: new_size.into(),
            client_token: None,
        }
    }
}
impl crate::ToFormData for ResizeDisk {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ResizeDisk {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ResizeDisk";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ResizeDiskResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("DiskId".into(), (&self.disk_id).into()));
        params.push(("NewSize".into(), (&self.new_size).into()));

        if let Some(f) = &self.r#type {
            params.push(("Type".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDiskAttribute {
    /// 待修改属性的磁盘ID。
    /// > `DiskId`和`DiskIds.N`两个参数不能同时被调用，请您根据需求任选其一传值。
    #[setters(generate = true, strip_option)]
    disk_id: Option<String>,
    /// 磁盘名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    disk_name: Option<String>,
    /// 磁盘描述。 长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    ///          
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 磁盘是否随实例释放。默认值：无，无表示不改变当前的值。
    ///
    /// <props="china">开启多重挂载特性的云盘，不支持设置该参数。</props>
    ///
    /// 在下列两种情况下，将参数`DeleteWithInstance`设置成`false`时会报错。
    ///          
    /// - 磁盘的种类（category）为本地盘（ephemeral）时。  
    /// - 磁盘的种类（category）为普通云盘（cloud），且不可以卸载（Portable=false）时。  
    ///
    /// ><warning>如果您设置了不随实例释放（DeleteWithInstance=false），一旦磁盘挂载的ECS实例被安全锁定且OperationLocks中标记了"LockReason" : "security"的锁定状态，释放实例时会忽略磁盘的DeleteWithInstance属性而被同时释放。></warning>
    #[setters(generate = true, strip_option)]
    delete_with_instance: Option<bool>,
    /// 删除磁盘时，是否同时删除其自动快照。取值范围：
    ///
    /// - true：启用。
    ///
    /// - false：关闭。
    ///
    /// 默认值：无，无表示不改变当前的值。
    #[setters(generate = true, strip_option)]
    delete_auto_snapshot: Option<bool>,
    /// 磁盘是否启用自动快照策略功能。取值范围：
    ///
    /// - true：启用。
    /// - false：关闭。
    ///
    /// 默认值：无，表示不改变当前的值。
    ///
    /// > 该参数已弃用。创建后的云盘默认启用自动快照策略功能，您只需要为云盘绑定自动快照策略即可正常使用。
    #[setters(generate = true, strip_option)]
    enable_auto_snapshot: Option<bool>,
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    /// 待修改多个磁盘的ID列表。N的取值范围为0 ~ 100。
    /// > `DiskId`和`DiskIds.N`两个参数不能同时被调用，请您根据需求任选其一传值。
    #[setters(generate = true, strip_option)]
    disk_ids: Option<Vec<String>>,
    /// 针对支持Burst（性能突发）的磁盘是否开启此功能，取值范围：
    ///
    /// - true：是。
    /// - false：否。
    ///
    /// > 对于不支持Burst功能的磁盘，传入任意值将会报错。
    #[setters(generate = true, strip_option)]
    bursting_enabled: Option<bool>,
}

impl sealed::Bound for ModifyDiskAttribute {}

impl ModifyDiskAttribute {
    pub fn new() -> Self {
        Self {
            disk_id: None,
            disk_name: None,
            description: None,
            delete_with_instance: None,
            delete_auto_snapshot: None,
            enable_auto_snapshot: None,
            region_id: None,
            disk_ids: None,
            bursting_enabled: None,
        }
    }
}
impl crate::ToFormData for ModifyDiskAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDiskAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDiskAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDiskAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);

        if let Some(f) = &self.bursting_enabled {
            params.push(("BurstingEnabled".into(), (f).into()));
        }

        if let Some(f) = &self.delete_auto_snapshot {
            params.push(("DeleteAutoSnapshot".into(), (f).into()));
        }

        if let Some(f) = &self.delete_with_instance {
            params.push(("DeleteWithInstance".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.disk_id {
            params.push(("DiskId".into(), (f).into()));
        }

        if let Some(f) = &self.disk_ids {
            crate::FlatSerialize::flat_serialize(f, "DiskIds", &mut params);
        }

        if let Some(f) = &self.disk_name {
            params.push(("DiskName".into(), (f).into()));
        }

        if let Some(f) = &self.enable_auto_snapshot {
            params.push(("EnableAutoSnapshot".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDiskChargeType {
    /// 云盘挂载的实例ID。
    instance_id: String,
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 云盘ID列表，一个带有格式的JSON Array，最多支持16个ID，用半角逗号（,）隔开。
    disk_ids: String,
    /// 是否自动支付。取值范围：
    ///          
    /// - true（默认）：自动支付。您需要确保账户余额充足，如果账户余额不足会生成异常订单，只能作废订单。
    /// - false：只生成订单不扣费。如果您的账户余额不足，会生成正常的未支付订单，此订单可登录阿里云**费用与成本**后，在<props="china"><ph>[我的订单](https://usercenter2.aliyun.com/order/list)</ph></props><props="intl"><ph>[订单管理](https://usercenter2-intl.aliyun.com/order/list)</ph></props>页面支付。
    #[setters(generate = true, strip_option)]
    auto_pay: Option<bool>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 云盘计费方式。取值范围：
    ///          
    /// - PrePaid（默认）：按量付费数据盘转换为包年包月数据盘。
    /// - PostPaid：包年包月数据盘转换为按量付费数据盘。
    ///
    /// > 转换按量付费云盘为包年包月时，其容量费用计费周期自动与关联的ECS实例同步。
    #[setters(generate = true, strip_option)]
    disk_charge_type: Option<String>,
}

impl sealed::Bound for ModifyDiskChargeType {}

impl ModifyDiskChargeType {
    pub fn new(
        instance_id: impl Into<String>,
        region_id: impl Into<String>,
        disk_ids: impl Into<String>,
    ) -> Self {
        Self {
            instance_id: instance_id.into(),
            region_id: region_id.into(),
            disk_ids: disk_ids.into(),
            auto_pay: None,
            client_token: None,
            disk_charge_type: None,
        }
    }
}
impl crate::ToFormData for ModifyDiskChargeType {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDiskChargeType {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDiskChargeType";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDiskChargeTypeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.auto_pay {
            params.push(("AutoPay".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.disk_charge_type {
            params.push(("DiskChargeType".into(), (f).into()));
        }
        params.push(("DiskIds".into(), (&self.disk_ids).into()));
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDiskSpec {
    /// 云盘的ID。
    disk_id: String,
    /// 修改一块ESSD云盘的性能级别。取值范围：
    ///
    /// - PL0：单盘最高随机读写IOPS 1万。
    /// - PL1：单盘最高随机读写IOPS 5万。
    /// - PL2：单盘最高随机读写IOPS 10万。
    /// - PL3：单盘最高随机读写IOPS 100万。
    ///
    /// 默认值：PL1。
    #[setters(generate = true, strip_option)]
    performance_level: Option<String>,
    /// 变更一块云盘的类型。取值范围：
    ///
    /// - cloud_essd：ESSD云盘。
    /// - cloud_auto：ESSD AutoPL云盘。
    /// - cloud_ssd：SSD云盘。
    /// <props="china">
    /// - cloud_essd_entry：ESSD Entry云盘。
    /// </props>
    /// - cloud_efficiency：高效云盘。
    ///
    /// 默认值：空，表示不变配云盘。
    ///
    /// > - 以上有效取值按云盘性能降序排列。如果指定的云盘是包年包月云盘，则不允许降配云盘。
    ///
    /// <props="china">
    /// - ESSD Entry云盘仅支持变配到ESSD云盘和ESSD AutoPL云盘。更多信息，请参见[变更云盘类型](~~161980~~)。
    /// </props>
    #[setters(generate = true, strip_option)]
    disk_category: Option<String>,
    /// 是否只预检此次请求。取值范围：
    ///
    /// * true：发送检查请求。检查项包括是否填写了必需参数、请求格式、业务限制和ECS库存。如果检查不通过，则返回对应错误。如果检查通过，则返回错误码`DryRunOperation`。
    ///
    /// * false：发送正常请求，通过检查后返回2XX HTTP状态码并且直接变配云盘或修改ESSD性能等级。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 是否修改ESSD AutoPL云盘预配置读写IOPS。
    ///
    /// 取值范围：0~min{50000, 1000*容量-基准性能}。
    ///
    /// 基准性能=min{1,800+50*容量, 50,000}。
    ///
    /// > 当`DiskCategory`取值为`cloud_auto`时才支持设置该参数。更多信息，请参见[ESSD AutoPL云盘](~~368372~~)和[修改ESSD AutoPL云盘预配置信息](~~413275~~)。
    #[setters(generate = true, strip_option)]
    provisioned_iops: Option<i64>,
    /// 磁盘性能控制参数集合。
    #[setters(generate = true, strip_option)]
    performance_control_options: Option<ControlOptions>,
    /// > 该参数正在邀测中，暂不支持使用。
    #[setters(generate = true, strip_option)]
    destination_zone_id: Option<String>,
}

impl sealed::Bound for ModifyDiskSpec {}

impl ModifyDiskSpec {
    pub fn new(disk_id: impl Into<String>) -> Self {
        Self {
            disk_id: disk_id.into(),
            performance_level: None,
            disk_category: None,
            dry_run: None,
            provisioned_iops: None,
            performance_control_options: None,
            destination_zone_id: None,
        }
    }
}
impl crate::ToFormData for ModifyDiskSpec {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDiskSpec {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDiskSpec";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDiskSpecResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.destination_zone_id {
            params.push(("DestinationZoneId".into(), (f).into()));
        }

        if let Some(f) = &self.disk_category {
            params.push(("DiskCategory".into(), (f).into()));
        }
        params.push(("DiskId".into(), (&self.disk_id).into()));

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.performance_control_options {
            crate::FlatSerialize::flat_serialize(f, "PerformanceControlOptions", &mut params);
        }

        if let Some(f) = &self.performance_level {
            params.push(("PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.provisioned_iops {
            params.push(("ProvisionedIops".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ReplaceSystemDisk {
    /// 指定实例的ID。
    ///
    /// >发起请求之前请确保目标实例状态为`已停止`（`Stopped`）。
    instance_id: String,
    /// 重置系统时使用的镜像ID。该参数为必填参数。
    #[setters(generate = true, strip_option)]
    image_id: Option<String>,
    /// 新的系统盘容量，单位为GiB。取值范围：
    ///
    /// - 普通云盘：Max{20, 参数ImageId对应的镜像大小}~500。
    /// - ESSD云盘：
    ///   - PL0：Max{1, 参数 ImageId 对应的镜像大小}~2048。
    ///   - PL1：Max{20, 参数 ImageId 对应的镜像大小}~2048。
    ///   - PL2：Max{461, 参数 ImageId 对应的镜像大小}~2048。
    ///   - PL3：Max{1261, 参数 ImageId 对应的镜像大小}~2048。
    /// - ESSD AutoPL 云盘：Max{1, 参数 ImageId 对应的镜像大小}~2048。
    /// - 其他云盘：Max{20, 参数ImageId对应的镜像大小}~2048。
    ///
    /// 默认值：Max{40, 参数ImageId对应的镜像大小}。
    ///
    /// > 超过`Max{20, 更换前的系统盘容量}`的云盘容量部分，将收取额外费用。
    #[setters(generate = true, strip_option)]
    system_disk_size: Option<i32>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 是否使用阿里云提供的虚拟机系统配置（Windows：NTP、KMS；Linux：NTP、YUM）。
    ///
    /// > 挂载系统盘时（即设备名为/dev/xvda）有效。
    #[setters(generate = true, strip_option)]
    use_additional_service: Option<bool>,
    /// 是否重置ECS实例的用户名密码。长度为8至30个字符，必须同时包含大小写英文字母、数字和特殊符号中的三类字符。特殊符号可以是：
    ///
    /// ```ignore
    /// ()`~!@#$%^&*-_+=|{}[]:;'<>,.?/
    /// ```
    ///
    /// 其中，Windows实例不能以斜线号（/）为密码首字符。
    ///
    /// 默认值：保持不变。
    ///
    /// > 如果传入`Password`参数，建议您使用HTTPS协议发送请求，避免密码泄露。
    #[setters(generate = true, strip_option)]
    password: Option<String>,
    /// 是否使用镜像预设的密码。
    ///
    /// 默认值：false。
    ///
    /// > 使用该参数时，Password参数必须为空。同时您需要确保使用的镜像已经设置了密码。
    ///
    #[setters(generate = true, strip_option)]
    password_inherit: Option<bool>,
    /// 密钥对名称。
    ///
    /// > 该参数仅对Linux系统ECS实例生效。您可以为ECS实例绑定一个SSH密钥对，作为登录凭证。使用了SSH密钥对后，用户名密码的登录凭证方式将被禁用。
    #[setters(generate = true, strip_option)]
    key_pair_name: Option<String>,
    /// > 该参数已废弃，为提高兼容性，建议您使用 `ImageId`。
    #[setters(generate = true, strip_option)]
    disk_id: Option<String>,
    /// > 已弃用。
    #[setters(generate = true, strip_option)]
    platform: Option<String>,
    /// > 已弃用。
    #[setters(generate = true, strip_option)]
    architecture: Option<String>,
    /// 更换系统盘后，是否免费使用云安全中心服务。取值范围：
    ///
    /// - Active：使用。该值仅支持公共镜像。
    ///
    /// - Deactive：不使用。该值支持所有镜像。
    ///
    /// 默认值：Deactive。
    #[setters(generate = true, strip_option)]
    security_enhancement_strategy: Option<String>,
    /// 是否加密云盘。取值范围：
    ///
    /// - true：是。
    ///
    /// - false：否。
    ///
    ///
    /// 默认值：false。
    ///
    /// ><notice>当使用共享加密镜像，创建基于加密快照的云盘时，必须指定该云盘的请求参数Encrypted=true，以确保创建出的云盘使用的是被共享方自己的密钥。></notice>
    #[setters(generate = true, strip_option)]
    encrypted: Option<bool>,
    /// 系统盘对应的KMS密钥ID。
    #[setters(generate = true, strip_option)]
    kms_key_id: Option<String>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    encrypt_algorithm: Option<String>,
    /// 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    arn: Option<Vec<SystemDiskArn>>,
}

impl sealed::Bound for ReplaceSystemDisk {}

impl ReplaceSystemDisk {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            image_id: None,
            system_disk_size: None,
            client_token: None,
            use_additional_service: None,
            password: None,
            password_inherit: None,
            key_pair_name: None,
            disk_id: None,
            platform: None,
            architecture: None,
            security_enhancement_strategy: None,
            encrypted: None,
            kms_key_id: None,
            encrypt_algorithm: None,
            arn: None,
        }
    }
}
impl crate::ToFormData for ReplaceSystemDisk {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ReplaceSystemDisk {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ReplaceSystemDisk";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ReplaceSystemDiskResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(16);

        if let Some(f) = &self.architecture {
            params.push(("Architecture".into(), (f).into()));
        }

        if let Some(f) = &self.arn {
            crate::FlatSerialize::flat_serialize(f, "Arn", &mut params);
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.disk_id {
            params.push(("DiskId".into(), (f).into()));
        }

        if let Some(f) = &self.encrypt_algorithm {
            params.push(("EncryptAlgorithm".into(), (f).into()));
        }

        if let Some(f) = &self.encrypted {
            params.push(("Encrypted".into(), (f).into()));
        }

        if let Some(f) = &self.image_id {
            params.push(("ImageId".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.kms_key_id {
            params.push(("KMSKeyId".into(), (f).into()));
        }

        if let Some(f) = &self.key_pair_name {
            params.push(("KeyPairName".into(), (f).into()));
        }

        if let Some(f) = &self.password {
            params.push(("Password".into(), (f).into()));
        }

        if let Some(f) = &self.password_inherit {
            params.push(("PasswordInherit".into(), (f).into()));
        }

        if let Some(f) = &self.platform {
            params.push(("Platform".into(), (f).into()));
        }

        if let Some(f) = &self.security_enhancement_strategy {
            params.push(("SecurityEnhancementStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_size {
            params.push(("SystemDisk.Size".into(), (f).into()));
        }

        if let Some(f) = &self.use_additional_service {
            params.push(("UseAdditionalService".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ResetDisk {
    /// 待回滚的云盘ID。
    disk_id: String,
    /// 需要回滚的云盘某一阶段的历史快照ID。
    snapshot_id: String,
    /// 是否预检本次请求。取值范围：
    ///
    /// - true：发送检查请求，不会直接回滚云盘。检查项包括是否填写了必选参数、请求格式和资源状态限制。如果检查不通过，则返回对应错误信息。如果检查通过，则返回错误码`DryRunOperation`。
    /// - false：发送正常请求，通过检查后直接发起云盘回滚操作。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for ResetDisk {}

impl ResetDisk {
    pub fn new(disk_id: impl Into<String>, snapshot_id: impl Into<String>) -> Self {
        Self {
            disk_id: disk_id.into(),
            snapshot_id: snapshot_id.into(),
            dry_run: None,
        }
    }
}
impl crate::ToFormData for ResetDisk {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ResetDisk {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ResetDisk";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ResetDiskResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("DiskId".into(), (&self.disk_id).into()));

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }
        params.push(("SnapshotId".into(), (&self.snapshot_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ResetDisks {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 是否预检本次请求。取值范围：
    ///
    /// - true：发送检查请求，不会直接回滚云盘。检查项包括是否填写了必选参数、请求格式和资源状态限制。如果检查不通过，则返回对应错误信息。如果检查通过，则返回错误码`DryRunOperation`。
    /// - false：发送正常请求，通过检查后直接发起云盘回滚操作。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 云盘列表。
    disk: Vec<ResetDisksDisk>,
}

impl sealed::Bound for ResetDisks {}

impl ResetDisks {
    pub fn new(region_id: impl Into<String>, disk: impl Into<Vec<ResetDisksDisk>>) -> Self {
        Self {
            region_id: region_id.into(),
            dry_run: None,
            disk: disk.into(),
        }
    }
}
impl crate::ToFormData for ResetDisks {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ResetDisks {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ResetDisks";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ResetDisksResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        crate::FlatSerialize::flat_serialize(&self.disk, "Disk", &mut params);

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ReInitDisk {
    /// 待初始化的磁盘ID。
    disk_id: String,
    /// 重新初始化系统盘时，是否重置ECS实例的用户名密码。长度为8至30个字符，必须同时包含大小写英文字母、数字和特殊符号中的三类字符。特殊符号可以是：
    ///
    /// ```ignore
    /// ()`~!@#$%^&*-_+=|{}[]:;'<>,.?/
    /// ```
    ///
    /// 其中，Windows实例不能以斜线号（/）为密码首字符。
    ///
    /// > 如果传入`Password`参数，建议您使用HTTPS协议发送请求，避免密码泄露。
    #[setters(generate = true, strip_option)]
    password: Option<String>,
    /// 密钥对名称。
    ///
    /// > 该参数仅适用于Linux实例。重新初始化系统盘时，您可以为ECS实例绑定一个SSH密钥对，作为登录凭证。使用了SSH密钥对后，用户名密码的登录凭证方式将被禁用。
    #[setters(generate = true, strip_option)]
    key_pair_name: Option<String>,
    /// 重新初始化磁盘后，是否自动启动实例。取值范围：
    ///
    /// - true：是，自动启动实例。
    /// - false：否。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    auto_start_instance: Option<bool>,
    /// 当指定的云盘为系统盘时，重新初始化云盘后是否免费使用云安全中心服务。取值范围：
    ///          
    /// - Active：使用。该值仅支持公共镜像。  
    ///
    /// - Deactive：不使用。该值支持所有镜像。  
    ///
    /// 默认值：Deactive。
    #[setters(generate = true, strip_option)]
    security_enhancement_strategy: Option<String>,
}

impl sealed::Bound for ReInitDisk {}

impl ReInitDisk {
    pub fn new(disk_id: impl Into<String>) -> Self {
        Self {
            disk_id: disk_id.into(),
            password: None,
            key_pair_name: None,
            auto_start_instance: None,
            security_enhancement_strategy: None,
        }
    }
}
impl crate::ToFormData for ReInitDisk {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ReInitDisk {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ReInitDisk";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ReInitDiskResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.auto_start_instance {
            params.push(("AutoStartInstance".into(), (f).into()));
        }
        params.push(("DiskId".into(), (&self.disk_id).into()));

        if let Some(f) = &self.key_pair_name {
            params.push(("KeyPairName".into(), (f).into()));
        }

        if let Some(f) = &self.password {
            params.push(("Password".into(), (f).into()));
        }

        if let Some(f) = &self.security_enhancement_strategy {
            params.push(("SecurityEnhancementStrategy".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDiskDeployment {
    /// 云盘ID。
    disk_id: String,
    /// 变更云盘类型，仅在不同专属块存储集群之间迁移时有效。当前仅支持cloud_essd（ESSD云盘）。
    ///
    /// 默认值：空，表示不变配云盘。
    #[setters(generate = true, strip_option)]
    disk_category: Option<String>,
    /// 修改ESSD云盘的性能级别，仅在不同专属块存储集群之间迁移时有效。取值范围：
    /// - PL0：单盘最高随机读写IOPS 1万。
    /// - PL1：单盘最高随机读写IOPS 5万。
    ///
    /// 默认值：空，表示不修改性能级别。
    #[setters(generate = true, strip_option)]
    performance_level: Option<String>,
    /// 专属块存储集群ID。
    /// - 迁移至专属块存储集群时，必须指定`StorageClusterId`。
    /// - 迁移至公共云块存储集群时，`StorageClusterId`必须为空。
    ///
    /// 默认值：空，表示迁移至公共云块存储集群。
    #[setters(generate = true, strip_option)]
    storage_cluster_id: Option<String>,
    /// 是否只预检此次请求。取值范围：
    /// - true：发送检查请求。检查项包括是否填写了必需参数、请求格式、业务限制和ECS库存。如果检查不通过，则返回对应错误。如果检查通过，则返回错误码DryRunOperation。
    /// - false：发送正常请求，通过检查后返回2XX HTTP状态码并且直接迁移云盘。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for ModifyDiskDeployment {}

impl ModifyDiskDeployment {
    pub fn new(disk_id: impl Into<String>) -> Self {
        Self {
            disk_id: disk_id.into(),
            disk_category: None,
            performance_level: None,
            storage_cluster_id: None,
            dry_run: None,
        }
    }
}
impl crate::ToFormData for ModifyDiskDeployment {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDiskDeployment {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDiskDeployment";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDiskDeploymentResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.disk_category {
            params.push(("DiskCategory".into(), (f).into()));
        }
        params.push(("DiskId".into(), (&self.disk_id).into()));

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.performance_level {
            params.push(("PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.storage_cluster_id {
            params.push(("StorageClusterId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteDisk {
    /// 需要释放的云盘设备ID。
    disk_id: String,
}

impl sealed::Bound for DeleteDisk {}

impl DeleteDisk {
    pub fn new(disk_id: impl Into<String>) -> Self {
        Self {
            disk_id: disk_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteDisk {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteDisk {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteDisk";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteDiskResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(1);
        params.push(("DiskId".into(), (&self.disk_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct EnableDiskEncryptionByDefault {
    /// 地域ID。您可以调用[DescribeRegions](~~2679950~~)查看最新的阿里云地域列表。
    region_id: String,
}

impl sealed::Bound for EnableDiskEncryptionByDefault {}

impl EnableDiskEncryptionByDefault {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for EnableDiskEncryptionByDefault {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for EnableDiskEncryptionByDefault {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "EnableDiskEncryptionByDefault";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<EnableDiskEncryptionByDefaultResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(1);
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDiskEncryptionByDefaultStatus {
    /// 地域ID。您可以调用[DescribeRegions](~~2679950~~)查看最新的阿里云地域列表。
    region_id: String,
}

impl sealed::Bound for DescribeDiskEncryptionByDefaultStatus {}

impl DescribeDiskEncryptionByDefaultStatus {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeDiskEncryptionByDefaultStatus {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDiskEncryptionByDefaultStatus {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDiskEncryptionByDefaultStatus";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDiskEncryptionByDefaultStatusResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(1);
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDiskDefaultKMSKeyId {
    /// 地域ID。您可以调用[DescribeRegions](~~2679950~~)查看最新的阿里云地域列表。
    region_id: String,
}

impl sealed::Bound for DescribeDiskDefaultKMSKeyId {}

impl DescribeDiskDefaultKMSKeyId {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeDiskDefaultKMSKeyId {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDiskDefaultKMSKeyId {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDiskDefaultKMSKeyId";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDiskDefaultKMSKeyIdResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(1);
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDiskDefaultKMSKeyId {
    /// 地域ID。您可以调用[DescribeRegions](~~2679950~~)查看最新的阿里云地域列表。
    region_id: String,
    /// KMS密钥ID。
    kms_key_id: String,
}

impl sealed::Bound for ModifyDiskDefaultKMSKeyId {}

impl ModifyDiskDefaultKMSKeyId {
    pub fn new(region_id: impl Into<String>, kms_key_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            kms_key_id: kms_key_id.into(),
        }
    }
}
impl crate::ToFormData for ModifyDiskDefaultKMSKeyId {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDiskDefaultKMSKeyId {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDiskDefaultKMSKeyId";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDiskDefaultKMSKeyIdResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("KMSKeyId".into(), (&self.kms_key_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ResetDiskDefaultKMSKeyId {
    /// 地域ID。您可以调用[DescribeRegions](~~2679950~~)查看最新的阿里云地域列表。
    region_id: String,
}

impl sealed::Bound for ResetDiskDefaultKMSKeyId {}

impl ResetDiskDefaultKMSKeyId {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for ResetDiskDefaultKMSKeyId {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ResetDiskDefaultKMSKeyId {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ResetDiskDefaultKMSKeyId";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ResetDiskDefaultKMSKeyIdResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(1);
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DisableDiskEncryptionByDefault {
    /// 地域ID。您可以调用[DescribeRegions](~~2679950~~)查看最新的阿里云地域列表。
    region_id: String,
}

impl sealed::Bound for DisableDiskEncryptionByDefault {}

impl DisableDiskEncryptionByDefault {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for DisableDiskEncryptionByDefault {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DisableDiskEncryptionByDefault {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DisableDiskEncryptionByDefault";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DisableDiskEncryptionByDefaultResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(1);
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct OpenSnapshotService {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
}

impl sealed::Bound for OpenSnapshotService {}

impl OpenSnapshotService {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for OpenSnapshotService {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for OpenSnapshotService {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "OpenSnapshotService";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<OpenSnapshotServiceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(1);
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateSnapshot {
    /// 云盘ID。
    disk_id: String,
    /// 快照的名称。长度为2~128个字符，必须以大小写字母或中文开头，支持Unicode中letter分类下的字符（其中包括英文、中文等），ASCII数字（0-9）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    ///
    /// > 不能以http://和https:// 开头。为防止和自动快照的名称冲突，不能以`auto`开头。
    #[setters(generate = true, strip_option)]
    snapshot_name: Option<String>,
    /// 快照的描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 设置快照的保留时间，单位为天。取值范围：1~65536。保留时间到期后快照会被自动释放。
    ///
    /// 默认值：空，表示快照不会被自动释放。
    #[setters(generate = true, strip_option)]
    retention_days: Option<i32>,
    /// 快照类型。取值范围：
    ///
    /// - Standard：标准快照。
    /// - Flash：本地快照。
    ///
    /// >该参数即将被弃用。ESSD云盘标准快照已升级为[默认极速可用](~~193667~~)，您无需额外配置，且不产生额外花销。
    #[setters(generate = true, strip_option)]
    category: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 快照所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 是否开启快照极速可用功能。取值范围：
    /// - true：开启。仅ESSD云盘支持开启该功能。
    /// - false：关闭。即创建标准快照。
    ///
    /// 默认值：false。
    ///
    /// >该参数已弃用。ESSD云盘标准快照已升级为[默认极速可用](~~193667~~)，您无需额外配置，且不产生额外花销。
    #[setters(generate = true, strip_option)]
    instant_access: Option<bool>,
    /// 设置快照极速可用功能的保留时间，保留时间到期后快照将自动释放。该参数在`InstantAccess=true`时生效。单位：天。取值范围：1~65535。
    ///
    /// 默认与参数`RetentionDays`的值一致。
    ///
    /// >该参数已弃用。ESSD云盘标准快照已升级为[默认极速可用](~~193667~~)，您无需额外配置，且不产生额外花销。
    #[setters(generate = true, strip_option)]
    instant_access_retention_days: Option<i32>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<CreateSnapshotTag>>,
    /// > 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    storage_location_arn: Option<String>,
}

impl sealed::Bound for CreateSnapshot {}

impl CreateSnapshot {
    pub fn new(disk_id: impl Into<String>) -> Self {
        Self {
            disk_id: disk_id.into(),
            snapshot_name: None,
            description: None,
            retention_days: None,
            category: None,
            client_token: None,
            resource_group_id: None,
            instant_access: None,
            instant_access_retention_days: None,
            tag: None,
            storage_location_arn: None,
        }
    }
}
impl crate::ToFormData for CreateSnapshot {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateSnapshot {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateSnapshot";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateSnapshotResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(11);

        if let Some(f) = &self.category {
            params.push(("Category".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("DiskId".into(), (&self.disk_id).into()));

        if let Some(f) = &self.instant_access {
            params.push(("InstantAccess".into(), (f).into()));
        }

        if let Some(f) = &self.instant_access_retention_days {
            params.push(("InstantAccessRetentionDays".into(), (f).into()));
        }

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.retention_days {
            params.push(("RetentionDays".into(), (f).into()));
        }

        if let Some(f) = &self.snapshot_name {
            params.push(("SnapshotName".into(), (f).into()));
        }

        if let Some(f) = &self.storage_location_arn {
            params.push(("StorageLocationArn".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSnapshots {
    /// 指定的实例ID，即需要查询实例下云盘的快照信息。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 指定的云盘设备ID。
    #[setters(generate = true, strip_option)]
    disk_id: Option<String>,
    /// 快照链ID。
    #[setters(generate = true, strip_option)]
    snapshot_link_id: Option<String>,
    /// 云盘所属于的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 快照标识编码。取值可以由多个快照ID组成一个JSON数组，最多支持100个ID，ID之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    snapshot_ids: Option<String>,
    /// > 该参数即将下线，推荐您使用参数 NextToken 与 MaxResults 完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// > 该参数即将下线，推荐您使用 NextToken 与 MaxResults 完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 查询起始标志。由上一次的请求结果中获取。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 快照名称。
    #[setters(generate = true, strip_option)]
    snapshot_name: Option<String>,
    /// 快照状态。取值范围：
    ///          
    /// - progressing：正在创建的快照。
    /// - accomplished：创建成功的快照。
    /// - failed：创建失败的快照。
    /// - all（默认）：所有快照状态。
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// 快照创建类型。取值范围：
    ///          
    /// - auto：自动创建快照。
    /// - user：手动创建快照。
    /// - all（默认）：所有的快照创建类型。
    #[setters(generate = true, strip_option)]
    snapshot_type: Option<String>,
    /// 查询资源时的筛选键，取值必须为`CreationStartTime`。同时设置`Filter.1.Key`和`Filter.1.Value`可以查询在指定时间点后创建的资源信息。
    #[setters(generate = true, strip_option)]
    filter1_key: Option<String>,
    /// 查询资源时的筛选键，取值必须为`CreationEndTime`。同时设置`Filter.2.Key`和`Filter.2.Value`可以查询在指定时间点前创建的资源信息。
    #[setters(generate = true, strip_option)]
    filter2_key: Option<String>,
    /// 查询资源时的筛选值。指定该参数时必须同时指定`Filter.1.Key`参数，格式为：`yyyy-MM-ddTHH:mmZ`，采用UTC +0时区。
    #[setters(generate = true, strip_option)]
    filter1_value: Option<String>,
    /// 查询资源时的筛选值。指定该参数时必须同时指定`Filter.2.Key`参数，格式为：`yyyy-MM-ddTHH:mmZ`，采用UTC +0时区。
    #[setters(generate = true, strip_option)]
    filter2_value: Option<String>,
    /// 快照是否被用作创建镜像或云盘。取值范围：
    ///
    /// - image：使用快照创建了自定义镜像。
    /// - disk：使用快照创建了云盘。
    /// - image_disk：使用快照创建了数据盘和自定义镜像。
    /// - none：暂未使用。
    #[setters(generate = true, strip_option)]
    usage: Option<String>,
    /// 快照源云盘的云盘类型。取值范围：
    ///      
    /// - system：系统盘。
    /// - data：数据盘。
    ///
    /// > 取值不区分大小写。
    #[setters(generate = true, strip_option)]
    source_disk_type: Option<String>,
    /// 是否过滤加密快照。默认值：false 。
    #[setters(generate = true, strip_option)]
    encrypted: Option<bool>,
    /// 资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 是否只预检此次请求。
    ///
    /// - true：发送检查请求，不会查询资源状况。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，会返回错误码DryRunOperation。
    /// - false（默认）：发送正常请求，通过检查后返回2XX HTTP状态码并直接查询资源状况。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 数据盘对应的KMS密钥ID。
    #[setters(generate = true, strip_option)]
    kms_key_id: Option<String>,
    /// 快照类型。取值范围：
    /// - Standard：标准快照。
    /// - Flash：本地快照。该参数取值即将被弃用，原本地快照更替为快照极速可用功能。该参数说明如下：
    ///   - 如果您在2020年12月14日之前使用过本地快照。您可以正常使用该参数。
    ///   - 如果您在2020年12月14日之前未使用过本地快照。您不能使用该参数。
    /// - archive：归档快照。
    ///
    ///
    ///
    /// <props="china">更多信息，请参见[12月14日阿里云快照服务升级与新增计费项通知](https://help.aliyun.com/noticelist/articleid/1060755542.html)。</props>
    #[setters(generate = true, strip_option)]
    category: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<SnapshotsTag>>,
}

impl sealed::Bound for DescribeSnapshots {}

impl DescribeSnapshots {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            instance_id: None,
            disk_id: None,
            snapshot_link_id: None,
            region_id: region_id.into(),
            snapshot_ids: None,
            page_number: None,
            page_size: None,
            next_token: None,
            max_results: None,
            snapshot_name: None,
            status: None,
            snapshot_type: None,
            filter1_key: None,
            filter2_key: None,
            filter1_value: None,
            filter2_value: None,
            usage: None,
            source_disk_type: None,
            encrypted: None,
            resource_group_id: None,
            dry_run: None,
            kms_key_id: None,
            category: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeSnapshots {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSnapshots {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSnapshots";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSnapshotsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(24);

        if let Some(f) = &self.category {
            params.push(("Category".into(), (f).into()));
        }

        if let Some(f) = &self.disk_id {
            params.push(("DiskId".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.encrypted {
            params.push(("Encrypted".into(), (f).into()));
        }

        if let Some(f) = &self.filter1_key {
            params.push(("Filter.1.Key".into(), (f).into()));
        }

        if let Some(f) = &self.filter1_value {
            params.push(("Filter.1.Value".into(), (f).into()));
        }

        if let Some(f) = &self.filter2_key {
            params.push(("Filter.2.Key".into(), (f).into()));
        }

        if let Some(f) = &self.filter2_value {
            params.push(("Filter.2.Value".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.kms_key_id {
            params.push(("KMSKeyId".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.snapshot_ids {
            params.push(("SnapshotIds".into(), (f).into()));
        }

        if let Some(f) = &self.snapshot_link_id {
            params.push(("SnapshotLinkId".into(), (f).into()));
        }

        if let Some(f) = &self.snapshot_name {
            params.push(("SnapshotName".into(), (f).into()));
        }

        if let Some(f) = &self.snapshot_type {
            params.push(("SnapshotType".into(), (f).into()));
        }

        if let Some(f) = &self.source_disk_type {
            params.push(("SourceDiskType".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.usage {
            params.push(("Usage".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSnapshotsUsage {
    /// 快照所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
}

impl sealed::Bound for DescribeSnapshotsUsage {}

impl DescribeSnapshotsUsage {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeSnapshotsUsage {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSnapshotsUsage {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSnapshotsUsage";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSnapshotsUsageResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(1);
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifySnapshotAttribute {
    /// 快照ID。
    snapshot_id: String,
    /// 快照的显示名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以http://和https://开头。可以包含数字、半角冒号（:）、下划线（_）或者连字符（-）。
    ///
    /// 为防止和自动快照的名称冲突，不能以auto开头。
    #[setters(generate = true, strip_option)]
    snapshot_name: Option<String>,
    /// 快照的描述。可为空，长度为最大256 个英文或中文字符，不能以http://和https://开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 关闭快照极速可用功能。取值范围：
    ///
    /// - true：关闭快照极速可用。
    /// - false：不关闭快照极速可用。
    ///
    /// 默认值：false。
    ///
    /// >该参数已弃用。ESSD云盘标准快照已升级为[默认极速可用](~~193667~~)，您无需额外配置，且不产生额外花销。
    #[setters(generate = true, strip_option)]
    disable_instant_access: Option<bool>,
    /// 快照保留天数。设置该值时，快照保留时间会从快照**创建时间**(按照ISO 8601标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ)开始计算。取值范围：1~65536。
    ///
    /// >快照保留时间仅支持延长，不支持缩短快照已有保留时间。
    #[setters(generate = true, strip_option)]
    retention_days: Option<i32>,
}

impl sealed::Bound for ModifySnapshotAttribute {}

impl ModifySnapshotAttribute {
    pub fn new(snapshot_id: impl Into<String>) -> Self {
        Self {
            snapshot_id: snapshot_id.into(),
            snapshot_name: None,
            description: None,
            disable_instant_access: None,
            retention_days: None,
        }
    }
}
impl crate::ToFormData for ModifySnapshotAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifySnapshotAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifySnapshotAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifySnapshotAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.disable_instant_access {
            params.push(("DisableInstantAccess".into(), (f).into()));
        }

        if let Some(f) = &self.retention_days {
            params.push(("RetentionDays".into(), (f).into()));
        }
        params.push(("SnapshotId".into(), (&self.snapshot_id).into()));

        if let Some(f) = &self.snapshot_name {
            params.push(("SnapshotName".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifySnapshotCategory {
    /// 快照ID。
    snapshot_id: String,
    /// 快照类型。
    ///
    /// - Archive：归档快照
    #[setters(generate = true, strip_option)]
    category: Option<CategoryCategory>,
    /// 快照保留天数。起始时间为快照资源创建时间CreationTime。标准快照创建完成之后，必须至少已保留 14 天，才能进行归档。
    ///
    /// 归档类型快照有保留时间限制，需要在归档类型中至少保留60天。计算归档快照保留时间时，需扣除标准快照已保留时间。不足60天删除归档快照会收取60天的归档存储费用，请参见[快照计费](~~56159~~)。
    ///
    /// 取值范围[74，65536]
    ///
    /// >不填写该参数则表示永久保留。
    #[setters(generate = true, strip_option)]
    retention_days: Option<i32>,
}

impl sealed::Bound for ModifySnapshotCategory {}

impl ModifySnapshotCategory {
    pub fn new(snapshot_id: impl Into<String>) -> Self {
        Self {
            snapshot_id: snapshot_id.into(),
            category: None,
            retention_days: None,
        }
    }
}
impl crate::ToFormData for ModifySnapshotCategory {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifySnapshotCategory {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifySnapshotCategory";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifySnapshotCategoryResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.category {
            params.push(("Category".into(), (f).into()));
        }

        if let Some(f) = &self.retention_days {
            params.push(("RetentionDays".into(), (f).into()));
        }
        params.push(("SnapshotId".into(), (&self.snapshot_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CopySnapshot {
    /// 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 新快照的标签信息。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<CopySnapshotTag>>,
    /// 源快照所在的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 新快照的目标地域ID。
    destination_region_id: String,
    /// 源快照ID。
    snapshot_id: String,
    /// 新快照的名称。长度为2~128个字符，必须以大小写字母或中文开头，不能以http://和https:// 开头。支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    ///
    /// 默认值：空。
    destination_snapshot_name: String,
    /// 新快照的描述信息。长度为2~256个英文或中文字符，不能以http://或https://开头。
    ///
    /// 默认值：空。
    destination_snapshot_description: String,
    /// 新快照的保留时长，单位为天，到期后快照会被自动释放。取值范围：1~65536。
    ///
    /// 默认值：空，表示快照不会被自动释放。
    #[setters(generate = true, strip_option)]
    retention_days: Option<i32>,
    /// 是否加密云盘。取值范围：
    ///
    /// - true：是。
    /// - false：否。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    encrypted: Option<bool>,
    /// 目标地域的KMS用户主密钥。
    #[setters(generate = true, strip_option)]
    kms_key_id: Option<String>,
    /// >该参数正在邀测中，暂不支持使用。
    #[setters(generate = true, strip_option)]
    arn: Option<Vec<SnapshotArn>>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    destination_storage_location_arn: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。ClientToken只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for CopySnapshot {}

impl CopySnapshot {
    pub fn new(
        region_id: impl Into<String>,
        destination_region_id: impl Into<String>,
        snapshot_id: impl Into<String>,
        destination_snapshot_name: impl Into<String>,
        destination_snapshot_description: impl Into<String>,
    ) -> Self {
        Self {
            resource_group_id: None,
            tag: None,
            region_id: region_id.into(),
            destination_region_id: destination_region_id.into(),
            snapshot_id: snapshot_id.into(),
            destination_snapshot_name: destination_snapshot_name.into(),
            destination_snapshot_description: destination_snapshot_description.into(),
            retention_days: None,
            encrypted: None,
            kms_key_id: None,
            arn: None,
            destination_storage_location_arn: None,
            client_token: None,
        }
    }
}
impl crate::ToFormData for CopySnapshot {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CopySnapshot {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CopySnapshot";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CopySnapshotResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(13);

        if let Some(f) = &self.arn {
            crate::FlatSerialize::flat_serialize(f, "Arn", &mut params);
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push((
            "DestinationRegionId".into(),
            (&self.destination_region_id).into(),
        ));
        params.push((
            "DestinationSnapshotDescription".into(),
            (&self.destination_snapshot_description).into(),
        ));
        params.push((
            "DestinationSnapshotName".into(),
            (&self.destination_snapshot_name).into(),
        ));

        if let Some(f) = &self.destination_storage_location_arn {
            params.push(("DestinationStorageLocationArn".into(), (f).into()));
        }

        if let Some(f) = &self.encrypted {
            params.push(("Encrypted".into(), (f).into()));
        }

        if let Some(f) = &self.kms_key_id {
            params.push(("KMSKeyId".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.retention_days {
            params.push(("RetentionDays".into(), (f).into()));
        }
        params.push(("SnapshotId".into(), (&self.snapshot_id).into()));

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteSnapshot {
    /// 快照ID。
    snapshot_id: String,
    /// 是否强制删除已经被用于创建云盘的快照。取值范围：
    ///
    /// - true：强制删除。强制删除后该磁盘无法重新初始化。
    ///
    /// - false：不强制删除。
    ///
    /// 默认值：false
    #[setters(generate = true, strip_option)]
    force: Option<bool>,
}

impl sealed::Bound for DeleteSnapshot {}

impl DeleteSnapshot {
    pub fn new(snapshot_id: impl Into<String>) -> Self {
        Self {
            snapshot_id: snapshot_id.into(),
            force: None,
        }
    }
}
impl crate::ToFormData for DeleteSnapshot {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteSnapshot {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteSnapshot";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteSnapshotResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);

        if let Some(f) = &self.force {
            params.push(("Force".into(), (f).into()));
        }
        params.push(("SnapshotId".into(), (&self.snapshot_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSnapshotLinks {
    /// 云盘所属于的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 云盘ID。一次最多指定100个云盘ID。DiskIds参数取值格式为JSON数组，ID之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    disk_ids: Option<String>,
    /// 快照链ID。一次最多指定100个快照ID。SnapshotLinkIds参数取值格式为JSON数组，ID之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    snapshot_link_ids: Option<String>,
    /// 云盘状态列表的页码。起始值：1。
    ///
    /// 默认值：1 。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。取值范围：1~100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 查询凭证（Token），取值为上一次 API 调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。最大值为 100。
    /// 默认值：
    /// - 当不设置值或设置的值小于 10 时，默认值为 10。
    /// - 当设置的值大于 100 时，默认值为 100。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
}

impl sealed::Bound for DescribeSnapshotLinks {}

impl DescribeSnapshotLinks {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: None,
            disk_ids: None,
            snapshot_link_ids: None,
            page_number: None,
            page_size: None,
            next_token: None,
            max_results: None,
        }
    }
}
impl crate::ToFormData for DescribeSnapshotLinks {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSnapshotLinks {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSnapshotLinks";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSnapshotLinksResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.disk_ids {
            params.push(("DiskIds".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.snapshot_link_ids {
            params.push(("SnapshotLinkIds".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateSnapshotGroup {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 是否开启快照极速可用。取值范围：
    ///
    /// - true：开启。
    /// - false：关闭。
    ///
    /// 默认值：false。
    ///
    /// >该参数已弃用。ESSD云盘标准快照已升级为[默认极速可用](~~193667~~)，您无需额外配置，且不产生额外花销。
    #[setters(generate = true, strip_option)]
    instant_access: Option<bool>,
    /// 设置快照极速可用的使用时间。单位：天，取值范围：1~65535。
    ///
    /// 仅当`InstantAccess=true`时，该参数生效。到期后自动关闭快照极速使用功能。
    ///
    /// 默认值：空，表示和快照释放时间一致。
    ///
    /// >该参数已弃用。ESSD云盘标准快照已升级为[默认极速可用](~~193667~~)，您无需额外配置，且不产生额外花销。
    #[setters(generate = true, strip_option)]
    instant_access_retention_days: Option<i32>,
    /// 快照一致性组名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`或`https://`开头，可以包含数字、半角句号（.）、下划线（_）、短划线（-）或者半角冒号（:）。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// 描述。长度为2～256个字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。ClientToken只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// >该参数暂未开发使用。
    #[setters(generate = true, strip_option)]
    storage_location_arn: Option<String>,
    /// 实例中不需要创建快照的云盘ID。指定云盘ID后，创建的快照一致性组将不包含该云盘对应的快照。N的取值范围为1~16。
    ///
    /// 默认值：空，表示为实例中的所有云盘创建快照。
    ///
    /// > 该参数不可与`DiskId.N`同时设置。
    #[setters(generate = true, strip_option)]
    exclude_disk_id: Option<Vec<String>>,
    /// 指定创建快照一致性组的云盘ID。在同可用区内支持跨实例设置多个云盘ID。N的取值范围为1~16，即一个快照一致性组内最多支持设置16块总大小不超过32 TiB的云盘。
    ///
    /// 您需要注意：
    ///
    /// - 该参数不可与`ExcludeDiskId.N`同时设置。
    /// - 如果您设置了`InstanceId`，则该参数只能设置指定实例内已挂载的云盘，不再支持设置多个跨实例的云盘ID。
    #[setters(generate = true, strip_option)]
    disk_id: Option<Vec<String>>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<SnapshotGroupTag>>,
    /// 快照一致性组所属的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
}

impl sealed::Bound for CreateSnapshotGroup {}

impl CreateSnapshotGroup {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: None,
            instant_access: None,
            instant_access_retention_days: None,
            name: None,
            description: None,
            client_token: None,
            storage_location_arn: None,
            exclude_disk_id: None,
            disk_id: None,
            tag: None,
            resource_group_id: None,
        }
    }
}
impl crate::ToFormData for CreateSnapshotGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateSnapshotGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateSnapshotGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateSnapshotGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(12);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.disk_id {
            crate::FlatSerialize::flat_serialize(f, "DiskId", &mut params);
        }

        if let Some(f) = &self.exclude_disk_id {
            crate::FlatSerialize::flat_serialize(f, "ExcludeDiskId", &mut params);
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.instant_access {
            params.push(("InstantAccess".into(), (f).into()));
        }

        if let Some(f) = &self.instant_access_retention_days {
            params.push(("InstantAccessRetentionDays".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.storage_location_arn {
            params.push(("StorageLocationArn".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSnapshotGroups {
    /// 所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 指定的实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 快照一致性组的名称。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// 查询凭证（Token），取值为上一次API调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。
    ///
    /// 最大值为100。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 指定的快照一致性组ID。N的取值范围为1~10。
    #[setters(generate = true, strip_option)]
    snapshot_group_id: Option<Vec<String>>,
    /// 快照一致性组的状态。N的取值范围为1~3。取值如下：
    ///
    /// - progressing：创建中。
    ///
    /// - accomplished：创建成功。
    ///
    /// - failed：创建失败。
    #[setters(generate = true, strip_option)]
    status: Option<Vec<String>>,
    /// 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    additional_attributes: Option<Vec<String>>,
    /// 快照一致性组的标签键值对。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<SnapshotGroupsTag>>,
    /// 快照一致性组所属的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
}

impl sealed::Bound for DescribeSnapshotGroups {}

impl DescribeSnapshotGroups {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: None,
            name: None,
            next_token: None,
            max_results: None,
            snapshot_group_id: None,
            status: None,
            additional_attributes: None,
            tag: None,
            resource_group_id: None,
        }
    }
}
impl crate::ToFormData for DescribeSnapshotGroups {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSnapshotGroups {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSnapshotGroups";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSnapshotGroupsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.additional_attributes {
            crate::FlatSerialize::flat_serialize(f, "AdditionalAttributes", &mut params);
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.snapshot_group_id {
            crate::FlatSerialize::flat_serialize(f, "SnapshotGroupId", &mut params);
        }

        if let Some(f) = &self.status {
            crate::FlatSerialize::flat_serialize(f, "Status", &mut params);
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifySnapshotGroup {
    /// 快照一致性组所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 快照一致性组ID。您可以调用[DescribeSnapshotGroups](~~210940~~)查询快照一致性组ID。
    snapshot_group_id: String,
    /// 修改后的快照一致性组名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`和`https://`开头，可以包含数字、英文句号（.）、下划线（_）、短划线（-）或者半角冒号（:）。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// 修改后的描述。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for ModifySnapshotGroup {}

impl ModifySnapshotGroup {
    pub fn new(region_id: impl Into<String>, snapshot_group_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            snapshot_group_id: snapshot_group_id.into(),
            name: None,
            description: None,
        }
    }
}
impl crate::ToFormData for ModifySnapshotGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifySnapshotGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifySnapshotGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifySnapshotGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SnapshotGroupId".into(), (&self.snapshot_group_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteSnapshotGroup {
    /// 快照一致性组所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 快照一致性组ID。您可以调用[DescribeSnapshotGroups](~~210940~~)查询快照一致性组ID。
    snapshot_group_id: String,
}

impl sealed::Bound for DeleteSnapshotGroup {}

impl DeleteSnapshotGroup {
    pub fn new(region_id: impl Into<String>, snapshot_group_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            snapshot_group_id: snapshot_group_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteSnapshotGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteSnapshotGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteSnapshotGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteSnapshotGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SnapshotGroupId".into(), (&self.snapshot_group_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateAutoSnapshotPolicy {
    /// 自动快照策略所属的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 自动快照策略的名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以http://或https://开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    ///
    /// 默认值：空
    #[setters(generate = true, strip_option)]
    auto_snapshot_policy_name: Option<String>,
    /// 自动快照的创建时间点。使用UTC +8时间，单位为小时。取值范围：0~23，代表00:00至23:00共24个时间点，例如1表示01:00。格式说明：
    ///
    /// - 传入的参数需要保持JSON数组格式。例如，\["1"\]表示01:00创建自动快照。
    /// - 当一天内需要创建多次自动快照时，可以传入多个时间点，时间点之间用半角逗号（,）隔开，最多传入24个时间点。例如，\["1","3","5"\]表示01:00、03:00、05:00时创建自动快照。
    ///
    /// >如果云盘数据较多，单次创建自动快照的时长超过两个时间点之间的间隔，则自动跳过下一时间点。例如：您分别设置了09:00、10:00、11:00和12:00为自动快照时间点。由于云盘数据较多，09:00开始创建，10:20完成创建，实际耗时80分钟。系统会跳过时间点10:00，等到11:00继续为您创建自动快照。
    time_points: String,
    /// 自动快照的重复日期，单位为天，周期为星期。取值范围：1~7，例如1表示周一。格式说明：
    ///
    /// - 传入的参数需要保持JSON数组格式。例如，\["1"\]表示每周一重复创建自动快照。
    /// - 当一星期内需要创建多次自动快照时，可以传入多个时间点，时间点之间用半角逗号（,）隔开，最多传入7个时间点。例如，\["1","3","5"\]表示每周一、周三、周五重复创建自动快照。
    repeat_weekdays: String,
    /// 自动快照的保留时间，单位为天。取值范围：
    ///
    /// - -1：永久保存
    /// - 1~65535：指定保存天数
    ///
    /// 默认值：-1。
    retention_days: i32,
    /// 是否允许自动跨地域复制。
    ///
    /// - true：允许。
    /// - false：不允许。
    #[setters(generate = true, strip_option)]
    enable_cross_region_copy: Option<bool>,
    /// 跨地域复制快照的目标地域。目前支持设置一个目标地域。
    #[setters(generate = true, strip_option)]
    target_copy_regions: Option<String>,
    /// > 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    storage_location_arn: Option<String>,
    /// 跨地域复制快照的保留时间，单位为天。取值范围：
    ///
    /// - -1：永久保存
    /// - 1~65535：指定保存天数
    ///
    /// 默认值：-1。
    #[setters(generate = true, strip_option)]
    copied_snapshots_retention_days: Option<i32>,
    /// 自动快照策略标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<PolicyTag>>,
    /// 资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 快照异地备份加密参数对象
    #[setters(generate = true, strip_option)]
    copy_encryption_configuration: Option<PolicyCopyEncryptionConfiguration>,
}

impl sealed::Bound for CreateAutoSnapshotPolicy {}

impl CreateAutoSnapshotPolicy {
    pub fn new(
        region_id: impl Into<String>,
        time_points: impl Into<String>,
        repeat_weekdays: impl Into<String>,
        retention_days: impl Into<i32>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            auto_snapshot_policy_name: None,
            time_points: time_points.into(),
            repeat_weekdays: repeat_weekdays.into(),
            retention_days: retention_days.into(),
            enable_cross_region_copy: None,
            target_copy_regions: None,
            storage_location_arn: None,
            copied_snapshots_retention_days: None,
            tag: None,
            resource_group_id: None,
            copy_encryption_configuration: None,
        }
    }
}
impl crate::ToFormData for CreateAutoSnapshotPolicy {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateAutoSnapshotPolicy {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateAutoSnapshotPolicy";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateAutoSnapshotPolicyResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(12);

        if let Some(f) = &self.copied_snapshots_retention_days {
            params.push(("CopiedSnapshotsRetentionDays".into(), (f).into()));
        }

        if let Some(f) = &self.copy_encryption_configuration {
            crate::FlatSerialize::flat_serialize(f, "CopyEncryptionConfiguration", &mut params);
        }

        if let Some(f) = &self.enable_cross_region_copy {
            params.push(("EnableCrossRegionCopy".into(), (f).into()));
        }

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.storage_location_arn {
            params.push(("StorageLocationArn".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.target_copy_regions {
            params.push(("TargetCopyRegions".into(), (f).into()));
        }

        if let Some(f) = &self.auto_snapshot_policy_name {
            params.push(("autoSnapshotPolicyName".into(), (f).into()));
        }
        params.push(("regionId".into(), (&self.region_id).into()));
        params.push(("repeatWeekdays".into(), (&self.repeat_weekdays).into()));
        params.push(("retentionDays".into(), (&self.retention_days).into()));
        params.push(("timePoints".into(), (&self.time_points).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeAutoSnapshotPolicyEx {
    /// 要查询的自动快照策略所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 自动快照策略ID。
    #[setters(generate = true, strip_option)]
    auto_snapshot_policy_id: Option<String>,
    /// 自动快照策略的名称。
    #[setters(generate = true, strip_option)]
    auto_snapshot_policy_name: Option<String>,
    /// 自动快照策略返回结果分多页展示。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页展示返回的自动快照策略时的每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ExTag>>,
    /// 资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
}

impl sealed::Bound for DescribeAutoSnapshotPolicyEx {}

impl DescribeAutoSnapshotPolicyEx {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            auto_snapshot_policy_id: None,
            auto_snapshot_policy_name: None,
            page_number: None,
            page_size: None,
            tag: None,
            resource_group_id: None,
        }
    }
}
impl crate::ToFormData for DescribeAutoSnapshotPolicyEx {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeAutoSnapshotPolicyEx {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeAutoSnapshotPolicyEx";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeAutoSnapshotPolicyExResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.auto_snapshot_policy_id {
            params.push(("AutoSnapshotPolicyId".into(), (f).into()));
        }

        if let Some(f) = &self.auto_snapshot_policy_name {
            params.push(("AutoSnapshotPolicyName".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeAutoSnapshotPolicyAssociations {
    /// 自动快照策略所属的地域 ID。您可以调用 [DescribeRegions](https://help.aliyun.com/zh/ecs/developer-reference/api-ecs-2014-05-26-describeregions?spm=a2c4g.11186623.0.i11) 查看最新的阿里云地域列表。
    region_id: String,
    /// 自动快照策略 ID。
    /// - AutoSnapshotPolicyId 和 DiskId 只能指定一个。
    #[setters(generate = true, strip_option)]
    auto_snapshot_policy_id: Option<String>,
    /// 云盘 ID。
    /// - AutoSnapshotPolicyId 和 DiskId 只能指定一个。
    #[setters(generate = true, strip_option)]
    disk_id: Option<String>,
    /// 查询凭证（Token），取值为上一次 API 调用返回的`NextToken`参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。最大值为 100。
    ///
    /// 默认值：
    /// - 当不设置值或设置的值小于 10 时，默认值为 10。
    /// - 当设置的值大于 100 时，默认值为 100。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
}

impl sealed::Bound for DescribeAutoSnapshotPolicyAssociations {}

impl DescribeAutoSnapshotPolicyAssociations {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            auto_snapshot_policy_id: None,
            disk_id: None,
            next_token: None,
            max_results: None,
        }
    }
}
impl crate::ToFormData for DescribeAutoSnapshotPolicyAssociations {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeAutoSnapshotPolicyAssociations {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeAutoSnapshotPolicyAssociations";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeAutoSnapshotPolicyAssociationsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.auto_snapshot_policy_id {
            params.push(("AutoSnapshotPolicyId".into(), (f).into()));
        }

        if let Some(f) = &self.disk_id {
            params.push(("DiskId".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyAutoSnapshotPolicyEx {
    /// 自动快照策略所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 目标自动快照策略ID。您可以调用[DescribeAutoSnapshotPolicyEx](~~25530~~)查看您可用的自动快照策略。
    auto_snapshot_policy_id: String,
    /// 自动快照策略的名称。如果参数为空则代表不修改。
    #[setters(generate = true, strip_option)]
    auto_snapshot_policy_name: Option<String>,
    /// 自动快照的创建时间点。使用UTC +8时间，单位为小时。取值范围为0~23，代表00:00至23:00共24个时间点，如1表示01:00。
    ///
    /// 当一天内需要创建多次自动快照时，可以传入多个时间点：
    ///
    /// - 最多传入24个时间点。
    /// - 多个时间点用一个格式类似`"0", "1", … "23"`的JSON数组表示，时间点之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    time_points: Option<String>,
    /// 自动快照的重复日期，单位为天，周期为星期。取值范围为1~7，如1表示周一。
    ///
    /// 当一星期内需要创建多次自动快照时，可以传入多个时间点：
    ///
    /// - 最多传入7个时间点。
    /// - 多个时间点用一个格式类似`"1", "2", … "7"`的JSON数组表示，时间点之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    repeat_weekdays: Option<String>,
    /// 自动快照的保留时间，单位为天。取值范围：
    ///
    /// - -1：永久保存。
    /// - 1~65536：指定保存天数。
    ///
    /// 默认值为-1。
    #[setters(generate = true, strip_option)]
    retention_days: Option<i32>,
    /// 是否允许自动跨地域复制。
    ///
    /// - true：允许。
    /// - false：不允许。
    #[setters(generate = true, strip_option)]
    enable_cross_region_copy: Option<bool>,
    /// 跨地域复制快照的目标地域。目前支持设置一个目标地域。
    #[setters(generate = true, strip_option)]
    target_copy_regions: Option<String>,
    /// 跨地域复制快照的保留时间，单位为天。取值范围：
    ///
    /// - -1：永久保存。
    /// - 1~65535：指定保存天数。
    ///
    /// 默认值为-1。
    #[setters(generate = true, strip_option)]
    copied_snapshots_retention_days: Option<i32>,
    /// 快照跨地域复制加密参数对象
    #[setters(generate = true, strip_option)]
    copy_encryption_configuration: Option<ExCopyEncryptionConfiguration>,
}

impl sealed::Bound for ModifyAutoSnapshotPolicyEx {}

impl ModifyAutoSnapshotPolicyEx {
    pub fn new(region_id: impl Into<String>, auto_snapshot_policy_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            auto_snapshot_policy_id: auto_snapshot_policy_id.into(),
            auto_snapshot_policy_name: None,
            time_points: None,
            repeat_weekdays: None,
            retention_days: None,
            enable_cross_region_copy: None,
            target_copy_regions: None,
            copied_snapshots_retention_days: None,
            copy_encryption_configuration: None,
        }
    }
}
impl crate::ToFormData for ModifyAutoSnapshotPolicyEx {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyAutoSnapshotPolicyEx {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyAutoSnapshotPolicyEx";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyAutoSnapshotPolicyExResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.copied_snapshots_retention_days {
            params.push(("CopiedSnapshotsRetentionDays".into(), (f).into()));
        }

        if let Some(f) = &self.copy_encryption_configuration {
            crate::FlatSerialize::flat_serialize(f, "CopyEncryptionConfiguration", &mut params);
        }

        if let Some(f) = &self.enable_cross_region_copy {
            params.push(("EnableCrossRegionCopy".into(), (f).into()));
        }

        if let Some(f) = &self.target_copy_regions {
            params.push(("TargetCopyRegions".into(), (f).into()));
        }
        params.push((
            "autoSnapshotPolicyId".into(),
            (&self.auto_snapshot_policy_id).into(),
        ));

        if let Some(f) = &self.auto_snapshot_policy_name {
            params.push(("autoSnapshotPolicyName".into(), (f).into()));
        }
        params.push(("regionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.repeat_weekdays {
            params.push(("repeatWeekdays".into(), (f).into()));
        }

        if let Some(f) = &self.retention_days {
            params.push(("retentionDays".into(), (f).into()));
        }

        if let Some(f) = &self.time_points {
            params.push(("timePoints".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ApplyAutoSnapshotPolicy {
    /// 自动快照策略和云盘所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 目标自动快照策略ID。
    auto_snapshot_policy_id: String,
    /// 一块或多块云盘的ID。取值是JSON数组格式，云盘ID之间用半角逗号（,）隔开。
    disk_ids: String,
}

impl sealed::Bound for ApplyAutoSnapshotPolicy {}

impl ApplyAutoSnapshotPolicy {
    pub fn new(
        region_id: impl Into<String>,
        auto_snapshot_policy_id: impl Into<String>,
        disk_ids: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            auto_snapshot_policy_id: auto_snapshot_policy_id.into(),
            disk_ids: disk_ids.into(),
        }
    }
}
impl crate::ToFormData for ApplyAutoSnapshotPolicy {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ApplyAutoSnapshotPolicy {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ApplyAutoSnapshotPolicy";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ApplyAutoSnapshotPolicyResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push((
            "autoSnapshotPolicyId".into(),
            (&self.auto_snapshot_policy_id).into(),
        ));
        params.push(("diskIds".into(), (&self.disk_ids).into()));
        params.push(("regionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CancelAutoSnapshotPolicy {
    /// 自动快照策略和云盘所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 目标云盘ID。当您需要取消多块云盘的自动快照策略时，多块云盘ID用一个格式类似 "d-xxxxxxxxx", "d-yyyyyyyyy", … "d-zzzzzzzzz" 的JSON数组表示，云盘ID之间用半角逗号（,）隔开。
    disk_ids: String,
    /// 需要取消的自动快照策略 ID。
    /// - 默认值为空。如果使用默认值，您需要注意：
    ///   - 如果云盘上的自动快照策略数量是 1，则会取消这条自动快照策略。
    ///   - 如果云盘上的自动快照策略数量大于 1，则会返回`OperationDenied.TooManyAutoSnapshotPolicies`错误码，导致请求失败。建议您使用`autoSnapshotPolicyId`明确指定需要取消的自动快照策略 ID。
    #[setters(generate = true, strip_option)]
    auto_snapshot_policy_id: Option<String>,
}

impl sealed::Bound for CancelAutoSnapshotPolicy {}

impl CancelAutoSnapshotPolicy {
    pub fn new(region_id: impl Into<String>, disk_ids: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            disk_ids: disk_ids.into(),
            auto_snapshot_policy_id: None,
        }
    }
}
impl crate::ToFormData for CancelAutoSnapshotPolicy {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CancelAutoSnapshotPolicy {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CancelAutoSnapshotPolicy";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CancelAutoSnapshotPolicyResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.auto_snapshot_policy_id {
            params.push(("autoSnapshotPolicyId".into(), (f).into()));
        }
        params.push(("diskIds".into(), (&self.disk_ids).into()));
        params.push(("regionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteAutoSnapshotPolicy {
    /// 自动快照所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 自动快照策略的ID。您可以调用[DescribeAutoSnapshotPolicyEx](~~25530~~)查看您可用的自动快照策略。
    auto_snapshot_policy_id: String,
}

impl sealed::Bound for DeleteAutoSnapshotPolicy {}

impl DeleteAutoSnapshotPolicy {
    pub fn new(region_id: impl Into<String>, auto_snapshot_policy_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            auto_snapshot_policy_id: auto_snapshot_policy_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteAutoSnapshotPolicy {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteAutoSnapshotPolicy {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteAutoSnapshotPolicy";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteAutoSnapshotPolicyResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push((
            "autoSnapshotPolicyId".into(),
            (&self.auto_snapshot_policy_id).into(),
        ));
        params.push(("regionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSnapshotPackage {
    /// OSS存储包列表的页码。起始值：1
    ///
    /// 默认值：1
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。最大值：100
    ///
    /// 默认值：10
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 快照所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
}

impl sealed::Bound for DescribeSnapshotPackage {}

impl DescribeSnapshotPackage {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            page_number: None,
            page_size: None,
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeSnapshotPackage {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSnapshotPackage {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSnapshotPackage";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSnapshotPackageResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeBandwidthLimitation {
    /// 目标地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例的计费方式。更多详情，请参见[计费概览](~~25398~~)。取值范围：
    ///
    /// - PrePaid：包年包月。
    /// - PostPaid：按量付费。
    ///
    /// 默认值：PostPaid。
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 按量付费实例的抢占策略。取值范围：
    ///
    /// - NoSpot：正常按量付费实例。
    /// - SpotWithPriceLimit：设置上限价格的抢占式实例。
    /// - SpotAsPriceGo：系统自动出价，最高按量付费价格。
    ///
    /// 默认值：NoSpot。
    ///
    /// >当参数InstanceChargeType取值为PostPaid时，参数SpotStrategy才有效。
    #[setters(generate = true, strip_option)]
    spot_strategy: Option<String>,
    /// 实例规格。取值请参见[实例规格族](~~25378~~)。
    instance_type: String,
    /// 资源ID。
    ///
    /// > 当您将参数OperationType设置为Upgrade或者Downgrade时，参数ResourceId为必选参数。
    #[setters(generate = true, strip_option)]
    resource_id: Option<String>,
    /// 查询不同操作方式的公网带宽规格限制。取值范围：
    ///
    /// - Upgrade：升级公网带宽。
    /// - Downgrade：降级公网带宽。
    /// - Create：新建ECS实例。
    ///
    /// 默认值：Create。
    #[setters(generate = true, strip_option)]
    operation_type: Option<String>,
}

impl sealed::Bound for DescribeBandwidthLimitation {}

impl DescribeBandwidthLimitation {
    pub fn new(region_id: impl Into<String>, instance_type: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_charge_type: None,
            spot_strategy: None,
            instance_type: instance_type.into(),
            resource_id: None,
            operation_type: None,
        }
    }
}
impl crate::ToFormData for DescribeBandwidthLimitation {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeBandwidthLimitation {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeBandwidthLimitation";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeBandwidthLimitationResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }
        params.push(("InstanceType".into(), (&self.instance_type).into()));

        if let Some(f) = &self.operation_type {
            params.push(("OperationType".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_id {
            params.push(("ResourceId".into(), (f).into()));
        }

        if let Some(f) = &self.spot_strategy {
            params.push(("SpotStrategy".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceNetworkSpec {
    /// 待修改网络配置的实例ID。
    instance_id: String,
    /// 公网出带宽最大值，单位：Mbit/s（Megabit per second）。取值范围：
    ///
    /// - 按使用流量计费：0~100。
    ///
    /// - 按固定带宽计费：
    ///   - 包年包月实例：0~200。
    ///   - 按量付费实例：0~100。
    ///
    ///
    /// > 单实例出带宽峰值也会受到ECS实例规格的 **网络带宽基础/突发（Gbit/s）** 指标数据限制。更多信息，请参见[实例规格族](~~25378~~)。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_out: Option<i32>,
    /// 公网入带宽最大值，单位：Mbit/s（Megabit per second）。取值范围：
    ///
    /// - 当所购公网出带宽小于等于10 Mbit/s时：1~10，默认为10。
    /// - 当所购公网出带宽大于10 Mbit/s时：1~`InternetMaxBandwidthOut`的取值，默认为`InternetMaxBandwidthOut`的取值。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_in: Option<i32>,
    /// > 该参数正在邀测中，暂未开放使用。
    #[setters(generate = true, strip_option)]
    isp: Option<String>,
    /// 转换网络计费方式。取值范围：
    ///
    /// - PayByBandwidth：按固定带宽计费。
    /// - PayByTraffic：按使用流量计费。
    ///
    /// > **按使用流量计费**模式下的出入带宽峰值都是带宽上限，不作为业务承诺指标。当出现资源争抢时，带宽峰值可能会受到限制。如果您的业务需要有带宽的保障，请使用**按固定带宽计费**模式。
    ///
    #[setters(generate = true, strip_option)]
    network_charge_type: Option<String>,
    /// 是否分配公网IP地址。
    ///
    /// - true：分配。
    /// - false：不分配。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    allocate_public_ip: Option<bool>,
    /// 临时带宽升级开始时间。按照[ISO 8601](~~25696~~)标准表示，并使用UTC+0时间，格式为yyyy-MM-ddTHH:mmZ。精确到**分钟**（mm）。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
    /// 临时带宽升级结束时间。按照[ISO 8601](~~25696~~)标准表示，并使用UTC+0时间，格式为yyyy-MM-ddTHHZ。精确到**小时**（HH）。
    ///
    /// > 临时升级带宽的结束时间和开始时间的间隔必须大于或等于3小时。
    #[setters(generate = true, strip_option)]
    end_time: Option<String>,
    /// 是否自动支付。取值范围：
    ///
    /// - true：变更带宽配置后，自动扣费。当您将参数Autopay置为true时，您需要确保账户余额充足，如果账户余额不足会生成异常订单，此订单暂时不支持通过ECS控制台支付，只能作废。  
    ///
    /// <props="china">
    /// - false：变更带宽配置后，只生成订单不扣费。如果您的支付方式余额不足，可以将参数Autopay置为false，即取消自动支付，此时调用该接口会生成正常的未支付订单，此订单可登录[ECS管理控制台](https://ecs.console.aliyun.com)支付。
    ///
    /// </props>
    ///
    /// <props="intl">
    /// - false：变更带宽配置后，只生成订单不扣费。如果您的支付方式余额不足，可以将参数Autopay置为false，即取消自动支付，此时调用该接口会生成正常的未支付订单，此订单可登录[ECS管理控制台](https://ecs.console.aliyun.com)支付。
    ///
    /// </props>
    ///
    /// 默认值：true。
    #[setters(generate = true, strip_option)]
    auto_pay: Option<bool>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for ModifyInstanceNetworkSpec {}

impl ModifyInstanceNetworkSpec {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            internet_max_bandwidth_out: None,
            internet_max_bandwidth_in: None,
            isp: None,
            network_charge_type: None,
            allocate_public_ip: None,
            start_time: None,
            end_time: None,
            auto_pay: None,
            client_token: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceNetworkSpec {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceNetworkSpec {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceNetworkSpec";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceNetworkSpecResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.allocate_public_ip {
            params.push(("AllocatePublicIp".into(), (f).into()));
        }

        if let Some(f) = &self.auto_pay {
            params.push(("AutoPay".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.end_time {
            params.push(("EndTime".into(), (f).into()));
        }

        if let Some(f) = &self.isp {
            params.push(("ISP".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.internet_max_bandwidth_in {
            params.push(("InternetMaxBandwidthIn".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_out {
            params.push(("InternetMaxBandwidthOut".into(), (f).into()));
        }

        if let Some(f) = &self.network_charge_type {
            params.push(("NetworkChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AllocatePublicIpAddress {
    /// 待分配IP地址的实例ID。
    ///
    /// >该实例带宽必须大于0。
    instance_id: String,
    /// 实例的公网IP地址。如果该参数值为空，则默认由系统随机分配IP地址。
    ///
    /// >该参数只支持白名单用户指定，普通用户不支持指定IP地址。
    #[setters(generate = true, strip_option)]
    ip_address: Option<String>,
    /// 实例的VLAN ID。
    /// > 该参数即将被弃用，为提高兼容性，请尽量使用其他参数。
    #[setters(generate = true, strip_option)]
    vlan_id: Option<String>,
}

impl sealed::Bound for AllocatePublicIpAddress {}

impl AllocatePublicIpAddress {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            ip_address: None,
            vlan_id: None,
        }
    }
}
impl crate::ToFormData for AllocatePublicIpAddress {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AllocatePublicIpAddress {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AllocatePublicIpAddress";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AllocatePublicIpAddressResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.ip_address {
            params.push(("IpAddress".into(), (f).into()));
        }

        if let Some(f) = &self.vlan_id {
            params.push(("VlanId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ConvertNatPublicIpToEip {
    /// 需要转化公网IP的实例ID。
    instance_id: String,
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
}

impl sealed::Bound for ConvertNatPublicIpToEip {}

impl ConvertNatPublicIpToEip {
    pub fn new(instance_id: impl Into<String>, region_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for ConvertNatPublicIpToEip {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ConvertNatPublicIpToEip {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ConvertNatPublicIpToEip";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ConvertNatPublicIpToEipResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceVpcAttribute {
    /// 实例ID。
    ///
    /// > 调用该接口时，ECS实例的状态必须是**已停止**（`Stopped`），其他对于实例的限制条件，请认真阅读**接口说明**部分。
    instance_id: String,
    /// 交换机ID。
    ///
    /// - 传入的ID为实例的当前交换机时，表明实例不变更交换机。
    /// - 传入的ID为一台新的交换机，并且参数`VpcId`为空时，新旧交换机必须属于同一个可用区、同一个专有网络VPC。
    /// - 当参数`VpcId`不为空时，该参数传入的交换机ID必须属于VpcId，并且和原交换机属于同一个可用区。
    v_switch_id: String,
    /// 新的私网IP地址。
    ///
    /// >参数`PrivateIpAddress`依赖于`VSwitchId`，指定的IP地址必须在虚拟交换机子网网段中。
    ///
    /// 默认值：当不传该值时，从虚拟交换机子网网段中随机分配。
    #[setters(generate = true, strip_option)]
    private_ip_address: Option<String>,
    /// 目标VPC ID。
    #[setters(generate = true, strip_option)]
    vpc_id: Option<String>,
    /// 实例修改VPC后加入的安全组ID列表。当且仅当传入`VpcId`参数时，需要同时传入该参数。
    ///
    /// - 安全组所属的VPC必须与目标VPC一致。
    /// - 指定修改后实例加入的安全组列表，可以是一个或者多个。安全组个数与实例能够加入安全组的限制有关。具体限制，请参见[使用限制](~~25412#SecurityGroupQuota1~~)。
    /// - 列表内安全组类型必须一致。
    /// - 支持切换安全组的类型。
    ///           当ECS实例跨类型切换安全组时，您需要充分了解两种安全组规则的配置区别，避免影响实例网络。更多信息，请参见[安全组概述](~~25387~~)。
    #[setters(generate = true, strip_option)]
    security_group_id: Option<Vec<String>>,
}

impl sealed::Bound for ModifyInstanceVpcAttribute {}

impl ModifyInstanceVpcAttribute {
    pub fn new(instance_id: impl Into<String>, v_switch_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            v_switch_id: v_switch_id.into(),
            private_ip_address: None,
            vpc_id: None,
            security_group_id: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceVpcAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceVpcAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceVpcAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceVpcAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.private_ip_address {
            params.push(("PrivateIpAddress".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_id {
            crate::FlatSerialize::flat_serialize(f, "SecurityGroupId", &mut params);
        }
        params.push(("VSwitchId".into(), (&self.v_switch_id).into()));

        if let Some(f) = &self.vpc_id {
            params.push(("VpcId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeClassicLinkInstances {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// VPC ID。目标VPC必须已开启ClassicLink功能，详情请参见[建立ClassicLink连接](~~65413~~)。
    #[setters(generate = true, strip_option)]
    vpc_id: Option<String>,
    /// 实例ID。最多指定100台实例ID，并使用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 当前页码。起始值：1
    ///
    /// 默认值：1
    #[setters(generate = true, strip_option)]
    page_number: Option<String>,
    /// 分页查询时设置的每页行数。取值范围：1~100
    ///
    /// 默认值：10
    #[setters(generate = true, strip_option)]
    page_size: Option<String>,
}

impl sealed::Bound for DescribeClassicLinkInstances {}

impl DescribeClassicLinkInstances {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            vpc_id: None,
            instance_id: None,
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeClassicLinkInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeClassicLinkInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeClassicLinkInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeClassicLinkInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.vpc_id {
            params.push(("VpcId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AttachClassicLinkVpc {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 经典网络类型实例ID。您可以调用[DescribeInstances](~~25506~~)查看您可用的实例。
    instance_id: String,
    /// 开启ClassicLink的VPC ID。您可以调用[DescribeVpcs](~~35739~~)查看您可用的VPC。
    vpc_id: String,
}

impl sealed::Bound for AttachClassicLinkVpc {}

impl AttachClassicLinkVpc {
    pub fn new(
        region_id: impl Into<String>,
        instance_id: impl Into<String>,
        vpc_id: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
            vpc_id: vpc_id.into(),
        }
    }
}
impl crate::ToFormData for AttachClassicLinkVpc {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AttachClassicLinkVpc {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AttachClassicLinkVpc";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AttachClassicLinkVpcResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("VpcId".into(), (&self.vpc_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DetachClassicLinkVpc {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 经典网络类型实例ID。
    instance_id: String,
    /// 实例连接的VPC ID。
    vpc_id: String,
}

impl sealed::Bound for DetachClassicLinkVpc {}

impl DetachClassicLinkVpc {
    pub fn new(
        region_id: impl Into<String>,
        instance_id: impl Into<String>,
        vpc_id: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
            vpc_id: vpc_id.into(),
        }
    }
}
impl crate::ToFormData for DetachClassicLinkVpc {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DetachClassicLinkVpc {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DetachClassicLinkVpc";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DetachClassicLinkVpcResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("VpcId".into(), (&self.vpc_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateNetworkInterface {
    /// 要创建的弹性网卡所在地域的ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡的标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<InterfaceTag>>,
    /// 资源组ID。您可以调用[ListResourceGroups](~~158855~~)查询资源组信息。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 弹性网卡的交换机ID。弹性网卡的私网IP地址在交换机的IP地址段内的空闲地址中取值。
    ///
    /// ><notice>弹性网卡和待绑定的实例需要属于同一可用区，可以分属不同的交换机。</notice>
    v_switch_id: String,
    /// 弹性网卡的主私网IP地址。
    ///
    /// 指定IP必须是在所属交换机的地址段内的空闲地址，不指定则默认随机分配该交换机中的空闲地址。
    #[setters(generate = true, strip_option)]
    primary_ip_address: Option<String>,
    /// 加入一个安全组。安全组和弹性网卡必须在同一个专有网络VPC中。
    ///
    /// > 调用接口时，您必须设置`SecurityGroupId`或`SecurityGroupIds.N`其中一个，但不支持同时设置。
    #[setters(generate = true, strip_option)]
    security_group_id: Option<String>,
    /// 弹性网卡名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文等），ASCII数字（0-9）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    network_interface_name: Option<String>,
    /// 弹性网卡的描述信息。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    visible: Option<bool>,
    /// 弹性网卡类型。取值范围：
    ///
    /// - Secondary：辅助弹性网卡。
    /// - Trunk：中继网卡 (邀测中）。
    ///
    /// 默认值：Secondary。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    business_type: Option<String>,
    /// 指定私有IP地址数量，让ECS为您自动创建IP地址。取值范围：1~49。
    #[setters(generate = true, strip_option)]
    secondary_private_ip_address_count: Option<i32>,
    /// 弹性网卡队列数。取值范围：1~2048
    ///
    /// 附加弹性网卡时，该值必须少于实例规格支持单块网卡的最大队列数。实例规格的单块网卡最大队列数可以通过[DescribeInstanceTypes](~~25620~~)接口查询`MaximumQueueNumberPerEni`字段。
    ///
    /// 默认值：空。在附加时会采用实例规格的弹性网卡默认队列数，实例规格的弹性网卡默认队列数可以通过[DescribeInstanceTypes](~~25620~~)接口查询`SecondaryEniQueueNumber`字段。
    #[setters(generate = true, strip_option)]
    queue_number: Option<i32>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 弹性网卡的通讯模式。取值范围：
    ///
    /// - Standard：使用TCP通讯模式。
    /// - HighPerformance：开启ERI（Elastic RDMA Interface）接口，使用RDMA通讯模式。
    ///
    /// > 对于使用RDMA通信模式的弹性网卡，仅允许与实例规格支持ERI的实例绑定，且使用RDMA模式的弹性网卡数量不能超过该实例规格族的限制。更多信息，请参见[实例规格族](~~25378~~)，[在企业级实例上配置eRDMA](~~336853~~)<props="china">及[在GPU实例上配置eRDMA](~~2248432~~)</props>。
    ///
    /// 默认值：Standard。
    #[setters(generate = true, strip_option)]
    network_interface_traffic_mode: Option<String>,
    /// RDMA网卡队列数。
    ///
    /// 如果要为实例附加多张RDMA网卡，建议根据实例规格支持的RDMA网卡的`QueuePairNumber`上限值和规划要使用的网卡数量，手动为每张网卡指定QueuePairNumber，并确保所有网卡的QueuePairNumber总数不超过该实例规格允许的最大值。调用[DescribeInstanceTypes](~~2679699~~)查看实例规格的上限。
    ///
    /// ><notice>如果RDMA网卡未指定QueuePairNumber，则默认使用该实例规格支持的所有RDMA网卡的QueuePairNumber上限值。因此，一旦附加了一张未设置QueuePairNumber的RDMA网卡，就不能再添加更多RDMA网卡了（普通网卡不受此限制）。</notice>
    #[setters(generate = true, strip_option)]
    queue_pair_number: Option<i32>,
    /// 加入一个或多个安全组。安全组和弹性网卡必须在同一个专有网络VPC中。N的取值范围与弹性网卡能够加入安全组配额有关，更多信息，请参见[使用限制](~~25412~~)。
    ///
    /// > 调用接口时，您必须设置`SecurityGroupId`或`SecurityGroupIds.N`其中一个，但不支持同时设置。
    #[setters(generate = true, strip_option)]
    security_group_ids: Option<Vec<String>>,
    /// 从弹性网卡所属交换机的CIDR地址段内的空闲地址中选择一个或多个辅助私有IP地址。N的取值范围：0~10。
    ///
    /// > 分配辅助私有IP地址时，您不能同时指定参数`PrivateIpAddress.N`和参数`SecondaryPrivateIpAddressCount`。
    #[setters(generate = true, strip_option)]
    private_ip_address: Option<Vec<String>>,
    /// 为弹性网卡指定一个或多个IPv6地址。支持设置最多10个IPv6地址，即N的取值范围：1~10。
    ///
    /// 取值示例：Ipv6Address.1=2001:db8:1234:1a00::\*\*\*\*
    ///
    /// > 如果您需要为弹性网卡设置IPv6地址，则必须设置`Ipv6Addresses.N`或者`Ipv6AddressCount`的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv6_address: Option<Vec<String>>,
    /// 为弹性网卡指定随机生成的IPv6地址数量。取值范围：1~10。
    ///
    /// > 如果您需要为弹性网卡设置IPv6地址，则必须设置`Ipv6Addresses.N`或者`Ipv6AddressCount`的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv6_address_count: Option<i32>,
    /// 为弹性网卡指定一个或多个IPv4前缀。N的取值范围：1~10。
    /// > 如果您需要为弹性网卡设置IPv4前缀，则必须设置Ipv4Prefix.N或者Ipv4PrefixCount的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv4_prefix: Option<Vec<String>>,
    /// 为弹性网卡指定一个或多个IPv4前缀。取值范围：1~10。
    /// > 如果您需要为弹性网卡设置IPv4前缀，则必须设置Ipv4Prefix.N或者Ipv4PrefixCount的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv4_prefix_count: Option<i32>,
    /// 为弹性网卡指定一个或多个IPv6前缀。N的取值范围：1~10。
    /// > 如果您需要为弹性网卡设置IPv6前缀，则必须设置Ipv6Prefix.N或者Ipv6PrefixCount的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv6_prefix: Option<Vec<String>>,
    /// 为弹性网卡指定一个或多个IPv6前缀。取值范围：1~10。
    /// > 如果您需要为弹性网卡设置IPv6前缀，则必须设置Ipv6Prefix.N或者Ipv6PrefixCount的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv6_prefix_count: Option<i32>,
    /// 释放实例时是否保留网卡。取值范围：
    ///
    /// - true：不保留。
    ///
    /// - false：保留。
    #[setters(generate = true, strip_option)]
    delete_on_release: Option<bool>,
    /// 弹性网卡出方向队列深度。
    ///
    /// 您需要注意：
    ///
    /// - 网卡的出方向队列深度必须和入方向队列深度相等，取值范围：8192~16384，且必须为 2 的幂。
    ///
    /// - 较大的出方向队列深度可以提升出方向的吞吐量，但会占用更多的内存。
    ///
    /// > 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    tx_queue_size: Option<i32>,
    /// 弹性网卡入方向队列深度。
    ///
    /// 您需要注意：
    ///
    /// - 网卡的入方向队列深度必须和出方向队列深度相等，取值范围：8192~16384，且必须为 2 的幂。
    ///
    /// - 较大的入方向队列深度可以提升入方向的吞吐量，但会占用更多的内存。
    ///
    /// > 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    rx_queue_size: Option<i32>,
    /// 弹性网卡通讯参数集合。
    #[setters(generate = true, strip_option)]
    network_interface_traffic_config: Option<InterfaceNetworkInterfaceTrafficConfig>,
    /// 网络连接跟踪配置信息集合。
    ///
    /// 使用该参数前，请认真阅读[连接超时管理](~~2865958~~)。
    #[setters(generate = true, strip_option)]
    connection_tracking_configuration: Option<InterfaceConnectionTrackingConfiguration>,
    /// >参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    enhanced_network: Option<InterfaceEnhancedNetwork>,
    /// 是否开启源/目的检查功能。建议您打开该功能，以提高网络安全。可能值：
    ///
    /// - true：是。
    ///
    /// - false：否。
    ///
    /// 默认值：false。
    ///
    /// > 仅部分地域支持该功能。使用前，请认真阅读[源/目的检查](~~2863210~~)。
    #[setters(generate = true, strip_option)]
    source_dest_check: Option<bool>,
}

impl sealed::Bound for CreateNetworkInterface {}

impl CreateNetworkInterface {
    pub fn new(region_id: impl Into<String>, v_switch_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            tag: None,
            resource_group_id: None,
            v_switch_id: v_switch_id.into(),
            primary_ip_address: None,
            security_group_id: None,
            network_interface_name: None,
            description: None,
            visible: None,
            instance_type: None,
            business_type: None,
            secondary_private_ip_address_count: None,
            queue_number: None,
            client_token: None,
            network_interface_traffic_mode: None,
            queue_pair_number: None,
            security_group_ids: None,
            private_ip_address: None,
            ipv6_address: None,
            ipv6_address_count: None,
            ipv4_prefix: None,
            ipv4_prefix_count: None,
            ipv6_prefix: None,
            ipv6_prefix_count: None,
            delete_on_release: None,
            tx_queue_size: None,
            rx_queue_size: None,
            network_interface_traffic_config: None,
            connection_tracking_configuration: None,
            enhanced_network: None,
            source_dest_check: None,
        }
    }
}
impl crate::ToFormData for CreateNetworkInterface {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateNetworkInterface {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateNetworkInterface";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateNetworkInterfaceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(31);

        if let Some(f) = &self.business_type {
            params.push(("BusinessType".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.connection_tracking_configuration {
            crate::FlatSerialize::flat_serialize(f, "ConnectionTrackingConfiguration", &mut params);
        }

        if let Some(f) = &self.delete_on_release {
            params.push(("DeleteOnRelease".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.enhanced_network {
            crate::FlatSerialize::flat_serialize(f, "EnhancedNetwork", &mut params);
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.ipv4_prefix {
            crate::FlatSerialize::flat_serialize(f, "Ipv4Prefix", &mut params);
        }

        if let Some(f) = &self.ipv4_prefix_count {
            params.push(("Ipv4PrefixCount".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_address {
            crate::FlatSerialize::flat_serialize(f, "Ipv6Address", &mut params);
        }

        if let Some(f) = &self.ipv6_address_count {
            params.push(("Ipv6AddressCount".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_prefix {
            crate::FlatSerialize::flat_serialize(f, "Ipv6Prefix", &mut params);
        }

        if let Some(f) = &self.ipv6_prefix_count {
            params.push(("Ipv6PrefixCount".into(), (f).into()));
        }

        if let Some(f) = &self.network_interface_name {
            params.push(("NetworkInterfaceName".into(), (f).into()));
        }

        if let Some(f) = &self.network_interface_traffic_config {
            crate::FlatSerialize::flat_serialize(f, "NetworkInterfaceTrafficConfig", &mut params);
        }

        if let Some(f) = &self.network_interface_traffic_mode {
            params.push(("NetworkInterfaceTrafficMode".into(), (f).into()));
        }

        if let Some(f) = &self.primary_ip_address {
            params.push(("PrimaryIpAddress".into(), (f).into()));
        }

        if let Some(f) = &self.private_ip_address {
            crate::FlatSerialize::flat_serialize(f, "PrivateIpAddress", &mut params);
        }

        if let Some(f) = &self.queue_number {
            params.push(("QueueNumber".into(), (f).into()));
        }

        if let Some(f) = &self.queue_pair_number {
            params.push(("QueuePairNumber".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.rx_queue_size {
            params.push(("RxQueueSize".into(), (f).into()));
        }

        if let Some(f) = &self.secondary_private_ip_address_count {
            params.push(("SecondaryPrivateIpAddressCount".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_id {
            params.push(("SecurityGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_ids {
            crate::FlatSerialize::flat_serialize(f, "SecurityGroupIds", &mut params);
        }

        if let Some(f) = &self.source_dest_check {
            params.push(("SourceDestCheck".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.tx_queue_size {
            params.push(("TxQueueSize".into(), (f).into()));
        }
        params.push(("VSwitchId".into(), (&self.v_switch_id).into()));

        if let Some(f) = &self.visible {
            params.push(("Visible".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeNetworkInterfaces {
    /// 所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 标签列表
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<InterfacesTag>>,
    /// 资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 弹性网卡所属的交换机ID。
    #[setters(generate = true, strip_option)]
    v_switch_id: Option<String>,
    /// 弹性网卡所属的专有网络VPC ID。
    #[setters(generate = true, strip_option)]
    vpc_id: Option<String>,
    /// 弹性网卡主私网IPv4地址。
    #[setters(generate = true, strip_option)]
    primary_ip_address: Option<String>,
    /// 辅助网卡对应的安全组ID。
    ///
    /// - 如果您需要通过安全组ID查询辅助网卡的信息，请指定该参数。
    /// - 如果您需要通过安全组ID查询主网卡信息，请调用[DescribeInstances](~~25506~~)指定`SecurityGroupId`参数进行查询。
    #[setters(generate = true, strip_option)]
    security_group_id: Option<String>,
    /// 弹性网卡的名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    network_interface_name: Option<String>,
    /// 弹性网卡类型。取值范围：
    ///
    /// - Primary：主网卡。
    /// - Secondary：辅助网卡。
    ///
    /// 默认值：空，表示查询所有类型。
    #[setters(generate = true, strip_option, rename = "r#type")]
    r#type: Option<String>,
    /// 弹性网卡当前附加的实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 该弹性网卡的使用者是否为云产品或虚商。
    #[setters(generate = true, strip_option)]
    service_managed: Option<bool>,
    /// 弹性网卡的状态。取值范围：
    ///
    /// * Available：可用。
    /// * Attaching：附加中。
    /// * InUse：已附加。
    /// * Detaching：分离中。
    /// * Deleting：删除中。
    ///
    /// 默认值：空，表示查询所有状态。
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// > 该参数已废弃，建议您通过指定MaxResults或NextToken参数时使用分页方式查询。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// > 该参数已废弃，建议您通过指定MaxResults或NextToken参数时使用分页方式查询。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 查询凭证（Token），取值为上一次API调用返回的`NextToken`参数值。
    ///
    /// 有关本接口查看返回数据的设置方式，请参见上文接口说明。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页的最大条目数。取值范围：10~500。
    ///
    /// 默认值：
    ///
    /// - 当不设置值或设置的值小于10时，默认值为10。
    /// - 当设置的值大于500时，默认值为500。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 弹性网卡的辅助私网IPv4地址。N的取值范围：1~100。
    #[setters(generate = true, strip_option)]
    private_ip_address: Option<Vec<String>>,
    /// 弹性网卡ID。N的取值范围：1~100。
    #[setters(generate = true, strip_option)]
    network_interface_id: Option<Vec<String>>,
    /// 弹性网卡的IPv6地址。N表示可以设置多个IPv6地址，N的取值范围：1~100。
    #[setters(generate = true, strip_option)]
    ipv6_address: Option<Vec<String>>,
}

impl sealed::Bound for DescribeNetworkInterfaces {}

impl DescribeNetworkInterfaces {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            tag: None,
            resource_group_id: None,
            v_switch_id: None,
            vpc_id: None,
            primary_ip_address: None,
            security_group_id: None,
            network_interface_name: None,
            r#type: None,
            instance_id: None,
            service_managed: None,
            status: None,
            page_number: None,
            page_size: None,
            next_token: None,
            max_results: None,
            private_ip_address: None,
            network_interface_id: None,
            ipv6_address: None,
        }
    }
}
impl crate::ToFormData for DescribeNetworkInterfaces {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeNetworkInterfaces {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeNetworkInterfaces";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeNetworkInterfacesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(19);

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_address {
            crate::FlatSerialize::flat_serialize(f, "Ipv6Address", &mut params);
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.network_interface_id {
            crate::FlatSerialize::flat_serialize(f, "NetworkInterfaceId", &mut params);
        }

        if let Some(f) = &self.network_interface_name {
            params.push(("NetworkInterfaceName".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }

        if let Some(f) = &self.primary_ip_address {
            params.push(("PrimaryIpAddress".into(), (f).into()));
        }

        if let Some(f) = &self.private_ip_address {
            crate::FlatSerialize::flat_serialize(f, "PrivateIpAddress", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_id {
            params.push(("SecurityGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.service_managed {
            params.push(("ServiceManaged".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.r#type {
            params.push(("Type".into(), (f).into()));
        }

        if let Some(f) = &self.v_switch_id {
            params.push(("VSwitchId".into(), (f).into()));
        }

        if let Some(f) = &self.vpc_id {
            params.push(("VpcId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeNetworkInterfaceAttribute {
    /// 弹性网卡所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// > 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<AttributeTag>>,
    /// 弹性网卡ID。
    network_interface_id: String,
    /// 弹性网卡属性，取值范围：
    ///
    /// attachment：查询中继网卡的成员网卡的挂载信息（该参数正在邀测中，暂未开放使用）。
    ///
    /// connectionTrackingConfiguration：网络连接跟踪配置信息。
    ///
    /// 默认值：
    #[setters(generate = true, strip_option)]
    attribute: Option<String>,
}

impl sealed::Bound for DescribeNetworkInterfaceAttribute {}

impl DescribeNetworkInterfaceAttribute {
    pub fn new(region_id: impl Into<String>, network_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            tag: None,
            network_interface_id: network_interface_id.into(),
            attribute: None,
        }
    }
}
impl crate::ToFormData for DescribeNetworkInterfaceAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeNetworkInterfaceAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeNetworkInterfaceAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeNetworkInterfaceAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.attribute {
            params.push(("Attribute".into(), (f).into()));
        }
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyNetworkInterfaceAttribute {
    /// 弹性网卡所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡的名称。长度为2~128个字符，必须以大小写字母或中文开头，不能以`http://`和`https://`开头。支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    network_interface_name: Option<String>,
    /// 弹性网卡ID。
    network_interface_id: String,
    /// 网卡队列数。取值范围：1~2048。
    ///
    /// - 允许修改处于可用状态（`Available`）的网卡队列数，或者已附加（`InUse`）至实例但实例为已停止（`Stopped`）状态的网卡队列数。
    ///
    /// - 网卡队列数不能超过实例规格允许的单块网卡最大队列数，同时实例的所有网卡累加队列数不能超过实例规格允许的队列数总配额。实例规格的单块网卡最大队列数和总配额可以通过[DescribeInstanceTypes](~~25620~~)接口查询`MaximumQueueNumberPerEni`、`TotalEniQueueQuantity`字段。
    #[setters(generate = true, strip_option)]
    queue_number: Option<i32>,
    /// 弹性网卡的描述信息。长度为2~255个英文或中文字符，不能以http://和https://开头。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// SecurityGroupId列表，辅助弹性网卡最终加入的安全组，并会移出已有的安全组。
    ///
    /// - N的取值范围与每张弹性网卡能够加入的安全组数量配额有关，更多信息，请参见[使用限制](~~25412#SecurityGroupQuota~~)。
    ///
    /// - 修改安全组后很快会生效，但可能有较小的延迟。
    #[setters(generate = true, strip_option)]
    security_group_id: Option<Vec<String>>,
    /// 释放实例时是否保留网卡。取值范围：
    ///
    /// - true：不保留。
    ///
    /// - false：保留。
    #[setters(generate = true, strip_option)]
    delete_on_release: Option<bool>,
    /// 弹性网卡入方向队列深度。
    ///
    /// > 该参数正在邀测中，暂未开放使用，如有需求请工单联系加白。
    ///
    /// 您需要注意：
    ///
    /// - 仅适用于7代及以后ECS规格。
    /// - 目前仅适用于Linux镜像。
    /// - 较大的入方向队列深度可以提升入方向的吞吐量，降低丢包概率，但会占用更多的内存。
    #[setters(generate = true, strip_option)]
    rx_queue_size: Option<i32>,
    /// 弹性网卡出方向队列深度。
    ///
    /// > 该参数正在邀测中，暂未开放使用，如有需求请工单联系加白。
    ///
    /// 您需要注意：
    ///
    /// - 仅适用于7代及以后ECS规格。
    /// - 目前仅适用于Linux镜像。
    /// - 较大的出方向队列深度可以提升出方向的吞吐量，降低丢包概率，但会占用更多的内存。
    #[setters(generate = true, strip_option)]
    tx_queue_size: Option<i32>,
    /// 弹性网卡通讯参数
    #[setters(generate = true, strip_option)]
    network_interface_traffic_config: Option<AttributeNetworkInterfaceTrafficConfig>,
    /// 网络连接跟踪配置信息集合。
    ///
    /// 使用该参数前，请认真阅读[连接超时管理](~~2865958~~)。
    #[setters(generate = true, strip_option)]
    connection_tracking_configuration: Option<AttributeConnectionTrackingConfiguration>,
    /// 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    enhanced_network: Option<AttributeEnhancedNetwork>,
    /// 是否开启源/目的检查功能。建议您打开该功能，以提高网络安全。可能值：
    ///
    /// - true：是。
    ///
    /// - false：否。
    ///
    /// 默认值：false。
    ///
    /// > 仅部分地域支持该功能。使用前，请认真阅读[源/目的检查](~~2863210~~)。
    #[setters(generate = true, strip_option)]
    source_dest_check: Option<bool>,
}

impl sealed::Bound for ModifyNetworkInterfaceAttribute {}

impl ModifyNetworkInterfaceAttribute {
    pub fn new(region_id: impl Into<String>, network_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_name: None,
            network_interface_id: network_interface_id.into(),
            queue_number: None,
            description: None,
            security_group_id: None,
            delete_on_release: None,
            rx_queue_size: None,
            tx_queue_size: None,
            network_interface_traffic_config: None,
            connection_tracking_configuration: None,
            enhanced_network: None,
            source_dest_check: None,
        }
    }
}
impl crate::ToFormData for ModifyNetworkInterfaceAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyNetworkInterfaceAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyNetworkInterfaceAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyNetworkInterfaceAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(13);

        if let Some(f) = &self.connection_tracking_configuration {
            crate::FlatSerialize::flat_serialize(f, "ConnectionTrackingConfiguration", &mut params);
        }

        if let Some(f) = &self.delete_on_release {
            params.push(("DeleteOnRelease".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.enhanced_network {
            crate::FlatSerialize::flat_serialize(f, "EnhancedNetwork", &mut params);
        }
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));

        if let Some(f) = &self.network_interface_name {
            params.push(("NetworkInterfaceName".into(), (f).into()));
        }

        if let Some(f) = &self.network_interface_traffic_config {
            crate::FlatSerialize::flat_serialize(f, "NetworkInterfaceTrafficConfig", &mut params);
        }

        if let Some(f) = &self.queue_number {
            params.push(("QueueNumber".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.rx_queue_size {
            params.push(("RxQueueSize".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_id {
            crate::FlatSerialize::flat_serialize(f, "SecurityGroupId", &mut params);
        }

        if let Some(f) = &self.source_dest_check {
            params.push(("SourceDestCheck".into(), (f).into()));
        }

        if let Some(f) = &self.tx_queue_size {
            params.push(("TxQueueSize".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteNetworkInterface {
    /// 所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡的ID。
    network_interface_id: String,
}

impl sealed::Bound for DeleteNetworkInterface {}

impl DeleteNetworkInterface {
    pub fn new(region_id: impl Into<String>, network_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_id: network_interface_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteNetworkInterface {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteNetworkInterface {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteNetworkInterface";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteNetworkInterfaceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AttachNetworkInterface {
    /// 实例所在地域的ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡ID。
    network_interface_id: String,
    /// 实例ID。
    instance_id: String,
    /// 中继网卡ID。
    /// >该参数暂未上线，不支持使用。
    #[setters(generate = true, strip_option)]
    trunk_network_instance_id: Option<String>,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    wait_for_network_configuration_ready: Option<bool>,
    /// 网卡指定的物理网卡索引。
    ///
    /// >NetworkCardIndex 取值与实例规格族有关。如果实例规格不支持NetworkCard则不能指定；如果支持，取值请参见[实例规格族](~~25378~~)。
    #[setters(generate = true, strip_option)]
    network_card_index: Option<i32>,
}

impl sealed::Bound for AttachNetworkInterface {}

impl AttachNetworkInterface {
    pub fn new(
        region_id: impl Into<String>,
        network_interface_id: impl Into<String>,
        instance_id: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_id: network_interface_id.into(),
            instance_id: instance_id.into(),
            trunk_network_instance_id: None,
            wait_for_network_configuration_ready: None,
            network_card_index: None,
        }
    }
}
impl crate::ToFormData for AttachNetworkInterface {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AttachNetworkInterface {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AttachNetworkInterface";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AttachNetworkInterfaceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.network_card_index {
            params.push(("NetworkCardIndex".into(), (f).into()));
        }
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.trunk_network_instance_id {
            params.push(("TrunkNetworkInstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.wait_for_network_configuration_ready {
            params.push(("WaitForNetworkConfigurationReady".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DetachNetworkInterface {
    /// 资源所属地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡ID。
    network_interface_id: String,
    /// 实例ID。
    instance_id: String,
    /// 中继网卡ID。
    /// >该参数暂未上线，不支持使用。
    #[setters(generate = true, strip_option)]
    trunk_network_instance_id: Option<String>,
}

impl sealed::Bound for DetachNetworkInterface {}

impl DetachNetworkInterface {
    pub fn new(
        region_id: impl Into<String>,
        network_interface_id: impl Into<String>,
        instance_id: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_id: network_interface_id.into(),
            instance_id: instance_id.into(),
            trunk_network_instance_id: None,
        }
    }
}
impl crate::ToFormData for DetachNetworkInterface {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DetachNetworkInterface {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DetachNetworkInterface";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DetachNetworkInterfaceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.trunk_network_instance_id {
            params.push(("TrunkNetworkInstanceId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AssignPrivateIpAddresses {
    /// 弹性网卡所属的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡ID。
    network_interface_id: String,
    /// 指定私网IP地址数量，自动从交换机的空闲IP地址中分配IP地址。
    ///
    /// 分配辅助私网IP地址时，您不能同时指定`PrivateIpAddress.N`和`SecondaryPrivateIpAddressCount`。
    #[setters(generate = true, strip_option)]
    secondary_private_ip_address_count: Option<i32>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 从弹性网卡所属交换机的空闲IP地址中选择一个或多个辅助私网IP地址。N的取值范围：
    ///
    /// - 弹性网卡处于可用（`Available`）状态：1~32。
    /// - 弹性网卡处于已附加（`InUse`）状态：受到实例规格限制，更多信息，请参见[实例规格族](~~25378~~)。
    ///
    /// 分配辅助私网IP地址时，您不能同时指定`PrivateIpAddress.N`和`SecondaryPrivateIpAddressCount`。
    #[setters(generate = true, strip_option)]
    private_ip_address: Option<Vec<String>>,
    /// 为弹性网卡指定一个或多个IPv4前缀。N的取值范围：1~10。
    /// > 如果您需要为弹性网卡设置IPv4前缀，则必须设置Ipv4Prefix.N或者Ipv4PrefixCount的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv4_prefix: Option<Vec<String>>,
    /// 为弹性网卡指定随机生成的IPv4前缀数量。取值范围：1~10。
    /// > 如果您需要为弹性网卡设置IPv4前缀，则必须设置Ipv4Prefix.N或者Ipv4PrefixCount的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv4_prefix_count: Option<i32>,
}

impl sealed::Bound for AssignPrivateIpAddresses {}

impl AssignPrivateIpAddresses {
    pub fn new(region_id: impl Into<String>, network_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_id: network_interface_id.into(),
            secondary_private_ip_address_count: None,
            client_token: None,
            private_ip_address: None,
            ipv4_prefix: None,
            ipv4_prefix_count: None,
        }
    }
}
impl crate::ToFormData for AssignPrivateIpAddresses {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AssignPrivateIpAddresses {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AssignPrivateIpAddresses";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AssignPrivateIpAddressesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.ipv4_prefix {
            crate::FlatSerialize::flat_serialize(f, "Ipv4Prefix", &mut params);
        }

        if let Some(f) = &self.ipv4_prefix_count {
            params.push(("Ipv4PrefixCount".into(), (f).into()));
        }
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));

        if let Some(f) = &self.private_ip_address {
            crate::FlatSerialize::flat_serialize(f, "PrivateIpAddress", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.secondary_private_ip_address_count {
            params.push(("SecondaryPrivateIpAddressCount".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct UnassignPrivateIpAddresses {
    /// 资源所属地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡ID。
    network_interface_id: String,
    /// 一个或多个需要删除的辅助私有IP地址。
    #[setters(generate = true, strip_option)]
    private_ip_address: Option<Vec<String>>,
    /// 一个或多个需要删除的IPv4前缀。
    #[setters(generate = true, strip_option)]
    ipv4_prefix: Option<Vec<String>>,
}

impl sealed::Bound for UnassignPrivateIpAddresses {}

impl UnassignPrivateIpAddresses {
    pub fn new(region_id: impl Into<String>, network_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_id: network_interface_id.into(),
            private_ip_address: None,
            ipv4_prefix: None,
        }
    }
}
impl crate::ToFormData for UnassignPrivateIpAddresses {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for UnassignPrivateIpAddresses {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "UnassignPrivateIpAddresses";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<UnassignPrivateIpAddressesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.ipv4_prefix {
            crate::FlatSerialize::flat_serialize(f, "Ipv4Prefix", &mut params);
        }
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));

        if let Some(f) = &self.private_ip_address {
            crate::FlatSerialize::flat_serialize(f, "PrivateIpAddress", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AssignIpv6Addresses {
    /// 弹性网卡所在地域的ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡ID。
    network_interface_id: String,
    /// 为弹性网卡指定随机生成的IPv6地址数量。取值范围：1~10。
    ///
    /// > 调用该接口时，您必须设置`Ipv6Addresses.N`参数或者`Ipv6AddressCount`参数的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv6_address_count: Option<i32>,
    /// 为弹性网卡指定一个或多个IPv6地址。支持设置最多10个IPv6地址，即N的取值范围：1~10。
    ///
    /// 取值示例：Ipv6Address.1=2001:db8:1234:1a00::\*\*\*\*
    ///
    /// > 调用该接口时，您必须设置`Ipv6Addresses.N`参数或者`Ipv6AddressCount`参数的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv6_address: Option<Vec<String>>,
    /// 为弹性网卡指定一个或多个IPv6前缀。N的取值范围：1~10。
    /// > 如果您需要为弹性网卡设置IPv6前缀，则必须设置Ipv6Prefix.N或者Ipv6PrefixCount的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv6_prefix: Option<Vec<String>>,
    /// 为弹性网卡指定一个或多个IPv6前缀。取值范围：1~10。
    /// > 如果您需要为弹性网卡设置IPv6前缀，则必须设置Ipv6Prefix.N或者Ipv6PrefixCount的其中一个，但不能同时设置这两个参数。
    #[setters(generate = true, strip_option)]
    ipv6_prefix_count: Option<i32>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for AssignIpv6Addresses {}

impl AssignIpv6Addresses {
    pub fn new(region_id: impl Into<String>, network_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_id: network_interface_id.into(),
            ipv6_address_count: None,
            ipv6_address: None,
            ipv6_prefix: None,
            ipv6_prefix_count: None,
            client_token: None,
        }
    }
}
impl crate::ToFormData for AssignIpv6Addresses {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AssignIpv6Addresses {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AssignIpv6Addresses";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AssignIpv6AddressesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_address {
            crate::FlatSerialize::flat_serialize(f, "Ipv6Address", &mut params);
        }

        if let Some(f) = &self.ipv6_address_count {
            params.push(("Ipv6AddressCount".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_prefix {
            crate::FlatSerialize::flat_serialize(f, "Ipv6Prefix", &mut params);
        }

        if let Some(f) = &self.ipv6_prefix_count {
            params.push(("Ipv6PrefixCount".into(), (f).into()));
        }
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct UnassignIpv6Addresses {
    /// 弹性网卡所在地域的ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡ID。
    network_interface_id: String,
    /// 一个或多个需要删除的IPv6地址。N的取值范围为1~10。
    #[setters(generate = true, strip_option)]
    ipv6_address: Option<Vec<String>>,
    /// 一个或多个需要回收的IPv6前缀。N的取值范围为1~10。
    #[setters(generate = true, strip_option)]
    ipv6_prefix: Option<Vec<String>>,
}

impl sealed::Bound for UnassignIpv6Addresses {}

impl UnassignIpv6Addresses {
    pub fn new(region_id: impl Into<String>, network_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_id: network_interface_id.into(),
            ipv6_address: None,
            ipv6_prefix: None,
        }
    }
}
impl crate::ToFormData for UnassignIpv6Addresses {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for UnassignIpv6Addresses {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "UnassignIpv6Addresses";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<UnassignIpv6AddressesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.ipv6_address {
            crate::FlatSerialize::flat_serialize(f, "Ipv6Address", &mut params);
        }

        if let Some(f) = &self.ipv6_prefix {
            crate::FlatSerialize::flat_serialize(f, "Ipv6Prefix", &mut params);
        }
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateNetworkInterfacePermission {
    /// 弹性网卡权限的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 阿里云合作伙伴（认证ISV）账号ID或者个人用户ID。
    account_id: i64,
    /// 弹性网卡ID。
    network_interface_id: String,
    /// 弹性网卡权限动作。当前仅支持InstanceAttach。
    ///
    /// InstanceAttach：允许授权的用户将您的弹性网卡挂载到对方的ECS实例上。ECS实例必须和弹性网卡在同一个可用区中。
    permission: String,
}

impl sealed::Bound for CreateNetworkInterfacePermission {}

impl CreateNetworkInterfacePermission {
    pub fn new(
        region_id: impl Into<String>,
        account_id: impl Into<i64>,
        network_interface_id: impl Into<String>,
        permission: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            account_id: account_id.into(),
            network_interface_id: network_interface_id.into(),
            permission: permission.into(),
        }
    }
}
impl crate::ToFormData for CreateNetworkInterfacePermission {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateNetworkInterfacePermission {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateNetworkInterfacePermission";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateNetworkInterfacePermissionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("AccountId".into(), (&self.account_id).into()));
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));
        params.push(("Permission".into(), (&self.permission).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeNetworkInterfacePermissions {
    /// 弹性网卡权限的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡ID。您必须指定`NetworkInterfaceId`或`NetworkInterfacePermissionId.N`确定查询范围。
    #[setters(generate = true, strip_option)]
    network_interface_id: Option<String>,
    /// 弹性网卡权限列表的页码。
    ///
    /// 起始值：1
    ///
    /// 默认值：1
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。
    ///
    /// 最大值：100
    ///
    /// 默认值：10
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 弹性网卡权限ID列表。列表元素数量：1~100。
    #[setters(generate = true, strip_option)]
    network_interface_permission_id: Option<Vec<String>>,
}

impl sealed::Bound for DescribeNetworkInterfacePermissions {}

impl DescribeNetworkInterfacePermissions {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_id: None,
            page_number: None,
            page_size: None,
            network_interface_permission_id: None,
        }
    }
}
impl crate::ToFormData for DescribeNetworkInterfacePermissions {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeNetworkInterfacePermissions {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeNetworkInterfacePermissions";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeNetworkInterfacePermissionsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.network_interface_id {
            params.push(("NetworkInterfaceId".into(), (f).into()));
        }

        if let Some(f) = &self.network_interface_permission_id {
            crate::FlatSerialize::flat_serialize(f, "NetworkInterfacePermissionId", &mut params);
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreatePrefixList {
    /// 地域ID。
    region_id: String,
    /// 前缀列表支持的最大条目容量。取值范围：1~200。
    max_entries: i32,
    /// 前缀列表的地址族。取值范围：
    ///
    /// - IPv4。
    /// - IPv6。
    address_family: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。`ClientToken`只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 前缀列表的名称。长度为2~128个字符，必须以大小字母或中文开头，不能以`http://`、`https://`、`com.aliyun`和`com.alibabacloud`开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    prefix_list_name: String,
    /// 前缀列表的描述信息。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 前缀列表条目信息。
    #[setters(generate = true, strip_option)]
    entry: Option<Vec<PrefixListEntry>>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<PrefixListTag>>,
    /// 前缀列表所属的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
}

impl sealed::Bound for CreatePrefixList {}

impl CreatePrefixList {
    pub fn new(
        region_id: impl Into<String>,
        max_entries: impl Into<i32>,
        address_family: impl Into<String>,
        prefix_list_name: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            max_entries: max_entries.into(),
            address_family: address_family.into(),
            client_token: None,
            prefix_list_name: prefix_list_name.into(),
            description: None,
            entry: None,
            tag: None,
            resource_group_id: None,
        }
    }
}
impl crate::ToFormData for CreatePrefixList {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreatePrefixList {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreatePrefixList";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreatePrefixListResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);
        params.push(("AddressFamily".into(), (&self.address_family).into()));

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.entry {
            crate::FlatSerialize::flat_serialize(f, "Entry", &mut params);
        }
        params.push(("MaxEntries".into(), (&self.max_entries).into()));
        params.push(("PrefixListName".into(), (&self.prefix_list_name).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribePrefixLists {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 前缀列表的名称。
    #[setters(generate = true, strip_option)]
    prefix_list_name: Option<String>,
    /// 查询凭证（Token）。取值为上一次调用该接口返回的`NextToken`参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 前缀列表的地址族。取值范围：
    ///
    /// - IPv4。
    /// - IPv6。
    ///
    /// 默认值：空，查询所有前缀列表信息。
    #[setters(generate = true, strip_option)]
    address_family: Option<String>,
    /// 前缀列表ID。N的取值范围：0~100。
    #[setters(generate = true, strip_option)]
    prefix_list_id: Option<Vec<String>>,
    /// 前缀列表所属的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<PrefixListsTag>>,
}

impl sealed::Bound for DescribePrefixLists {}

impl DescribePrefixLists {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            prefix_list_name: None,
            next_token: None,
            max_results: None,
            address_family: None,
            prefix_list_id: None,
            resource_group_id: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribePrefixLists {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribePrefixLists {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribePrefixLists";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribePrefixListsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.address_family {
            params.push(("AddressFamily".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.prefix_list_id {
            crate::FlatSerialize::flat_serialize(f, "PrefixListId", &mut params);
        }

        if let Some(f) = &self.prefix_list_name {
            params.push(("PrefixListName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribePrefixListAttributes {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 前缀列表ID。
    prefix_list_id: String,
}

impl sealed::Bound for DescribePrefixListAttributes {}

impl DescribePrefixListAttributes {
    pub fn new(region_id: impl Into<String>, prefix_list_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            prefix_list_id: prefix_list_id.into(),
        }
    }
}
impl crate::ToFormData for DescribePrefixListAttributes {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribePrefixListAttributes {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribePrefixListAttributes";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribePrefixListAttributesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("PrefixListId".into(), (&self.prefix_list_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribePrefixListAssociations {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 前缀列表ID。
    prefix_list_id: String,
    /// 查询凭证（Token）。取值为上一次调用该接口返回的`NextToken`参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
}

impl sealed::Bound for DescribePrefixListAssociations {}

impl DescribePrefixListAssociations {
    pub fn new(region_id: impl Into<String>, prefix_list_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            prefix_list_id: prefix_list_id.into(),
            next_token: None,
            max_results: None,
        }
    }
}
impl crate::ToFormData for DescribePrefixListAssociations {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribePrefixListAssociations {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribePrefixListAssociations";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribePrefixListAssociationsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push(("PrefixListId".into(), (&self.prefix_list_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyPrefixList {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 前缀列表ID。
    prefix_list_id: String,
    /// 前缀列表的名称。长度为2~128个字符，必须以大小写字母或中文开头，不能以`http://`、`https://`、`com.aliyun`和`com.alibabacloud`开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    prefix_list_name: Option<String>,
    /// 前缀列表的描述信息。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 添加的前缀列表信息。
    #[setters(generate = true, strip_option)]
    add_entry: Option<Vec<PrefixListAddEntry>>,
    /// 删除的前缀列表信息。
    #[setters(generate = true, strip_option)]
    remove_entry: Option<Vec<PrefixListRemoveEntry>>,
}

impl sealed::Bound for ModifyPrefixList {}

impl ModifyPrefixList {
    pub fn new(region_id: impl Into<String>, prefix_list_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            prefix_list_id: prefix_list_id.into(),
            prefix_list_name: None,
            description: None,
            add_entry: None,
            remove_entry: None,
        }
    }
}
impl crate::ToFormData for ModifyPrefixList {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyPrefixList {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyPrefixList";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyPrefixListResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.add_entry {
            crate::FlatSerialize::flat_serialize(f, "AddEntry", &mut params);
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("PrefixListId".into(), (&self.prefix_list_id).into()));

        if let Some(f) = &self.prefix_list_name {
            params.push(("PrefixListName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.remove_entry {
            crate::FlatSerialize::flat_serialize(f, "RemoveEntry", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeletePrefixList {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 前缀列表ID。
    prefix_list_id: String,
}

impl sealed::Bound for DeletePrefixList {}

impl DeletePrefixList {
    pub fn new(region_id: impl Into<String>, prefix_list_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            prefix_list_id: prefix_list_id.into(),
        }
    }
}
impl crate::ToFormData for DeletePrefixList {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeletePrefixList {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeletePrefixList";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeletePrefixListResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("PrefixListId".into(), (&self.prefix_list_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreatePortRangeList {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 端口列表支持的最大条目容量，创建后不可更改。取值范围：1~2000。
    ///
    /// ><notice>端口列表关联资源（例如安全组）计算规则配额时，将使用最大条目容量计算，而非实际条目数，请合理设置。></notice>
    max_entries: i32,
    /// 端口列表的名称。长度为 2~128 个字符，必须以大小字母或中文开头，不能以http://、https://、com.aliyun和com.alibabacloud开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    port_range_list_name: String,
    /// 端口列表的描述信息。长度为 2~256 个英文或中文字符，不能以http://和https://开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 端口列表条目数组。
    #[setters(generate = true, strip_option)]
    entry: Option<Vec<RangeListEntry>>,
    /// 端口列表所在的企业资源组 ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 端口列表绑定的标签数组。数组长度：0~20
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<RangeListTag>>,
}

impl sealed::Bound for CreatePortRangeList {}

impl CreatePortRangeList {
    pub fn new(
        region_id: impl Into<String>,
        max_entries: impl Into<i32>,
        port_range_list_name: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            max_entries: max_entries.into(),
            port_range_list_name: port_range_list_name.into(),
            description: None,
            entry: None,
            resource_group_id: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for CreatePortRangeList {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreatePortRangeList {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreatePortRangeList";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreatePortRangeListResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.entry {
            crate::FlatSerialize::flat_serialize(f, "Entry", &mut params);
        }
        params.push(("MaxEntries".into(), (&self.max_entries).into()));
        params.push((
            "PortRangeListName".into(),
            (&self.port_range_list_name).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribePortRangeLists {
    /// 地域ID。您可以调用[DescribeRegions](~~2679950~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 查询凭证（Token）。取值为上一次调用该接口返回的NextToken参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。
    ///
    /// - 最大值：100。
    ///
    /// - 默认值：10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 端口列表的名称。长度为 2~128 个字符，必须以大小字母或中文开头，不能以http://、https://、com.aliyun和com.alibabacloud开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    port_range_list_name: Option<String>,
    /// 端口列表 ID。N 的取值范围：0~100。
    #[setters(generate = true, strip_option)]
    port_range_list_id: Option<Vec<String>>,
    /// 资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。您可以调用[ListResourceGroups](~~2716558~~)查询资源组列表。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 端口列表绑定的标签数组。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<RangeListsTag>>,
}

impl sealed::Bound for DescribePortRangeLists {}

impl DescribePortRangeLists {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            next_token: None,
            max_results: None,
            port_range_list_name: None,
            port_range_list_id: None,
            resource_group_id: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribePortRangeLists {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribePortRangeLists {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribePortRangeLists";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribePortRangeListsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.port_range_list_id {
            crate::FlatSerialize::flat_serialize(f, "PortRangeListId", &mut params);
        }

        if let Some(f) = &self.port_range_list_name {
            params.push(("PortRangeListName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribePortRangeListEntries {
    /// 端口列表所在的地域ID。您可以调用[DescribeRegions](~~2679950~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 端口列表 ID。
    port_range_list_id: String,
}

impl sealed::Bound for DescribePortRangeListEntries {}

impl DescribePortRangeListEntries {
    pub fn new(region_id: impl Into<String>, port_range_list_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            port_range_list_id: port_range_list_id.into(),
        }
    }
}
impl crate::ToFormData for DescribePortRangeListEntries {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribePortRangeListEntries {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribePortRangeListEntries";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribePortRangeListEntriesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("PortRangeListId".into(), (&self.port_range_list_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribePortRangeListAssociations {
    /// 端口列表所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 端口列表 ID。
    port_range_list_id: String,
    /// 查询凭证（Token），取值为上一次调用该接口返回的`NextToken`参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
}

impl sealed::Bound for DescribePortRangeListAssociations {}

impl DescribePortRangeListAssociations {
    pub fn new(region_id: impl Into<String>, port_range_list_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            port_range_list_id: port_range_list_id.into(),
            next_token: None,
            max_results: None,
        }
    }
}
impl crate::ToFormData for DescribePortRangeListAssociations {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribePortRangeListAssociations {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribePortRangeListAssociations";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribePortRangeListAssociationsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push(("PortRangeListId".into(), (&self.port_range_list_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyPortRangeList {
    /// 端口列表所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 待修改的端口列表 ID。
    port_range_list_id: String,
    /// 端口列表的名称。长度为 2~128 个字符，必须以大小字母或中文开头，不能以http://、https://、com.aliyun和com.alibabacloud开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    port_range_list_name: Option<String>,
    /// 端口列表的描述信息。长度为 2~256 个英文或中文字符，不能以http://和https://开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 增加或修改的端口列表条目数组。
    #[setters(generate = true, strip_option)]
    add_entry: Option<Vec<RangeListAddEntry>>,
    /// 删除的端口列表条目数组。
    #[setters(generate = true, strip_option)]
    remove_entry: Option<Vec<RangeListRemoveEntry>>,
}

impl sealed::Bound for ModifyPortRangeList {}

impl ModifyPortRangeList {
    pub fn new(region_id: impl Into<String>, port_range_list_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            port_range_list_id: port_range_list_id.into(),
            port_range_list_name: None,
            description: None,
            add_entry: None,
            remove_entry: None,
        }
    }
}
impl crate::ToFormData for ModifyPortRangeList {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyPortRangeList {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyPortRangeList";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyPortRangeListResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.add_entry {
            crate::FlatSerialize::flat_serialize(f, "AddEntry", &mut params);
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("PortRangeListId".into(), (&self.port_range_list_id).into()));

        if let Some(f) = &self.port_range_list_name {
            params.push(("PortRangeListName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.remove_entry {
            crate::FlatSerialize::flat_serialize(f, "RemoveEntry", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeletePortRangeList {
    /// 端口列表所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 端口列表 ID。
    ///
    /// >如果当前端口列表已关联其他资源，则无法删除，需解除关联后删除。
    port_range_list_id: String,
}

impl sealed::Bound for DeletePortRangeList {}

impl DeletePortRangeList {
    pub fn new(region_id: impl Into<String>, port_range_list_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            port_range_list_id: port_range_list_id.into(),
        }
    }
}
impl crate::ToFormData for DeletePortRangeList {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeletePortRangeList {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeletePortRangeList";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeletePortRangeListResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("PortRangeListId".into(), (&self.port_range_list_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateSecurityGroup {
    /// 安全组所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 安全组描述信息。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 安全组名称。长度为2~128个字符，必须以大小写字母或中文开头，不能以`http://`和`https://`开头。支持Unicode中letter分类下的字符（其中包括英文、中文等）和数字。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    security_group_name: Option<String>,
    /// 安全组所属VPC ID。
    ///
    /// >若指定的地域支持经典网络，则允许不指定VpcId，来创建经典网络的安全组；若指定的地域不支持经典网络，则必须指定VpcId，创建专有网络的安全组。
    #[setters(generate = true, strip_option)]
    vpc_id: Option<String>,
    /// 安全组类型，分为普通安全组与企业安全组。取值范围：
    ///
    /// - normal：普通安全组。
    /// - enterprise：企业安全组。更多详情，请参见[企业安全组概述](~~120621~~)。
    ///
    /// 默认值：normal。
    #[setters(generate = true, strip_option)]
    security_group_type: Option<String>,
    /// 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    service_managed: Option<bool>,
    /// 安全组所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 安全组绑定的标签数组。数组长度：0~20。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<SecurityGroupTag>>,
}

impl sealed::Bound for CreateSecurityGroup {}

impl CreateSecurityGroup {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            description: None,
            client_token: None,
            security_group_name: None,
            vpc_id: None,
            security_group_type: None,
            service_managed: None,
            resource_group_id: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for CreateSecurityGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateSecurityGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateSecurityGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateSecurityGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_name {
            params.push(("SecurityGroupName".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_type {
            params.push(("SecurityGroupType".into(), (f).into()));
        }

        if let Some(f) = &self.service_managed {
            params.push(("ServiceManaged".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.vpc_id {
            params.push(("VpcId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSecurityGroups {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 安全组ID列表。一次最多支持100个安全组ID，ID之间用半角逗号（,）隔开，格式为JSON数组。
    #[setters(generate = true, strip_option)]
    security_group_ids: Option<String>,
    /// 安全组所在的专有网络ID。
    #[setters(generate = true, strip_option)]
    vpc_id: Option<String>,
    /// 安全组类型。取值范围：
    /// - normal：普通安全组。
    /// - enterprise：企业安全组。
    ///
    /// > 当不为该参数传值时，表示查询所有类型的安全组。
    #[setters(generate = true, strip_option)]
    security_group_type: Option<String>,
    /// 查询凭证（Token）。取值为上一次调用该接口返回的NextToken参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页的最大条目数。一旦设置该参数，即表示使用`MaxResults`与`NextToken`组合参数的查询方式。
    ///
    /// 最大值为100。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 安全组的网络类型。取值范围：
    ///
    /// - vpc：专有网络。
    /// - classic：经典网络。
    #[setters(generate = true, strip_option)]
    network_type: Option<String>,
    /// 安全组名称。
    #[setters(generate = true, strip_option)]
    security_group_name: Option<String>,
    /// 是否查询安全组的容量信息。传True时，返回值中的`EcsCount`和`AvailableInstanceAmount`有效。
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    is_query_ecs_count: Option<bool>,
    /// 安全组所在的企业资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。您可以调用[ListResourceGroups](~~158855~~)查询资源组列表。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<SecurityGroupsTag>>,
    /// 是否只预检此次请求。取值范围：
    ///          
    /// - true：发送检查请求，不会查询资源状况。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，会返回错误码DryRunOperation。
    /// - false：发送正常请求，通过检查后返回2XX HTTP状态码并直接查询资源状况。
    ///
    /// 默认值为false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 安全组ID。
    #[setters(generate = true, strip_option)]
    security_group_id: Option<String>,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    fuzzy_query: Option<bool>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 是否为托管安全组。取值范围：
    ///
    /// - true：是托管安全组。
    /// - false：不是托管安全组。
    #[setters(generate = true, strip_option)]
    service_managed: Option<bool>,
}

impl sealed::Bound for DescribeSecurityGroups {}

impl DescribeSecurityGroups {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            security_group_ids: None,
            vpc_id: None,
            security_group_type: None,
            next_token: None,
            max_results: None,
            network_type: None,
            security_group_name: None,
            is_query_ecs_count: None,
            resource_group_id: None,
            tag: None,
            dry_run: None,
            security_group_id: None,
            fuzzy_query: None,
            page_number: None,
            page_size: None,
            service_managed: None,
        }
    }
}
impl crate::ToFormData for DescribeSecurityGroups {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSecurityGroups {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSecurityGroups";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSecurityGroupsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(17);

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.fuzzy_query {
            params.push(("FuzzyQuery".into(), (f).into()));
        }

        if let Some(f) = &self.is_query_ecs_count {
            params.push(("IsQueryEcsCount".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.network_type {
            params.push(("NetworkType".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_id {
            params.push(("SecurityGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_ids {
            params.push(("SecurityGroupIds".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_name {
            params.push(("SecurityGroupName".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_type {
            params.push(("SecurityGroupType".into(), (f).into()));
        }

        if let Some(f) = &self.service_managed {
            params.push(("ServiceManaged".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.vpc_id {
            params.push(("VpcId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSecurityGroupAttribute {
    /// 安全组ID。
    security_group_id: String,
    /// 安全组所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 安全组规则的网卡类型。
    ///
    /// - 经典网络类型安全组的取值范围：
    ///     - internet（默认）：公网。
    ///     - intranet：内网。
    ///     > 单次调用只能查询一种网卡类型的安全组规则，查询全部类型请分两次调用。
    /// - 专有网络类型安全组的取值只能为：intranet（默认），即内网。
    ///     > 如果传入internet或空值，则会默认转化为intranet。
    #[setters(generate = true, strip_option)]
    nic_type: Option<String>,
    /// 安全组规则授权方向。取值范围：
    ///          
    /// - egress：安全组出方向。
    /// - ingress：安全组入方向。
    /// - all：不区分方向。
    ///
    /// 默认值：all。
    #[setters(generate = true, strip_option)]
    direction: Option<String>,
    /// 查询凭证（Token）。取值为上一次调用该接口返回的 NextToken 参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页的最大条目数。
    ///
    /// - 最小值：10。
    /// - 最大值：1000。
    ///
    /// 默认值为 500。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 安全组属性，取值范围：
    ///
    /// - snapshotPolicyIds：查询安全组关联的快照策略信息。
    #[setters(generate = true, strip_option)]
    attribute: Option<String>,
}

impl sealed::Bound for DescribeSecurityGroupAttribute {}

impl DescribeSecurityGroupAttribute {
    pub fn new(security_group_id: impl Into<String>, region_id: impl Into<String>) -> Self {
        Self {
            security_group_id: security_group_id.into(),
            region_id: region_id.into(),
            nic_type: None,
            direction: None,
            next_token: None,
            max_results: None,
            attribute: None,
        }
    }
}
impl crate::ToFormData for DescribeSecurityGroupAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSecurityGroupAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSecurityGroupAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSecurityGroupAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.attribute {
            params.push(("Attribute".into(), (f).into()));
        }

        if let Some(f) = &self.direction {
            params.push(("Direction".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.nic_type {
            params.push(("NicType".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifySecurityGroupPolicy {
    /// 安全组的ID。
    security_group_id: String,
    /// 安全组所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 安全组内的ECS实例之间的内网连通策略。取值范围：
    ///
    /// - Accept：互通。
    /// - Drop：隔离。
    ///
    /// >取值不区分大小写。
    inner_access_policy: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for ModifySecurityGroupPolicy {}

impl ModifySecurityGroupPolicy {
    pub fn new(
        security_group_id: impl Into<String>,
        region_id: impl Into<String>,
        inner_access_policy: impl Into<String>,
    ) -> Self {
        Self {
            security_group_id: security_group_id.into(),
            region_id: region_id.into(),
            inner_access_policy: inner_access_policy.into(),
            client_token: None,
        }
    }
}
impl crate::ToFormData for ModifySecurityGroupPolicy {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifySecurityGroupPolicy {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifySecurityGroupPolicy";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifySecurityGroupPolicyResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push((
            "InnerAccessPolicy".into(),
            (&self.inner_access_policy).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifySecurityGroupAttribute {
    /// 安全组ID。
    security_group_id: String,
    /// 安全组描述信息。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    ///
    /// 默认值：空，不会进行修改。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 安全组名称。长度为2~128个字符，必须以大小写字母或中文开头，不能以`http://`和`https://`开头。支持Unicode中letter分类下的字符（其中包括英文、中文等）和数字。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    ///
    /// 默认值：空，不会进行修改。
    #[setters(generate = true, strip_option)]
    security_group_name: Option<String>,
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
}

impl sealed::Bound for ModifySecurityGroupAttribute {}

impl ModifySecurityGroupAttribute {
    pub fn new(security_group_id: impl Into<String>, region_id: impl Into<String>) -> Self {
        Self {
            security_group_id: security_group_id.into(),
            description: None,
            security_group_name: None,
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for ModifySecurityGroupAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifySecurityGroupAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifySecurityGroupAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifySecurityGroupAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        if let Some(f) = &self.security_group_name {
            params.push(("SecurityGroupName".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteSecurityGroup {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 安全组ID。您可以调用[DescribeSecurityGroups](~~25556~~)查看安全组ID。
    security_group_id: String,
}

impl sealed::Bound for DeleteSecurityGroup {}

impl DeleteSecurityGroup {
    pub fn new(region_id: impl Into<String>, security_group_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            security_group_id: security_group_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteSecurityGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteSecurityGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteSecurityGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteSecurityGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AuthorizeSecurityGroup {
    /// 安全组所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 安全组ID。
    security_group_id: String,
    /// 安全组规则数组。数组长度：1~100。
    #[setters(generate = true, strip_option)]
    permissions: Option<Vec<AuthorizeSecurityGroupPermission>>,
    /// 已废弃。请使用`Permissions.N.Policy`来设置访问权限。
    #[setters(generate = true, strip_option)]
    policy: Option<String>,
    /// 已废弃。请使用`Permissions.N.Priority`来指定安全组规则优先级。
    #[setters(generate = true, strip_option)]
    priority: Option<String>,
    /// 已废弃。请使用`Permissions.N.IpProtocol`来指定协议类型。
    #[setters(generate = true, strip_option)]
    ip_protocol: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourceCidrIp`来指定源端IPv4 CIDR地址块。
    #[setters(generate = true, strip_option)]
    source_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.Ipv6SourceCidrIp`来指定源端IPv6 CIDR地址块。
    #[setters(generate = true, strip_option)]
    ipv6_source_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourceGroupId`来指定源端安全组ID。
    #[setters(generate = true, strip_option)]
    source_group_id: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourcePrefixListId`来指定源端前缀列表ID。
    #[setters(generate = true, strip_option)]
    source_prefix_list_id: Option<String>,
    /// 已废弃。请使用`Permissions.N.PortRange`来指定端口范围。
    #[setters(generate = true, strip_option)]
    port_range: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestCidrIp`来指定目的端IPv4 CIDR地址段。
    #[setters(generate = true, strip_option)]
    dest_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.Ipv6DestCidrIp`来指定目的端IPv6 CIDR地址段。
    #[setters(generate = true, strip_option)]
    ipv6_dest_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourcePortRange`来指定源端端口范围。
    #[setters(generate = true, strip_option)]
    source_port_range: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourceGroupOwnerAccount`来指定源端安全组所属的阿里云账户。
    #[setters(generate = true, strip_option)]
    source_group_owner_account: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourceGroupOwnerId`来指定源端安全组所属的阿里云账户ID。
    #[setters(generate = true, strip_option)]
    source_group_owner_id: Option<i64>,
    /// 已废弃。请使用`Permissions.N.NicType`来指定网卡类型。
    #[setters(generate = true, strip_option)]
    nic_type: Option<String>,
    /// 已废弃。请使用`Permissions.N.Description`来指定安全组规则的描述。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for AuthorizeSecurityGroup {}

impl AuthorizeSecurityGroup {
    pub fn new(region_id: impl Into<String>, security_group_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            security_group_id: security_group_id.into(),
            permissions: None,
            policy: None,
            priority: None,
            ip_protocol: None,
            source_cidr_ip: None,
            ipv6_source_cidr_ip: None,
            source_group_id: None,
            source_prefix_list_id: None,
            port_range: None,
            dest_cidr_ip: None,
            ipv6_dest_cidr_ip: None,
            source_port_range: None,
            source_group_owner_account: None,
            source_group_owner_id: None,
            nic_type: None,
            description: None,
        }
    }
}
impl crate::ToFormData for AuthorizeSecurityGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AuthorizeSecurityGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AuthorizeSecurityGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AuthorizeSecurityGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(19);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.dest_cidr_ip {
            params.push(("DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.ip_protocol {
            params.push(("IpProtocol".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_dest_cidr_ip {
            params.push(("Ipv6DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_source_cidr_ip {
            params.push(("Ipv6SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.nic_type {
            params.push(("NicType".into(), (f).into()));
        }

        if let Some(f) = &self.permissions {
            crate::FlatSerialize::flat_serialize(f, "Permissions", &mut params);
        }

        if let Some(f) = &self.policy {
            params.push(("Policy".into(), (f).into()));
        }

        if let Some(f) = &self.port_range {
            params.push(("PortRange".into(), (f).into()));
        }

        if let Some(f) = &self.priority {
            params.push(("Priority".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        if let Some(f) = &self.source_cidr_ip {
            params.push(("SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.source_group_id {
            params.push(("SourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.source_group_owner_account {
            params.push(("SourceGroupOwnerAccount".into(), (f).into()));
        }

        if let Some(f) = &self.source_group_owner_id {
            params.push(("SourceGroupOwnerId".into(), (f).into()));
        }

        if let Some(f) = &self.source_port_range {
            params.push(("SourcePortRange".into(), (f).into()));
        }

        if let Some(f) = &self.source_prefix_list_id {
            params.push(("SourcePrefixListId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifySecurityGroupRule {
    /// 目标安全组所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 安全组ID。
    security_group_id: String,
    /// 安全组规则ID。您可以通过[DescribeSecurityGroupAttribute](~~2679845~~) 查询安全组规则ID。
    #[setters(generate = true, strip_option)]
    security_group_rule_id: Option<String>,
    /// 访问权限。取值范围：
    ///          
    /// - accept：接受访问。
    /// - drop：拒绝访问，不返回拒绝信息。
    ///
    /// 默认值：accept。
    #[setters(generate = true, strip_option)]
    policy: Option<String>,
    /// 安全组规则优先级。取值范围：1~100。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    priority: Option<String>,
    /// 网络层/传输层协议。支持两类赋值：
    /// 1. 不区分大小写的协议名。取值范围：
    /// - ICMP
    /// - GRE
    /// - TCP
    /// - UDP
    /// - ALL：支持所有协议。
    /// 2. 符合IANA规范的协议号取值，即0 到 255的整数。目前开放的地域列表：
    /// - 菲律宾
    /// - 英国
    /// - 马来西亚
    /// - 呼和浩特
    /// - 青岛
    /// - 美西
    /// - 新加坡
    #[setters(generate = true, strip_option)]
    ip_protocol: Option<String>,
    /// 设置访问权限的源端IPv4 CIDR地址块。支持CIDR格式和IPv4格式的IP地址范围。
    ///
    /// 默认值：无。
    #[setters(generate = true, strip_option)]
    source_cidr_ip: Option<String>,
    /// 设置访问权限的源端IPv6 CIDR地址块。支持CIDR格式和IPv6格式的IP地址范围。
    ///
    /// > 仅支持VPC类型的IP地址，且该参数与`SourceCidrIp`参数不可同时设置。
    ///
    /// 默认值：无。
    #[setters(generate = true, strip_option)]
    ipv6_source_cidr_ip: Option<String>,
    /// 设置访问权限的源端安全组ID。至少设置一项`SourceGroupId`或者`SourceCidrIp`参数。
    ///
    /// - 如果指定了`SourceGroupId`没有指定参数`SourceCidrIp`，则参数`NicType`取值只能为intranet。
    /// - 如果同时指定了`SourceGroupId`和`SourceCidrIp`，则默认以`SourceCidrIp`为准。
    #[setters(generate = true, strip_option)]
    source_group_id: Option<String>,
    /// 设置访问权限的源端前缀列表ID。您可以调用[DescribePrefixLists](~~205046~~)查询可以使用的前缀列表ID。
    ///
    /// 当您指定了`SourceCidrIp`、`Ipv6SourceCidrIp`或`SourceGroupId`参数中的一个时，将忽略该参数。
    #[setters(generate = true, strip_option)]
    source_prefix_list_id: Option<String>,
    /// 目的端安全组开放的传输层协议相关的端口范围。取值范围：
    ///          
    /// - TCP/UDP协议：取值范围为1~65535。使用斜线（/）隔开起始端口和终止端口。例如：1/200。
    /// - ICMP协议：-1/-1。
    /// - GRE协议：-1/-1。
    /// - ALL：-1/-1。
    #[setters(generate = true, strip_option)]
    port_range: Option<String>,
    /// 目的端IPv4 CIDR地址块。支持CIDR格式和IPv4格式的IP地址范围。
    ///
    /// 默认值：无。
    #[setters(generate = true, strip_option)]
    dest_cidr_ip: Option<String>,
    /// 目的端IPv6 CIDR地址段。支持CIDR格式和IPv6格式的IP地址范围。
    ///
    /// >仅支持VPC类型的IP地址，且该参数与`DestCidrIp`参数不可同时设置。
    ///
    /// 默认值：无。
    #[setters(generate = true, strip_option)]
    ipv6_dest_cidr_ip: Option<String>,
    /// 源端安全组开放的传输层协议相关的端口范围。取值范围：
    ///          
    /// - TCP/UDP协议：取值范围为1~65535。使用斜线（/）隔开起始端口和终止端口。例如：1/200
    /// - ICMP协议：-1/-1。
    /// - GRE协议：-1/-1。
    /// - ALL：-1/-1。
    #[setters(generate = true, strip_option)]
    source_port_range: Option<String>,
    /// 跨账户设置安全组规则时，源端安全组所属的阿里云账户。
    ///          
    /// - 如果`SourceGroupOwnerAccount`及`SourceGroupOwnerID`均未设置，则认为是设置您其他安全组的访问权限。
    /// - 如果已经设置参数`SourceCidrIp`，则参数`SourceGroupOwnerAccount`无效。
    #[setters(generate = true, strip_option)]
    source_group_owner_account: Option<String>,
    /// 跨账户设置安全组规则时，源端安全组所属的阿里云账户。
    ///          
    /// - 如果`SourceGroupOwnerId`及`SourceGroupOwnerAccount`均未设置，则认为是设置您其他安全组的访问权限。
    /// - 如果您已经设置参数`SourceCidrIp`，则参数`SourceGroupOwnerId`无效。
    #[setters(generate = true, strip_option)]
    source_group_owner_id: Option<i64>,
    /// 网卡类型。
    ///
    ///
    /// > 根据安全组规则ID修改规则时，不支持修改该参数。如果需要修改，建议先增加一条新规则，再删除当前规则。
    #[setters(generate = true, strip_option)]
    nic_type: Option<String>,
    /// 安全组规则的描述信息。长度为1~512个字符。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 端口列表 ID。
    /// 您可以调用`DescribePortRangeLists`查询可以使用的端口列表 ID。
    /// - 当您指定了PortRange参数时，将忽略该参数。
    /// - 安全组的网络类型为经典网络时，不支持设置端口列表。关于安全组以及端口列表使用限制的更多信息，请参见[安全组使用限制](~~25412#SecurityGroupQuota1~~)。
    #[setters(generate = true, strip_option)]
    port_range_list_id: Option<String>,
}

impl sealed::Bound for ModifySecurityGroupRule {}

impl ModifySecurityGroupRule {
    pub fn new(region_id: impl Into<String>, security_group_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            security_group_id: security_group_id.into(),
            security_group_rule_id: None,
            policy: None,
            priority: None,
            ip_protocol: None,
            source_cidr_ip: None,
            ipv6_source_cidr_ip: None,
            source_group_id: None,
            source_prefix_list_id: None,
            port_range: None,
            dest_cidr_ip: None,
            ipv6_dest_cidr_ip: None,
            source_port_range: None,
            source_group_owner_account: None,
            source_group_owner_id: None,
            nic_type: None,
            description: None,
            port_range_list_id: None,
        }
    }
}
impl crate::ToFormData for ModifySecurityGroupRule {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifySecurityGroupRule {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifySecurityGroupRule";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifySecurityGroupRuleResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(20);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.dest_cidr_ip {
            params.push(("DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.ip_protocol {
            params.push(("IpProtocol".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_dest_cidr_ip {
            params.push(("Ipv6DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_source_cidr_ip {
            params.push(("Ipv6SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.nic_type {
            params.push(("NicType".into(), (f).into()));
        }

        if let Some(f) = &self.policy {
            params.push(("Policy".into(), (f).into()));
        }

        if let Some(f) = &self.port_range {
            params.push(("PortRange".into(), (f).into()));
        }

        if let Some(f) = &self.port_range_list_id {
            params.push(("PortRangeListId".into(), (f).into()));
        }

        if let Some(f) = &self.priority {
            params.push(("Priority".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        if let Some(f) = &self.security_group_rule_id {
            params.push(("SecurityGroupRuleId".into(), (f).into()));
        }

        if let Some(f) = &self.source_cidr_ip {
            params.push(("SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.source_group_id {
            params.push(("SourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.source_group_owner_account {
            params.push(("SourceGroupOwnerAccount".into(), (f).into()));
        }

        if let Some(f) = &self.source_group_owner_id {
            params.push(("SourceGroupOwnerId".into(), (f).into()));
        }

        if let Some(f) = &self.source_port_range {
            params.push(("SourcePortRange".into(), (f).into()));
        }

        if let Some(f) = &self.source_prefix_list_id {
            params.push(("SourcePrefixListId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RevokeSecurityGroup {
    /// 安全组所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 安全组ID。
    security_group_id: String,
    /// 安全组规则ID数组。数组长度：0~100。
    #[setters(generate = true, strip_option)]
    security_group_rule_id: Option<Vec<String>>,
    /// 安全组规则数组。数组长度：0~100。
    #[setters(generate = true, strip_option)]
    permissions: Option<Vec<RevokeSecurityGroupPermission>>,
    /// 已废弃。请使用`Permissions.N.Policy`来设置访问权限。
    #[setters(generate = true, strip_option)]
    policy: Option<String>,
    /// 已废弃。请使用`Permissions.N.Priority`来指定规则优先级。
    #[setters(generate = true, strip_option)]
    priority: Option<String>,
    /// 已废弃。请使用`Permissions.N.IpProtocol`来指定协议类型。
    #[setters(generate = true, strip_option)]
    ip_protocol: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourceCidrIp`来指定源端IPv4 CIDR地址块。
    #[setters(generate = true, strip_option)]
    source_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.Ipv6SourceCidrIp`来指定源端IPv6 CIDR地址块。
    #[setters(generate = true, strip_option)]
    ipv6_source_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourceGroupId`来指定源端安全组ID。
    #[setters(generate = true, strip_option)]
    source_group_id: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourcePrefixListId`来指定源端前缀列表ID。
    #[setters(generate = true, strip_option)]
    source_prefix_list_id: Option<String>,
    /// 已废弃。请使用`Permissions.N.PortRange`来指定端口范围。
    #[setters(generate = true, strip_option)]
    port_range: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestCidrIp`来指定目的端IPv4 CIDR地址段。
    #[setters(generate = true, strip_option)]
    dest_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.Ipv6DestCidrIp`来指定目的端IPv6 CIDR地址段。
    #[setters(generate = true, strip_option)]
    ipv6_dest_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourcePortRange`来指定源端端口范围。
    #[setters(generate = true, strip_option)]
    source_port_range: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourceGroupOwnerAccount`来指定源端安全组所属的阿里云账户。
    #[setters(generate = true, strip_option)]
    source_group_owner_account: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourceGroupOwnerId`来指定源端安全组所属的阿里云账户ID。
    #[setters(generate = true, strip_option)]
    source_group_owner_id: Option<i64>,
    /// 已废弃。请使用`Permissions.N.NicType`来指定网卡类型。
    #[setters(generate = true, strip_option)]
    nic_type: Option<String>,
    /// 已废弃。请使用`Permissions.N.Description`来指定规则的描述。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for RevokeSecurityGroup {}

impl RevokeSecurityGroup {
    pub fn new(region_id: impl Into<String>, security_group_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            security_group_id: security_group_id.into(),
            security_group_rule_id: None,
            permissions: None,
            policy: None,
            priority: None,
            ip_protocol: None,
            source_cidr_ip: None,
            ipv6_source_cidr_ip: None,
            source_group_id: None,
            source_prefix_list_id: None,
            port_range: None,
            dest_cidr_ip: None,
            ipv6_dest_cidr_ip: None,
            source_port_range: None,
            source_group_owner_account: None,
            source_group_owner_id: None,
            nic_type: None,
            description: None,
        }
    }
}
impl crate::ToFormData for RevokeSecurityGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RevokeSecurityGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RevokeSecurityGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RevokeSecurityGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(20);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.dest_cidr_ip {
            params.push(("DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.ip_protocol {
            params.push(("IpProtocol".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_dest_cidr_ip {
            params.push(("Ipv6DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_source_cidr_ip {
            params.push(("Ipv6SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.nic_type {
            params.push(("NicType".into(), (f).into()));
        }

        if let Some(f) = &self.permissions {
            crate::FlatSerialize::flat_serialize(f, "Permissions", &mut params);
        }

        if let Some(f) = &self.policy {
            params.push(("Policy".into(), (f).into()));
        }

        if let Some(f) = &self.port_range {
            params.push(("PortRange".into(), (f).into()));
        }

        if let Some(f) = &self.priority {
            params.push(("Priority".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        if let Some(f) = &self.security_group_rule_id {
            crate::FlatSerialize::flat_serialize(f, "SecurityGroupRuleId", &mut params);
        }

        if let Some(f) = &self.source_cidr_ip {
            params.push(("SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.source_group_id {
            params.push(("SourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.source_group_owner_account {
            params.push(("SourceGroupOwnerAccount".into(), (f).into()));
        }

        if let Some(f) = &self.source_group_owner_id {
            params.push(("SourceGroupOwnerId".into(), (f).into()));
        }

        if let Some(f) = &self.source_port_range {
            params.push(("SourcePortRange".into(), (f).into()));
        }

        if let Some(f) = &self.source_prefix_list_id {
            params.push(("SourcePrefixListId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AuthorizeSecurityGroupEgress {
    /// 源端安全组所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 安全组ID。
    security_group_id: String,
    /// 安全组规则数组。数组长度：1~100。
    #[setters(generate = true, strip_option)]
    permissions: Option<Vec<AuthorizeSecurityGroupEgressPermission>>,
    /// 已废弃。请使用`Permissions.N.Policy`来设置访问权限。
    #[setters(generate = true, strip_option)]
    policy: Option<String>,
    /// 已废弃。请使用`Permissions.N.Priority`来指定规则优先级。
    #[setters(generate = true, strip_option)]
    priority: Option<String>,
    /// 已废弃。请使用`Permissions.N.IpProtocol`来指定协议类型。
    #[setters(generate = true, strip_option)]
    ip_protocol: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestCidrIp`来指定目的端IPv4 CIDR地址块。
    #[setters(generate = true, strip_option)]
    dest_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.Ipv6DestCidrIp`来指定目的端IPv6 CIDR地址块。
    #[setters(generate = true, strip_option)]
    ipv6_dest_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestGroupId`来指定目的端安全组ID。
    #[setters(generate = true, strip_option)]
    dest_group_id: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestPrefixListId`来指定源端前缀列表ID。
    #[setters(generate = true, strip_option)]
    dest_prefix_list_id: Option<String>,
    /// 已废弃。请使用`Permissions.N.PortRange`来指定端口范围。
    #[setters(generate = true, strip_option)]
    port_range: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourceCidrIp`来指定源端IPv4 CIDR地址段。
    #[setters(generate = true, strip_option)]
    source_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.Ipv6SourceCidrIp`来指定源端IPv6 CIDR地址段。
    #[setters(generate = true, strip_option)]
    ipv6_source_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourcePortRange`来指定源端端口范围。
    #[setters(generate = true, strip_option)]
    source_port_range: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestGroupOwnerAccount`来指定目的端安全组所属的阿里云账户。
    #[setters(generate = true, strip_option)]
    dest_group_owner_account: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestGroupOwnerId`来指定目的端安全组所属的阿里云账户ID。
    #[setters(generate = true, strip_option)]
    dest_group_owner_id: Option<i64>,
    /// 已废弃。请使用`Permissions.N.NicType`来指定网卡类型。
    #[setters(generate = true, strip_option)]
    nic_type: Option<String>,
    /// 已废弃。请使用`Permissions.N.Description`来指定规则的描述。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for AuthorizeSecurityGroupEgress {}

impl AuthorizeSecurityGroupEgress {
    pub fn new(region_id: impl Into<String>, security_group_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            security_group_id: security_group_id.into(),
            permissions: None,
            policy: None,
            priority: None,
            ip_protocol: None,
            dest_cidr_ip: None,
            ipv6_dest_cidr_ip: None,
            dest_group_id: None,
            dest_prefix_list_id: None,
            port_range: None,
            source_cidr_ip: None,
            ipv6_source_cidr_ip: None,
            source_port_range: None,
            dest_group_owner_account: None,
            dest_group_owner_id: None,
            nic_type: None,
            description: None,
        }
    }
}
impl crate::ToFormData for AuthorizeSecurityGroupEgress {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AuthorizeSecurityGroupEgress {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AuthorizeSecurityGroupEgress";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AuthorizeSecurityGroupEgressResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(19);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.dest_cidr_ip {
            params.push(("DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.dest_group_id {
            params.push(("DestGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.dest_group_owner_account {
            params.push(("DestGroupOwnerAccount".into(), (f).into()));
        }

        if let Some(f) = &self.dest_group_owner_id {
            params.push(("DestGroupOwnerId".into(), (f).into()));
        }

        if let Some(f) = &self.dest_prefix_list_id {
            params.push(("DestPrefixListId".into(), (f).into()));
        }

        if let Some(f) = &self.ip_protocol {
            params.push(("IpProtocol".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_dest_cidr_ip {
            params.push(("Ipv6DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_source_cidr_ip {
            params.push(("Ipv6SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.nic_type {
            params.push(("NicType".into(), (f).into()));
        }

        if let Some(f) = &self.permissions {
            crate::FlatSerialize::flat_serialize(f, "Permissions", &mut params);
        }

        if let Some(f) = &self.policy {
            params.push(("Policy".into(), (f).into()));
        }

        if let Some(f) = &self.port_range {
            params.push(("PortRange".into(), (f).into()));
        }

        if let Some(f) = &self.priority {
            params.push(("Priority".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        if let Some(f) = &self.source_cidr_ip {
            params.push(("SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.source_port_range {
            params.push(("SourcePortRange".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifySecurityGroupEgressRule {
    /// 源端安全组所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 安全组ID。
    security_group_id: String,
    /// 安全组规则ID。您可以通过[DescribeSecurityGroupAttribute](~~2679845~~) 查询安全组规则ID。
    #[setters(generate = true, strip_option)]
    security_group_rule_id: Option<String>,
    /// 访问权限。取值范围：
    ///
    /// - accept：接受访问。
    /// - drop：拒绝访问，不返回拒绝信息。
    ///
    /// 默认值：accept。
    #[setters(generate = true, strip_option)]
    policy: Option<String>,
    /// 安全组规则优先级。取值范围：1~100。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    priority: Option<String>,
    /// 网络层/传输层协议。支持两类赋值：
    /// 1. 不区分大小写的协议名。取值范围：
    /// - ICMP
    /// - GRE
    /// - TCP
    /// - UDP
    /// - ALL：支持所有协议。
    /// 2. 符合IANA规范的协议号取值，即0 到 255的整数。目前开放的地域列表：
    /// - 菲律宾
    /// - 英国
    /// - 马来西亚
    /// - 呼和浩特
    /// - 青岛
    /// - 美西
    /// - 新加坡
    #[setters(generate = true, strip_option)]
    ip_protocol: Option<String>,
    /// 目的端IPv4 CIDR地址块。支持CIDR格式和IPv4格式的IP地址范围。
    ///
    /// 默认值：无。
    #[setters(generate = true, strip_option)]
    dest_cidr_ip: Option<String>,
    /// 目的端IPv6 CIDR地址块。支持CIDR格式和IPv6格式的IP地址范围。
    ///
    /// > 仅支持VPC类型的IP地址，且该参数与`DestCidrIp`参数不可同时设置。
    ///
    /// 默认值：无。
    #[setters(generate = true, strip_option)]
    ipv6_dest_cidr_ip: Option<String>,
    /// 需要设置访问权限的目的端安全组ID。至少设置一项`DestGroupId`或者`DestCidrIp`参数。
    ///
    /// - 至少设置DestGroupId、DestCidrIp、Ipv6DestCidrIp或DestPrefixListId参数中的一项。
    /// - 如果指定了DestGroupId没有指定参数DestCidrIp，则参数NicType取值只能为intranet。
    /// - 如果同时指定了DestGroupId和DestCidrIp，则默认以DestCidrIp为准。
    #[setters(generate = true, strip_option)]
    dest_group_id: Option<String>,
    /// 目的端前缀列表ID。您可以调用[DescribePrefixLists](~~205046~~)查询可以使用的前缀列表ID。
    ///
    /// 当您指定了`DestCidrIp`、`Ipv6DestCidrIp`或者`DestGroupId`参数中的一个时，将忽略该参数。
    #[setters(generate = true, strip_option)]
    dest_prefix_list_id: Option<String>,
    /// 目的端安全组开放的传输层协议相关的端口范围。取值范围：
    ///
    /// - TCP/UDP协议：取值范围为1~65535。使用斜线（/）隔开起始端口和终止端口。例如：1/200。
    /// - ICMP协议：-1/-1。
    /// - GRE协议：-1/-1。
    /// - ALL：-1/-1。
    #[setters(generate = true, strip_option)]
    port_range: Option<String>,
    /// 源端IPv4 CIDR地址块。支持CIDR格式和IPv4格式的IP地址范围。
    ///
    /// 默认值：无。
    #[setters(generate = true, strip_option)]
    source_cidr_ip: Option<String>,
    /// 源端IPv6 CIDR地址块。支持CIDR格式和IPv6格式的IP地址范围。
    ///
    /// > 仅支持VPC类型的IP地址，且该参数与`SourceCidrIp`参数不可同时设置。
    ///
    /// 默认值：无。
    #[setters(generate = true, strip_option)]
    ipv6_source_cidr_ip: Option<String>,
    /// 源端安全组开放的传输层协议相关的端口范围。取值范围：
    ///
    /// - TCP/UDP协议：取值范围为1~65535。使用斜线（/）隔开起始端口和终止端口。例如：1/200
    /// - ICMP协议：-1/-1。
    /// - GRE协议：-1/-1。
    /// - ALL：-1/-1。
    #[setters(generate = true, strip_option)]
    source_port_range: Option<String>,
    /// 跨账户设置安全组规则时，目的端安全组所属的阿里云账户。
    #[setters(generate = true, strip_option)]
    dest_group_owner_account: Option<String>,
    /// 跨账户设置安全组规则时，目的端安全组所属的阿里云账户ID。
    #[setters(generate = true, strip_option)]
    dest_group_owner_id: Option<i64>,
    /// 网卡类型。
    ///
    ///
    /// > 根据安全组规则ID修改规则时，不支持修改该参数。如果需要修改，建议先增加一条新规则，再删除当前规则。
    #[setters(generate = true, strip_option)]
    nic_type: Option<String>,
    /// 安全组规则的描述信息。长度为1~512个字符。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 端口列表 ID。
    /// 您可以调用`DescribePortRangeLists`查询可以使用的端口列表 ID。
    /// - 当您指定了PortRange参数时，将忽略该参数。
    /// - 安全组的网络类型为经典网络时，不支持设置端口列表。关于安全组以及端口列表使用限制的更多信息，请参见[安全组使用限制](~~25412#SecurityGroupQuota1~~)。
    #[setters(generate = true, strip_option)]
    port_range_list_id: Option<String>,
}

impl sealed::Bound for ModifySecurityGroupEgressRule {}

impl ModifySecurityGroupEgressRule {
    pub fn new(region_id: impl Into<String>, security_group_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            security_group_id: security_group_id.into(),
            security_group_rule_id: None,
            policy: None,
            priority: None,
            ip_protocol: None,
            dest_cidr_ip: None,
            ipv6_dest_cidr_ip: None,
            dest_group_id: None,
            dest_prefix_list_id: None,
            port_range: None,
            source_cidr_ip: None,
            ipv6_source_cidr_ip: None,
            source_port_range: None,
            dest_group_owner_account: None,
            dest_group_owner_id: None,
            nic_type: None,
            description: None,
            port_range_list_id: None,
        }
    }
}
impl crate::ToFormData for ModifySecurityGroupEgressRule {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifySecurityGroupEgressRule {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifySecurityGroupEgressRule";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifySecurityGroupEgressRuleResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(20);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.dest_cidr_ip {
            params.push(("DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.dest_group_id {
            params.push(("DestGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.dest_group_owner_account {
            params.push(("DestGroupOwnerAccount".into(), (f).into()));
        }

        if let Some(f) = &self.dest_group_owner_id {
            params.push(("DestGroupOwnerId".into(), (f).into()));
        }

        if let Some(f) = &self.dest_prefix_list_id {
            params.push(("DestPrefixListId".into(), (f).into()));
        }

        if let Some(f) = &self.ip_protocol {
            params.push(("IpProtocol".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_dest_cidr_ip {
            params.push(("Ipv6DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_source_cidr_ip {
            params.push(("Ipv6SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.nic_type {
            params.push(("NicType".into(), (f).into()));
        }

        if let Some(f) = &self.policy {
            params.push(("Policy".into(), (f).into()));
        }

        if let Some(f) = &self.port_range {
            params.push(("PortRange".into(), (f).into()));
        }

        if let Some(f) = &self.port_range_list_id {
            params.push(("PortRangeListId".into(), (f).into()));
        }

        if let Some(f) = &self.priority {
            params.push(("Priority".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        if let Some(f) = &self.security_group_rule_id {
            params.push(("SecurityGroupRuleId".into(), (f).into()));
        }

        if let Some(f) = &self.source_cidr_ip {
            params.push(("SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.source_port_range {
            params.push(("SourcePortRange".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RevokeSecurityGroupEgress {
    /// 安全组所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 安全组ID。
    security_group_id: String,
    /// 安全组规则ID数组。数组长度：0~100。
    #[setters(generate = true, strip_option)]
    security_group_rule_id: Option<Vec<String>>,
    /// 安全组规则数组。数组长度：0~100。
    #[setters(generate = true, strip_option)]
    permissions: Option<Vec<RevokeSecurityGroupEgressPermission>>,
    /// 已废弃。请使用`Permissions.N.Policy`来设置访问权限。
    #[setters(generate = true, strip_option)]
    policy: Option<String>,
    /// 已废弃。请使用`Permissions.N.Priority`来指定规则优先级。
    #[setters(generate = true, strip_option)]
    priority: Option<String>,
    /// 已废弃。请使用`Permissions.N.IpProtocol`来指定协议类型。
    #[setters(generate = true, strip_option)]
    ip_protocol: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestCidrIp`来指定目的端IPv4 CIDR地址块。
    #[setters(generate = true, strip_option)]
    dest_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.Ipv6DestCidrIp`来指定目的端IPv6 CIDR地址块。
    #[setters(generate = true, strip_option)]
    ipv6_dest_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestGroupId`来指定目的端安全组ID。
    #[setters(generate = true, strip_option)]
    dest_group_id: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestPrefixListId`来指定源端前缀列表ID。
    #[setters(generate = true, strip_option)]
    dest_prefix_list_id: Option<String>,
    /// 已废弃。请使用`Permissions.N.PortRange`来指定端口范围。
    #[setters(generate = true, strip_option)]
    port_range: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourceCidrIp`来指定源端IPv4 CIDR地址段。
    #[setters(generate = true, strip_option)]
    source_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.Ipv6SourceCidrIp`来指定源端IPv6 CIDR地址段。
    #[setters(generate = true, strip_option)]
    ipv6_source_cidr_ip: Option<String>,
    /// 已废弃。请使用`Permissions.N.SourcePortRange`来指定源端端口范围。
    #[setters(generate = true, strip_option)]
    source_port_range: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestGroupOwnerAccount`来指定目的端安全组所属的阿里云账户。
    #[setters(generate = true, strip_option)]
    dest_group_owner_account: Option<String>,
    /// 已废弃。请使用`Permissions.N.DestGroupOwnerId`来指定目的端安全组所属的阿里云账户ID。
    #[setters(generate = true, strip_option)]
    dest_group_owner_id: Option<i64>,
    /// 已废弃。请使用`Permissions.N.NicType`来指定网卡类型。
    #[setters(generate = true, strip_option)]
    nic_type: Option<String>,
    /// 已废弃。请使用`Permissions.N.Description`来指定规则的描述。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for RevokeSecurityGroupEgress {}

impl RevokeSecurityGroupEgress {
    pub fn new(region_id: impl Into<String>, security_group_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            security_group_id: security_group_id.into(),
            security_group_rule_id: None,
            permissions: None,
            policy: None,
            priority: None,
            ip_protocol: None,
            dest_cidr_ip: None,
            ipv6_dest_cidr_ip: None,
            dest_group_id: None,
            dest_prefix_list_id: None,
            port_range: None,
            source_cidr_ip: None,
            ipv6_source_cidr_ip: None,
            source_port_range: None,
            dest_group_owner_account: None,
            dest_group_owner_id: None,
            nic_type: None,
            description: None,
        }
    }
}
impl crate::ToFormData for RevokeSecurityGroupEgress {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RevokeSecurityGroupEgress {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RevokeSecurityGroupEgress";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RevokeSecurityGroupEgressResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(20);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.dest_cidr_ip {
            params.push(("DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.dest_group_id {
            params.push(("DestGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.dest_group_owner_account {
            params.push(("DestGroupOwnerAccount".into(), (f).into()));
        }

        if let Some(f) = &self.dest_group_owner_id {
            params.push(("DestGroupOwnerId".into(), (f).into()));
        }

        if let Some(f) = &self.dest_prefix_list_id {
            params.push(("DestPrefixListId".into(), (f).into()));
        }

        if let Some(f) = &self.ip_protocol {
            params.push(("IpProtocol".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_dest_cidr_ip {
            params.push(("Ipv6DestCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_source_cidr_ip {
            params.push(("Ipv6SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.nic_type {
            params.push(("NicType".into(), (f).into()));
        }

        if let Some(f) = &self.permissions {
            crate::FlatSerialize::flat_serialize(f, "Permissions", &mut params);
        }

        if let Some(f) = &self.policy {
            params.push(("Policy".into(), (f).into()));
        }

        if let Some(f) = &self.port_range {
            params.push(("PortRange".into(), (f).into()));
        }

        if let Some(f) = &self.priority {
            params.push(("Priority".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        if let Some(f) = &self.security_group_rule_id {
            crate::FlatSerialize::flat_serialize(f, "SecurityGroupRuleId", &mut params);
        }

        if let Some(f) = &self.source_cidr_ip {
            params.push(("SourceCidrIp".into(), (f).into()));
        }

        if let Some(f) = &self.source_port_range {
            params.push(("SourcePortRange".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSecurityGroupReferences {
    /// 安全组所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 安全组ID数组。数组长度：0~10。
    security_group_id: Vec<String>,
}

impl sealed::Bound for DescribeSecurityGroupReferences {}

impl DescribeSecurityGroupReferences {
    pub fn new(region_id: impl Into<String>, security_group_id: impl Into<Vec<String>>) -> Self {
        Self {
            region_id: region_id.into(),
            security_group_id: security_group_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeSecurityGroupReferences {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSecurityGroupReferences {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSecurityGroupReferences";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSecurityGroupReferencesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            "SecurityGroupId",
            &mut params,
        );

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct JoinSecurityGroup {
    /// 安全组ID。您可以调用[DescribeSecurityGroups](~~25556~~)查看您可用的安全组。
    security_group_id: String,
    /// 实例ID。
    ///
    /// > 当该参数传入值时，`NetworkInterfaceId`必须为空。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 弹性网卡ID。
    ///
    /// > 当该参数传入值时，`InstanceId`必须为空。
    #[setters(generate = true, strip_option)]
    network_interface_id: Option<String>,
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    ///
    /// - 实例加入安全组的操作可以不指定地域ID。
    /// - 弹性网卡加入安全组的操作必须指定弹性网卡所在的地域ID。
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
}

impl sealed::Bound for JoinSecurityGroup {}

impl JoinSecurityGroup {
    pub fn new(security_group_id: impl Into<String>) -> Self {
        Self {
            security_group_id: security_group_id.into(),
            instance_id: None,
            network_interface_id: None,
            region_id: None,
        }
    }
}
impl crate::ToFormData for JoinSecurityGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for JoinSecurityGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "JoinSecurityGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<JoinSecurityGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.network_interface_id {
            params.push(("NetworkInterfaceId".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct LeaveSecurityGroup {
    /// 安全组ID。
    security_group_id: String,
    /// 实例ID。
    ///
    /// > 当该参数传入值时，`NetworkInterfaceId`必须为空。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 弹性网卡ID。
    ///
    /// > 当该参数传入值时，`InstanceId`必须为空。
    #[setters(generate = true, strip_option)]
    network_interface_id: Option<String>,
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    ///
    /// - 实例移出安全组的操作可以不指定地域ID。
    /// - 弹性网卡移出安全组的操作必须指定弹性网卡所在的地域ID。
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
}

impl sealed::Bound for LeaveSecurityGroup {}

impl LeaveSecurityGroup {
    pub fn new(security_group_id: impl Into<String>) -> Self {
        Self {
            security_group_id: security_group_id.into(),
            instance_id: None,
            network_interface_id: None,
            region_id: None,
        }
    }
}
impl crate::ToFormData for LeaveSecurityGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for LeaveSecurityGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "LeaveSecurityGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<LeaveSecurityGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.network_interface_id {
            params.push(("NetworkInterfaceId".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("SecurityGroupId".into(), (&self.security_group_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateKeyPair {
    /// 密钥对所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 密钥对名称。长度为2~128个英文或中文字符。必须以大小字母或中文开头，不能以`http://`或`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    key_pair_name: String,
    /// SSH密钥对所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<CreateKeyPairTag>>,
}

impl sealed::Bound for CreateKeyPair {}

impl CreateKeyPair {
    pub fn new(region_id: impl Into<String>, key_pair_name: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            key_pair_name: key_pair_name.into(),
            resource_group_id: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for CreateKeyPair {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateKeyPair {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateKeyPair";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateKeyPairResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("KeyPairName".into(), (&self.key_pair_name).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ImportKeyPair {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 密钥对名称。必须保持名称唯一性。长度为2~128个字符，必须以大小写字母或中文开头，不能以http://和https:// 开头。支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    key_pair_name: String,
    /// 密钥对的公钥内容。
    public_key_body: String,
    /// SSH密钥对所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ImportKeyPairTag>>,
}

impl sealed::Bound for ImportKeyPair {}

impl ImportKeyPair {
    pub fn new(
        region_id: impl Into<String>,
        key_pair_name: impl Into<String>,
        public_key_body: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            key_pair_name: key_pair_name.into(),
            public_key_body: public_key_body.into(),
            resource_group_id: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for ImportKeyPair {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ImportKeyPair {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ImportKeyPair";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ImportKeyPairResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);
        params.push(("KeyPairName".into(), (&self.key_pair_name).into()));
        params.push(("PublicKeyBody".into(), (&self.public_key_body).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeKeyPairs {
    /// 密钥对所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 密钥对名称。支持正则表达式模糊搜索，使用*匹配子表达式，示例：
    ///
    /// - `*SshKey`：查询以SshKey结尾的密钥对名称，包括SshKey。
    /// - `SshKey*`：查询以SshKey开头的密钥对名称，包括SshKey。
    /// - `*SshKey*`：查询名称中间有SshKey的密钥对，包括SshKey。
    /// - `SshKey`：精确匹配SshKey。
    #[setters(generate = true, strip_option)]
    key_pair_name: Option<String>,
    /// 密钥对的指纹。根据RFC 4716定义的公钥指纹格式，采用MD5信息摘要算法。更多详情，请参见[RFC 4716](https://tools.ietf.org/html/rfc4716)。
    #[setters(generate = true, strip_option)]
    key_pair_finger_print: Option<String>,
    /// 密钥对列表的页码。起始值：1。
    ///
    /// 默认值：1 。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。最大值：50。
    ///
    /// 默认值：10 。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 是否在返回结果中包含PublicKey。
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    include_public_key: Option<bool>,
    /// 密钥对所在的企业资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<PairsTag>>,
}

impl sealed::Bound for DescribeKeyPairs {}

impl DescribeKeyPairs {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            key_pair_name: None,
            key_pair_finger_print: None,
            page_number: None,
            page_size: None,
            include_public_key: None,
            resource_group_id: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeKeyPairs {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeKeyPairs {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeKeyPairs";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeKeyPairsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.include_public_key {
            params.push(("IncludePublicKey".into(), (f).into()));
        }

        if let Some(f) = &self.key_pair_finger_print {
            params.push(("KeyPairFingerPrint".into(), (f).into()));
        }

        if let Some(f) = &self.key_pair_name {
            params.push(("KeyPairName".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AttachKeyPair {
    /// SSH密钥对所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// SSH密钥对名称。
    key_pair_name: String,
    /// 绑定SSH密钥对的实例ID。取值可以由多台实例ID组成一个JSON数组，最多支持50个ID，ID之间用半角逗号（,）隔开。
    instance_ids: String,
}

impl sealed::Bound for AttachKeyPair {}

impl AttachKeyPair {
    pub fn new(
        region_id: impl Into<String>,
        key_pair_name: impl Into<String>,
        instance_ids: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            key_pair_name: key_pair_name.into(),
            instance_ids: instance_ids.into(),
        }
    }
}
impl crate::ToFormData for AttachKeyPair {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AttachKeyPair {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AttachKeyPair";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AttachKeyPairResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("InstanceIds".into(), (&self.instance_ids).into()));
        params.push(("KeyPairName".into(), (&self.key_pair_name).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DetachKeyPair {
    /// SSH密钥对所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// SSH密钥对名称。
    key_pair_name: String,
    /// 解绑SSH密钥对的实例ID。取值可以是由多台实例ID组成的一个JSON数组，最多支持50个ID，ID之间用半角逗号（,）隔开。
    instance_ids: String,
}

impl sealed::Bound for DetachKeyPair {}

impl DetachKeyPair {
    pub fn new(
        region_id: impl Into<String>,
        key_pair_name: impl Into<String>,
        instance_ids: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            key_pair_name: key_pair_name.into(),
            instance_ids: instance_ids.into(),
        }
    }
}
impl crate::ToFormData for DetachKeyPair {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DetachKeyPair {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DetachKeyPair";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DetachKeyPairResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("InstanceIds".into(), (&self.instance_ids).into()));
        params.push(("KeyPairName".into(), (&self.key_pair_name).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteKeyPairs {
    /// SSH密钥对所在的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// SSH密钥对名称。取值可以由多个SSH密钥对名称组成一个JSON数组，最多支持100对SSH密钥对，名称之间用半角逗号（,）隔开。
    ///
    /// >在进行删除SSH密钥对前，您可以调用[DescribeKeyPairs](~~51773~~)查询已有密钥对。
    key_pair_names: String,
}

impl sealed::Bound for DeleteKeyPairs {}

impl DeleteKeyPairs {
    pub fn new(region_id: impl Into<String>, key_pair_names: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            key_pair_names: key_pair_names.into(),
        }
    }
}
impl crate::ToFormData for DeleteKeyPairs {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteKeyPairs {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteKeyPairs";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteKeyPairsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("KeyPairNames".into(), (&self.key_pair_names).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateLaunchTemplate {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 启动模版自身的标签对信息。
    ///
    /// > 当前仅支持通过API创建和查询启动模板的标签，控制台无法创建或查看。
    #[setters(generate = true, strip_option)]
    template_tag: Option<Vec<TemplateTemplateTag>>,
    /// 实例启动模板名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`或`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    launch_template_name: String,
    /// 实例启动模板的版本描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    version_description: Option<String>,
    /// 镜像ID，启动实例时选择的镜像资源。您可以通过[DescribeImages](~~25534~~)查询您可以使用的镜像资源。
    #[setters(generate = true, strip_option)]
    image_id: Option<String>,
    /// 镜像来源。取值范围：
    ///
    /// - system：阿里云提供的公共镜像。
    /// - self：您创建的自定义镜像。
    /// - others：其他阿里云用户共享给您的镜像。
    /// - marketplace：<props="china"><ph>[云市场](https://market.aliyun.com/)</ph></props><props="intl"><ph>[云市场](https://marketplace.alibabacloud.com/)</ph></props>提供的镜像。您查询到的云市场镜像可以直接使用，无需提前订阅。您需要自行留意云市场镜像的收费详情。
    #[setters(generate = true, strip_option)]
    image_owner_alias: Option<String>,
    /// 是否使用镜像预设的密码。
    ///
    /// > 使用该参数时，Password参数必须为空，同时您需要确保使用的镜像已经设置了密码。
    #[setters(generate = true, strip_option)]
    password_inherit: Option<bool>,
    /// 实例的资源规格。更多信息，请参见[实例规格族](~~25378~~)，也可以调用[DescribeInstanceTypes](~~25620~~)接口获得最新的规格表。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 指定新创建实例所属于的安全组ID。同一个安全组内的实例之间可以互相访问，一个安全组最多能管理1000台实例。
    ///
    /// > 不支持同时指定`SecurityGroupId`和`SecurityGroupIds.N`。
    #[setters(generate = true, strip_option)]
    security_group_id: Option<String>,
    /// 专有网络VPC ID。
    #[setters(generate = true, strip_option)]
    vpc_id: Option<String>,
    /// 创建VPC类型实例时需要指定虚拟交换机ID。
    #[setters(generate = true, strip_option)]
    v_switch_id: Option<String>,
    /// 实例名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。默认值为实例的`InstanceId`。
    ///
    /// 创建多台ECS实例时，您可以批量设置有序的实例名称，并且可以包含方括号（[]）和逗号（,）。具体操作，请参见[批量设置有序的实例名称或主机名称](~~196048~~)。
    #[setters(generate = true, strip_option)]
    instance_name: Option<String>,
    /// 实例描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 公网入带宽最大值，单位为Mbit/s。取值范围：
    ///
    /// - 当所购公网出带宽小于等于10 Mbit/s时：1~10，默认为10。
    /// - 当所购公网出带宽大于10 Mbit/s时：1~`InternetMaxBandwidthOut`的取值，默认为`InternetMaxBandwidthOut`的取值。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_in: Option<i32>,
    /// 公网出带宽最大值，单位为Mbit/s。取值范围为0~100。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_out: Option<i32>,
    /// 云服务器的主机名。
    ///
    /// -   半角句号（.）和短划线（-）不能作为首尾字符，更不能连续使用。
    /// -   Windows实例：字符长度为2~15，不支持半角句号（.），不能全是数字。允许大小写英文字母、数字和短划线（-）。
    /// -   其他类型实例（Linux等）：字符长度为2~64，支持多个半角句号（.），半角句号之间为一段，每段允许大小写英文字母、数字和短划线（-）。
    #[setters(generate = true, strip_option)]
    host_name: Option<String>,
    /// 实例所属的可用区ID。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 系统盘的云盘种类。取值范围：
    ///
    /// -   cloud：普通云盘。
    /// -   cloud_efficiency：高效云盘。
    /// -   cloud_ssd：SSD云盘。
    /// -   cloud_essd：ESSD云盘。您可以通过参数`SystemDisk.PerformanceLevel`设置云盘的性能等级。
    /// - cloud_auto：ESSD AutoPL 云盘
    /// - cloud_essd_entry：ESSD Entry 云盘。
    ///
    /// 已停售的实例规格且非I/O优化实例默认值为cloud，否则默认值为cloud_efficiency。
    #[setters(generate = true, strip_option)]
    system_disk_category: Option<String>,
    /// 系统盘大小，单位为GiB。取值范围：
    ///
    /// - cloud：20~500。
    /// - 其他云盘种类：20~2048。
    ///
    /// 该参数的取值必须大于或者等于max{20, ImageSize}。
    #[setters(generate = true, strip_option)]
    system_disk_size: Option<i32>,
    /// 系统盘名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`或`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    system_disk_disk_name: Option<String>,
    /// 系统盘描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    system_disk_description: Option<String>,
    /// >该参数正在邀测中，暂未开放使用。
    #[setters(generate = true, strip_option)]
    system_disk_iops: Option<i32>,
    /// 创建ESSD云盘作为系统盘使用时，设置云盘的性能等级。取值范围：
    ///
    /// - PL0（默认）：单盘最高随机读写IOPS 1万。
    /// - PL1：单盘最高随机读写IOPS 5万。
    /// - PL2：单盘最高随机读写IOPS 10万。
    /// - PL3：单盘最高随机读写IOPS 100万。
    ///
    /// 有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。
    #[setters(generate = true, strip_option)]
    system_disk_performance_level: Option<String>,
    /// 系统盘是否随实例释放。取值范围：
    ///
    /// - true：随实例释放。
    /// - false：不随实例释放。
    ///
    /// 默认值：true。
    #[setters(generate = true, strip_option)]
    system_disk_delete_with_instance: Option<bool>,
    /// 系统盘采用的自动快照策略ID。
    #[setters(generate = true, strip_option)]
    system_disk_auto_snapshot_policy_id: Option<String>,
    /// ESSD AutoPL云盘预配置读写IOPS。取值范围：0~min{50000, 1000*容量-基准性能}。
    ///
    /// 基准性能=min{1,800+50*容量, 50,000}
    ///
    /// > 当DiskCategory取值为cloud_auto时才支持设置该参数。更多信息，请参见[ESSD AutoPL云盘](~~368372~~)和[修改ESSD AutoPL云盘预配置信息](~~413275~~)。
    #[setters(generate = true, strip_option)]
    system_disk_provisioned_iops: Option<i64>,
    /// 是否开启Burst（性能突发）。取值范围：
    ///
    /// - true：是。
    /// - false：否。
    #[setters(generate = true, strip_option)]
    system_disk_bursting_enabled: Option<bool>,
    /// 是否为I/O优化实例。取值范围：
    ///
    /// -   none：非I/O优化。
    /// -   optimized：I/O优化。
    #[setters(generate = true, strip_option)]
    io_optimized: Option<String>,
    /// 实例的计费方式。取值范围：
    ///
    /// - PrePaid：包年包月。选择该类付费方式时，<props="china"><ph>您必须确认自己的账号支持余额支付和信用支付</ph></props><props="intl"><ph>您必须确认自己的账号支持信用支付</ph></props>，否则将返回`InvalidPayMethod`的错误提示。
    /// - PostPaid：按量付费。
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 购买资源的时长，单位为：月。当创建实例时，参数`InstanceChargeType`取值为`PrePaid`时该参数才生效且为必选值。取值范围：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 网络计费方式。取值范围：
    ///
    /// - PayByBandwidth：按固定带宽计费。
    /// - PayByTraffic：按使用流量计费。
    ///
    /// > **按使用流量计费**模式下的出入带宽峰值都是带宽上限，不作为业务承诺指标。当出现资源争抢时，带宽峰值可能会受到限制。如果您的业务需要有带宽的保障，请使用**按固定带宽计费**模式。
    ///
    #[setters(generate = true, strip_option)]
    internet_charge_type: Option<String>,
    /// 是否启用实例操作系统配置。
    /// > 该参数即将被弃用，为提高兼容性，请尽量使用其他参数。
    #[setters(generate = true, strip_option)]
    enable_vm_os_config: Option<bool>,
    /// 实例网络类型。取值范围：
    ///
    /// - classic：经典网络。
    /// - vpc：专有网络VPC。
    #[setters(generate = true, strip_option)]
    network_type: Option<String>,
    /// 实例自定义数据，需要以Base64方式编码，原始数据最多为32 KB。
    #[setters(generate = true, strip_option)]
    user_data: Option<String>,
    /// 密钥对名称。
    ///
    /// -   Windows实例，忽略该参数。即使填写了该参数，仍旧只执行`Password`的内容。
    /// -   Linux实例的密码登录方式会被初始化成禁止。
    #[setters(generate = true, strip_option)]
    key_pair_name: Option<String>,
    /// 实例RAM角色名称。您可以使用RAM API [ListRoles](~~28713~~)查询您已创建的实例RAM角色。
    #[setters(generate = true, strip_option)]
    ram_role_name: Option<String>,
    /// 自动释放时间。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC时间。格式为：yyyy-MM-ddTHH:mm:ssZ。
    ///
    /// - 如果秒（`ss`）取值不是`00`，则自动取为当前分钟（`mm`）开始时。
    ///
    /// - 最短释放时间为当前时间半小时之后。
    ///
    /// - 最长释放时间不能超过当前时间三年。
    #[setters(generate = true, strip_option)]
    auto_release_time: Option<String>,
    /// 按量实例的抢占策略。当参数`InstanceChargeType`取值为`PostPaid`时生效。取值范围：
    ///
    /// -   NoSpot：正常按量付费实例。
    /// -   SpotWithPriceLimit：设置上限价格的抢占式实例。
    /// -   SpotAsPriceGo：系统自动出价，跟随当前市场实际价格。
    #[setters(generate = true, strip_option)]
    spot_strategy: Option<String>,
    /// 设置实例的每小时最高价格。支持最大3位小数，参数`SpotStrategy`取值为`SpotWithPriceLimit`时生效。
    #[setters(generate = true, strip_option)]
    spot_price_limit: Option<f32>,
    /// 抢占式实例的保留时长，单位为小时。 默认值：1。取值范围：
    /// - 1：创建后阿里云会保证实例运行1小时不会被自动释放；超过1小时后，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    /// - 0：创建后，阿里云不保证实例运行1小时，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    ///
    /// 实例回收前5分钟阿里云会通过ECS系统事件向您发送通知。抢占式实例按秒计费，建议您结合具体任务执行耗时来选择合适的保留时长。
    ///
    /// > 当SpotStrategy值为SpotWithPriceLimit或SpotAsPriceGo时该参数生效。
    #[setters(generate = true, strip_option)]
    spot_duration: Option<i32>,
    /// 实例、块存储和弹性网卡所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 启动模板所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    template_resource_group_id: Option<String>,
    /// 是否为操作系统开启安全加固。取值范围：
    ///
    /// -   Active：启用安全加固，只对公共镜像生效。
    /// -   Deactive：不启用安全加固，对所有镜像类型生效。
    #[setters(generate = true, strip_option)]
    security_enhancement_strategy: Option<String>,
    /// 实例私网IP地址。
    ///
    /// 专有网络VPC类型ECS实例设置私网IP地址时，必须从虚拟交换机（`VSwitchId`）的空闲网段中选择。
    #[setters(generate = true, strip_option)]
    private_ip_address: Option<String>,
    /// 部署集ID。
    #[setters(generate = true, strip_option)]
    deployment_set_id: Option<String>,
    /// 为主网卡指定随机生成的IPv6地址数量。取值范围为1~10。
    #[setters(generate = true, strip_option)]
    ipv6_address_count: Option<i32>,
    /// 数据盘信息列表。
    #[setters(generate = true, strip_option)]
    data_disk: Option<Vec<TemplateDataDisk>>,
    /// 弹性网卡信息。
    #[setters(generate = true, strip_option)]
    network_interface: Option<Vec<TemplateNetworkInterface>>,
    /// 通过该模板的版本创建的实例、云盘和主网卡的标签信息。
    ///
    /// <details>
    /// <summary>使用场景</summary>
    /// 通过调用CreateLaunchTemplate接口创建模版后，使用自动生成的默认版本来创建实例时，将使用此标签来标记实例、云盘和主网卡。
    /// </details>
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<LaunchTemplateTag>>,
    /// 实例加入的一个或多个安全组。N的取值范围与实例能够加入安全组配额有关，更多信息，请参见[使用限制](~~25412~~)。
    ///
    /// > 不支持同时指定`SecurityGroupId`和`SecurityGroupIds.N`。
    #[setters(generate = true, strip_option)]
    security_group_ids: Option<Vec<String>>,
    /// 系统盘是否加密。取值范围：
    ///
    /// - true：加密。
    /// - false：不加密。
    ///
    /// 默认值：false。
    ///
    /// >中国香港D可用区、新加坡A可用区暂不支持在创建实例时加密系统盘。
    #[setters(generate = true, strip_option)]
    system_disk_encrypted: Option<String>,
    /// 实例释放保护属性，指定是否支持通过控制台或API（[DeleteInstance](~~25507~~)）释放实例。取值范围：
    /// - true：开启实例释放保护。
    ///
    /// - false：关闭实例释放保护。
    ///
    /// 默认值：false。
    ///
    /// >该属性仅适用于按量付费实例，且只能限制手动释放操作，对系统释放操作不生效。
    #[setters(generate = true, strip_option)]
    deletion_protection: Option<bool>,
    /// 设置突发性能实例的运行模式。取值范围：
    ///
    /// - Standard：标准模式，实例性能请参见[什么是突发性能实例](~~59977~~)下的性能约束模式章节。
    /// - Unlimited：无性能约束模式，实例性能请参见[什么是突发性能实例](~~59977~~)下的无性能约束模式章节。
    #[setters(generate = true, strip_option)]
    credit_specification: Option<String>,
    /// 是否要自动续费。取值范围：
    ///
    /// - true：自动续费。
    /// - false：不自动续费。
    ///
    /// 默认值：false。
    ///
    /// > 当参数`InstanceChargeType`取值`PrePaid`时才生效。
    #[setters(generate = true, strip_option)]
    auto_renew: Option<bool>,
    /// 单次自动续费的续费时长。取值范围：
    ///          
    /// <props="china">
    /// - PeriodUnit=Week时：1、2、3。
    /// - PeriodUnit=Month时：1、2、3、6、12、24、36、48、60。
    ///
    /// </props>
    ///
    /// <props="intl">PeriodUnit=Month时：1、2、3、6、12、24、36、48、60。</props>
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    auto_renew_period: Option<i32>,
    /// 包年包月计费方式的时长单位。取值范围：
    ///
    /// <props="china">
    /// - Week。
    /// - Month（默认）。
    ///
    /// </props>
    ///
    /// <props="intl">Month（默认）。</props>
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 是否启用实例元数据的访问通道。取值范围：
    ///
    /// - enabled：启用。
    /// - disabled：禁用。
    ///
    /// 默认值：enabled。
    ///
    /// > 有关实例元数据的信息，请参见[实例元数据概述](~~108460~~)。
    #[setters(generate = true, strip_option)]
    http_endpoint: Option<String>,
    /// 访问实例元数据时是否强制使用加固模式（IMDSv2）。取值范围：
    ///
    /// - optional：不强制使用。
    /// - required：强制使用。设置该取值后，普通模式无法访问实例元数据。
    ///
    /// 默认值：optional。
    ///
    /// > 有关访问实例元数据的模式，请参见[实例元数据概述](~~108460~~)。
    #[setters(generate = true, strip_option)]
    http_tokens: Option<String>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    http_put_response_hop_limit: Option<i32>,
    /// 系统盘对应的KMS密钥ID。
    #[setters(generate = true, strip_option)]
    system_disk_kms_key_id: Option<String>,
    /// 镜像相关属性信息。
    #[setters(generate = true, strip_option)]
    image_options: Option<TemplateImageOptions>,
    /// 安全选项。
    #[setters(generate = true, strip_option)]
    security_options: Option<TemplateSecurityOptions>,
}

impl sealed::Bound for CreateLaunchTemplate {}

impl CreateLaunchTemplate {
    pub fn new(region_id: impl Into<String>, launch_template_name: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            template_tag: None,
            launch_template_name: launch_template_name.into(),
            version_description: None,
            image_id: None,
            image_owner_alias: None,
            password_inherit: None,
            instance_type: None,
            security_group_id: None,
            vpc_id: None,
            v_switch_id: None,
            instance_name: None,
            description: None,
            internet_max_bandwidth_in: None,
            internet_max_bandwidth_out: None,
            host_name: None,
            zone_id: None,
            system_disk_category: None,
            system_disk_size: None,
            system_disk_disk_name: None,
            system_disk_description: None,
            system_disk_iops: None,
            system_disk_performance_level: None,
            system_disk_delete_with_instance: None,
            system_disk_auto_snapshot_policy_id: None,
            system_disk_provisioned_iops: None,
            system_disk_bursting_enabled: None,
            io_optimized: None,
            instance_charge_type: None,
            period: None,
            internet_charge_type: None,
            enable_vm_os_config: None,
            network_type: None,
            user_data: None,
            key_pair_name: None,
            ram_role_name: None,
            auto_release_time: None,
            spot_strategy: None,
            spot_price_limit: None,
            spot_duration: None,
            resource_group_id: None,
            template_resource_group_id: None,
            security_enhancement_strategy: None,
            private_ip_address: None,
            deployment_set_id: None,
            ipv6_address_count: None,
            data_disk: None,
            network_interface: None,
            tag: None,
            security_group_ids: None,
            system_disk_encrypted: None,
            deletion_protection: None,
            credit_specification: None,
            auto_renew: None,
            auto_renew_period: None,
            period_unit: None,
            http_endpoint: None,
            http_tokens: None,
            http_put_response_hop_limit: None,
            system_disk_kms_key_id: None,
            image_options: None,
            security_options: None,
        }
    }
}
impl crate::ToFormData for CreateLaunchTemplate {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateLaunchTemplate {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateLaunchTemplate";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateLaunchTemplateResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(62);

        if let Some(f) = &self.auto_release_time {
            params.push(("AutoReleaseTime".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew {
            params.push(("AutoRenew".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew_period {
            params.push(("AutoRenewPeriod".into(), (f).into()));
        }

        if let Some(f) = &self.credit_specification {
            params.push(("CreditSpecification".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk {
            crate::FlatSerialize::flat_serialize(f, "DataDisk", &mut params);
        }

        if let Some(f) = &self.deletion_protection {
            params.push(("DeletionProtection".into(), (f).into()));
        }

        if let Some(f) = &self.deployment_set_id {
            params.push(("DeploymentSetId".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.enable_vm_os_config {
            params.push(("EnableVmOsConfig".into(), (f).into()));
        }

        if let Some(f) = &self.host_name {
            params.push(("HostName".into(), (f).into()));
        }

        if let Some(f) = &self.http_endpoint {
            params.push(("HttpEndpoint".into(), (f).into()));
        }

        if let Some(f) = &self.http_put_response_hop_limit {
            params.push(("HttpPutResponseHopLimit".into(), (f).into()));
        }

        if let Some(f) = &self.http_tokens {
            params.push(("HttpTokens".into(), (f).into()));
        }

        if let Some(f) = &self.image_id {
            params.push(("ImageId".into(), (f).into()));
        }

        if let Some(f) = &self.image_options {
            crate::FlatSerialize::flat_serialize(f, "ImageOptions", &mut params);
        }

        if let Some(f) = &self.image_owner_alias {
            params.push(("ImageOwnerAlias".into(), (f).into()));
        }

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_name {
            params.push(("InstanceName".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.internet_charge_type {
            params.push(("InternetChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_in {
            params.push(("InternetMaxBandwidthIn".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_out {
            params.push(("InternetMaxBandwidthOut".into(), (f).into()));
        }

        if let Some(f) = &self.io_optimized {
            params.push(("IoOptimized".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_address_count {
            params.push(("Ipv6AddressCount".into(), (f).into()));
        }

        if let Some(f) = &self.key_pair_name {
            params.push(("KeyPairName".into(), (f).into()));
        }
        params.push((
            "LaunchTemplateName".into(),
            (&self.launch_template_name).into(),
        ));

        if let Some(f) = &self.network_interface {
            crate::FlatSerialize::flat_serialize(f, "NetworkInterface", &mut params);
        }

        if let Some(f) = &self.network_type {
            params.push(("NetworkType".into(), (f).into()));
        }

        if let Some(f) = &self.password_inherit {
            params.push(("PasswordInherit".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }

        if let Some(f) = &self.private_ip_address {
            params.push(("PrivateIpAddress".into(), (f).into()));
        }

        if let Some(f) = &self.ram_role_name {
            params.push(("RamRoleName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_enhancement_strategy {
            params.push(("SecurityEnhancementStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_id {
            params.push(("SecurityGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_ids {
            crate::FlatSerialize::flat_serialize(f, "SecurityGroupIds", &mut params);
        }

        if let Some(f) = &self.security_options {
            crate::FlatSerialize::flat_serialize(f, "SecurityOptions", &mut params);
        }

        if let Some(f) = &self.spot_duration {
            params.push(("SpotDuration".into(), (f).into()));
        }

        if let Some(f) = &self.spot_price_limit {
            params.push(("SpotPriceLimit".into(), (f).into()));
        }

        if let Some(f) = &self.spot_strategy {
            params.push(("SpotStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_auto_snapshot_policy_id {
            params.push(("SystemDisk.AutoSnapshotPolicyId".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_bursting_enabled {
            params.push(("SystemDisk.BurstingEnabled".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_category {
            params.push(("SystemDisk.Category".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_delete_with_instance {
            params.push(("SystemDisk.DeleteWithInstance".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_description {
            params.push(("SystemDisk.Description".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_disk_name {
            params.push(("SystemDisk.DiskName".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_encrypted {
            params.push(("SystemDisk.Encrypted".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_iops {
            params.push(("SystemDisk.Iops".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_kms_key_id {
            params.push(("SystemDisk.KMSKeyId".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_performance_level {
            params.push(("SystemDisk.PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_provisioned_iops {
            params.push(("SystemDisk.ProvisionedIops".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_size {
            params.push(("SystemDisk.Size".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.template_resource_group_id {
            params.push(("TemplateResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.template_tag {
            crate::FlatSerialize::flat_serialize(f, "TemplateTag", &mut params);
        }

        if let Some(f) = &self.user_data {
            params.push(("UserData".into(), (f).into()));
        }

        if let Some(f) = &self.v_switch_id {
            params.push(("VSwitchId".into(), (f).into()));
        }

        if let Some(f) = &self.version_description {
            params.push(("VersionDescription".into(), (f).into()));
        }

        if let Some(f) = &self.vpc_id {
            params.push(("VpcId".into(), (f).into()));
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeLaunchTemplates {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 启动模版自身的标签对信息列表。
    /// > 当前仅支持通过API创建和查询启动模板的标签，控制台无法创建或查看。
    #[setters(generate = true, strip_option)]
    template_tag: Option<Vec<TemplatesTemplateTag>>,
    /// 实例启动模板列表的页码。起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 启动模板所在的企业资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    template_resource_group_id: Option<String>,
    /// 一个或多个实例启动模板ID数组。
    ///
    /// - 最多支持查询100个启动模板。
    ///
    /// - 您必须指定LaunchTemplateId或LaunchTemplateName以确定模板。
    #[setters(generate = true, strip_option)]
    launch_template_id: Option<Vec<String>>,
    /// 一个或多个实例启动模板名称数组。
    ///
    /// - 最多支持查询100个启动模板。
    ///
    /// - 您必须指定LaunchTemplateId或LaunchTemplateName以确定模板。
    #[setters(generate = true, strip_option)]
    launch_template_name: Option<Vec<String>>,
}

impl sealed::Bound for DescribeLaunchTemplates {}

impl DescribeLaunchTemplates {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            template_tag: None,
            page_number: None,
            page_size: None,
            template_resource_group_id: None,
            launch_template_id: None,
            launch_template_name: None,
        }
    }
}
impl crate::ToFormData for DescribeLaunchTemplates {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeLaunchTemplates {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeLaunchTemplates";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeLaunchTemplatesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.launch_template_id {
            crate::FlatSerialize::flat_serialize(f, "LaunchTemplateId", &mut params);
        }

        if let Some(f) = &self.launch_template_name {
            crate::FlatSerialize::flat_serialize(f, "LaunchTemplateName", &mut params);
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.template_resource_group_id {
            params.push(("TemplateResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.template_tag {
            crate::FlatSerialize::flat_serialize(f, "TemplateTag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteLaunchTemplate {
    /// 实例启动模板所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 启动模板ID。更多信息，请参见[DescribeLaunchTemplates](~~73759~~)。
    ///
    /// 您必须指定 `LaunchTemplateId` 或 `LaunchTemplateName` 以确定启动模板。
    #[setters(generate = true, strip_option)]
    launch_template_id: Option<String>,
    /// 启动模板名称。
    ///
    /// 您必须指定`LaunchTemplateId`或`LaunchTemplateName`以确定启动模板。
    #[setters(generate = true, strip_option)]
    launch_template_name: Option<String>,
}

impl sealed::Bound for DeleteLaunchTemplate {}

impl DeleteLaunchTemplate {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            launch_template_id: None,
            launch_template_name: None,
        }
    }
}
impl crate::ToFormData for DeleteLaunchTemplate {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteLaunchTemplate {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteLaunchTemplate";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteLaunchTemplateResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.launch_template_id {
            params.push(("LaunchTemplateId".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_name {
            params.push(("LaunchTemplateName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateLaunchTemplateVersion {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 启动模板ID。更多信息，请调用[DescribeLaunchTemplates](~~73759~~)。您必须指定`LaunchTemplateId`或`LaunchTemplateName`以确定启动模板。
    #[setters(generate = true, strip_option)]
    launch_template_id: Option<String>,
    /// 实例启动模板名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`或`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    launch_template_name: Option<String>,
    /// 实例启动模板版本的描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    version_description: Option<String>,
    /// 镜像ID，启动实例时选择的镜像资源。您可以通过[DescribeImages](~~25534~~)查询您可以使用的镜像资源。
    #[setters(generate = true, strip_option)]
    image_id: Option<String>,
    /// 镜像来源。
    /// > 该参数即将被弃用，为提高兼容性，请尽量使用其他参数。
    #[setters(generate = true, strip_option)]
    image_owner_alias: Option<String>,
    /// 是否使用镜像预设的密码。取值范围：
    /// - true。
    /// - false。
    ///
    /// 默认值：false。
    ///
    /// > 使用该参数时，Password参数必须为空。同时您需要确保使用的镜像已经设置了密码。
    ///
    #[setters(generate = true, strip_option)]
    password_inherit: Option<bool>,
    /// 实例的规格。更多信息，请参见[实例规格族](~~25378~~)，您也可以调用[DescribeInstanceTypes](~~25620~~)接口获得最新的规格表。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 指定使用该版本创建实例所属于的安全组ID。同一个安全组内的实例之间可以互相访问。
    ///
    /// > 不支持同时指定`SecurityGroupId`和`SecurityGroupIds.N`。
    #[setters(generate = true, strip_option)]
    security_group_id: Option<String>,
    /// 实例所属专有网络VPC ID。
    #[setters(generate = true, strip_option)]
    vpc_id: Option<String>,
    /// 创建VPC类型实例时需要指定虚拟交换机ID。
    #[setters(generate = true, strip_option)]
    v_switch_id: Option<String>,
    /// 实例名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。默认值为实例的`InstanceId`。
    ///
    /// 创建多台ECS实例时，您可以批量设置有序的实例名称，并且可以包含方括号（[]）和逗号（,）。具体操作，请参见[批量设置有序的实例名称或主机名称](~~196048~~)。
    #[setters(generate = true, strip_option)]
    instance_name: Option<String>,
    /// 实例描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 公网入带宽最大值，单位为Mbit/s。取值范围：
    ///
    /// - 当所购公网出带宽小于等于10 Mbit/s时：1~10，默认为10。
    /// - 当所购公网出带宽大于10 Mbit/s时：1~`InternetMaxBandwidthOut`的取值，默认为`InternetMaxBandwidthOut`的取值。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_in: Option<i32>,
    /// 公网出带宽最大值，单位为Mbit/s。取值范围为0~100。
    #[setters(generate = true, strip_option)]
    internet_max_bandwidth_out: Option<i32>,
    /// 云服务器的主机名。
    ///
    /// -   半角句号（.）和短划线（-）不能作为首尾字符，更不能连续使用。
    /// -   Windows实例：字符长度为2~15，不支持半角句号（.），不能全是数字。允许大小写英文字母、数字和短划线（-）。
    /// -   其他类型实例（Linux等）：字符长度为2~64，支持多个半角句号（.），半角句号之间为一段，每段允许大小写英文字母、数字和短划线（-）。
    #[setters(generate = true, strip_option)]
    host_name: Option<String>,
    /// 实例所属的可用区ID。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 系统盘的云盘种类。取值范围：
    ///
    /// -   cloud：普通云盘。
    /// -   cloud_efficiency：高效云盘。
    /// -   cloud_ssd：SSD云盘。
    /// -   cloud_auto：ESSD AutoPL云盘。
    /// -   cloud_essd：ESSD云盘。您可以通过参数`SystemDisk.PerformanceLevel`设置云盘的性能等级。
    /// - cloud_essd_entry：ESSD Entry 云盘。
    ///
    /// 已停售的实例规格且非I/O优化实例默认值为cloud，否则默认值为cloud_efficiency。
    #[setters(generate = true, strip_option)]
    system_disk_category: Option<String>,
    /// 系统盘大小，单位为GiB。取值范围：
    ///
    /// - cloud：20~500。
    /// - 其他云盘种类：20~2048。
    ///
    /// 该参数的取值必须大于或者等于max{20, ImageSize}。
    #[setters(generate = true, strip_option)]
    system_disk_size: Option<i32>,
    /// 系统盘名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`或`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    system_disk_disk_name: Option<String>,
    /// 系统盘描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    system_disk_description: Option<String>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    system_disk_iops: Option<i32>,
    /// 创建ESSD云盘作为系统盘使用时，设置云盘的性能等级。取值范围：
    ///
    /// - PL0（默认）：单盘最高随机读写IOPS 1万。
    /// - PL1：单盘最高随机读写IOPS 5万。
    /// - PL2：单盘最高随机读写IOPS 10万。
    /// - PL3：单盘最高随机读写IOPS 100万。
    ///
    /// 有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。
    #[setters(generate = true, strip_option)]
    system_disk_performance_level: Option<String>,
    /// 系统盘是否随实例释放。取值范围：
    ///
    /// - true：随实例释放。
    /// - false：不随实例释放。
    ///
    /// 默认值：true。
    #[setters(generate = true, strip_option)]
    system_disk_delete_with_instance: Option<bool>,
    /// 系统盘采用的自动快照策略ID。
    #[setters(generate = true, strip_option)]
    system_disk_auto_snapshot_policy_id: Option<String>,
    /// 是否修改ESSD AutoPL云盘预配置读写IOPS。取值范围：0~min{50000, 1000*容量-基准性能}。
    ///
    /// 基准性能=min{1,800+50*容量, 50,000}。
    ///
    /// > 当DiskCategory取值为cloud_auto时才支持设置该参数。更多信息，请参见[ESSD AutoPL云盘](~~368372~~)和[修改ESSD AutoPL云盘预配置信息](~~413275~~)。
    ///
    #[setters(generate = true, strip_option)]
    system_disk_provisioned_iops: Option<i64>,
    /// 是否开启Burst（性能突发）。取值范围：
    ///
    /// - true：是。
    /// - false：否。
    #[setters(generate = true, strip_option)]
    system_disk_bursting_enabled: Option<bool>,
    /// 是否为I/O优化实例。取值范围：
    ///
    /// -   none：非I/O优化。
    /// -   optimized：I/O优化。
    #[setters(generate = true, strip_option)]
    io_optimized: Option<String>,
    /// 实例的计费方式。取值范围：
    ///
    /// <props="china">
    /// - PrePaid：包年包月。选择该类计费方式时，您必须确认自己的账号支持余额支付和信用支付，否则将返回`InvalidPayMethod`的错误提示。
    /// - PostPaid：按量付费。
    ///
    /// </props>
    /// <props="intl">
    /// - PrePaid：包年包月。选择该类计费方式时，您必须确认自己的账号支持信用支付，否则将返回`InvalidPayMethod`的错误提示。
    /// - PostPaid：按量付费。
    ///
    /// </props>
    /// <props="partner">
    /// - PrePaid：包年包月。选择该类计费方式时，您必须确认自己的账号支持信用支付，否则将返回`InvalidPayMethod`的错误提示。
    /// - PostPaid：按量付费。
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 购买资源的时长，单位为：月。当参数`InstanceChargeType`取值为`PrePaid`时该参数才生效且为必选值。取值范围：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 公网出方向带宽计费方式。取值范围：
    ///
    /// - PayByBandwidth：按固定带宽计费。
    /// - PayByTraffic：按使用流量计费。
    ///
    /// > **按使用流量计费**模式下的出入带宽峰值都是带宽上限，不作为业务承诺指标。当出现资源争抢时，带宽峰值可能会受到限制。如果您的业务需要有带宽的保障，请使用**按固定带宽计费**模式。
    ///
    #[setters(generate = true, strip_option)]
    internet_charge_type: Option<String>,
    /// 是否启用实例操作系统配置。
    #[setters(generate = true, strip_option)]
    enable_vm_os_config: Option<bool>,
    /// 实例网络类型。取值范围：
    ///
    /// - classic：经典网络。
    /// - vpc：专有网络VPC。
    #[setters(generate = true, strip_option)]
    network_type: Option<String>,
    /// 实例自定义数据，需要以Base64方式编码，原始数据最多为32 KB。
    #[setters(generate = true, strip_option)]
    user_data: Option<String>,
    /// 密钥对名称。
    ///
    /// -   Windows实例，忽略该参数。即使填写了该参数，仍旧只执行`Password`的内容。
    /// -   Linux实例的密码登录方式会被初始化成禁止。
    #[setters(generate = true, strip_option)]
    key_pair_name: Option<String>,
    /// 实例RAM角色名称。您可以使用RAM API [ListRoles](~~28713~~)查询您已创建的实例RAM角色。
    #[setters(generate = true, strip_option)]
    ram_role_name: Option<String>,
    /// 自动释放时间。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC时间。格式为：yyyy-MM-ddTHH:mm:ssZ。
    ///
    /// - 如果秒（`ss`）取值不是`00`，则自动取为当前分钟（`mm`）开始时。
    ///
    /// - 最短释放时间为当前时间半小时之后。
    ///
    /// - 最长释放时间不能超过当前时间三年。
    #[setters(generate = true, strip_option)]
    auto_release_time: Option<String>,
    /// 按量实例的抢占策略。当参数`InstanceChargeType`取值为`PostPaid`时生效。取值范围：
    ///
    /// -   NoSpot：正常按量付费实例。
    /// -   SpotWithPriceLimit：设置上限价格的抢占式实例。
    /// -   SpotAsPriceGo：系统自动出价，跟随当前市场实际价格。
    #[setters(generate = true, strip_option)]
    spot_strategy: Option<String>,
    /// 设置实例的每小时最高价格。支持最大3位小数。
    #[setters(generate = true, strip_option)]
    spot_price_limit: Option<f32>,
    /// 抢占式实例的保留时长，单位为小时。 默认值：1。取值范围：
    /// - 1：创建后阿里云会保证实例运行1小时不会被自动释放；超过1小时后，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    /// - 0：创建后，阿里云不保证实例运行1小时，系统会自动比较出价与市场价格、检查资源库存，来决定实例的持有和回收。
    ///
    /// 实例回收前5分钟阿里云会通过ECS系统事件向您发送通知。抢占式实例按秒计费，建议您结合具体任务执行耗时来选择合适的保留时长。
    ///
    /// > 当SpotStrategy值为SpotWithPriceLimit或SpotAsPriceGo时该参数生效。
    #[setters(generate = true, strip_option)]
    spot_duration: Option<i32>,
    /// 资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 是否为操作系统开启安全加固。取值范围：
    ///
    /// -   Active：启用安全加固，只对公共镜像生效。
    /// -   Deactive：不启用安全加固，对所有镜像类型生效。
    #[setters(generate = true, strip_option)]
    security_enhancement_strategy: Option<String>,
    /// 实例私网IP地址。
    ///
    /// 专有网络VPC类型ECS实例设置私网IP地址时，必须从虚拟交换机（`VSwitchId`）的空闲网段中选择。
    #[setters(generate = true, strip_option)]
    private_ip_address: Option<String>,
    /// 为主网卡指定随机生成的IPv6地址数量。取值范围为1~10。
    #[setters(generate = true, strip_option)]
    ipv6_address_count: Option<i32>,
    /// 部署集ID。
    #[setters(generate = true, strip_option)]
    deployment_set_id: Option<String>,
    /// 数据盘列表。
    #[setters(generate = true, strip_option)]
    data_disk: Option<Vec<VersionDataDisk>>,
    /// 弹性网卡信息。
    #[setters(generate = true, strip_option)]
    network_interface: Option<Vec<VersionNetworkInterface>>,
    /// 通过该版本创建的实例、云盘和主网卡的标签信息。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<VersionTag>>,
    /// 实例加入的一个或多个安全组。N的取值范围与实例能够加入安全组配额有关。更多信息，[使用限制](~~25412~~)。
    ///
    /// > 不支持同时指定`SecurityGroupId`和`SecurityGroupIds.N`。
    #[setters(generate = true, strip_option)]
    security_group_ids: Option<Vec<String>>,
    /// 系统盘是否加密。取值范围：
    ///
    /// - true：加密。
    ///
    /// - false：不加密。
    ///
    /// 默认值：false。
    ///
    /// >中国香港D可用区、新加坡A可用区暂不支持在创建实例时加密系统盘。
    #[setters(generate = true, strip_option)]
    system_disk_encrypted: Option<String>,
    /// 实例释放保护属性，指定是否支持通过控制台或API（[DeleteInstance](~~25507~~)）释放实例。取值范围：
    /// - true：开启实例释放保护。
    ///
    /// - false：关闭实例释放保护。
    ///
    /// 默认值：false。
    ///
    /// >该属性仅适用于按量付费实例，且只能限制手动释放操作，对系统释放操作不生效。
    #[setters(generate = true, strip_option)]
    deletion_protection: Option<bool>,
    /// 设置突发性能实例的运行模式。取值范围：
    ///
    /// - Standard：标准模式，实例性能请参见[什么是突发性能实例](~~59977~~)下的性能约束模式章节。
    /// - Unlimited：无性能约束模式，实例性能请参见[什么是突发性能实例](~~59977~~)下的无性能约束模式章节。
    #[setters(generate = true, strip_option)]
    credit_specification: Option<String>,
    /// 是否要自动续费。当参数`InstanceChargeType`取值`PrePaid`时才生效。取值范围：
    ///
    /// - true：自动续费。
    /// - false：不自动续费。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    auto_renew: Option<bool>,
    /// 单次自动续费的续费时长。取值范围：
    ///          
    /// <props="china">
    /// - PeriodUnit=Week时：1、2、3。
    /// - PeriodUnit=Month时：1、2、3、6、12、24、36、48、60。
    ///
    /// </props>
    ///
    /// <props="intl">PeriodUnit=Month时：1、2、3、6、12、24、36、48、60。</props>
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    auto_renew_period: Option<i32>,
    /// 包年包月计费方式的时长单位。取值范围：
    ///
    /// <props="china">
    /// - Week。
    /// - Month（默认）。
    ///
    /// </props>
    ///
    /// <props="intl">Month（默认）。</props>
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 是否启用实例元数据的访问通道。取值范围：
    ///
    /// - enabled：启用。
    /// - disabled：禁用。
    ///
    /// 默认值：enabled。
    ///
    /// > 有关实例元数据的信息，请参见[实例元数据概述](~~108460~~)。
    #[setters(generate = true, strip_option)]
    http_endpoint: Option<String>,
    /// 访问实例元数据时是否强制使用加固模式（IMDSv2）。取值范围：
    ///
    /// - optional：不强制使用。
    /// - required：强制使用。设置该取值后，普通模式无法访问实例元数据。
    ///
    /// 默认值：optional。
    ///
    /// > 有关访问实例元数据的模式，请参见[实例元数据概述](~~108460~~)。
    #[setters(generate = true, strip_option)]
    http_tokens: Option<String>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    http_put_response_hop_limit: Option<i32>,
    /// 系统盘对应的KMS密钥ID。
    #[setters(generate = true, strip_option)]
    system_disk_kms_key_id: Option<String>,
    /// 镜像相关属性信息。
    #[setters(generate = true, strip_option)]
    image_options: Option<VersionImageOptions>,
    /// 安全选项。
    #[setters(generate = true, strip_option)]
    security_options: Option<VersionSecurityOptions>,
}

impl sealed::Bound for CreateLaunchTemplateVersion {}

impl CreateLaunchTemplateVersion {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            launch_template_id: None,
            launch_template_name: None,
            version_description: None,
            image_id: None,
            image_owner_alias: None,
            password_inherit: None,
            instance_type: None,
            security_group_id: None,
            vpc_id: None,
            v_switch_id: None,
            instance_name: None,
            description: None,
            internet_max_bandwidth_in: None,
            internet_max_bandwidth_out: None,
            host_name: None,
            zone_id: None,
            system_disk_category: None,
            system_disk_size: None,
            system_disk_disk_name: None,
            system_disk_description: None,
            system_disk_iops: None,
            system_disk_performance_level: None,
            system_disk_delete_with_instance: None,
            system_disk_auto_snapshot_policy_id: None,
            system_disk_provisioned_iops: None,
            system_disk_bursting_enabled: None,
            io_optimized: None,
            instance_charge_type: None,
            period: None,
            internet_charge_type: None,
            enable_vm_os_config: None,
            network_type: None,
            user_data: None,
            key_pair_name: None,
            ram_role_name: None,
            auto_release_time: None,
            spot_strategy: None,
            spot_price_limit: None,
            spot_duration: None,
            resource_group_id: None,
            security_enhancement_strategy: None,
            private_ip_address: None,
            ipv6_address_count: None,
            deployment_set_id: None,
            data_disk: None,
            network_interface: None,
            tag: None,
            security_group_ids: None,
            system_disk_encrypted: None,
            deletion_protection: None,
            credit_specification: None,
            auto_renew: None,
            auto_renew_period: None,
            period_unit: None,
            http_endpoint: None,
            http_tokens: None,
            http_put_response_hop_limit: None,
            system_disk_kms_key_id: None,
            image_options: None,
            security_options: None,
        }
    }
}
impl crate::ToFormData for CreateLaunchTemplateVersion {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateLaunchTemplateVersion {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateLaunchTemplateVersion";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateLaunchTemplateVersionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(61);

        if let Some(f) = &self.auto_release_time {
            params.push(("AutoReleaseTime".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew {
            params.push(("AutoRenew".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew_period {
            params.push(("AutoRenewPeriod".into(), (f).into()));
        }

        if let Some(f) = &self.credit_specification {
            params.push(("CreditSpecification".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk {
            crate::FlatSerialize::flat_serialize(f, "DataDisk", &mut params);
        }

        if let Some(f) = &self.deletion_protection {
            params.push(("DeletionProtection".into(), (f).into()));
        }

        if let Some(f) = &self.deployment_set_id {
            params.push(("DeploymentSetId".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.enable_vm_os_config {
            params.push(("EnableVmOsConfig".into(), (f).into()));
        }

        if let Some(f) = &self.host_name {
            params.push(("HostName".into(), (f).into()));
        }

        if let Some(f) = &self.http_endpoint {
            params.push(("HttpEndpoint".into(), (f).into()));
        }

        if let Some(f) = &self.http_put_response_hop_limit {
            params.push(("HttpPutResponseHopLimit".into(), (f).into()));
        }

        if let Some(f) = &self.http_tokens {
            params.push(("HttpTokens".into(), (f).into()));
        }

        if let Some(f) = &self.image_id {
            params.push(("ImageId".into(), (f).into()));
        }

        if let Some(f) = &self.image_options {
            crate::FlatSerialize::flat_serialize(f, "ImageOptions", &mut params);
        }

        if let Some(f) = &self.image_owner_alias {
            params.push(("ImageOwnerAlias".into(), (f).into()));
        }

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_name {
            params.push(("InstanceName".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.internet_charge_type {
            params.push(("InternetChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_in {
            params.push(("InternetMaxBandwidthIn".into(), (f).into()));
        }

        if let Some(f) = &self.internet_max_bandwidth_out {
            params.push(("InternetMaxBandwidthOut".into(), (f).into()));
        }

        if let Some(f) = &self.io_optimized {
            params.push(("IoOptimized".into(), (f).into()));
        }

        if let Some(f) = &self.ipv6_address_count {
            params.push(("Ipv6AddressCount".into(), (f).into()));
        }

        if let Some(f) = &self.key_pair_name {
            params.push(("KeyPairName".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_id {
            params.push(("LaunchTemplateId".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_name {
            params.push(("LaunchTemplateName".into(), (f).into()));
        }

        if let Some(f) = &self.network_interface {
            crate::FlatSerialize::flat_serialize(f, "NetworkInterface", &mut params);
        }

        if let Some(f) = &self.network_type {
            params.push(("NetworkType".into(), (f).into()));
        }

        if let Some(f) = &self.password_inherit {
            params.push(("PasswordInherit".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }

        if let Some(f) = &self.private_ip_address {
            params.push(("PrivateIpAddress".into(), (f).into()));
        }

        if let Some(f) = &self.ram_role_name {
            params.push(("RamRoleName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_enhancement_strategy {
            params.push(("SecurityEnhancementStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_id {
            params.push(("SecurityGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.security_group_ids {
            crate::FlatSerialize::flat_serialize(f, "SecurityGroupIds", &mut params);
        }

        if let Some(f) = &self.security_options {
            crate::FlatSerialize::flat_serialize(f, "SecurityOptions", &mut params);
        }

        if let Some(f) = &self.spot_duration {
            params.push(("SpotDuration".into(), (f).into()));
        }

        if let Some(f) = &self.spot_price_limit {
            params.push(("SpotPriceLimit".into(), (f).into()));
        }

        if let Some(f) = &self.spot_strategy {
            params.push(("SpotStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_auto_snapshot_policy_id {
            params.push(("SystemDisk.AutoSnapshotPolicyId".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_bursting_enabled {
            params.push(("SystemDisk.BurstingEnabled".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_category {
            params.push(("SystemDisk.Category".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_delete_with_instance {
            params.push(("SystemDisk.DeleteWithInstance".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_description {
            params.push(("SystemDisk.Description".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_disk_name {
            params.push(("SystemDisk.DiskName".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_encrypted {
            params.push(("SystemDisk.Encrypted".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_iops {
            params.push(("SystemDisk.Iops".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_kms_key_id {
            params.push(("SystemDisk.KMSKeyId".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_performance_level {
            params.push(("SystemDisk.PerformanceLevel".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_provisioned_iops {
            params.push(("SystemDisk.ProvisionedIops".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_size {
            params.push(("SystemDisk.Size".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.user_data {
            params.push(("UserData".into(), (f).into()));
        }

        if let Some(f) = &self.v_switch_id {
            params.push(("VSwitchId".into(), (f).into()));
        }

        if let Some(f) = &self.version_description {
            params.push(("VersionDescription".into(), (f).into()));
        }

        if let Some(f) = &self.vpc_id {
            params.push(("VpcId".into(), (f).into()));
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeLaunchTemplateVersions {
    /// 实例启动模板所属的地域ID。
    ///
    /// 您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 一个或多个实例启动模板版本号。
    #[setters(generate = true, strip_option)]
    launch_template_version: Option<Vec<i64>>,
    /// 实例启动模板ID。
    ///
    /// 您必须指定`LaunchTemplateId`或`LaunchTemplateName`以确定模板。
    #[setters(generate = true, strip_option)]
    launch_template_id: Option<String>,
    /// 实例启动模板名称。
    ///
    /// 您必须指定`LaunchTemplateId`或`LaunchTemplateName`以确定模板。
    #[setters(generate = true, strip_option)]
    launch_template_name: Option<String>,
    /// 限定查询的最小版本号。与`MaxVersion`结合使用，可查询最小版本号和最大版本号区间的版本信息。
    #[setters(generate = true, strip_option)]
    min_version: Option<i64>,
    /// 限定查询的最大版本号。与`MinVersion`结合使用，可查询最小版本号和最大版本号区间的版本信息。
    #[setters(generate = true, strip_option)]
    max_version: Option<i64>,
    /// 是否查询默认版本。
    #[setters(generate = true, strip_option)]
    default_version: Option<bool>,
    /// 是否查询模板配置详细信息。取值范围：
    ///
    /// - true：查询模版配置详细信息，在模版基本信息的基础上，还会返回模版配置细节，如镜像ID、系统盘大小等。
    ///
    /// - false：只查询模版基本信息，如模版ID、模版名称、默认版本等。
    ///
    /// 默认值：true。
    #[setters(generate = true, strip_option)]
    detail_flag: Option<bool>,
    /// 实例启动模板列表的页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeLaunchTemplateVersions {}

impl DescribeLaunchTemplateVersions {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            launch_template_version: None,
            launch_template_id: None,
            launch_template_name: None,
            min_version: None,
            max_version: None,
            default_version: None,
            detail_flag: None,
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeLaunchTemplateVersions {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeLaunchTemplateVersions {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeLaunchTemplateVersions";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeLaunchTemplateVersionsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.default_version {
            params.push(("DefaultVersion".into(), (f).into()));
        }

        if let Some(f) = &self.detail_flag {
            params.push(("DetailFlag".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_id {
            params.push(("LaunchTemplateId".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_name {
            params.push(("LaunchTemplateName".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_version {
            crate::FlatSerialize::flat_serialize(f, "LaunchTemplateVersion", &mut params);
        }

        if let Some(f) = &self.max_version {
            params.push(("MaxVersion".into(), (f).into()));
        }

        if let Some(f) = &self.min_version {
            params.push(("MinVersion".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyLaunchTemplateDefaultVersion {
    /// 模板所属的地域ID。您可以调用 [DescribeRegions](~~25609~~) 查看最新的阿里云地域列表。
    region_id: String,
    /// 启动模板ID。您必须指定LaunchTemplateId或LaunchTemplateName以确定模板。
    #[setters(generate = true, strip_option)]
    launch_template_id: Option<String>,
    /// 启动模板名称。您必须指定LaunchTemplateId或LaunchTemplateName以确定模板。
    #[setters(generate = true, strip_option)]
    launch_template_name: Option<String>,
    /// 设置为默认版本的启动模板版本号。
    default_version_number: i64,
}

impl sealed::Bound for ModifyLaunchTemplateDefaultVersion {}

impl ModifyLaunchTemplateDefaultVersion {
    pub fn new(region_id: impl Into<String>, default_version_number: impl Into<i64>) -> Self {
        Self {
            region_id: region_id.into(),
            launch_template_id: None,
            launch_template_name: None,
            default_version_number: default_version_number.into(),
        }
    }
}
impl crate::ToFormData for ModifyLaunchTemplateDefaultVersion {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyLaunchTemplateDefaultVersion {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyLaunchTemplateDefaultVersion";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyLaunchTemplateDefaultVersionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push((
            "DefaultVersionNumber".into(),
            (&self.default_version_number).into(),
        ));

        if let Some(f) = &self.launch_template_id {
            params.push(("LaunchTemplateId".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_name {
            params.push(("LaunchTemplateName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteLaunchTemplateVersion {
    /// 模板所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 待删除的模板版本号。
    delete_version: Vec<i64>,
    /// 需要删除的启动模板ID。更多信息，请参见[DescribeLaunchTemplates](~~73759~~)。
    #[setters(generate = true, strip_option)]
    launch_template_id: Option<String>,
    /// 启动模板名称。
    #[setters(generate = true, strip_option)]
    launch_template_name: Option<String>,
}

impl sealed::Bound for DeleteLaunchTemplateVersion {}

impl DeleteLaunchTemplateVersion {
    pub fn new(region_id: impl Into<String>, delete_version: impl Into<Vec<i64>>) -> Self {
        Self {
            region_id: region_id.into(),
            delete_version: delete_version.into(),
            launch_template_id: None,
            launch_template_name: None,
        }
    }
}
impl crate::ToFormData for DeleteLaunchTemplateVersion {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteLaunchTemplateVersion {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteLaunchTemplateVersion";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteLaunchTemplateVersionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        crate::FlatSerialize::flat_serialize(&self.delete_version, "DeleteVersion", &mut params);

        if let Some(f) = &self.launch_template_id {
            params.push(("LaunchTemplateId".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_name {
            params.push(("LaunchTemplateName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateAutoProvisioningGroup {
    /// 弹性供应组所在地域的ID，您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性供应组所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 弹性供应组的名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`和`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    auto_provisioning_group_name: Option<String>,
    /// 弹性供应组的交付类型。取值范围：
    ///
    /// - request：一次性异步交付。供应组仅在启动时异步交付实例集群，调度失败后不再重试。
    ///
    /// - instant：一次性同步交付。供应组仅在启动时同步创建实例，并在请求响应中返回创建成功的实例列表和创建失败的原因。
    ///
    /// - maintain：持续供应。供应组在启动时尝试交付实例集群，并监控实时容量，未达到目标容量则尝试继续创建ECS实例。
    ///
    /// 默认值：maintain。
    #[setters(generate = true, strip_option)]
    auto_provisioning_group_type: Option<String>,
    /// 创建抢占式实例的策略。取值范围：
    ///
    /// - lowest-price：成本优化策略。选择价格最低的实例规格。
    ///
    /// - diversified：均衡可用区分布策略。在扩展启动模板指定的可用区内创建实例，均匀分布到各可用区。
    ///
    /// - capacity-optimized：容量优化分布策略。根据库存情况，选择最优的实例规格和可用区进行创建。
    ///
    /// 默认值：lowest-price。
    #[setters(generate = true, strip_option)]
    spot_allocation_strategy: Option<String>,
    /// 竞价实例中断时的行为。取值范围：
    ///
    /// - stop：停止实例。
    ///
    /// - terminate：释放实例。
    ///
    /// 默认值：terminate。
    #[setters(generate = true, strip_option)]
    spot_instance_interruption_behavior: Option<String>,
    /// 在`SpotAllocationStrategy`为`lowest-price`时生效，表示弹性供应组选择价格最低的实例规格创建实例的数量。
    ///
    /// 取值范围：低于`LaunchTemplateConfig.N`中N的取值。
    #[setters(generate = true, strip_option)]
    spot_instance_pools_to_use_count: Option<i32>,
    /// 创建按量付费实例的策略。取值范围：
    ///
    /// - lowest-price：成本优化策略。选择价格最低的实例规格。
    ///
    /// - prioritized：优先级策略。按照`LaunchTemplateConfig.N.Priority`设定的优先级创建实例。
    ///
    /// 默认值：lowest-price。
    #[setters(generate = true, strip_option)]
    pay_as_you_go_allocation_strategy: Option<String>,
    /// 弹性供应组实时容量超过目标容量并触发缩容时，是否释放缩容的实例。取值范围：
    ///
    /// - termination：释放缩容的实例。
    /// - no-termination：只将缩容的实例移出弹性供应组。
    ///
    /// 默认值：no-termination。
    #[setters(generate = true, strip_option)]
    excess_capacity_termination_policy: Option<String>,
    /// 弹性供应组的启动时间，和`ValidUntil`共同确定有效时段。
    ///
    /// 按照[ISO 8601](~~25696~~)标准表示，并使用UTC+0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    ///
    /// 默认值：该接口立即生效的时间戳。
    #[setters(generate = true, strip_option)]
    valid_from: Option<String>,
    /// 弹性供应组的到期时间，和`ValidFrom`共同确定有效时段。
    ///
    /// 按照[ISO 8601](~~25696~~)标准表示，并使用UTC+0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    ///
    /// 默认值：2099-12-31T23:59:59Z。
    #[setters(generate = true, strip_option)]
    valid_until: Option<String>,
    /// 弹性供应组到期时，是否释放组内实例。取值范围：
    ///
    /// - true：释放组内实例。
    /// - false：只将组内实例移出弹性供应组。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    terminate_instances_with_expiration: Option<bool>,
    /// 删除弹性供应组时，是否释放组内实例。取值范围：
    ///
    /// - true：释放组内实例。
    /// - false：保留组内实例。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    terminate_instances: Option<bool>,
    /// 弹性供应组内抢占式实例的最高价格。
    ///
    /// > 同时设置了`MaxSpotPrice`和`LaunchTemplateConfig.N.MaxPrice`时，以最低值为准。
    #[setters(generate = true, strip_option)]
    max_spot_price: Option<f32>,
    /// 弹性供应组的目标总容量。取值范围：正整数。
    ///
    /// 总容量必须大于等于`PayAsYouGoTargetCapacity`（指定的按量付费实例目标容量）和`SpotTargetCapacity`（指定的抢占式实例目标容量）取值之和。
    total_target_capacity: String,
    /// 弹性供应组内，按量付费实例的目标容量。取值范围：小于等于`TotalTargetCapacity`的参数取值。
    #[setters(generate = true, strip_option)]
    pay_as_you_go_target_capacity: Option<String>,
    /// 弹性供应组内，抢占式实例的目标容量。取值范围：小于等于`TotalTargetCapacity`的参数取值。
    #[setters(generate = true, strip_option)]
    spot_target_capacity: Option<String>,
    /// `PayAsYouGoTargetCapacity`和`SpotTargetCapacity`之和小于`TotalTargetCapacity`时，指定差额容量的计费方式。取值范围：
    ///
    /// - PayAsYouGo：按量付费实例。
    /// - Spot：抢占式实例。
    ///
    /// 默认值：Spot。
    #[setters(generate = true, strip_option)]
    default_target_capacity_type: Option<String>,
    /// 弹性供应组关联的实例启动模板的ID，您可以调用[DescribeLaunchTemplates](~~73759~~)查询可用的实例启动模板。同时指定启动模板与启动配置信息（`LaunchConfiguration.*`）时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_template_id: Option<String>,
    /// 弹性供应组关联的实例启动模板的版本，您可以调用[DescribeLaunchTemplateVersions](~~73761~~)查询可用的实例启动模板版本。
    ///
    /// 默认值：启动模板的默认版本。
    #[setters(generate = true, strip_option)]
    launch_template_version: Option<String>,
    /// 弹性供应组的描述信息。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。ClientToken只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 镜像ID。启动实例时选择的镜像资源，您可以调用[DescribeImages](~~25534~~)查询可以使用的镜像资源。同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_image_id: Option<String>,
    /// 实例所属的安全组ID。同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_security_group_id: Option<String>,
    /// 是否为I/O优化实例。取值范围：
    ///
    /// - none：非I/O优化。
    /// - optimized：I/O优化。
    ///
    /// 已停售的实例规格实例默认值是none，其他实例规格默认值是optimized。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_io_optimized: Option<String>,
    /// 网络计费类型。取值范围：
    ///
    /// - PayByBandwidth：按固定带宽计费。
    /// - PayByTraffic：按使用流量计费。
    ///
    /// > 按使用流量计费模式下的出入带宽峰值都是带宽上限，不作为业务承诺指标。当出现资源争抢时，带宽峰值可能会受到限制。如果您的业务需要有带宽的保障，请使用按固定带宽计费模式。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_internet_charge_type: Option<String>,
    /// 公网入带宽最大值，单位为Mbit/s。取值范围：
    ///
    /// - 当公网出带宽小于等于10 Mbit/s时：1~10，默认为10。
    /// - 当公网出带宽大于10 Mbit/s时：1~`LaunchConfiguration.InternetMaxBandwidthOut`的取值，默认为`LaunchConfiguration.InternetMaxBandwidthOut`的取值。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_internet_max_bandwidth_in: Option<i32>,
    /// 公网出带宽最大值，单位为Mbit/s。取值范围：0~100。
    ///
    /// 默认值：0。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_internet_max_bandwidth_out: Option<i32>,
    /// 实例名称。长度为2~128个字符，必须以大小写字母或中文开头，不能以`http://`和`https://`开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    ///
    /// 默认值：实例的`InstanceId`。
    ///
    /// 创建多台ECS实例时，您可以批量设置有序的实例名称。具体操作，请参见[批量设置有序的实例名称或主机名称](~~196048~~)。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_instance_name: Option<String>,
    /// 实例主机名称。限制说明如下：
    ///
    /// - 半角句号（.）和短划线（-）不能作为首尾字符，更不能连续使用。
    /// - Windows实例：字符长度为2~15，不支持半角句号（.），不能全是数字。允许大小写英文字母、数字和短划线（-）。
    /// - 其他类型实例（Linux等）：字符长度为2~64，支持多个半角句号（.），点之间为一段，每段允许大小写英文字母、数字和短划线（-）。
    /// - 不支持同时设置`LaunchConfiguration.HostName`与`LaunchConfiguration.HostNames.N`，否则会返回报错信息。
    /// - 同时指定启动模板与启动配置信息时，优先使用启动模板。
    ///
    #[setters(generate = true, strip_option)]
    launch_configuration_host_name: Option<String>,
    /// 实例描述。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_instance_description: Option<String>,
    /// 密钥对名称。
    ///
    /// -   Windows实例，忽略该参数。默认为空。
    /// -   Linux实例的密码登录方式会被初始化成禁止。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_key_pair_name: Option<String>,
    /// 实例RAM角色名称。您可以使用RAM API [ListRoles](~~28713~~)查询您已创建的实例RAM角色。同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_ram_role_name: Option<String>,
    /// 是否开启安全加固。取值范围：
    ///
    /// -   Active：启用安全加固，只对公共镜像生效。
    /// -   Deactive：不启用安全加固，对所有镜像类型生效。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_security_enhancement_strategy: Option<String>,
    /// 实例自定义数据。需要以Base64方式编码，原始数据最多为32 KB。同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_user_data: Option<String>,
    /// 系统盘的云盘种类。取值范围：
    ///
    /// -   cloud_efficiency：高效云盘。
    /// -   cloud_ssd：SSD云盘。
    /// -   cloud_essd：ESSD云盘。
    /// -   cloud：普通云盘。
    ///
    /// 已停售的实例规格且非I/O优化实例默认值为cloud，否则默认值为cloud_efficiency。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_system_disk_category: Option<String>,
    /// 系统盘大小。单位为GiB，取值范围：20~500。该参数的取值必须大于或者等于max{20, LaunchConfiguration.ImageId对应的镜像大小}。
    ///
    /// 默认值：max{40, 参数LaunchConfiguration.ImageId对应的镜像大小}。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_system_disk_size: Option<i32>,
    /// 系统盘名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`和`https://`开头。可以包含数字、半角句号（.）、半角冒号（:）、下划线（_）或者短划线（-）。
    ///
    /// 默认值：空。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_system_disk_name: Option<String>,
    /// 系统盘的描述。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_system_disk_description: Option<String>,
    /// 创建ESSD云盘作为系统盘使用时，设置云盘的性能等级。取值范围：
    ///
    /// - PL0（默认）：单盘最高随机读写IOPS 1万。
    /// - PL1：单盘最高随机读写IOPS 5万。
    /// - PL2：单盘最高随机读写IOPS 10万。
    /// - PL3：单盘最高随机读写IOPS 100万。
    ///
    /// 有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_system_disk_performance_level: Option<String>,
    /// 是否使用镜像预设的密码。取值范围：
    ///
    /// - true：使用。
    /// - false：不使用。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_password_inherit: Option<bool>,
    /// 实例所在的企业资源组ID。同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_resource_group_id: Option<String>,
    /// 设置突发性能实例的运行模式。取值范围：
    ///
    /// - Standard：标准模式，实例性能请参见[什么是突发性能实例](~~59977~~)下的性能约束模式章节。
    /// - Unlimited：无性能约束模式，实例性能请参见[什么是突发性能实例](~~59977~~)下的无性能约束模式章节。
    ///
    /// 默认值：无。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_credit_specification: Option<String>,
    /// 实例的密码。长度为8至30个字符，必须同时包含大小写英文字母、数字和特殊符号中的三类字符。特殊符号可以是：
    ///
    /// ``()`~!@#$%^&*-_+=|{}`[]`:;'<>,.?/``
    ///
    /// 其中，Windows实例不能以正斜线（/）为密码首字符。
    ///
    /// 同时指定启动模板与启动配置信息时，优先使用启动模板。
    ///
    ///
    #[setters(generate = true, strip_option)]
    launch_configuration_password: Option<String>,
    /// 部署集ID。
    #[setters(generate = true, strip_option)]
    launch_configuration_deployment_set_id: Option<String>,
    /// 扩展启动模板列表。
    #[setters(generate = true, strip_option)]
    launch_template_config: Option<Vec<CreateAutoProvisioningGroupLaunchTemplateConfig>>,
    /// 扩展启动模板云盘配置列表。
    #[setters(generate = true, strip_option)]
    launch_configuration_data_disk: Option<Vec<ConfigurationDataDisk>>,
    /// 扩展启动模板标签列表。
    #[setters(generate = true, strip_option)]
    launch_configuration_tag: Option<Vec<ConfigurationTag>>,
    /// 实例系统盘信息列表。
    #[setters(generate = true, strip_option)]
    system_disk_config: Option<Vec<SystemDiskConfig>>,
    /// 实例数据盘信息列表。
    #[setters(generate = true, strip_option)]
    data_disk_config: Option<Vec<DataDiskConfig>>,
    /// 为一台或多台实例指定不同的主机名称。限制说明如下：
    ///
    /// - 仅创建一次性同步交付类型的弹性供应组（`AutoProvisioningGroupType=instant`）时，该参数生效。
    /// - N表示实例个数，取值范围为1~1000，且需要和TotalTargetCapacity参数值保持一致。
    /// - 半角句号（.）和短划线（-）不能作为首尾字符，更不能连续使用。
    /// - Windows实例：字符长度为2~15，不支持半角句号（.），不能全是数字。允许包含大小写英文字母、数字和短划线（-）。
    /// - 其他类型实例（Linux等）：字符长度为2~64，支持多个半角句号（.），半角句号（.）之间为一段，每段允许包含大小写英文字母、数字和短划线（-）。
    /// - 不支持同时设置`LaunchConfiguration.HostName`与`LaunchConfiguration.HostNames.N`，否则会返回报错信息。
    /// - 同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_host_names: Option<Vec<String>>,
    /// 弹性供应组的目标最小容量。取值范围：正整数。
    ///
    /// 当您设置该参数后，需要注意：
    /// - 仅创建一次性同步交付类型的弹性供应组（`AutoProvisioningGroupType=instant`）时，该参数生效。
    /// - 如果当前地域下的实例库存小于该参数值，则会导致调用接口失败，不会创建实例。
    /// - 如果当前地域下的实例库存大于该参数值，则按照已设置的其他参数值正常创建实例。
    #[setters(generate = true, strip_option)]
    min_target_capacity: Option<String>,
    /// 实例所属的安全组列表。
    #[setters(generate = true, strip_option)]
    launch_configuration_security_group_ids: Option<Vec<String>>,
    /// 实例的系统盘信息。同时指定启动模板与启动配置信息时，优先使用启动模板。
    #[setters(generate = true, strip_option)]
    launch_configuration_system_disk: Option<ConfigurationSystemDisk>,
    /// >该参数正在邀测中，暂不支持使用。
    #[setters(generate = true, strip_option)]
    launch_configuration_arn: Option<Vec<LaunchConfigurationArn>>,
    /// >该参数正在邀测中，暂未开放使用。
    #[setters(generate = true, strip_option)]
    hibernation_options_configured: Option<bool>,
    /// 按量付费实例的自动释放时间。按照[ISO 8601](~~25696~~)标准表示，使用UTC+0时间。格式为：`yyyy-MM-ddTHH:mm:ssZ`。
    ///
    /// - 如果秒（`ss`）取值不是`00`，则自动取为当前分钟（`mm`）开始时。
    ///
    /// - 最短释放时间为当前时间半小时之后。
    ///
    /// - 最长释放时间不能超过当前时间三年。
    #[setters(generate = true, strip_option)]
    launch_configuration_auto_release_time: Option<String>,
    /// 镜像族系名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`aliyun`和`acs:`开头，不能包含`http://`或者`https://`。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    launch_configuration_image_family: Option<String>,
    /// 弹性供应组绑定的标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ProvisioningGroupTag>>,
    /// 创建实例时使用的资源池策略。当您设置该参数后，需要注意：
    /// - 该参数只在创建按量付费实例时生效。
    /// - 仅创建一次性同步交付类型的弹性供应组（`AutoProvisioningGroupType=instant`）时，该参数生效。
    #[setters(generate = true, strip_option)]
    resource_pool_options: Option<PoolOptions>,
    /// 启动配置参数。
    #[setters(generate = true, strip_option)]
    launch_configuration: Option<LaunchConfiguration>,
    /// 包年包月实例的容量详细配置。
    #[setters(generate = true, strip_option)]
    pre_paid_options: Option<PaidOptions>,
}

impl sealed::Bound for CreateAutoProvisioningGroup {}

impl CreateAutoProvisioningGroup {
    pub fn new(region_id: impl Into<String>, total_target_capacity: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            auto_provisioning_group_name: None,
            auto_provisioning_group_type: None,
            spot_allocation_strategy: None,
            spot_instance_interruption_behavior: None,
            spot_instance_pools_to_use_count: None,
            pay_as_you_go_allocation_strategy: None,
            excess_capacity_termination_policy: None,
            valid_from: None,
            valid_until: None,
            terminate_instances_with_expiration: None,
            terminate_instances: None,
            max_spot_price: None,
            total_target_capacity: total_target_capacity.into(),
            pay_as_you_go_target_capacity: None,
            spot_target_capacity: None,
            default_target_capacity_type: None,
            launch_template_id: None,
            launch_template_version: None,
            description: None,
            client_token: None,
            launch_configuration_image_id: None,
            launch_configuration_security_group_id: None,
            launch_configuration_io_optimized: None,
            launch_configuration_internet_charge_type: None,
            launch_configuration_internet_max_bandwidth_in: None,
            launch_configuration_internet_max_bandwidth_out: None,
            launch_configuration_instance_name: None,
            launch_configuration_host_name: None,
            launch_configuration_instance_description: None,
            launch_configuration_key_pair_name: None,
            launch_configuration_ram_role_name: None,
            launch_configuration_security_enhancement_strategy: None,
            launch_configuration_user_data: None,
            launch_configuration_system_disk_category: None,
            launch_configuration_system_disk_size: None,
            launch_configuration_system_disk_name: None,
            launch_configuration_system_disk_description: None,
            launch_configuration_system_disk_performance_level: None,
            launch_configuration_password_inherit: None,
            launch_configuration_resource_group_id: None,
            launch_configuration_credit_specification: None,
            launch_configuration_password: None,
            launch_configuration_deployment_set_id: None,
            launch_template_config: None,
            launch_configuration_data_disk: None,
            launch_configuration_tag: None,
            system_disk_config: None,
            data_disk_config: None,
            launch_configuration_host_names: None,
            min_target_capacity: None,
            launch_configuration_security_group_ids: None,
            launch_configuration_system_disk: None,
            launch_configuration_arn: None,
            hibernation_options_configured: None,
            launch_configuration_auto_release_time: None,
            launch_configuration_image_family: None,
            tag: None,
            resource_pool_options: None,
            launch_configuration: None,
            pre_paid_options: None,
        }
    }
}
impl crate::ToFormData for CreateAutoProvisioningGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateAutoProvisioningGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateAutoProvisioningGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateAutoProvisioningGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(62);

        if let Some(f) = &self.auto_provisioning_group_name {
            params.push(("AutoProvisioningGroupName".into(), (f).into()));
        }

        if let Some(f) = &self.auto_provisioning_group_type {
            params.push(("AutoProvisioningGroupType".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.data_disk_config {
            crate::FlatSerialize::flat_serialize(f, "DataDiskConfig", &mut params);
        }

        if let Some(f) = &self.default_target_capacity_type {
            params.push(("DefaultTargetCapacityType".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.excess_capacity_termination_policy {
            params.push(("ExcessCapacityTerminationPolicy".into(), (f).into()));
        }

        if let Some(f) = &self.hibernation_options_configured {
            params.push(("HibernationOptionsConfigured".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration {
            crate::FlatSerialize::flat_serialize(f, "LaunchConfiguration", &mut params);
        }

        if let Some(f) = &self.launch_configuration_arn {
            crate::FlatSerialize::flat_serialize(f, "LaunchConfiguration.Arn", &mut params);
        }

        if let Some(f) = &self.launch_configuration_auto_release_time {
            params.push(("LaunchConfiguration.AutoReleaseTime".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_credit_specification {
            params.push(("LaunchConfiguration.CreditSpecification".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_data_disk {
            crate::FlatSerialize::flat_serialize(f, "LaunchConfiguration.DataDisk", &mut params);
        }

        if let Some(f) = &self.launch_configuration_deployment_set_id {
            params.push(("LaunchConfiguration.DeploymentSetId".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_host_name {
            params.push(("LaunchConfiguration.HostName".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_host_names {
            crate::FlatSerialize::flat_serialize(f, "LaunchConfiguration.HostNames", &mut params);
        }

        if let Some(f) = &self.launch_configuration_image_family {
            params.push(("LaunchConfiguration.ImageFamily".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_image_id {
            params.push(("LaunchConfiguration.ImageId".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_instance_description {
            params.push(("LaunchConfiguration.InstanceDescription".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_instance_name {
            params.push(("LaunchConfiguration.InstanceName".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_internet_charge_type {
            params.push(("LaunchConfiguration.InternetChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_internet_max_bandwidth_in {
            params.push((
                "LaunchConfiguration.InternetMaxBandwidthIn".into(),
                (f).into(),
            ));
        }

        if let Some(f) = &self.launch_configuration_internet_max_bandwidth_out {
            params.push((
                "LaunchConfiguration.InternetMaxBandwidthOut".into(),
                (f).into(),
            ));
        }

        if let Some(f) = &self.launch_configuration_io_optimized {
            params.push(("LaunchConfiguration.IoOptimized".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_key_pair_name {
            params.push(("LaunchConfiguration.KeyPairName".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_password {
            params.push(("LaunchConfiguration.Password".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_password_inherit {
            params.push(("LaunchConfiguration.PasswordInherit".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_ram_role_name {
            params.push(("LaunchConfiguration.RamRoleName".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_resource_group_id {
            params.push(("LaunchConfiguration.ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_security_enhancement_strategy {
            params.push((
                "LaunchConfiguration.SecurityEnhancementStrategy".into(),
                (f).into(),
            ));
        }

        if let Some(f) = &self.launch_configuration_security_group_id {
            params.push(("LaunchConfiguration.SecurityGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_security_group_ids {
            crate::FlatSerialize::flat_serialize(
                f,
                "LaunchConfiguration.SecurityGroupIds",
                &mut params,
            );
        }

        if let Some(f) = &self.launch_configuration_system_disk {
            crate::FlatSerialize::flat_serialize(f, "LaunchConfiguration.SystemDisk", &mut params);
        }

        if let Some(f) = &self.launch_configuration_system_disk_category {
            params.push(("LaunchConfiguration.SystemDiskCategory".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_system_disk_description {
            params.push((
                "LaunchConfiguration.SystemDiskDescription".into(),
                (f).into(),
            ));
        }

        if let Some(f) = &self.launch_configuration_system_disk_name {
            params.push(("LaunchConfiguration.SystemDiskName".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_system_disk_performance_level {
            params.push((
                "LaunchConfiguration.SystemDiskPerformanceLevel".into(),
                (f).into(),
            ));
        }

        if let Some(f) = &self.launch_configuration_system_disk_size {
            params.push(("LaunchConfiguration.SystemDiskSize".into(), (f).into()));
        }

        if let Some(f) = &self.launch_configuration_tag {
            crate::FlatSerialize::flat_serialize(f, "LaunchConfiguration.Tag", &mut params);
        }

        if let Some(f) = &self.launch_configuration_user_data {
            params.push(("LaunchConfiguration.UserData".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_config {
            crate::FlatSerialize::flat_serialize(f, "LaunchTemplateConfig", &mut params);
        }

        if let Some(f) = &self.launch_template_id {
            params.push(("LaunchTemplateId".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_version {
            params.push(("LaunchTemplateVersion".into(), (f).into()));
        }

        if let Some(f) = &self.max_spot_price {
            params.push(("MaxSpotPrice".into(), (f).into()));
        }

        if let Some(f) = &self.min_target_capacity {
            params.push(("MinTargetCapacity".into(), (f).into()));
        }

        if let Some(f) = &self.pay_as_you_go_allocation_strategy {
            params.push(("PayAsYouGoAllocationStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.pay_as_you_go_target_capacity {
            params.push(("PayAsYouGoTargetCapacity".into(), (f).into()));
        }

        if let Some(f) = &self.pre_paid_options {
            crate::FlatSerialize::flat_serialize(f, "PrePaidOptions", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.resource_pool_options {
            if let Ok(json) = serde_json::to_string(f) {
                params.push(("ResourcePoolOptions".into(), json.into()));
            }
        }

        if let Some(f) = &self.spot_allocation_strategy {
            params.push(("SpotAllocationStrategy".into(), (f).into()));
        }

        if let Some(f) = &self.spot_instance_interruption_behavior {
            params.push(("SpotInstanceInterruptionBehavior".into(), (f).into()));
        }

        if let Some(f) = &self.spot_instance_pools_to_use_count {
            params.push(("SpotInstancePoolsToUseCount".into(), (f).into()));
        }

        if let Some(f) = &self.spot_target_capacity {
            params.push(("SpotTargetCapacity".into(), (f).into()));
        }

        if let Some(f) = &self.system_disk_config {
            crate::FlatSerialize::flat_serialize(f, "SystemDiskConfig", &mut params);
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.terminate_instances {
            params.push(("TerminateInstances".into(), (f).into()));
        }

        if let Some(f) = &self.terminate_instances_with_expiration {
            params.push(("TerminateInstancesWithExpiration".into(), (f).into()));
        }
        params.push((
            "TotalTargetCapacity".into(),
            (&self.total_target_capacity).into(),
        ));

        if let Some(f) = &self.valid_from {
            params.push(("ValidFrom".into(), (f).into()));
        }

        if let Some(f) = &self.valid_until {
            params.push(("ValidUntil".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeAutoProvisioningGroups {
    /// 弹性供应组所在地域的ID。
    region_id: String,
    /// 分页查询时设置的列表页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 弹性供应组的名称。
    #[setters(generate = true, strip_option)]
    auto_provisioning_group_name: Option<String>,
    /// 弹性供应组所属的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 弹性供应组ID列表。可输入最多20个弹性供应组ID。
    #[setters(generate = true, strip_option)]
    auto_provisioning_group_id: Option<Vec<String>>,
    /// 弹性供应组的状态列表。
    #[setters(generate = true, strip_option)]
    auto_provisioning_group_status: Option<Vec<String>>,
    /// 弹性供应组绑定的标签。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ProvisioningGroupsTag>>,
}

impl sealed::Bound for DescribeAutoProvisioningGroups {}

impl DescribeAutoProvisioningGroups {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
            auto_provisioning_group_name: None,
            resource_group_id: None,
            auto_provisioning_group_id: None,
            auto_provisioning_group_status: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeAutoProvisioningGroups {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeAutoProvisioningGroups {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeAutoProvisioningGroups";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeAutoProvisioningGroupsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.auto_provisioning_group_id {
            crate::FlatSerialize::flat_serialize(f, "AutoProvisioningGroupId", &mut params);
        }

        if let Some(f) = &self.auto_provisioning_group_name {
            params.push(("AutoProvisioningGroupName".into(), (f).into()));
        }

        if let Some(f) = &self.auto_provisioning_group_status {
            crate::FlatSerialize::flat_serialize(f, "AutoProvisioningGroupStatus", &mut params);
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeAutoProvisioningGroupInstances {
    /// 弹性供应组所在地域的ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 分页查询列表的页码。
    ///
    /// 起始值：1
    ///
    /// 默认值：1
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。
    ///
    /// 最大值：100
    ///
    /// 默认值：10
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 弹性供应组的ID。
    auto_provisioning_group_id: String,
}

impl sealed::Bound for DescribeAutoProvisioningGroupInstances {}

impl DescribeAutoProvisioningGroupInstances {
    pub fn new(
        region_id: impl Into<String>,
        auto_provisioning_group_id: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
            auto_provisioning_group_id: auto_provisioning_group_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeAutoProvisioningGroupInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeAutoProvisioningGroupInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeAutoProvisioningGroupInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeAutoProvisioningGroupInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push((
            "AutoProvisioningGroupId".into(),
            (&self.auto_provisioning_group_id).into(),
        ));

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyAutoProvisioningGroup {
    /// 弹性供应组所在地域的ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性供应组的ID。
    #[setters(generate = true, strip_option)]
    auto_provisioning_group_id: Option<String>,
    /// 弹性供应组实时容量超过目标容量并触发缩容时，是否释放缩容的实例。取值范围：
    ///
    /// - termination：释放缩容的实例。
    /// - no-termination：只将缩容的实例移出弹性供应组。
    #[setters(generate = true, strip_option)]
    excess_capacity_termination_policy: Option<String>,
    /// PayAsYouGoTargetCapacity和SpotTargetCapacity之和小于TotalTargetCapacity时，指定差额容量的计费方式。取值范围：
    ///
    /// - PayAsYouGo：按量付费实例。
    /// - Spot：抢占式实例。
    #[setters(generate = true, strip_option)]
    default_target_capacity_type: Option<String>,
    /// 弹性供应组到期时，是否释放组内实例。取值范围：
    ///
    /// - true：释放组内实例。
    /// - false：只将组内实例移出弹性供应组。
    #[setters(generate = true, strip_option)]
    terminate_instances_with_expiration: Option<bool>,
    /// 弹性供应组内抢占式实例的最高价格。
    ///
    /// > 同时设置了MaxSpotPrice和LaunchTemplateConfig.N.MaxPrice时，以最低值为准。LaunchTemplateConfig.N.MaxPrice在创建弹性供应组时设置，且不可修改。
    #[setters(generate = true, strip_option)]
    max_spot_price: Option<f32>,
    /// 弹性供应组的目标总容量。取值范围：正整数。
    ///
    /// 总容量必须大于等于PayAsYouGoTargetCapacity（指定的按量付费实例目标容量）和SpotTargetCapacity（指定的抢占式实例目标容量）取值之和。
    #[setters(generate = true, strip_option)]
    total_target_capacity: Option<String>,
    /// 弹性供应组内，按量付费实例的目标容量。取值范围：小于TotalTargetCapacity的参数取值。
    #[setters(generate = true, strip_option)]
    pay_as_you_go_target_capacity: Option<String>,
    /// 弹性供应组内，抢占式实例的目标容量。取值范围：小于TotalTargetCapacity的参数取值。
    #[setters(generate = true, strip_option)]
    spot_target_capacity: Option<String>,
    /// 弹性供应组的名称。长度为2~128个英文或中文字符。必须以大小字母或中文开头，不能以http://和https://开头。可以包含数字、半角冒号（:）、下划线（_）或者连字符（-）。
    #[setters(generate = true, strip_option)]
    auto_provisioning_group_name: Option<String>,
    /// 扩展启动模板列表。
    #[setters(generate = true, strip_option)]
    launch_template_config: Option<Vec<ModifyAutoProvisioningGroupLaunchTemplateConfig>>,
}

impl sealed::Bound for ModifyAutoProvisioningGroup {}

impl ModifyAutoProvisioningGroup {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            auto_provisioning_group_id: None,
            excess_capacity_termination_policy: None,
            default_target_capacity_type: None,
            terminate_instances_with_expiration: None,
            max_spot_price: None,
            total_target_capacity: None,
            pay_as_you_go_target_capacity: None,
            spot_target_capacity: None,
            auto_provisioning_group_name: None,
            launch_template_config: None,
        }
    }
}
impl crate::ToFormData for ModifyAutoProvisioningGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyAutoProvisioningGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyAutoProvisioningGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyAutoProvisioningGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(11);

        if let Some(f) = &self.auto_provisioning_group_id {
            params.push(("AutoProvisioningGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.auto_provisioning_group_name {
            params.push(("AutoProvisioningGroupName".into(), (f).into()));
        }

        if let Some(f) = &self.default_target_capacity_type {
            params.push(("DefaultTargetCapacityType".into(), (f).into()));
        }

        if let Some(f) = &self.excess_capacity_termination_policy {
            params.push(("ExcessCapacityTerminationPolicy".into(), (f).into()));
        }

        if let Some(f) = &self.launch_template_config {
            crate::FlatSerialize::flat_serialize(f, "LaunchTemplateConfig", &mut params);
        }

        if let Some(f) = &self.max_spot_price {
            params.push(("MaxSpotPrice".into(), (f).into()));
        }

        if let Some(f) = &self.pay_as_you_go_target_capacity {
            params.push(("PayAsYouGoTargetCapacity".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.spot_target_capacity {
            params.push(("SpotTargetCapacity".into(), (f).into()));
        }

        if let Some(f) = &self.terminate_instances_with_expiration {
            params.push(("TerminateInstancesWithExpiration".into(), (f).into()));
        }

        if let Some(f) = &self.total_target_capacity {
            params.push(("TotalTargetCapacity".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeAutoProvisioningGroupHistory {
    /// 弹性供应组所在地域的ID。
    region_id: String,
    /// 分页查询的当前页码。起始值：1
    ///
    /// 默认值：1
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。最大值：100
    ///
    /// 默认值：10
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 弹性供应组的ID。
    auto_provisioning_group_id: String,
    /// 查询调度历史的起始时间。按照[ISO8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
    /// 查询调度历史的结束时间。按照[ISO8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    end_time: Option<String>,
}

impl sealed::Bound for DescribeAutoProvisioningGroupHistory {}

impl DescribeAutoProvisioningGroupHistory {
    pub fn new(
        region_id: impl Into<String>,
        auto_provisioning_group_id: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
            auto_provisioning_group_id: auto_provisioning_group_id.into(),
            start_time: None,
            end_time: None,
        }
    }
}
impl crate::ToFormData for DescribeAutoProvisioningGroupHistory {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeAutoProvisioningGroupHistory {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeAutoProvisioningGroupHistory";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeAutoProvisioningGroupHistoryResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);
        params.push((
            "AutoProvisioningGroupId".into(),
            (&self.auto_provisioning_group_id).into(),
        ));

        if let Some(f) = &self.end_time {
            params.push(("EndTime".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteAutoProvisioningGroup {
    /// 弹性供应组所在地域的ID。
    region_id: String,
    /// 弹性供应组的ID。
    auto_provisioning_group_id: String,
    /// 删除弹性供应组时是否释放组内实例。取值范围：
    ///
    /// - true：释放组内实例。
    /// - false：组内实例继续运行。
    ///
    /// >此参数值默认继承于调用`CreateAutoProvisioningGroup`创建弹性供应组时设置的`TerminateInstances`参数值，您也可以在调用本接口删除弹性供应组时，重新设置`TerminateInstances`参数值。
    #[setters(generate = true, strip_option)]
    terminate_instances: Option<bool>,
}

impl sealed::Bound for DeleteAutoProvisioningGroup {}

impl DeleteAutoProvisioningGroup {
    pub fn new(
        region_id: impl Into<String>,
        auto_provisioning_group_id: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            auto_provisioning_group_id: auto_provisioning_group_id.into(),
            terminate_instances: None,
        }
    }
}
impl crate::ToFormData for DeleteAutoProvisioningGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteAutoProvisioningGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteAutoProvisioningGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteAutoProvisioningGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push((
            "AutoProvisioningGroupId".into(),
            (&self.auto_provisioning_group_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.terminate_instances {
            params.push(("TerminateInstances".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateDeploymentSet {
    /// 部署集所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 部署集内实例宕机迁移后，缺乏可供打散的实例库存的紧急处理方案。取值范围：
    ///          
    /// - CancelMembershipAndStart：将实例移出部署集，宕机迁移后即刻启动实例。
    /// - KeepStopped：维持实例的部署集属性，实例保持停止状态。
    ///
    /// 默认值：CancelMembershipAndStart。
    #[setters(generate = true, strip_option)]
    on_unable_to_redeploy_failed_instance: Option<String>,
    /// 部署集描述信息。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 部署集名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`和`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    deployment_set_name: Option<String>,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    domain: Option<String>,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    granularity: Option<String>,
    /// 部署策略。取值范围：
    ///
    /// - Availability：高可用策略。
    ///
    /// - AvailabilityGroup：部署集组高可用策略。
    ///
    /// - LowLatency：网络低时延策略。
    ///
    /// 默认值：Availability。
    #[setters(generate = true, strip_option)]
    strategy: Option<String>,
    /// 为部署集组高可用策略设置分组数量。取值范围：1~7。
    ///
    /// 默认值：3。
    ///
    /// > 该参数仅当`Strategy=AvailabilityGroup`时生效。
    #[setters(generate = true, strip_option)]
    group_count: Option<i64>,
}

impl sealed::Bound for CreateDeploymentSet {}

impl CreateDeploymentSet {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            on_unable_to_redeploy_failed_instance: None,
            description: None,
            client_token: None,
            deployment_set_name: None,
            domain: None,
            granularity: None,
            strategy: None,
            group_count: None,
        }
    }
}
impl crate::ToFormData for CreateDeploymentSet {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateDeploymentSet {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateDeploymentSet";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateDeploymentSetResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.deployment_set_name {
            params.push(("DeploymentSetName".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.domain {
            params.push(("Domain".into(), (f).into()));
        }

        if let Some(f) = &self.granularity {
            params.push(("Granularity".into(), (f).into()));
        }

        if let Some(f) = &self.group_count {
            params.push(("GroupCount".into(), (f).into()));
        }

        if let Some(f) = &self.on_unable_to_redeploy_failed_instance {
            params.push(("OnUnableToRedeployFailedInstance".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.strategy {
            params.push(("Strategy".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDeploymentSetSupportedInstanceTypeFamily {
    /// 部署集所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 部署策略。取值范围：
    ///
    /// - Availability：高可用策略。
    ///
    /// - AvailabilityGroup：部署集组高可用策略。
    ///
    /// - LowLatency：网络低时延策略。
    ///
    /// 默认值：Availability。
    #[setters(generate = true, strip_option)]
    strategy: Option<String>,
}

impl sealed::Bound for DescribeDeploymentSetSupportedInstanceTypeFamily {}

impl DescribeDeploymentSetSupportedInstanceTypeFamily {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            strategy: None,
        }
    }
}
impl crate::ToFormData for DescribeDeploymentSetSupportedInstanceTypeFamily {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDeploymentSetSupportedInstanceTypeFamily {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDeploymentSetSupportedInstanceTypeFamily";

    type Body = crate::Form<Self>;

    type ResponseWrap =
        crate::JsonResponseWrap<DescribeDeploymentSetSupportedInstanceTypeFamilyResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.strategy {
            params.push(("Strategy".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDeploymentSets {
    /// 部署集所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 部署集列表的页码。
    ///
    /// 起始值为1。
    ///
    /// 默认值为1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。
    ///
    /// 最大值为50。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 部署集ID列表。取值可以由多个部署集ID组成一个JSON数组，格式为`["ds-xxxxxxxxx", "ds-yyyyyyyyy", … "ds-zzzzzzzzz"]`。最多支持100个ID，ID之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    deployment_set_ids: Option<String>,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    network_type: Option<String>,
    /// 部署策略。取值范围：
    ///
    /// - Availability：高可用策略。
    /// - AvailabilityGroup：部署集组高可用策略。
    #[setters(generate = true, strip_option)]
    strategy: Option<String>,
    /// 部署集名称。长度为2~128个英文或中文字符。必须以大小字母或中文开头，不能`以http://`或`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    deployment_set_name: Option<String>,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    granularity: Option<String>,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    domain: Option<String>,
}

impl sealed::Bound for DescribeDeploymentSets {}

impl DescribeDeploymentSets {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
            deployment_set_ids: None,
            network_type: None,
            strategy: None,
            deployment_set_name: None,
            granularity: None,
            domain: None,
        }
    }
}
impl crate::ToFormData for DescribeDeploymentSets {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDeploymentSets {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDeploymentSets";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDeploymentSetsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);

        if let Some(f) = &self.deployment_set_ids {
            params.push(("DeploymentSetIds".into(), (f).into()));
        }

        if let Some(f) = &self.deployment_set_name {
            params.push(("DeploymentSetName".into(), (f).into()));
        }

        if let Some(f) = &self.domain {
            params.push(("Domain".into(), (f).into()));
        }

        if let Some(f) = &self.granularity {
            params.push(("Granularity".into(), (f).into()));
        }

        if let Some(f) = &self.network_type {
            params.push(("NetworkType".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.strategy {
            params.push(("Strategy".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceDeployment {
    /// 实例所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID。
    instance_id: String,
    /// 专有宿主机ID。调用[DescribeDedicatedHosts](~~134242~~)查看可以使用的专有宿主机。
    ///
    /// 修改ECS实例宿主机（即将ECS实例从共享宿主机迁移至专有宿主机，或在不同专有宿主机间迁移ECS实例）时：
    /// - 若将实例迁移至指定专有宿主机上，必须设置该参数。
    /// - 若将实例迁移至系统自动为您选择的专有宿主机上，必须将该参数设置为空，并将参数`Tenancy`设置为host。
    ///
    /// 自动部署功能详情，请参见[专有宿主机功能特性](~~118938~~)。
    #[setters(generate = true, strip_option)]
    dedicated_host_id: Option<String>,
    /// 部署集ID。
    ///
    /// 将ECS实例加入一个部署集，或调整ECS实例的部署集时，该参数为必填参数。
    ///
    /// > 修改专有宿主机的相关参数（`Tenancy`、`Affinity`和`DedicatedHostId`）时，不可同时修改部署集。
    #[setters(generate = true, strip_option)]
    deployment_set_id: Option<String>,
    /// 当ECS实例要加入或调整的部署集策略为部署集组高可用策略（AvailabilityGroup）时，可以通过该参数指定实例在部署集中的分组号。取值范围：1~7。
    ///
    /// > 如果您为ECS实例调整部署集，且部署集策略为部署集组高可用策略（`AvailablilityGroup`），当不指定该参数时，系统会自动在各组之间均衡分配ECS实例。如果您为ECS实例指定的仍是当前实例所属的部署集，系统也会重新在各组之间均衡分配ECS实例。
    #[setters(generate = true, strip_option)]
    deployment_set_group_no: Option<i32>,
    /// 实例在调整部署集时，是否强制更换实例宿主机。取值范围：
    ///          
    /// - true：允许。允许重启运行中（Running）、已停止（Stopped）状态的ECS实例。已停止状态的实例不包括启用节省停机模式的按量付费ECS实例。
    ///     > 如果您指定的ECS实例搭载了本地盘，则本地盘也会允许强制更换，这可能导致在更换宿主机时本地盘数据丢失，请谨慎操作。
    ///
    /// - false：不允许。只在当前宿主机上加入部署集。这可能导致更换部署集失败。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    force: Option<bool>,
    /// 实例是否与专有宿主机关联。取值范围：
    ///
    /// - host：关联。已启用节省停机模式的实例停机后再次启动时，仍部署在原专有宿主机上。
    ///
    /// - default：不关联。已启用节省停机模式的实例停机后再次启动时，若原专有宿主机资源不足，可迁移至自动部署资源池中的其它专有宿主机上。
    ///
    /// 实例从共享宿主机迁移至专有宿主机时，默认值为default。
    #[setters(generate = true, strip_option)]
    affinity: Option<String>,
    /// 实例是否在专有宿主机上部署。取值：host，仅支持实例在专有宿主机上部署。
    #[setters(generate = true, strip_option)]
    tenancy: Option<String>,
    /// 是否先停止实例，再迁移到目标专有宿主机。取值范围：
    ///
    /// - reboot：先停止实例再迁移。
    ///
    /// - live：不停止实例，直接迁移。此时，您必须指定参数DedicatedHostId。该取值不支持在迁移ECS实例的同时变更实例规格。
    ///
    /// 默认值：reboot。
    #[setters(generate = true, strip_option)]
    migration_type: Option<String>,
    /// ECS实例要变更的目标实例规格。调用[DescribeInstanceTypes](~~25620~~)接口可获取最新实例规格列表。
    ///
    /// 修改ECS实例宿主机时，可同时变更ECS实例规格。目标实例规格必须与指定专有宿主机的规格相匹配，详情请参见[宿主机规格](~~68564~~)。
    /// - 变更实例规格时，必须指定专有宿主机ID，即设置参数`DedicatedHostId`的值。
    /// - 使用自动部署功能迁移ECS实例时，不能变更实例规格。
    ///
    ///
    ///
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 专有宿主机集群ID。
    #[setters(generate = true, strip_option)]
    dedicated_host_cluster_id: Option<String>,
    /// 是否将所选实例移出所选部署集。取值范围：
    ///
    /// - true：是。
    ///
    /// - false：否。
    ///
    /// 默认值：false。
    ///
    /// > 当该参数为true时，必须指定具有所属关系的InstanceId和DeploymentSetId。
    #[setters(generate = true, strip_option)]
    remove_from_deployment_set: Option<bool>,
}

impl sealed::Bound for ModifyInstanceDeployment {}

impl ModifyInstanceDeployment {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
            dedicated_host_id: None,
            deployment_set_id: None,
            deployment_set_group_no: None,
            force: None,
            affinity: None,
            tenancy: None,
            migration_type: None,
            instance_type: None,
            dedicated_host_cluster_id: None,
            remove_from_deployment_set: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceDeployment {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceDeployment {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceDeployment";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceDeploymentResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(12);

        if let Some(f) = &self.affinity {
            params.push(("Affinity".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_cluster_id {
            params.push(("DedicatedHostClusterId".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_id {
            params.push(("DedicatedHostId".into(), (f).into()));
        }

        if let Some(f) = &self.deployment_set_group_no {
            params.push(("DeploymentSetGroupNo".into(), (f).into()));
        }

        if let Some(f) = &self.deployment_set_id {
            params.push(("DeploymentSetId".into(), (f).into()));
        }

        if let Some(f) = &self.force {
            params.push(("Force".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.migration_type {
            params.push(("MigrationType".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.remove_from_deployment_set {
            params.push(("RemoveFromDeploymentSet".into(), (f).into()));
        }

        if let Some(f) = &self.tenancy {
            params.push(("Tenancy".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDeploymentSetAttribute {
    /// 部署集ID。
    deployment_set_id: String,
    /// 新的部署集描述信息。长度为2~256个英文或中文字符，不能以http://和https://开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 新的部署集名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    deployment_set_name: Option<String>,
    /// 部署集所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
}

impl sealed::Bound for ModifyDeploymentSetAttribute {}

impl ModifyDeploymentSetAttribute {
    pub fn new(deployment_set_id: impl Into<String>, region_id: impl Into<String>) -> Self {
        Self {
            deployment_set_id: deployment_set_id.into(),
            description: None,
            deployment_set_name: None,
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for ModifyDeploymentSetAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDeploymentSetAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDeploymentSetAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDeploymentSetAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("DeploymentSetId".into(), (&self.deployment_set_id).into()));

        if let Some(f) = &self.deployment_set_name {
            params.push(("DeploymentSetName".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteDeploymentSet {
    /// 部署集所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 即将删除的部署集ID。
    deployment_set_id: String,
}

impl sealed::Bound for DeleteDeploymentSet {}

impl DeleteDeploymentSet {
    pub fn new(region_id: impl Into<String>, deployment_set_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            deployment_set_id: deployment_set_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteDeploymentSet {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteDeploymentSet {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteDeploymentSet";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteDeploymentSetResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("DeploymentSetId".into(), (&self.deployment_set_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateElasticityAssurance {
    /// 弹性保障服务所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性保障服务所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 弹性保障服务的标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<AssuranceTag>>,
    /// 购买时长。时长单位由`PeriodUnit`参数确定。取值范围：
    ///
    /// - 当`PeriodUnit`参数值为`Month`时，该参数的取值：1、2、3、4、5、6、7、8、9。
    /// - 当`PeriodUnit`参数值为`Year`时，该参数的取值：1、2、3、4、5。
    /// - 当`PeriodUnit`参数值为`Day`时，该参数的取值：1~365。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 时长单位。取值范围：
    ///
    /// - Month：月
    /// - Year：年
    /// - Day：天
    ///   > `PeriodUnit`取值为`Day`时，必须同时指定RecurrenceRules，表示创建弹性保障-分时保障。
    ///
    /// 默认值：Year。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。`ClientToken`只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 弹性保障服务的名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`和`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者连字符（-）。
    #[setters(generate = true, strip_option)]
    private_pool_options_name: Option<String>,
    /// 弹性保障服务的描述信息。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 弹性保障服务的匹配模式。取值范围：
    ///
    /// - Open：开放模式的弹性保障服务。实例启动时将自动匹配开放类型的私有池容量。如果没有符合条件的私有池容量，则使用公共池资源启动。
    /// - Target：指定模式的弹性保障服务。实例启动时将使用指定的私有池容量，如果该私有池容量不可用，则实例会启动失败。
    ///
    /// 默认值：Open。
    #[setters(generate = true, strip_option)]
    private_pool_options_match_criteria: Option<String>,
    /// 弹性保障的总次数。取值：Unlimited，目前仅支持在服务生效期内的无限次模式。
    ///
    /// 默认值：Unlimited。
    #[setters(generate = true, strip_option)]
    assurance_times: Option<String>,
    /// 在一个实例规格内，需要预留的实例的总数量。
    ///
    /// 取值范围：1~1000。
    ///
    /// ><notice>此参数为必填参数。></notice>
    #[setters(generate = true, strip_option)]
    instance_amount: Option<i32>,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    instance_cpu_core_count: Option<i32>,
    /// 弹性保障服务生效时间。默认为调用该接口创建服务的时间。时间格式以ISO 8601为标准，需要使用UTC +0时间，格式为`yyyy-MM-ddTHH:mm:ssZ`。更多信息，请参见[ISO 8601](~~25696~~)。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
    /// 弹性保障服务所属地域下的可用区ID。目前仅支持在一个可用区下创建弹性保障服务。
    zone_id: Vec<String>,
    /// 实例规格。目前仅支持为一个实例规格设置弹性保障服务。
    instance_type: Vec<String>,
    /// 弹性保障-分时保障重复规则列表。
    ///
    /// <props="china">
    ///
    /// > 弹性保障-分时保障功能当前仅对部分地域和用户开放，若您有使用需求，请[提交工单](https://selfservice.console.aliyun.com/ticket/createIndex)。
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// > 弹性保障-分时保障功能当前仅对部分地域和用户开放，若您有使用需求，请[提交工单](https://smartservice.console.aliyun.com/service/create-ticket-intl)。
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    recurrence_rules: Option<Vec<CreateElasticityAssuranceRecurrenceRule>>,
    /// 是否自动续费。取值范围：
    ///
    /// - true：自动续费。
    /// - false：不自动续费。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    auto_renew: Option<bool>,
    /// 自动续费的时长，单位：月。取值范围：1、2、3、6、12、24、36。
    ///
    ///
    ///
    /// - 当`PeriodUnit=Month`时，默认值为1；
    ///
    /// - 当`PeriodUnit=Year`时，默认值为12。
    ///
    ///
    /// > 当参数`AutoRenew`取值`True`时，该参数为必填参数。
    #[setters(generate = true, strip_option)]
    auto_renew_period: Option<i32>,
}

impl sealed::Bound for CreateElasticityAssurance {}

impl CreateElasticityAssurance {
    pub fn new(
        region_id: impl Into<String>,
        zone_id: impl Into<Vec<String>>,
        instance_type: impl Into<Vec<String>>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            tag: None,
            period: None,
            period_unit: None,
            client_token: None,
            private_pool_options_name: None,
            description: None,
            private_pool_options_match_criteria: None,
            assurance_times: None,
            instance_amount: None,
            instance_cpu_core_count: None,
            start_time: None,
            zone_id: zone_id.into(),
            instance_type: instance_type.into(),
            recurrence_rules: None,
            auto_renew: None,
            auto_renew_period: None,
        }
    }
}
impl crate::ToFormData for CreateElasticityAssurance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateElasticityAssurance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateElasticityAssurance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateElasticityAssuranceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(18);

        if let Some(f) = &self.assurance_times {
            params.push(("AssuranceTimes".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew {
            params.push(("AutoRenew".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew_period {
            params.push(("AutoRenewPeriod".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.instance_amount {
            params.push(("InstanceAmount".into(), (f).into()));
        }

        if let Some(f) = &self.instance_cpu_core_count {
            params.push(("InstanceCpuCoreCount".into(), (f).into()));
        }
        crate::FlatSerialize::flat_serialize(&self.instance_type, "InstanceType", &mut params);

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_match_criteria {
            params.push(("PrivatePoolOptions.MatchCriteria".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_name {
            params.push(("PrivatePoolOptions.Name".into(), (f).into()));
        }

        if let Some(f) = &self.recurrence_rules {
            crate::FlatSerialize::flat_serialize(f, "RecurrenceRules", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }
        crate::FlatSerialize::flat_serialize(&self.zone_id, "ZoneId", &mut params);

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeElasticityAssurances {
    /// 弹性保障服务所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 弹性保障服务绑定的标签键值对列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<AssurancesTag>>,
    /// 分页查询时每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 弹性保障服务查询起始标志。由上一次的请求结果中获取。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 弹性保障服务ID列表。取值可以由多个ID组成一个JSON数组，最多支持100个ID，ID之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    private_pool_options_ids: Option<String>,
    /// >该参数已废弃。
    #[setters(generate = true, strip_option)]
    platform: Option<String>,
    /// 实例规格。通过实例规格只可以查询还在生效中的弹性保障服务，已释放的服务只能通过`PrivatePoolOptions.Ids`查询。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 弹性保障服务所属地域下的可用区ID。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 实例的计费方式。取值：PostPaid，目前仅支持按量付费。
    ///
    /// 默认值：PostPaid。
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 弹性保障服务的状态。取值范围：
    ///
    /// - All：所有状态。
    /// - Deactived：待激活（该状态白名单邀测中）。
    /// - Preparing：准备中。
    /// - Prepared：待生效。
    /// - Active：生效中。
    /// - Released：已释放。
    ///
    /// 若不指定，则查询除Pending、Released以外状态的弹性保障。
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// 弹性保障服务类型，取值范围：
    ///
    /// - ElasticityAssurance：普通弹性保障（未指定RecurrenceRules时为普通弹性保障）。
    ///
    /// - TimeDivisionElasticityAssurance：分时弹性保障（指定RecurrenceRules时为分时弹性保障）。
    ///
    /// <props="china">
    ///
    /// > 弹性保障-分时保障功能当前仅对部分地域和用户开放，若您有使用需求，请[提交工单](https://selfservice.console.aliyun.com/ticket/createIndex)。
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// > 弹性保障-分时保障功能当前仅对部分地域和用户开放，若您有使用需求，请[提交工单](https://smartservice.console.aliyun.com/service/create-ticket-intl)。
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    package_type: Option<String>,
}

impl sealed::Bound for DescribeElasticityAssurances {}

impl DescribeElasticityAssurances {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            tag: None,
            max_results: None,
            next_token: None,
            private_pool_options_ids: None,
            platform: None,
            instance_type: None,
            zone_id: None,
            instance_charge_type: None,
            status: None,
            package_type: None,
        }
    }
}
impl crate::ToFormData for DescribeElasticityAssurances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeElasticityAssurances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeElasticityAssurances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeElasticityAssurancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(12);

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.package_type {
            params.push(("PackageType".into(), (f).into()));
        }

        if let Some(f) = &self.platform {
            params.push(("Platform".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_ids {
            params.push(("PrivatePoolOptions.Ids".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeElasticityAssuranceInstances {
    /// 弹性保障服务所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 分页查询时每页行数。
    ///
    /// 最大值：100
    ///
    /// 默认值：10
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 弹性保障服务查询起始标志。由上一次的请求结果中获取。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 弹性保障服务ID。
    private_pool_options_id: String,
}

impl sealed::Bound for DescribeElasticityAssuranceInstances {}

impl DescribeElasticityAssuranceInstances {
    pub fn new(region_id: impl Into<String>, private_pool_options_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            max_results: None,
            next_token: None,
            private_pool_options_id: private_pool_options_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeElasticityAssuranceInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeElasticityAssuranceInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeElasticityAssuranceInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeElasticityAssuranceInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push((
            "PrivatePoolOptions.Id".into(),
            (&self.private_pool_options_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyElasticityAssurance {
    /// 弹性保障服务所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性保障服务ID。
    private_pool_options_id: String,
    /// 弹性保障服务的名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以http://和https://开头。可以包含数字、半角冒号（:）、下划线（_）或者连字符（-）。
    #[setters(generate = true, strip_option)]
    private_pool_options_name: Option<String>,
    /// 弹性保障服务的描述信息。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 弹性保障服务需要预留的实例总数量。取值范围：已使用的实例数量~1000。该参数不能与其他参数同时修改。
    #[setters(generate = true, strip_option)]
    instance_amount: Option<i32>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。ClientToken只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 弹性保障-分时保障重复规则列表。
    ///
    /// <props="china">
    ///
    /// > 弹性保障-分时保障功能当前仅对部分地域和用户开放，若您有使用需求，请[提交工单](https://selfservice.console.aliyun.com/ticket/createIndex)。
    ///
    /// </props>
    ///
    /// <props="intl">
    ///
    /// > 弹性保障-分时保障功能当前仅对部分地域和用户开放，若您有使用需求，请[提交工单](https://smartservice.console.aliyun.com/service/create-ticket-intl)。
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    recurrence_rules: Option<Vec<ModifyElasticityAssuranceRecurrenceRule>>,
}

impl sealed::Bound for ModifyElasticityAssurance {}

impl ModifyElasticityAssurance {
    pub fn new(region_id: impl Into<String>, private_pool_options_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            private_pool_options_id: private_pool_options_id.into(),
            private_pool_options_name: None,
            description: None,
            instance_amount: None,
            client_token: None,
            recurrence_rules: None,
        }
    }
}
impl crate::ToFormData for ModifyElasticityAssurance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyElasticityAssurance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyElasticityAssurance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyElasticityAssuranceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.instance_amount {
            params.push(("InstanceAmount".into(), (f).into()));
        }
        params.push((
            "PrivatePoolOptions.Id".into(),
            (&self.private_pool_options_id).into(),
        ));

        if let Some(f) = &self.private_pool_options_name {
            params.push(("PrivatePoolOptions.Name".into(), (f).into()));
        }

        if let Some(f) = &self.recurrence_rules {
            crate::FlatSerialize::flat_serialize(f, "RecurrenceRules", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RenewElasticityAssurances {
    /// 弹性保障服务所属地域ID。
    ///
    /// 您可以调用[DescribeRegions](~~2680071~~)查看最新的阿里云地域列表。
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    /// 续费时长。时长单位由`PeriodUnit`参数确定。取值范围：
    ///
    /// - 当`PeriodUnit`参数值为`Month`时，该参数的取值：1、2、3、4、5、6、7、8、9。
    ///
    /// - 当`PeriodUnit`参数值为`Year`时，该参数的取值：1、2、3。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 续费时长单位。取值范围：
    ///
    /// - Month：月
    ///
    /// - Year：年
    ///
    /// 默认值：Year。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。
    ///
    /// `ClientToken`只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 是否自动支付。可能值：
    /// - true：是。
    /// - false：否。
    ///
    /// 默认值：true。
    #[setters(generate = true, strip_option)]
    auto_pay: Option<bool>,
    /// 弹性保障服务ID列表。
    ///
    /// **限制**：单次续费的弹性保障服务数量最多不超过20个。
    ///
    /// 您可以调用[DescribeElasticityAssurances](~~2679748~~)查看已购买的弹性保障服务。
    #[setters(generate = true, strip_option)]
    private_pool_options_id: Option<Vec<String>>,
    /// 是否自动续费。取值范围：
    ///
    /// - true：自动续费。
    ///
    /// - false：不自动续费。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    auto_renew: Option<bool>,
    /// 自动续费的时长，单位：月。取值范围：1、2、3、6、12、24、36。
    ///
    /// - 当`PeriodUnit=Month`时，默认值为1；
    ///
    /// - 当`PeriodUnit=Year`时，默认值为12。
    ///
    ///
    /// >当参数`AutoRenew`取值为`true`时，该参数为必填。
    #[setters(generate = true, strip_option)]
    auto_renew_period: Option<i32>,
}

impl sealed::Bound for RenewElasticityAssurances {}

impl RenewElasticityAssurances {
    pub fn new() -> Self {
        Self {
            region_id: None,
            period: None,
            period_unit: None,
            client_token: None,
            auto_pay: None,
            private_pool_options_id: None,
            auto_renew: None,
            auto_renew_period: None,
        }
    }
}
impl crate::ToFormData for RenewElasticityAssurances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RenewElasticityAssurances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RenewElasticityAssurances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RenewElasticityAssurancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.auto_pay {
            params.push(("AutoPay".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew {
            params.push(("AutoRenew".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew_period {
            params.push(("AutoRenewPeriod".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_id {
            crate::FlatSerialize::flat_serialize(f, "PrivatePoolOptions.Id", &mut params);
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyElasticityAssuranceAutoRenewAttribute {
    /// 弹性保障服务所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 设置实例自动续费时长。
    ///
    ///
    ///
    /// - 当`PeriodUnit`为`Year`时，取值范围：1、3、5。
    ///
    /// - 当`PeriodUnit`为`Month`时，取值范围：1。
    ///
    ///
    ///
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 续费时长的单位。取值范围：
    ///
    /// - Month：月
    ///
    /// - Year：年
    ///
    /// 默认值：Month。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 实例的自动续费状态。取值范围：
    ///
    /// - AutoRenewal：设置为自动续费。
    ///
    /// - Normal：取消自动续费。
    ///
    /// - NotRenewal：不再续费。传入该值后，系统不再发送到期提醒，只在到期前第三天发送不续费提醒。不再续费的弹性保障服务可以更改成待续费（`Normal`）后，再自行续费或设置为自动续费。
    #[setters(generate = true, strip_option)]
    renewal_status: Option<String>,
    /// 待修改的弹性保障服务ID列表。
    ///
    /// > 单次修改的弹性保障服务数量最多不超过 50 个。
    #[setters(generate = true, strip_option)]
    private_pool_options_id: Option<Vec<String>>,
}

impl sealed::Bound for ModifyElasticityAssuranceAutoRenewAttribute {}

impl ModifyElasticityAssuranceAutoRenewAttribute {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            period: None,
            period_unit: None,
            renewal_status: None,
            private_pool_options_id: None,
        }
    }
}
impl crate::ToFormData for ModifyElasticityAssuranceAutoRenewAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyElasticityAssuranceAutoRenewAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyElasticityAssuranceAutoRenewAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap =
        crate::JsonResponseWrap<ModifyElasticityAssuranceAutoRenewAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_id {
            crate::FlatSerialize::flat_serialize(f, "PrivatePoolOptions.Id", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.renewal_status {
            params.push(("RenewalStatus".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeElasticityAssuranceAutoRenewAttribute {
    /// 弹性保障服务所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性保障服务ID列表。
    ///
    ///
    /// **限制**：单次查询的弹性保障服务数量最多不超过50个。
    #[setters(generate = true, strip_option)]
    private_pool_options_id: Option<Vec<String>>,
}

impl sealed::Bound for DescribeElasticityAssuranceAutoRenewAttribute {}

impl DescribeElasticityAssuranceAutoRenewAttribute {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            private_pool_options_id: None,
        }
    }
}
impl crate::ToFormData for DescribeElasticityAssuranceAutoRenewAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeElasticityAssuranceAutoRenewAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeElasticityAssuranceAutoRenewAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap =
        crate::JsonResponseWrap<DescribeElasticityAssuranceAutoRenewAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);

        if let Some(f) = &self.private_pool_options_id {
            crate::FlatSerialize::flat_serialize(f, "PrivatePoolOptions.Id", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct PurchaseElasticityAssurance {
    /// 弹性保障服务所属地域 ID。您可以调用[DescribeRegions](~~2679950~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 购买时长。时长单位由PeriodUnit参数确定。取值范围：
    ///
    /// - 当PeriodUnit参数值为Month时，该参数的取值：1、2、3、4、5、6、7、8、9。
    /// - 当PeriodUnit参数值为Year时，该参数的取值：1、2、3、4、5。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 时长单位。取值范围：
    ///
    /// - Month：月
    /// - Year：年
    ///
    /// 默认值：Year。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 弹性保障服务ID。
    private_pool_options_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。`ClientToken`只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 弹性保障服务的匹配模式。取值范围：
    ///
    /// - Open：开放模式的弹性保障服务。实例启动时将自动匹配开放类型的私有池容量。如果没有符合条件的私有池容量，则使用公共池资源启动。
    /// - Target：指定模式的弹性保障服务。实例启动时将使用指定的私有池容量，如果该私有池容量不可用，则实例会启动失败。
    ///
    /// 默认值：Open。
    #[setters(generate = true, strip_option)]
    private_pool_options_match_criteria: Option<String>,
    /// 弹性保障服务生效时间。默认为调用该接口创建服务的时间。时间格式以ISO8601为标准，需要使用UTC +0时间，格式为`yyyy-MM-ddTHH:mm:ssZ`。更多信息，请参见[ISO8601](~~25696~~)。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
}

impl sealed::Bound for PurchaseElasticityAssurance {}

impl PurchaseElasticityAssurance {
    pub fn new(region_id: impl Into<String>, private_pool_options_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            period: None,
            period_unit: None,
            private_pool_options_id: private_pool_options_id.into(),
            client_token: None,
            private_pool_options_match_criteria: None,
            start_time: None,
        }
    }
}
impl crate::ToFormData for PurchaseElasticityAssurance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for PurchaseElasticityAssurance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "PurchaseElasticityAssurance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<PurchaseElasticityAssuranceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }
        params.push((
            "PrivatePoolOptions.Id".into(),
            (&self.private_pool_options_id).into(),
        ));

        if let Some(f) = &self.private_pool_options_match_criteria {
            params.push(("PrivatePoolOptions.MatchCriteria".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateCapacityReservation {
    /// 容量预定服务所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 容量预定服务所在的企业资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 容量预定服务绑定的标签对列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ReservationTag>>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。`ClientToken`只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 容量预定服务的名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`和`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    private_pool_options_name: Option<String>,
    /// 容量预定服务的描述信息。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 容量预定服务生效后生成的私有资源池的类型。取值范围：
    ///
    /// - Open：开放模式。启动实例时将自动匹配开放类型的私有池容量。如果没有符合条件的私有池容量，则使用公共池资源启动。
    /// - Target：专用模式。使用指定的私有池容量启动实例，如果该私有池容量不可用，则实例会启动失败。
    ///
    /// 默认值：Open。
    #[setters(generate = true, strip_option)]
    private_pool_options_match_criteria: Option<String>,
    /// 在一个实例规格内，需要预留的实例的总数量。
    instance_amount: i32,
    /// 实例规格。目前仅支持为一个实例规格设置容量预定服务。您可以调用[DescribeInstanceTypes](~~25620~~)查询云服务器ECS提供的实例规格信息。
    instance_type: String,
    /// 容量预定服务的生效方式。目前调用API的方式仅支持设置为立即生效。
    ///
    /// > 该参数不传值即表示设置为立即生效。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
    /// 容量预定服务的失效时间。时间格式以ISO 8601为标准，并需要使用UTC +0时间，格式为`yyyy-MM-ddTHH:mm:ssZ`。更多信息，请参见[ISO 8601](~~25696~~)。
    #[setters(generate = true, strip_option)]
    end_time: Option<String>,
    /// 容量预定服务的失效方式。取值范围：
    ///
    /// - Limited：指定时间释放。必须同时指定`EndTime`参数。
    /// - Unlimited：手动释放。不限制时间。
    #[setters(generate = true, strip_option)]
    end_time_type: Option<String>,
    /// 实例使用的镜像的操作系统类型。该参数与地域级预留实例券的`Platform`参数对应。如果容量预定服务和地域级预留实例券的操作系统类型相匹配，则可以使用地域级预留实例券来抵扣容量预定服务中的未使用容量的账单。取值范围：
    ///
    /// - Windows：Windows Server类型的操作系统。
    /// - Linux：Linux及类Unix类型的操作系统。
    ///
    /// 默认值：Linux。
    ///
    /// > 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    platform: Option<String>,
    /// 容量预定服务所属地域下的可用区ID。目前仅支持在一个可用区下创建容量预定服务。
    zone_id: Vec<String>,
}

impl sealed::Bound for CreateCapacityReservation {}

impl CreateCapacityReservation {
    pub fn new(
        region_id: impl Into<String>,
        instance_amount: impl Into<i32>,
        instance_type: impl Into<String>,
        zone_id: impl Into<Vec<String>>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            tag: None,
            client_token: None,
            private_pool_options_name: None,
            description: None,
            private_pool_options_match_criteria: None,
            instance_amount: instance_amount.into(),
            instance_type: instance_type.into(),
            start_time: None,
            end_time: None,
            end_time_type: None,
            platform: None,
            zone_id: zone_id.into(),
        }
    }
}
impl crate::ToFormData for CreateCapacityReservation {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateCapacityReservation {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateCapacityReservation";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateCapacityReservationResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(14);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.end_time {
            params.push(("EndTime".into(), (f).into()));
        }

        if let Some(f) = &self.end_time_type {
            params.push(("EndTimeType".into(), (f).into()));
        }
        params.push(("InstanceAmount".into(), (&self.instance_amount).into()));
        params.push(("InstanceType".into(), (&self.instance_type).into()));

        if let Some(f) = &self.platform {
            params.push(("Platform".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_match_criteria {
            params.push(("PrivatePoolOptions.MatchCriteria".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_name {
            params.push(("PrivatePoolOptions.Name".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }
        crate::FlatSerialize::flat_serialize(&self.zone_id, "ZoneId", &mut params);

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeCapacityReservations {
    /// 容量预定服务所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 容量预定服务绑定的标签对集合。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ReservationsTag>>,
    /// 分页查询时每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 容量预定服务查询起始标志。由上一次的请求结果中获取。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 容量预定服务ID列表。取值可以由多个ID组成一个JSON数组，最多支持100个ID，ID之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    private_pool_options_ids: Option<String>,
    /// 实例的操作系统。取值范围：
    ///
    /// - windows：仅查询Windows系统的容量预定服务。
    /// - linux：仅查Linux系统的容量预定服务。
    /// - all：查询所有容量预定服务。
    ///
    /// 默认值：all。
    #[setters(generate = true, strip_option)]
    platform: Option<String>,
    /// 实例规格。通过实例规格只可以查询还在生效中的容量预定服务，已释放的服务只能通过PrivatePoolOptions.Ids查询。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 容量预定服务所属的可用区ID。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 实例的计费方式。取值范围：
    ///
    /// - PostPaid：按量付费。
    /// - PrePaid：包年包月。
    ///
    /// 默认值：PostPaid。
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    /// 容量预定服务的状态。取值范围：
    ///
    /// - All：所有状态。
    /// - Pending：初始化。指定时间生效的容量预定会先进入初始化状态。
    /// - Preparing：准备中。指定时间生效的容量预定在资源交付进行阶段，处于准备中状态。
    /// - Prepared：待生效。指定时间生效的容量预定在资源交付完成，服务正式生效之前，处于待生效状态。
    /// - Active：生效中。
    /// - Released：已释放，包括手动释放与到期自动释放。
    ///
    /// 若不指定，则查询除Pending、Released以外状态的容量预定。
    #[setters(generate = true, strip_option)]
    status: Option<String>,
}

impl sealed::Bound for DescribeCapacityReservations {}

impl DescribeCapacityReservations {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            tag: None,
            max_results: None,
            next_token: None,
            private_pool_options_ids: None,
            platform: None,
            instance_type: None,
            zone_id: None,
            instance_charge_type: None,
            status: None,
        }
    }
}
impl crate::ToFormData for DescribeCapacityReservations {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeCapacityReservations {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeCapacityReservations";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeCapacityReservationsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(11);

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.platform {
            params.push(("Platform".into(), (f).into()));
        }

        if let Some(f) = &self.private_pool_options_ids {
            params.push(("PrivatePoolOptions.Ids".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeCapacityReservationInstances {
    /// 容量预定服务所属地域 ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 分页查询时每页行数。
    ///
    /// - 最大值：100
    ///
    /// - 默认值：10
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 容量预定服务查询起始标志。由上一次的请求结果中获取。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 容量预定服务 ID。
    private_pool_options_id: String,
}

impl sealed::Bound for DescribeCapacityReservationInstances {}

impl DescribeCapacityReservationInstances {
    pub fn new(region_id: impl Into<String>, private_pool_options_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            max_results: None,
            next_token: None,
            private_pool_options_id: private_pool_options_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeCapacityReservationInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeCapacityReservationInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeCapacityReservationInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeCapacityReservationInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push((
            "PrivatePoolOptions.Id".into(),
            (&self.private_pool_options_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyCapacityReservation {
    /// 容量预定服务所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 容量预定服务ID。
    private_pool_options_id: String,
    /// 容量预定服务的名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`和`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者连字符（-）。
    #[setters(generate = true, strip_option)]
    private_pool_options_name: Option<String>,
    /// 容量预定服务的描述信息。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 容量预定服务的生效方式。目前仅支持设置为立即生效，且参数无需传值。
    ///
    /// > 该参数不传值即表示设置为立即生效。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
    /// 容量预定服务的失效时间，仅`EndTimeType=Limited`时该参数生效。时间格式以ISO8601为标准，并需要使用UTC +0时间，格式为`yyyy-MM-ddTHH:mm:ssZ`。更多信息，请参见[ISO8601](~~25696~~)。
    #[setters(generate = true, strip_option)]
    end_time: Option<String>,
    /// 容量预定服务的失效方式。取值范围：
    ///
    /// - Limited：指定时间释放。必须同时指定`EndTime`参数。
    /// - Unlimited：手动释放。不限制时间。
    #[setters(generate = true, strip_option)]
    end_time_type: Option<String>,
    /// 实例使用的镜像的操作系统类型。取值范围：
    ///
    /// - Windows：Windows Server类型的操作系统。
    /// - Linux：Linux及类Unix类型的操作系统。
    ///
    /// > 该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    platform: Option<String>,
    /// 容量预定服务需要预留的实例总数量。取值范围：已使用的实例数量~1000
    ///
    /// > 扩充实例总数量时，可能因库存不足导致扩充失败。
    #[setters(generate = true, strip_option)]
    instance_amount: Option<i32>,
}

impl sealed::Bound for ModifyCapacityReservation {}

impl ModifyCapacityReservation {
    pub fn new(region_id: impl Into<String>, private_pool_options_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            private_pool_options_id: private_pool_options_id.into(),
            private_pool_options_name: None,
            description: None,
            start_time: None,
            end_time: None,
            end_time_type: None,
            platform: None,
            instance_amount: None,
        }
    }
}
impl crate::ToFormData for ModifyCapacityReservation {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyCapacityReservation {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyCapacityReservation";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyCapacityReservationResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.end_time {
            params.push(("EndTime".into(), (f).into()));
        }

        if let Some(f) = &self.end_time_type {
            params.push(("EndTimeType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_amount {
            params.push(("InstanceAmount".into(), (f).into()));
        }

        if let Some(f) = &self.platform {
            params.push(("Platform".into(), (f).into()));
        }
        params.push((
            "PrivatePoolOptions.Id".into(),
            (&self.private_pool_options_id).into(),
        ));

        if let Some(f) = &self.private_pool_options_name {
            params.push(("PrivatePoolOptions.Name".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceAttachmentAttributes {
    /// 弹性保障服务所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID。取值可以由多个实例ID组成一个JSON数组，最多支持100个ID，ID之间用半角逗号（,）隔开。
    instance_ids: String,
    /// 实例状态列表的页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeInstanceAttachmentAttributes {}

impl DescribeInstanceAttachmentAttributes {
    pub fn new(region_id: impl Into<String>, instance_ids: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_ids: instance_ids.into(),
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeInstanceAttachmentAttributes {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceAttachmentAttributes {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceAttachmentAttributes";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceAttachmentAttributesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("InstanceIds".into(), (&self.instance_ids).into()));

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceAttachmentAttributes {
    /// 私有池所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 需要修改私有池匹配属性的实例ID。
    instance_id: String,
    /// 修改实例的私有池匹配模式。取值范围：
    ///
    /// - Open：开放模式。该模式下系统自动为实例匹配开放的私有池。如果没有符合条件的私有池容量，则使用公共池资源启动。
    /// - Target：指定模式。使用指定的私有池容量启动实例，如果该私有池容量不可用，则实例会启动失败。该模式下必须同时指定`PrivatePoolOptions.Id`参数，设置指定的私有池ID。
    /// - None：不使用。该模式下实例正常启动，不使用私有池。
    private_pool_options_match_criteria: String,
    /// 私有池ID，即弹性保障服务ID或者容量预定服务ID。
    ///
    /// - 当`PrivatePoolOptions.MatchCriteria`取值为`Target`时，该参数为必填项。
    /// - 当`PrivatePoolOptions.MatchCriteria`取值为`Open`或`None`时，该参数不传值。
    #[setters(generate = true, strip_option)]
    private_pool_options_id: Option<String>,
}

impl sealed::Bound for ModifyInstanceAttachmentAttributes {}

impl ModifyInstanceAttachmentAttributes {
    pub fn new(
        region_id: impl Into<String>,
        instance_id: impl Into<String>,
        private_pool_options_match_criteria: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
            private_pool_options_match_criteria: private_pool_options_match_criteria.into(),
            private_pool_options_id: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceAttachmentAttributes {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceAttachmentAttributes {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceAttachmentAttributes";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceAttachmentAttributesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.private_pool_options_id {
            params.push(("PrivatePoolOptions.Id".into(), (f).into()));
        }
        params.push((
            "PrivatePoolOptions.MatchCriteria".into(),
            (&self.private_pool_options_match_criteria).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ReleaseCapacityReservation {
    /// 容量预定服务所属地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 容量预定服务ID。
    private_pool_options_id: String,
    /// 是否对此次请求进行检索。取值：false，目前仅支持不检索本次请求，直接释放容量预定服务。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for ReleaseCapacityReservation {}

impl ReleaseCapacityReservation {
    pub fn new(region_id: impl Into<String>, private_pool_options_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            private_pool_options_id: private_pool_options_id.into(),
            dry_run: None,
        }
    }
}
impl crate::ToFormData for ReleaseCapacityReservation {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ReleaseCapacityReservation {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ReleaseCapacityReservation";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ReleaseCapacityReservationResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }
        params.push((
            "PrivatePoolOptions.Id".into(),
            (&self.private_pool_options_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct PurchaseReservedInstancesOffering {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)获取最新的阿里云地域列表。
    region_id: String,
    /// 标签数组。数组长度：0~20。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<OfferingTag>>,
    /// 资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 可用区ID，当`Scope`为`Zone`时生效且必填。您可以调用[DescribeZones](~~25610~~)获取可用区列表。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 预留实例券的名称。长度为2~128个英文或中文字符，必须以大小写字母或中文开头，不能以 http:// 和 https:// 开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    reserved_instance_name: Option<String>,
    /// 预留实例券可以匹配的实例规格。
    ///
    /// > 适用的实例规格持续更新，详情请参见[预留实例券概述](~~100370#3c1b682051vt4~~)。
    instance_type: String,
    /// 预留实例券的范围。取值范围：
    ///    
    /// - Region：地域级别。
    /// - Zone：可用区级别。
    ///
    /// 默认值：Region。
    #[setters(generate = true, strip_option)]
    scope: Option<String>,
    /// 预留实例券可以同时匹配同规格按量付费实例的数量。取值范围：1~50。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    instance_amount: Option<i32>,
    /// 预留实例券的付款类型。取值范围：
    ///          
    /// - No Upfront：零预付。
    /// - Partial Upfront：部分预付。
    /// - All Upfront：全预付。
    ///
    /// 默认值：All Upfront。
    #[setters(generate = true, strip_option)]
    offering_type: Option<String>,
    /// 预留实例券的描述。长度为2~256个英文或中文字符，不能以http://和https://开头。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 实例使用的镜像的操作系统类型。取值范围：
    ///
    /// - Windows：Windows Server类型的操作系统。
    /// - Linux：Linux及类Unix类型的操作系统。
    ///
    /// 默认值：Linux。
    #[setters(generate = true, strip_option)]
    platform: Option<String>,
    /// 购买预留实例券的时长。
    ///
    /// <props="intl">取值范围：1、3。</props>
    ///
    ///
    /// <props="china">
    ///
    /// - 当`PeriodUnit`为`Year`时，取值范围：1、3、5。
    ///
    /// - 当`PeriodUnit`为`Month`时，取值范围：1。
    ///
    /// </props>
    ///
    ///
    /// 默认值：1。
    ///
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 购买预留实例券的时长单位。
    ///
    /// <props="intl">取值范围：Year。</props>
    ///
    /// <props="intl">默认值：Year。</props>
    ///
    /// <props="china">取值范围：Year、Month。</props>
    ///
    /// <props="china">默认值：Month。</props>
    ///
    ///
    ///
    ///
    ///
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 是否要自动续费。可选值：
    ///
    /// - true：自动续费。
    /// - false（默认）：不自动续费。
    #[setters(generate = true, strip_option)]
    auto_renew: Option<bool>,
    /// 每次自动续费的时长，单位为月。当参数AutoRenew取值True时，该参数才生效。
    ///
    /// <props="china">AutoRenewPeriod取值范围：1，12，36，60。</props>
    ///
    /// <props="china">当PeriodUnit=Month， 默认值为1。</props>
    ///
    /// <props="intl">AutoRenewPeriod取值范围：12，36。</props>
    ///
    /// 当PeriodUnit=Year，默认值为12。
    #[setters(generate = true, strip_option)]
    auto_renew_period: Option<i32>,
    /// 预留实例券的指定生效时间。按照[ISO 8601](~~25696~~)标准表示，使用 UTC+0 时间。格式为：`yyyy-MM-ddTHHZ`。
    ///
    /// > 生效时间不填写时，默认从当前时间的整点时间开始生效。例如，你在2024-11-01 13:45:35成功购买，生效时间则为2024-11-01 13:00:00。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
}

impl sealed::Bound for PurchaseReservedInstancesOffering {}

impl PurchaseReservedInstancesOffering {
    pub fn new(region_id: impl Into<String>, instance_type: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            tag: None,
            resource_group_id: None,
            zone_id: None,
            reserved_instance_name: None,
            instance_type: instance_type.into(),
            scope: None,
            instance_amount: None,
            offering_type: None,
            description: None,
            platform: None,
            period: None,
            period_unit: None,
            client_token: None,
            auto_renew: None,
            auto_renew_period: None,
            start_time: None,
        }
    }
}
impl crate::ToFormData for PurchaseReservedInstancesOffering {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for PurchaseReservedInstancesOffering {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "PurchaseReservedInstancesOffering";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<PurchaseReservedInstancesOfferingResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(17);

        if let Some(f) = &self.auto_renew {
            params.push(("AutoRenew".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew_period {
            params.push(("AutoRenewPeriod".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.instance_amount {
            params.push(("InstanceAmount".into(), (f).into()));
        }
        params.push(("InstanceType".into(), (&self.instance_type).into()));

        if let Some(f) = &self.offering_type {
            params.push(("OfferingType".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }

        if let Some(f) = &self.platform {
            params.push(("Platform".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.reserved_instance_name {
            params.push(("ReservedInstanceName".into(), (f).into()));
        }

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.scope {
            params.push(("Scope".into(), (f).into()));
        }

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeReservedInstances {
    /// 预留实例券所属的地域ID。您可以调用[DescribeRegions](~~25609~~)获取最新的阿里云地域列表。
    region_id: String,
    /// 预留实例券列表的页码，起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时的每页行数，最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 标签数组。数组长度：1~20。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ReservedInstancesTag>>,
    /// 实例所属的可用区编号，当Scope为Zone时生效并且必填。您可以通过[DescribeZones](~~25610~~)获取可用区列表。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 预留实例券名称。
    ///
    /// > 完全匹配，暂不支持模糊查询过滤。
    #[setters(generate = true, strip_option)]
    reserved_instance_name: Option<String>,
    /// 锁定类型。取值范围：
    ///
    /// - financial：账号欠费或服务过期。
    /// - security：安全原因。
    #[setters(generate = true, strip_option)]
    lock_reason: Option<String>,
    /// 预留实例券对应的实例规格。取值请参见[实例规格族](~~25378~~)。
    ///
    /// > 购买预留实例券时选择的实例规格，实际抵扣的时候，地域级预留实例券支持同规格组内的不同大小规格换算抵扣。
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
    /// 预留实例券对应的实例规格族。取值请参见[实例规格族](~~25378~~)。
    #[setters(generate = true, strip_option)]
    instance_type_family: Option<String>,
    /// 预留实例券的范围。取值范围：
    ///          
    /// - Region：地域级别。
    /// - Zone：可用区级别。
    #[setters(generate = true, strip_option)]
    scope: Option<String>,
    /// 预留实例券的付款类型。取值范围：
    ///
    /// - No Upfront：零预付。
    /// - Partial Upfront：部分预付。
    /// - All Upfront：全预付。
    #[setters(generate = true, strip_option)]
    offering_type: Option<String>,
    /// 分配类型。取值范围：
    ///
    /// - Normal：查询当前账号下的预留实例券。
    /// - Shared：查询当前账号下已经建立主子账号共享的预留实例券。
    ///
    /// 默认值：Normal。
    #[setters(generate = true, strip_option)]
    allocation_type: Option<String>,
    /// 预留实例券ID数组。数组长度：1~100。
    #[setters(generate = true, strip_option)]
    reserved_instance_id: Option<Vec<String>>,
    /// 预留实例券的状态数组。
    #[setters(generate = true, strip_option)]
    status: Option<Vec<String>>,
}

impl sealed::Bound for DescribeReservedInstances {}

impl DescribeReservedInstances {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
            tag: None,
            zone_id: None,
            reserved_instance_name: None,
            lock_reason: None,
            instance_type: None,
            instance_type_family: None,
            scope: None,
            offering_type: None,
            allocation_type: None,
            reserved_instance_id: None,
            status: None,
        }
    }
}
impl crate::ToFormData for DescribeReservedInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeReservedInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeReservedInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeReservedInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(14);

        if let Some(f) = &self.allocation_type {
            params.push(("AllocationType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.instance_type_family {
            params.push(("InstanceTypeFamily".into(), (f).into()));
        }

        if let Some(f) = &self.lock_reason {
            params.push(("LockReason".into(), (f).into()));
        }

        if let Some(f) = &self.offering_type {
            params.push(("OfferingType".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.reserved_instance_id {
            crate::FlatSerialize::flat_serialize(f, "ReservedInstanceId", &mut params);
        }

        if let Some(f) = &self.reserved_instance_name {
            params.push(("ReservedInstanceName".into(), (f).into()));
        }

        if let Some(f) = &self.scope {
            params.push(("Scope".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            crate::FlatSerialize::flat_serialize(f, "Status", &mut params);
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyReservedInstances {
    /// 预留实例券所属的地域ID。
    ///
    /// 您可以调用[DescribeRegions](~~25609~~)获取最新的阿里云地域列表。
    region_id: String,
    /// 预留实例券ID数组。数组长度：1~20。
    reserved_instance_id: Vec<String>,
    /// 预留实例券的配置信息数组。数组长度：1~100。
    #[setters(generate = true, strip_option)]
    configuration: Option<Vec<InstancesConfiguration>>,
}

impl sealed::Bound for ModifyReservedInstances {}

impl ModifyReservedInstances {
    pub fn new(region_id: impl Into<String>, reserved_instance_id: impl Into<Vec<String>>) -> Self {
        Self {
            region_id: region_id.into(),
            reserved_instance_id: reserved_instance_id.into(),
            configuration: None,
        }
    }
}
impl crate::ToFormData for ModifyReservedInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyReservedInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyReservedInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyReservedInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.configuration {
            crate::FlatSerialize::flat_serialize(f, "Configuration", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance_id,
            "ReservedInstanceId",
            &mut params,
        );

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyReservedInstanceAttribute {
    /// 资源所在的地域ID。
    region_id: String,
    /// 预留实例券ID。
    reserved_instance_id: String,
    /// 预留实例券的名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`和`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    reserved_instance_name: Option<String>,
    /// 预留实例券的描述。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for ModifyReservedInstanceAttribute {}

impl ModifyReservedInstanceAttribute {
    pub fn new(region_id: impl Into<String>, reserved_instance_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            reserved_instance_id: reserved_instance_id.into(),
            reserved_instance_name: None,
            description: None,
        }
    }
}
impl crate::ToFormData for ModifyReservedInstanceAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyReservedInstanceAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyReservedInstanceAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyReservedInstanceAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push((
            "ReservedInstanceId".into(),
            (&self.reserved_instance_id).into(),
        ));

        if let Some(f) = &self.reserved_instance_name {
            params.push(("ReservedInstanceName".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RenewReservedInstances {
    /// 预留实例券ID。
    #[setters(generate = true, strip_option)]
    reserved_instance_id: Option<Vec<String>>,
    /// 预留实例券所属的地域ID。
    ///
    /// 您可以调用[DescribeRegions](~~25609~~)获取最新的阿里云地域列表。
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    /// 购买预留实例券的时长。
    ///
    /// <props="intl">取值范围：1、3。</props>
    ///
    ///
    /// <props="china">
    ///
    /// - 当`PeriodUnit`为`Year`时，取值范围：1、3、5。
    ///
    /// - 当`PeriodUnit`为`Month`时，取值范围：1。
    ///
    /// </props>
    ///
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 购买预留实例券的时长单位。
    ///
    /// <props="intl">取值范围：Year。</props>
    ///
    /// <props="intl">默认值：Year。</props>
    ///
    /// <props="china">取值范围：Year、Month。</props>
    ///
    /// <props="china">默认值：Month。</props>
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 是否要自动续费。
    ///
    /// - true：自动续费。
    /// - false：不自动续费。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    auto_renew: Option<bool>,
    /// 每次自动续费的时长，单位为月。当参数AutoRenew取值为true时，该参数才生效。
    ///
    /// <props="intl">取值范围：12，36。默认值为12。</props>
    ///
    /// <props="china">
    ///
    /// - PeriodUnit=Month， 取值范围：1，12，36，60。默认值为1。
    ///
    /// - PeriodUnit=Year，取值范围：12，36，60。默认值为12。
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    auto_renew_period: Option<i32>,
}

impl sealed::Bound for RenewReservedInstances {}

impl RenewReservedInstances {
    pub fn new() -> Self {
        Self {
            reserved_instance_id: None,
            region_id: None,
            period: None,
            period_unit: None,
            client_token: None,
            auto_renew: None,
            auto_renew_period: None,
        }
    }
}
impl crate::ToFormData for RenewReservedInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RenewReservedInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RenewReservedInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RenewReservedInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.auto_renew {
            params.push(("AutoRenew".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew_period {
            params.push(("AutoRenewPeriod".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        if let Some(f) = &self.reserved_instance_id {
            crate::FlatSerialize::flat_serialize(f, "ReservedInstanceId", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeReservedInstanceAutoRenewAttribute {
    /// 预留实例券所属的地域ID。
    ///
    /// 您可以调用[DescribeRegions](~~25609~~)获取最新的阿里云地域列表。
    region_id: String,
    /// 预留实例券ID数组。
    #[setters(generate = true, strip_option)]
    reserved_instance_id: Option<Vec<String>>,
}

impl sealed::Bound for DescribeReservedInstanceAutoRenewAttribute {}

impl DescribeReservedInstanceAutoRenewAttribute {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            reserved_instance_id: None,
        }
    }
}
impl crate::ToFormData for DescribeReservedInstanceAutoRenewAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeReservedInstanceAutoRenewAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeReservedInstanceAutoRenewAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeReservedInstanceAutoRenewAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.reserved_instance_id {
            crate::FlatSerialize::flat_serialize(f, "ReservedInstanceId", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyReservedInstanceAutoRenewAttribute {
    /// 预留实例券所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 自动续费周期。取值范围：
    ///
    /// <props="intl">取值范围：1、3。</props>
    ///
    /// <props="china">
    ///
    /// - 当`PeriodUnit`为`Year`时，取值范围：1、3、5。
    ///
    /// - 当`PeriodUnit`为`Month`时，取值范围：1。
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 自动续费时长单位。
    ///
    /// <props="intl">取值范围：Year。</props>
    ///
    /// <props="china">取值范围：Month、Year。</props>
    ///
    /// <props="china">默认值：Month。</props>
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 是否自动续费包年包月预留实例券。取值范围：
    ///
    /// - AutoRenewal：自动续费。
    /// - Normal：手动续费。
    #[setters(generate = true, strip_option)]
    renewal_status: Option<String>,
    /// 预留实例券ID。
    #[setters(generate = true, strip_option)]
    reserved_instance_id: Option<Vec<String>>,
}

impl sealed::Bound for ModifyReservedInstanceAutoRenewAttribute {}

impl ModifyReservedInstanceAutoRenewAttribute {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            period: None,
            period_unit: None,
            renewal_status: None,
            reserved_instance_id: None,
        }
    }
}
impl crate::ToFormData for ModifyReservedInstanceAutoRenewAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyReservedInstanceAutoRenewAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyReservedInstanceAutoRenewAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyReservedInstanceAutoRenewAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.renewal_status {
            params.push(("RenewalStatus".into(), (f).into()));
        }

        if let Some(f) = &self.reserved_instance_id {
            crate::FlatSerialize::flat_serialize(f, "ReservedInstanceId", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct PurchaseStorageCapacityUnit {
    /// SCU所属的地域ID。确定地域后，SCU只能抵扣该地域下云盘的按量付费账单。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// SCU的名称，长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http://`或`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// SCU容量大小，单位为GiB。取值范围：20、40、100、200、500、1024、2048、5210、10240、20480、52100。
    capacity: i32,
    /// SCU的描述信息，长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// SCU的生效时间。生效时间不能超过创建时间开始的180天。按照[ISO 8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHHZ。
    ///
    /// 默认值：无，表示从创建时间开始生效。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
    /// SCU的有效期时长。取值范围：
    ///
    /// - 当PeriodUnit=Month时，Period参数的有效取值为1、2、3、6。
    /// - 当PeriodUnit=Year时，Period参数的有效取值为1、3、5。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// SCU的有效期时长单位。取值范围：
    ///
    /// - Month：月。
    /// - Year：年。
    ///
    /// 默认值：Month。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 用于备注请求来源，默认值为OpenAPI，无需手动设置。
    #[setters(generate = true, strip_option)]
    from_app: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。`ClientToken`只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 购买的SCU的数量。取值范围：1~20。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    amount: Option<i32>,
    /// 标签数组。数组长度：1~20。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<UnitTag>>,
    /// 存储容量单位包所在的资源组ID。您只能传入已有权限的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
}

impl sealed::Bound for PurchaseStorageCapacityUnit {}

impl PurchaseStorageCapacityUnit {
    pub fn new(region_id: impl Into<String>, capacity: impl Into<i32>) -> Self {
        Self {
            region_id: region_id.into(),
            name: None,
            capacity: capacity.into(),
            description: None,
            start_time: None,
            period: None,
            period_unit: None,
            from_app: None,
            client_token: None,
            amount: None,
            tag: None,
            resource_group_id: None,
        }
    }
}
impl crate::ToFormData for PurchaseStorageCapacityUnit {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for PurchaseStorageCapacityUnit {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "PurchaseStorageCapacityUnit";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<PurchaseStorageCapacityUnitResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(12);

        if let Some(f) = &self.amount {
            params.push(("Amount".into(), (f).into()));
        }
        params.push(("Capacity".into(), (&self.capacity).into()));

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.from_app {
            params.push(("FromApp".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeStorageCapacityUnits {
    /// SCU所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// SCU列表的页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时的每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// SCU的名称，长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以`http:/`/或`https://`开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// SCU容量大小，单位为GiB。取值范围：{20, 40, 100, 200, 500, 1024, 2048, 5120, 10240, 20480, 51200}。
    #[setters(generate = true, strip_option)]
    capacity: Option<i32>,
    /// 分配类型。取值范围：
    ///
    /// - Normal：查询当前阿里云账号下的SCU。
    /// - Shared：查询已经建立阿里云账号与RAM用户共享的SCU。
    ///
    /// 默认值：Normal。
    #[setters(generate = true, strip_option)]
    allocation_type: Option<String>,
    /// SCU的ID数组。数组长度：1~100。
    #[setters(generate = true, strip_option)]
    storage_capacity_unit_id: Option<Vec<String>>,
    /// SCU的状态数组，数组长度为1~4。
    #[setters(generate = true, strip_option)]
    status: Option<Vec<String>>,
    /// 标签数组。数组长度：0~20。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<UnitsTag>>,
}

impl sealed::Bound for DescribeStorageCapacityUnits {}

impl DescribeStorageCapacityUnits {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
            name: None,
            capacity: None,
            allocation_type: None,
            storage_capacity_unit_id: None,
            status: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeStorageCapacityUnits {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeStorageCapacityUnits {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeStorageCapacityUnits";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeStorageCapacityUnitsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);

        if let Some(f) = &self.allocation_type {
            params.push(("AllocationType".into(), (f).into()));
        }

        if let Some(f) = &self.capacity {
            params.push(("Capacity".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.status {
            crate::FlatSerialize::flat_serialize(f, "Status", &mut params);
        }

        if let Some(f) = &self.storage_capacity_unit_id {
            crate::FlatSerialize::flat_serialize(f, "StorageCapacityUnitId", &mut params);
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyStorageCapacityUnitAttribute {
    /// SCU所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// SCU ID。
    storage_capacity_unit_id: String,
    /// SCU的新名称，长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以http://和https://开头。可以包含数字、半角冒号（:）、下划线（_）或者连字符（-）。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// SCU的新描述信息，长度为2~256个英文或中文字符，不能以http://和https://开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for ModifyStorageCapacityUnitAttribute {}

impl ModifyStorageCapacityUnitAttribute {
    pub fn new(region_id: impl Into<String>, storage_capacity_unit_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            storage_capacity_unit_id: storage_capacity_unit_id.into(),
            name: None,
            description: None,
        }
    }
}
impl crate::ToFormData for ModifyStorageCapacityUnitAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyStorageCapacityUnitAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyStorageCapacityUnitAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyStorageCapacityUnitAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push((
            "StorageCapacityUnitId".into(),
            (&self.storage_capacity_unit_id).into(),
        ));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RunCommand {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 命令执行的资源组ID，当指定该参数时：
    ///
    /// - 当InstanceId对应的ECS实例属于非默认资源组时，该ECS实例必须属于该资源组。
    ///
    /// - 支持通过指定该参数筛选出对应的命令执行结果（通过调用[DescribeInvocations](~~64840~~)或[DescribeInvocationResults](~~64845~~)）。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 命令名称。支持全字符集，长度不得超过128个字符。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// 命令描述。支持全字符集，长度不得超过512个字符。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 命令类型。取值范围：
    ///
    /// - RunBatScript：适用于Windows实例的Bat命令。
    /// - RunPowerShellScript：适用于Windows实例的PowerShell命令。
    /// - RunShellScript：适用于Linux实例的Shell命令。
    r#type: String,
    /// 命令内容。命令内容可以是明文内容或Base64编码后的内容。您需要注意：
    ///
    /// - 若保存命令，命令内容在Base64编码后的大小不能超过18 KB；若不保存命令，命令内容在Base64编码后的大小不能超过24 KB。您可通过`KeepCommand`设置是否保留命令。
    /// - 如果您的命令内容是Base64编码后的内容，则必须设置`ContentEncoding=Base64`。
    /// - 指定参数`EnableParameter=true`可在命令内容中启用自定义参数功能：
    ///     - 用`{{}}`包含的方式定义自定义参数，在`{{}}`内参数名前后的空格以及换行符会被忽略。
    ///     - 自定义参数个数不能超过20个。
    ///     - 自定义参数名允许a-zA-Z0-9-_的组合，不支持acs::前缀指定非内置环境参数，不支持其余字符，参数名不区分大小写。
    ///     - 单个自定义参数名不能超过64字节。
    ///
    /// - 您可以指定内置环境参数作为自定义参数，执行命令时无需手动对参数赋值，云助手将为您自动替换为环境中对应的值。支持指定以下内置环境参数：
    ///     - `{{ACS::RegionId}}`：地域ID。
    ///     - `{{ACS::AccountId}}`：阿里云主账号UID。
    ///     - `{{ACS::InstanceId}}`：实例ID。命令下发到多个实例时，如需指定`{{ACS::InstanceId}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.309
    ///         - Windows：2.1.3.309
    ///     - `{{ACS::InstanceName}}`：实例名称。命令下发到多个实例时，如需指定`{{ACS::InstanceName}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.344
    ///         - Windows：2.1.3.344
    ///     - `{{ACS::InvokeId}}`：命令执行ID。如需指定`{{ACS::InvokeId}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.309
    ///         - Windows：2.1.3.309
    ///     - `{{ACS::CommandId}}`：命令ID。通过调用本接口执行命令时，如需指定`{{ACS::CommandId}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.309
    ///         - Windows：2.1.3.309
    command_content: String,
    /// 命令在ECS实例中的运行目录。长度不得超过200个字符。
    ///
    /// 默认值：
    ///
    /// - Linux系统实例默认在管理员（root用户）的home目录下，即`/root`。
    /// - Windows系统实例默认在云助手Agent进程所在目录，例如`C:\Windows\System32`。
    #[setters(generate = true, strip_option)]
    working_dir: Option<String>,
    /// 执行命令的超时时间，单位：秒。
    ///
    /// 当因为进程原因、缺失模块、缺失云助手Agent等原因无法运行命令时，会出现超时现象。超时后，会强制终止命令进程。
    ///
    /// 默认值：60。
    #[setters(generate = true, strip_option)]
    timeout: Option<i64>,
    /// 命令中是否包含自定义参数。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    enable_parameter: Option<bool>,
    /// 设置命令执行的方式。取值范围：
    ///
    /// - Once：立即执行命令。
    /// - Period：定时执行命令。当该参数取值为`Period`时，必须同时指定`Frequency`参数。
    /// - NextRebootOnly：当实例下一次启动时，自动执行命令。
    /// - EveryReboot：实例每一次启动都将自动执行命令。
    /// - DryRun：只预检此次请求，命令执行不会实际生效，检查项包括请求参数、实例执行环境、云助手Agent运行状态等。
    ///
    /// 默认值：
    /// - 当不指定`Frequency`参数时，默认值为`Once`。
    /// - 当指定`Frequency`参数时，无论是否已设置了该参数值，都将按照`Period`处理。
    ///
    /// 注意事项：
    /// - 您可以调用[StopInvocation](~~64838~~)停止待执行的命令或定时执行的命令。
    /// - 当该参数取值`Period`或者`EveryReboot`时，您可以调用[DescribeInvocationResults](~~64845~~)，然后指定`IncludeHistory=true`查看命令定时执行的历史记录。
    #[setters(generate = true, strip_option)]
    repeat_mode: Option<String>,
    /// >该参数已废弃，传入该参数不会生效。
    #[setters(generate = true, strip_option)]
    timed: Option<bool>,
    /// 定时执行命令的执行时间。目前支持三种定时执行方式：固定时间间隔执行（基于Rate表达式）、仅在指定时间执行一次、基于时钟定时执行（基于Cron表达式）。
    ///
    /// - 固定时间间隔执行：基于Rate表达式，按照设置的时间间隔执行命令。时间间隔支持按秒（s） 、分钟（m） 、小时（h）和天（d）来选择，适用于在固定时间间隔执行任务的场景。格式为`rate(<执行间隔数值><执行间隔单位>)`，如5分钟执行一次，格式为`rate(5m)`。使用固定时间间隔执行有以下限制：
    ///     - 设置的时间间隔不大于7天、不小于60秒，且需大于定时任务的超时时间。
    ///     - 执行间隔只基于固定频率，与任务实际执行需要的时间无关。例如设置每5分钟执行一次命令，任务需要2分钟执行完成，则在任务完成3分钟后继续执行下一轮。
    ///     - 创建任务时不会立即执行。例如设置每5分钟执行一次命令，创建任务时不会立即执行一次命令，而是在任务创建完成后的5分钟后开始执行。
    ///
    /// - 仅在指定时间执行一次：按照设置的时区和执行时间点执行一次命令。格式为`at(yyyy-MM-dd HH:mm:ss <时区>)`，即`at(年-月-日 时:分:秒 <时区>)`。如果不指定时区，默认为UTC时区。时区支持以下三种形式：
    ///     - 时区全称：  如`Asia/Shanghai`（中国/上海时间）、`America/Los_Angeles`（美国/洛杉矶时间）等。
    ///     - 时区相对于格林威治时间的偏移量：  如`GMT+8:00`（东八区）、`GMT-7:00`（西七区）等。使用GMT格式时，小时位不支持添加前导零。
    ///     - 时区缩写：  仅支持UTC（协调世界时间）。
    ///
    ///   如果指定在中国/上海时间2022年06月06日13时15分30秒执行一次，格式为：`at(2022-06-06 13:15:30 Asia/Shanghai)`；如果指定在西七区2022年06月06日13时15分30秒执行一次，格式为：`at(2022-06-06 13:15:30 GMT-7:00)`。
    ///
    /// - 基于时钟定时执行（基于Cron表达式）：基于Cron表达式，按照设置的定时任务执行命令。格式为`<秒> <分钟> <小时> <日期> <月份> <星期> <年份（可选）> <时区>`，即`<Cron表达式> <时区>`。在指定的时区下，根据Cron表达式推算定时任务执行时间并执行。若不指定时区，默认为执行定时任务实例的系统内部时区。关于Cron表达式的更多信息，请参见[Cron表达式](~~64769~~)。时区支持以下三种形式：
    ///     - 时区全称：  如`Asia/Shanghai`（中国/上海时间）、`America/Los_Angeles`（美国/洛杉矶时间）等。
    ///     - 时区相对于格林威治时间的偏移量：  如`GMT+8:00`（东八区）、`GMT-7:00`（西七区）等。使用GMT格式时，小时位不支持添加前导零。
    ///     - 时区缩写：  仅支持UTC（协调世界时间）。
    ///   例如，在中国/上海时间，2022年每天上午10:15执行一次命令，格式为`0 15 10 ? * * 2022 Asia/Shanghai`；在东八区时间，2022年每天上午10:00到11:30每隔半小时执行，格式为`0 0/30 10-11 * * ? 2022 GMT+8:00`；在UTC时间，从2022年开始，每隔两年的10月每天下午14:00到下午14:55时间段内每隔5分钟执行，格式为`0 0/5 14 * 10 ? 2022/2 UTC`。
    ///
    ///     >设置的最小时间间隔需大于或等于定时任务的超时时间，且不小于10 秒。
    #[setters(generate = true, strip_option)]
    frequency: Option<String>,
    /// 命令中包含自定义参数时，执行命令时传入的自定义参数的键值对。例如，命令内容为`echo {{name}}`，则可以通过`Parameter`参数传入键值对`{"name":"Jack"}`。自定义参数将自动替换变量值`name`，得到一条新的命令，实际执行的是`echo Jack`。
    ///
    /// 自定义参数的个数范围为0~10，且您需要注意：
    ///
    /// - 键不允许为空字符串，最多支持64个字符。
    /// - 值允许为空字符串。
    /// - 自定义参数与原始命令内容在Base64编码后，若保存命令，命令内容在Base64编码后的大小不能超过18 KB；若不保存命令，命令内容在Base64编码后的大小不能超过24 KB。您可通过`KeepCommand`设置是否保留命令。
    /// - 设置的自定义参数名集合必须为创建命令时定义的参数集的子集。对于未传入的参数，您可以使用空字符串代替。
    ///
    /// 默认值为空，表示取消设置该参数从而禁用自定义参数。
    #[setters(generate = true, strip_option)]
    parameters: Option<crate::OpenObject>,
    /// 执行完该命令后，是否保留下来。取值范围：
    ///
    /// - true：保留。可以通过InvokeCommand再次执行。会占用云助手命令的保有量配额。
    /// - false：不保留。执行完成后自动删除，不占用云助手命令的保有量配额。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    keep_command: Option<bool>,
    /// 命令内容（`CommandContent`）的编码方式。取值范围（不区分大小写）：
    ///
    /// - PlainText：不编码，采用明文传输。
    /// - Base64：Base64编码。
    ///
    /// 默认值：PlainText，乱填或错填该取值会当作PlainText处理。
    #[setters(generate = true, strip_option)]
    content_encoding: Option<String>,
    /// 在ECS实例中执行命令的用户名称。长度不得超过255个字符。
    ///
    /// - Linux系统的ECS实例，默认以root用户执行命令。
    /// - Windows系统的ECS实例，默认以System用户执行命令。
    ///
    /// 您也可以指定实例中已存在的其他用户执行命令，以普通用户执行云助手命令更加安全。更多信息，请参见[设置普通用户执行云助手命令](~~203771~~)。
    #[setters(generate = true, strip_option)]
    username: Option<String>,
    /// 在Windows实例中执行命令的用户的密码名称。长度不得超过255个字符。
    ///
    /// 当您希望以非默认用户（System）在Windows实例中执行命令时，需要同时传入`Username`和该参数。为降低密码泄露的风险，需要将密码明文托管在系统运维管理的参数仓库中，此处仅传入密码的名称。更多信息，请参见[加密参数](~~186828~~)以及[设置普通用户执行云助手命令](~~203771~~)。
    ///
    /// > 当您使用Linux实例的root用户或Windows实例的System用户执行命令时，不需要传递该参数。
    #[setters(generate = true, strip_option)]
    windows_password_name: Option<String>,
    /// ECS实例ID数组，数组长度：1~100。
    ///
    /// 若指定了多台实例后，其中某台实例不满足执行条件时，您需要重新选择。
    ///
    /// 您也可以在配额中心申请提升配额（配额名称为命令执行支持实例上限数）。
    #[setters(generate = true, strip_option)]
    instance_id: Option<Vec<String>>,
    /// 标签对数组，数组长度：0~20。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<RunCommandTag>>,
    /// 容器ID。仅支持64位16进制字符串，允许存在`docker://`、`containerd://`或者`cri-o://`前缀来明确指定的容器运行。
    ///
    /// 注意事项：
    /// - 如果指定了该参数，云助手将在实例的指定容器内执行脚本。
    /// - 如果指定了该参数，仅支持在云助手Agent版本不低于2.2.3.344的Linux实例内运行。
    /// - 如果指定了该参数，已指定的`Username`参数和`WorkingDir`参数将不会生效。仅支持通过容器默认用户在容器的默认工作目录下执行命令。详细信息，请参见[使用云助手在容器内执行命令](~~456641~~)。
    /// > 在Linux容器中只支持执行Shell脚本，不支持在脚本开头使用类似`#!/usr/bin/python`命令的形式指定脚本内容的解释器。详细信息，请参见[使用云助手在容器内执行命令](~~456641~~)。
    #[setters(generate = true, strip_option)]
    container_id: Option<String>,
    /// 容器名称。
    ///
    /// 注意事项：
    /// - 如果指定了该参数，云助手将在实例的指定容器内执行脚本。
    /// - 如果指定了该参数，仅支持在云助手Agent版本不低于2.2.3.344的Linux实例内运行。
    /// - 如果指定了该参数，已指定的`Username`参数和`WorkingDir`参数将不会生效。仅支持通过容器默认用户在容器的默认工作目录下执行命令。详细信息，请参见[使用云助手在容器内执行命令](~~456641~~)。
    /// > 在Linux容器中只支持执行Shell脚本，不支持在脚本开头使用类似`#!/usr/bin/python`命令的形式指定脚本内容的解释器。详细信息，请参见[使用云助手在容器内执行命令](~~456641~~)。
    #[setters(generate = true, strip_option)]
    container_name: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 命令执行Output OSS投递配置。
    ///
    /// - 格式：oss://${BucketName}/${Prefix}，${BucketName}为待投递到的OSS Bucket名称，${Prefix}为待投递到的目录前缀。
    #[setters(generate = true, strip_option)]
    oss_output_delivery: Option<String>,
    /// 用于筛选实例的标签数组，数组长度：0~20。可以在不指定InstanceId的情况下，向具有相同标签的实例批量执行命令。
    #[setters(generate = true, strip_option)]
    resource_tag: Option<Vec<RunCommandResourceTag>>,
    /// 停止任务（手动停止或执行超时打断）时的模式。可能值：
    /// - Process：停止当前脚本进程。
    /// - ProcessTree：停止当前进程树（脚本进程以及它创建的所有子进程的集合）。
    #[setters(generate = true, strip_option)]
    termination_mode: Option<String>,
    /// 脚本执行的引导程序。长度不能超过 1 KB。
    #[setters(generate = true, strip_option)]
    launcher: Option<String>,
}

impl sealed::Bound for RunCommand {}

impl RunCommand {
    pub fn new(
        region_id: impl Into<String>,
        r#type: impl Into<String>,
        command_content: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            name: None,
            description: None,
            r#type: r#type.into(),
            command_content: command_content.into(),
            working_dir: None,
            timeout: None,
            enable_parameter: None,
            repeat_mode: None,
            timed: None,
            frequency: None,
            parameters: None,
            keep_command: None,
            content_encoding: None,
            username: None,
            windows_password_name: None,
            instance_id: None,
            tag: None,
            container_id: None,
            container_name: None,
            client_token: None,
            oss_output_delivery: None,
            resource_tag: None,
            termination_mode: None,
            launcher: None,
        }
    }
}
impl crate::ToFormData for RunCommand {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RunCommand {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RunCommand";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RunCommandResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(26);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("CommandContent".into(), (&self.command_content).into()));

        if let Some(f) = &self.container_id {
            params.push(("ContainerId".into(), (f).into()));
        }

        if let Some(f) = &self.container_name {
            params.push(("ContainerName".into(), (f).into()));
        }

        if let Some(f) = &self.content_encoding {
            params.push(("ContentEncoding".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.enable_parameter {
            params.push(("EnableParameter".into(), (f).into()));
        }

        if let Some(f) = &self.frequency {
            params.push(("Frequency".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            crate::FlatSerialize::flat_serialize(f, "InstanceId", &mut params);
        }

        if let Some(f) = &self.keep_command {
            params.push(("KeepCommand".into(), (f).into()));
        }

        if let Some(f) = &self.launcher {
            params.push(("Launcher".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.oss_output_delivery {
            params.push(("OssOutputDelivery".into(), (f).into()));
        }

        if let Some(f) = &self.parameters {
            if let Ok(json) = serde_json::to_string(f) {
                params.push(("Parameters".into(), json.into()));
            }
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.repeat_mode {
            params.push(("RepeatMode".into(), (f).into()));
        }

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.resource_tag {
            crate::FlatSerialize::flat_serialize(f, "ResourceTag", &mut params);
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.termination_mode {
            params.push(("TerminationMode".into(), (f).into()));
        }

        if let Some(f) = &self.timed {
            params.push(("Timed".into(), (f).into()));
        }

        if let Some(f) = &self.timeout {
            params.push(("Timeout".into(), (f).into()));
        }
        params.push(("Type".into(), (&self.r#type).into()));

        if let Some(f) = &self.username {
            params.push(("Username".into(), (f).into()));
        }

        if let Some(f) = &self.windows_password_name {
            params.push(("WindowsPasswordName".into(), (f).into()));
        }

        if let Some(f) = &self.working_dir {
            params.push(("WorkingDir".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateCommand {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 命令名称，支持全字符集。长度不得超过128个字符。
    name: String,
    /// 命令描述，支持全字符集。长度不得超过512个字符。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 命令的类型。取值范围：
    ///
    /// - RunBatScript：创建一个在Windows实例中运行的Bat脚本。
    /// - RunPowerShellScript：创建一个在Windows实例中运行的PowerShell脚本。
    /// - RunShellScript：创建一个在Linux实例中运行的Shell脚本。
    ///          
    r#type: String,
    /// 命令Base64编码后的内容。
    ///
    /// - 该参数的值必须使用Base64编码后传输，且脚本内容的大小在Base64编码之后不能超过18 KB。
    /// - 命令内容支持使用自定义参数形式，具体通过指定参数`EnableParameter=true`启用自定义参数功能：
    ///     - 自定义参数用`{{}}`包含的方式定义，在`{{}}`内参数名前后的空格以及换行符会被忽略。
    ///     - 自定义参数个数不能超过20个。
    ///     - 自定义参数名允许a-zA-Z0-9-_的组合，不支持acs::前缀指定非内置环境参数，不支持其余字符，参数名不区分大小写。
    ///     - 单个参数名不能超过64字节。
    ///
    /// - 您可以指定内置环境参数作为自定义参数，执行命令时无需手动对参数赋值，云助手将为您自动替换为环境中对应的值。支持指定以下内置环境参数：
    ///     - `{{ACS::RegionId}}`：地域ID。
    ///     - `{{ACS::AccountId}}`：阿里云主账号UID。
    ///     - `{{ACS::InstanceId}}`：实例ID。命令下发到多个实例时，如需指定`{{ACS::InstanceId}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.309
    ///         - Windows：2.1.3.309
    ///     - `{{ACS::InstanceName}}`：实例名称。命令下发到多个实例时，如需指定`{{ACS::InstanceName}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.344
    ///         - Windows：2.1.3.344
    ///
    ///     - `{{ACS::InvokeId}}`：命令执行ID。如需指定`{{ACS::InvokeId}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.309
    ///         - Windows：2.1.3.309
    ///      
    ///     - `{{ACS::CommandId}}` ：命令ID。通过调用[RunCommand](~~141751~~)接口执行命令时，如需指定`{{ACS::CommandId}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.309
    ///         - Windows：2.1.3.309
    command_content: String,
    /// 您创建的命令在ECS实例中运行的目录。长度不得超过200个字符。
    ///
    /// 默认值：
    /// - Linux实例：管理员root用户的home目录下，具体为`/root`目录。  
    /// - Windows实例：云助手Agent进程所在目录，例如`C:\Windows\System32`。
    ///
    /// >设置为其他目录时，请确保实例中存在该目录。
    #[setters(generate = true, strip_option)]
    working_dir: Option<String>,
    /// 您创建的命令在ECS实例中执行时最大的超时时间，单位为秒。当因为某种原因无法运行您创建的命令时，会出现超时现象。超时后，会强制终止命令进程，即取消命令的PID。
    ///
    /// 默认值：60。
    #[setters(generate = true, strip_option)]
    timeout: Option<i64>,
    /// 创建的命令是否使用自定义参数。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    enable_parameter: Option<bool>,
    /// 命令内容（CommandContent）的编码方式。取值范围：
    ///
    /// - PlainText：不编码，采用明文传输。
    ///
    /// - Base64：Base64编码。
    ///
    /// 默认值：Base64。
    ///
    /// >错填该取值会当作Base64处理。
    #[setters(generate = true, strip_option)]
    content_encoding: Option<String>,
    /// 命令所属的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 脚本执行的引导程序。长度不能超过 1 KB。
    #[setters(generate = true, strip_option)]
    launcher: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<CreateCommandTag>>,
}

impl sealed::Bound for CreateCommand {}

impl CreateCommand {
    pub fn new(
        region_id: impl Into<String>,
        name: impl Into<String>,
        r#type: impl Into<String>,
        command_content: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            name: name.into(),
            description: None,
            r#type: r#type.into(),
            command_content: command_content.into(),
            working_dir: None,
            timeout: None,
            enable_parameter: None,
            content_encoding: None,
            resource_group_id: None,
            launcher: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for CreateCommand {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateCommand {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateCommand";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateCommandResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(12);
        params.push(("CommandContent".into(), (&self.command_content).into()));

        if let Some(f) = &self.content_encoding {
            params.push(("ContentEncoding".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.enable_parameter {
            params.push(("EnableParameter".into(), (f).into()));
        }

        if let Some(f) = &self.launcher {
            params.push(("Launcher".into(), (f).into()));
        }
        params.push(("Name".into(), (&self.name).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.timeout {
            params.push(("Timeout".into(), (f).into()));
        }
        params.push(("Type".into(), (&self.r#type).into()));

        if let Some(f) = &self.working_dir {
            params.push(("WorkingDir".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct InvokeCommand {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 命令执行的资源组ID，当指定该参数时：
    ///
    /// - 当InstanceId对应的ECS实例属于非默认资源组时，该ECS实例必须属于该资源组。
    ///
    /// - 支持通过指定该参数筛选出对应的命令执行结果（通过调用[DescribeInvocations](~~64840~~)或[DescribeInvocationResults](~~64845~~)）。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 命令ID。您可以通过接口[DescribeCommands](~~64843~~)查询所有可用的CommandId。
    ///
    /// >对于公共命令，可以通过命令名称执行。更多信息，请参见[查看和执行云助手公共命令](~~429635~~)。
    command_id: String,
    /// 设置命令执行的方式。取值范围：
    ///
    /// - Once：立即执行命令。
    /// - Period：定时执行命令。当该参数取值为`Period`时，必须同时指定`Frequency`参数。
    /// - NextRebootOnly：当实例下一次启动时，自动执行命令。
    /// - EveryReboot：实例每一次启动都将自动执行命令。
    /// - DryRun：只预检此次请求，命令执行不会实际生效，检查项包括请求参数、实例执行环境、云助手Agent运行状态等。
    ///
    /// 默认值：
    ///
    /// - 当不指定`Frequency`参数时，默认值为`Once`。
    /// - 当指定`Frequency`参数时，无论是否已设置了该参数值，都将按照`Period`处理。
    ///
    /// 注意事项：
    ///
    /// - 您可以调用[StopInvocation](~~64838~~)停止待执行的命令或定时执行的命令。
    /// - 当该参数取值`Period`或者`EveryReboot`时，您可以调用[DescribeInvocationResults](~~64845~~)，然后指定`IncludeHistory=true`查看命令定时执行的历史记录。
    #[setters(generate = true, strip_option)]
    repeat_mode: Option<String>,
    /// >该参数已废弃，传入该参数不会生效。
    #[setters(generate = true, strip_option)]
    timed: Option<bool>,
    /// 定时执行命令的执行时间。目前支持三种定时执行方式：固定时间间隔执行（基于Rate表达式）、仅在指定时间执行一次、基于时钟定时执行（基于Cron表达式）。
    ///
    /// - 固定时间间隔执行：基于Rate表达式，按照设置的时间间隔执行命令。时间间隔支持按秒（s） 、分钟（m） 、小时（h）和天（d）来选择，适用于在固定时间间隔执行任务的场景。格式为`rate(<执行间隔数值><执行间隔单位>)`，例如5分钟执行一次，格式为`rate(5m)`。使用固定时间间隔执行有以下限制：
    ///     - 设置的时间间隔不大于7天、不小于60秒，且需大于定时任务的超时时间。
    ///     - 执行间隔只基于固定频率，与任务实际执行需要的时间无关。例如设置每5分钟执行一次命令，任务需要2分钟执行完成，则在任务完成3分钟后继续执行下一轮。
    ///     - 创建任务时不会立即执行。例如设置每5分钟执行一次命令，创建任务时不会立即执行一次命令，而是在任务创建完成后的5分钟后开始执行。
    ///
    /// - 仅在指定时间执行一次：按照设置的时区和执行时间点执行一次命令。格式为`at(yyyy-MM-dd HH:mm:ss <时区>)`，即`at(年-月-日 时:分:秒 <时区>)`。如果不指定时区，默认为UTC时区。时区支持以下三种形式：
    ///     - 时区全称：  例如`Asia/Shanghai`（中国/上海时间）、`America/Los_Angeles`（美国/洛杉矶时间）等。
    ///     - 时区相对于格林威治时间的偏移量：  例如`GMT+8:00`（东八区）、`GMT-7:00`（西七区）等。使用GMT格式时，小时位不支持添加前导零。
    ///     - 时区缩写：  仅支持UTC（协调世界时间）。
    ///
    ///   如果指定在中国/上海时间2022年06月06日13时15分30秒执行一次，格式为：`at(2022-06-06 13:15:30 Asia/Shanghai)`；如果指定在西七区2022年06月06日13时15分30秒执行一次，格式为：`at(2022-06-06 13:15:30 GMT-7:00)`。
    ///
    /// - 基于时钟定时执行（基于Cron表达式）：基于Cron表达式，按照设置的定时任务执行命令。格式为`<秒> <分钟> <小时> <日期> <月份> <星期> <年份（可选）> <时区>`，即`<Cron表达式> <时区>`。在指定的时区下，根据Cron表达式推算定时任务执行时间并执行。若不指定时区，默认为执行定时任务实例的系统内部时区。关于Cron表达式的更多信息，请参见[Cron表达式](~~64769~~)。时区支持以下三种形式：
    ///     - 时区全称：  例如`Asia/Shanghai`（中国/上海时间）、`America/Los_Angeles`（美国/洛杉矶时间）等。
    ///     - 时区相对于格林威治时间的偏移量：  例如`GMT+8:00`（东八区）、`GMT-7:00`（西七区）等。使用GMT格式时，小时位不支持添加前导零。
    ///     - 时区缩写：  仅支持UTC（协调世界时间）。
    ///   例如，在中国/上海时间，2022年每天上午10:15执行一次命令，格式为`0 15 10 ? * * 2022 Asia/Shanghai`；在东八区时间，2022年每天上午10:00到11:30每隔半小时执行，格式为`0 0/30 10-11 * * ? 2022 GMT+8:00`；在UTC时间，从2022年开始，每隔两年的10月每天下午14:00到下午14:55时间段内每隔5分钟执行，格式为`0 0/5 14 * 10 ? 2022/2 UTC`。
    ///
    ///     >设置的最小时间间隔需大于或等于定时任务的超时时间，且不小于10秒。
    #[setters(generate = true, strip_option)]
    frequency: Option<String>,
    /// 启用自定义参数功能时，执行命令时传入的自定义参数的键值对。自定义参数的个数范围为0~10。
    ///
    /// - Map的键不允许为空字符串，最多支持64个字符。
    /// - Map的值允许为空字符串。
    /// - 自定义参数与原始命令内容在Base64编码后，综合长度不能超过18 KB。
    /// - 设置的自定义参数名集合必须为创建命令时定义的参数集的子集。对于未传入的参数，您可以使用空字符串代替。
    ///
    /// 您可以取消设置该参数从而禁用自定义参数。
    #[setters(generate = true, strip_option)]
    parameters: Option<crate::OpenObject>,
    /// 在ECS实例中执行命令的用户名称。长度不得超过255个字符。
    ///
    /// - Linux系统的ECS实例，默认以root用户执行命令。
    /// - Windows系统的ECS实例，默认以System用户执行命令。
    ///
    /// 您也可以指定实例中已存在的其他用户执行命令，以普通用户执行云助手命令更加安全。更多信息，请参见[设置普通用户执行云助手命令](~~203771~~)。
    #[setters(generate = true, strip_option)]
    username: Option<String>,
    /// 在Windows实例中执行命令的用户的密码名称。长度不得超过255个字符。
    ///
    /// 当您希望以非默认用户（System）在Windows实例中执行命令时，需要同时传入`Username`和该参数。为降低密码泄露的风险，需要将密码明文托管在系统运维管理的参数仓库中，此处仅传入密码的名称。更多信息，请参见[加密参数](~~186828~~)以及[设置普通用户执行云助手命令](~~203771~~)。
    ///
    /// > 当您使用Linux实例的root用户或Windows实例的System用户执行命令时，不需要传递该参数。
    #[setters(generate = true, strip_option)]
    windows_password_name: Option<String>,
    /// 需要执行命令的实例列表，最多能指定100台实例ID。N的取值范围为1~100。
    ///
    /// 您也可以在配额中心申请提升配额（配额名称为命令执行支持实例上限数）。
    #[setters(generate = true, strip_option)]
    instance_id: Option<Vec<String>>,
    /// 容器ID。仅支持64位16进制字符串。支持使用`docker://`、`containerd://`或者`cri-o://`前缀来表示指定的容器运行时。
    ///
    /// 注意事项：
    /// - 如果指定了该参数，云助手将在实例的指定容器内执行脚本。
    /// - 如果指定了该参数，仅支持在云助手Agent版本不低于2.2.3.344的Linux实例内运行。
    ///
    ///     - 查看云助手Agent版本的具体操作，请参见[安装云助手Agent](~~64921~~)   。
    ///     - 升级云助手Agent版本的具体操作，请参见[升级或禁止升级云助手Agent](~~134383~~)。
    ///
    /// - 如果指定了该参数，本接口中已指定的`Username`参数和[CreateCommand](~~64844~~)中指定的`WorkingDir`参数将不会生效。仅支持通过容器默认用户在容器的默认工作目录下执行命令。更多信息，请参见[使用云助手在容器内执行命令](~~456641~~)。
    /// - 如果指定了该参数，在Linux容器中只支持执行Shell脚本，不支持在脚本开头使用类似`#!/usr/bin/python`命令的形式指定脚本内容的解释器。更多信息，请参见[使用云助手在容器内执行命令](~~456641~~)。
    #[setters(generate = true, strip_option)]
    container_id: Option<String>,
    /// 容器名称。
    ///
    /// 注意事项：
    /// - 如果指定了该参数，云助手将在实例的指定容器内执行脚本。
    /// - 如果指定了该参数，仅支持在云助手Agent版本不低于2.2.3.344的Linux实例内运行。
    ///
    ///     - 查看云助手Agent版本的具体操作，请参见[安装云助手Agent](~~64921~~)   。
    ///     - 升级云助手Agent版本的具体操作，请参见[升级或禁止升级云助手Agent](~~134383~~)。
    /// - 如果指定了该参数，本接口中已指定的`Username`参数和[CreateCommand](~~64844~~)中指定的`WorkingDir`参数将不会生效。仅支持通过容器默认用户在容器的默认工作目录下执行命令。更多信息，请参见[使用云助手在容器内执行命令](~~456641~~)。
    /// - 如果指定了该参数，在Linux容器中只支持执行Shell脚本，不支持在脚本开头使用类似`#!/usr/bin/python`命令的形式指定脚本内容的解释器。更多信息，请参见[使用云助手在容器内执行命令](~~456641~~)。
    ///
    #[setters(generate = true, strip_option)]
    container_name: Option<String>,
    /// 执行命令的超时时间，单位：秒。
    ///
    /// - 该值不能小于10秒。
    ///
    /// - 当因为进程原因、缺失模块、缺失云助手Agent等原因无法运行命令时，会出现超时现象。超时后，会强制终止命令进程。
    ///
    /// - 若不设置该值，会采用创建命令时指定的超时时间。
    ///
    /// - 该值只会作为该次命令执行的超时时间，不会改变命令本身的超时时间。
    #[setters(generate = true, strip_option)]
    timeout: Option<i64>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<InvokeCommandTag>>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。ClientToken只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 用于筛选实例的标签列表。可以在不指定InstanceId的情况下，向具有相同标签的实例批量执行命令。
    #[setters(generate = true, strip_option)]
    resource_tag: Option<Vec<InvokeCommandResourceTag>>,
    /// 停止任务（手动停止或执行超时打断）时的模式。可能值：
    /// - Process：停止当前脚本进程。
    /// - ProcessTree：停止当前进程树（脚本进程以及它创建的所有子进程的集合）。
    #[setters(generate = true, strip_option)]
    termination_mode: Option<String>,
    /// 脚本执行的引导程序。长度不能超过 1 KB。
    #[setters(generate = true, strip_option)]
    launcher: Option<String>,
    /// 命令在 ECS 实例中运行的目录。长度不得超过 200 个字符。
    /// - 若不设置该值，会采用创建命令时指定的运行目录。
    /// - 该值只会作为该次命令执行的运行目录，不会改变命令本身的运行目录。
    #[setters(generate = true, strip_option)]
    working_dir: Option<String>,
    /// 命令执行Output OSS投递配置。
    ///
    /// - 格式：oss://${BucketName}/${Prefix}，${BucketName}为待投递到的OSS Bucket名称，${Prefix}为待投递到的目录前缀。
    #[setters(generate = true, strip_option)]
    oss_output_delivery: Option<String>,
}

impl sealed::Bound for InvokeCommand {}

impl InvokeCommand {
    pub fn new(region_id: impl Into<String>, command_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            command_id: command_id.into(),
            repeat_mode: None,
            timed: None,
            frequency: None,
            parameters: None,
            username: None,
            windows_password_name: None,
            instance_id: None,
            container_id: None,
            container_name: None,
            timeout: None,
            tag: None,
            client_token: None,
            resource_tag: None,
            termination_mode: None,
            launcher: None,
            working_dir: None,
            oss_output_delivery: None,
        }
    }
}
impl crate::ToFormData for InvokeCommand {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for InvokeCommand {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "InvokeCommand";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<InvokeCommandResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(20);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("CommandId".into(), (&self.command_id).into()));

        if let Some(f) = &self.container_id {
            params.push(("ContainerId".into(), (f).into()));
        }

        if let Some(f) = &self.container_name {
            params.push(("ContainerName".into(), (f).into()));
        }

        if let Some(f) = &self.frequency {
            params.push(("Frequency".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            crate::FlatSerialize::flat_serialize(f, "InstanceId", &mut params);
        }

        if let Some(f) = &self.launcher {
            params.push(("Launcher".into(), (f).into()));
        }

        if let Some(f) = &self.oss_output_delivery {
            params.push(("OssOutputDelivery".into(), (f).into()));
        }

        if let Some(f) = &self.parameters {
            if let Ok(json) = serde_json::to_string(f) {
                params.push(("Parameters".into(), json.into()));
            }
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.repeat_mode {
            params.push(("RepeatMode".into(), (f).into()));
        }

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.resource_tag {
            crate::FlatSerialize::flat_serialize(f, "ResourceTag", &mut params);
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.termination_mode {
            params.push(("TerminationMode".into(), (f).into()));
        }

        if let Some(f) = &self.timed {
            params.push(("Timed".into(), (f).into()));
        }

        if let Some(f) = &self.timeout {
            params.push(("Timeout".into(), (f).into()));
        }

        if let Some(f) = &self.username {
            params.push(("Username".into(), (f).into()));
        }

        if let Some(f) = &self.windows_password_name {
            params.push(("WindowsPasswordName".into(), (f).into()));
        }

        if let Some(f) = &self.working_dir {
            params.push(("WorkingDir".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInvocations {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 命令执行的资源组ID。传入该参数后，需要在执行命令时指定ResourceGroupId，支持筛选出对应的命令执行结果。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 命令执行ID。
    #[setters(generate = true, strip_option)]
    invoke_id: Option<String>,
    /// 命令ID。您可以通过接口[DescribeCommands](~~64843~~)查询所有可用的CommandId。
    #[setters(generate = true, strip_option)]
    command_id: Option<String>,
    /// 命令名称。如果同时设置了`InstanceId`参数，则该参数不生效。
    #[setters(generate = true, strip_option)]
    command_name: Option<String>,
    /// 命令类型。取值范围：
    ///
    /// - RunBatScript：命令为在Windows实例中运行的Bat脚本。
    /// - RunPowerShellScript：命令为在Windows实例中运行的PowerShell脚本。
    /// - RunShellScript：命令为在Linux实例中运行的Shell脚本。
    #[setters(generate = true, strip_option)]
    command_type: Option<String>,
    /// 查询的命令是否在将来会自动执行。取值范围：
    ///
    /// - true：查询在调用`RunCommand`或`InvokeCommand`执行命令时，`RepeatMode`参数取值为`Period`、`NextRebootOnly`或者`EveryReboot`。
    /// - false：查询以下两种状态的命令。
    ///     - 在调用`RunCommand`或`InvokeCommand`执行命令时，`RepeatMode`参数取值为`Once`。
    ///     - 已被取消、被停止或者已完成执行的命令。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    timed: Option<bool>,
    /// 命令执行的总执行状态。总执行状态取决于创建执行中的一台或多台实例的共同执行状态。取值范围：
    ///          
    /// - Running：
    ///     - 定时执行：未手动停止定时执行命令前，执行状态一直为进行中。
    ///     - 单次执行：一旦有进行中的命令进程，总的执行状态就为进行中。
    /// - Finished：
    ///     - 定时执行：命令进程不可能为执行完成。
    ///     - 单次执行：所有实例全部完成执行。或者手动停止部分实例的命令进程，其余实例全部执行完成。
    /// - Success：各个实例上的命令执行状态均为Stopped或Success，且至少一个实例的命令执行状态是Success，则总执行状态为Success。
    ///     - 立即运行的任务：命令执行完成，且退出码为0。
    ///     - 定时运行的任务：最近一次执行成功且退出码为0，且指定的时间已全部完成。
    /// - Failed：
    ///     - 定时执行：命令进程不可能为执行失败。
    ///     - 单次执行：所有实例全部执行失败。
    /// - Stopped：停止命令。
    /// - Stopping：停止中。
    /// - PartialFailed：部分失败；如果同时设置了`InstanceId`参数，则不生效。
    /// - Pending：系统正在校验或发送命令。存在至少一台实例的命令执行状态为Pending，则总执行状态为Pending。
    /// - Scheduled：定时执行的命令已发送，等待运行。存在至少一台实例的命令执行状态为Scheduled，则总执行状态为Scheduled。
    #[setters(generate = true, strip_option)]
    invoke_status: Option<String>,
    /// 实例ID。当您传入了该参数，将查询该实例所有的命令执行记录。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 设置返回数据中`CommandContent`字段和`Output`字段的编码方式。取值范围：
    ///
    /// - PlainText：返回原始命令内容和输出信息。
    /// - Base64：返回Base64编码后的命令内容和输出信息。
    ///
    /// 默认值：Base64。
    #[setters(generate = true, strip_option)]
    content_encoding: Option<String>,
    /// 是否在结果中返回命令运行的输出信息。
    ///
    /// - true：返回。此时，您至少指定参数`InvokeId`或`InstanceId`。
    /// - false：不返回。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    include_output: Option<bool>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i64>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i64>,
    /// 分页查询时每页的最大条目数。
    ///
    /// 最大值为50。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 查询凭证（Token），取值为上一次API调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 命令执行的方式。如果同时设置了`InstanceId`参数，则不生效。取值范围：
    ///
    /// - Once：立即执行命令。
    /// - Period：定时执行命令。
    /// - NextRebootOnly：当实例下一次启动时，自动执行命令。
    /// - EveryReboot：实例每一次启动都将自动执行命令。
    ///
    /// 默认值为空，表示查询全部。
    #[setters(generate = true, strip_option)]
    repeat_mode: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<InvocationsTag>>,
}

impl sealed::Bound for DescribeInvocations {}

impl DescribeInvocations {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            invoke_id: None,
            command_id: None,
            command_name: None,
            command_type: None,
            timed: None,
            invoke_status: None,
            instance_id: None,
            content_encoding: None,
            include_output: None,
            page_number: None,
            page_size: None,
            max_results: None,
            next_token: None,
            repeat_mode: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeInvocations {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInvocations {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInvocations";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInvocationsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(17);

        if let Some(f) = &self.command_id {
            params.push(("CommandId".into(), (f).into()));
        }

        if let Some(f) = &self.command_name {
            params.push(("CommandName".into(), (f).into()));
        }

        if let Some(f) = &self.command_type {
            params.push(("CommandType".into(), (f).into()));
        }

        if let Some(f) = &self.content_encoding {
            params.push(("ContentEncoding".into(), (f).into()));
        }

        if let Some(f) = &self.include_output {
            params.push(("IncludeOutput".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.invoke_id {
            params.push(("InvokeId".into(), (f).into()));
        }

        if let Some(f) = &self.invoke_status {
            params.push(("InvokeStatus".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.repeat_mode {
            params.push(("RepeatMode".into(), (f).into()));
        }

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.timed {
            params.push(("Timed".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInvocationResults {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 命令执行的资源组ID。传入该参数后，需要在执行命令时指定ResourceGroupId，支持筛选出对应的命令执行结果。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 命令执行ID。您可以通过接口[DescribeInvocations](~~64840~~)查询InvokeId。
    #[setters(generate = true, strip_option)]
    invoke_id: Option<String>,
    /// 实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 命令ID。
    #[setters(generate = true, strip_option)]
    command_id: Option<String>,
    /// 命令执行状态。取值范围：
    ///
    /// - Running：运行中。
    ///     - 定时执行：未手动停止定时执行命令前，执行状态一直为进行中。
    ///     - 单次执行：一旦有进行中的命令进程，总的执行状态就为进行中。
    /// - Finished：已完成。
    ///     - 定时执行：命令进程不可能为执行完成。
    ///     - 单次执行：所有实例全部完成执行。或者手动停止部分实例的命令进程，其余实例全部执行完成。
    /// - Success：
    ///     - 单次执行的命令：命令执行完成，且退出码为0。
    ///     - 定时执行的命令：上一次执行成功且退出码为0，且指定的执行时间已结束。
    /// - Failed：执行失败。
    ///     - 定时执行：命令进程不可能为执行失败。
    ///     - 单次执行：所有实例全部执行失败。
    /// - PartialFailed：部分执行失败。
    ///     - 定时执行：命令进程不可能为部分失败。
    ///     - 单次执行：部分实例有执行失败的命令进程，则总执行状态为部分失败。
    /// - Stopped：命令执行已停止。
    /// - Stopping：正在停止执行的命令。
    #[setters(generate = true, strip_option)]
    invoke_record_status: Option<String>,
    /// 是否返回命令定时执行的历史记录。取值范围：
    ///
    ///  - true：表示返回命令定时执行的结果。当取值为true时，参数InvokeId的取值不能为空，且必须为定时执行（RepeatMode为Period）或系统每一次启动后执行（RepeatMode为EveryReboot）的命令执行ID。
    ///  - false：表示不返回。
    ///
    /// 默认值为false。
    #[setters(generate = true, strip_option)]
    include_history: Option<bool>,
    /// 设置返回数据中`CommandContent`字段和`Output`字段的编码方式，取值范围：
    /// - PlainText：返回原始命令内容和输出信息。
    /// - Base64：返回Base64编码后的命令内容和输出信息。
    ///
    /// 默认值为Base64。
    #[setters(generate = true, strip_option)]
    content_encoding: Option<String>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i64>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i64>,
    /// 分页查询时每页的最大条目数。
    ///
    /// 最大值为50。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 查询凭证（Token），取值为上一次API调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 标签列表
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<InvocationResultsTag>>,
}

impl sealed::Bound for DescribeInvocationResults {}

impl DescribeInvocationResults {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            invoke_id: None,
            instance_id: None,
            command_id: None,
            invoke_record_status: None,
            include_history: None,
            content_encoding: None,
            page_number: None,
            page_size: None,
            max_results: None,
            next_token: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeInvocationResults {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInvocationResults {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInvocationResults";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInvocationResultsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(13);

        if let Some(f) = &self.command_id {
            params.push(("CommandId".into(), (f).into()));
        }

        if let Some(f) = &self.content_encoding {
            params.push(("ContentEncoding".into(), (f).into()));
        }

        if let Some(f) = &self.include_history {
            params.push(("IncludeHistory".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.invoke_id {
            params.push(("InvokeId".into(), (f).into()));
        }

        if let Some(f) = &self.invoke_record_status {
            params.push(("InvokeRecordStatus".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInvocationAttribute {
    /// 地域ID。
    region_id: String,
    /// 待加入任务的ECS实例ID或托管实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<Vec<String>>,
    /// 待修改任务的命令执行ID。
    invoke_id: String,
    /// 待修改后的命令内容。命令内容可以是明文内容或Base64编码后的内容。您需要注意：
    ///
    /// - 若创建待修改任务时选择了保存命令，命令内容在Base64编码后的大小不能超过18 KB；若选择了不保存命令，命令内容在Base64编码后的大小不能超过24 KB。
    /// - 如果您的命令内容是Base64编码后的内容，则必须设置`ContentEncoding=Base64`。
    /// - 指定参数`EnableParameter=true`可在命令内容中启用自定义参数功能：
    ///     - 用`{{}}`包含的方式定义自定义参数，在`{{}}`内参数名前后的空格以及换行符会被忽略。
    ///     - 自定义参数个数不能超过20个。
    ///     - 自定义参数名允许a-zA-Z0-9-_的组合，不支持acs::前缀指定非内置环境参数，不支持其余字符，参数名不区分大小写。
    ///     - 单个自定义参数名不能超过64字节。
    ///
    /// - 您可以指定内置环境参数作为自定义参数，执行命令时无需手动对参数赋值，云助手将为您自动替换为环境中对应的值。支持指定以下内置环境参数：
    ///     - `{{ACS::RegionId}}`：地域ID。
    ///     - `{{ACS::AccountId}}`：阿里云主账号UID。
    ///     - `{{ACS::InstanceId}}`：实例ID。命令下发到多个实例时，如需指定`{{ACS::InstanceId}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.309
    ///         - Windows：2.1.3.309
    ///     - `{{ACS::InstanceName}}`：实例名称。命令下发到多个实例时，如需指定`{{ACS::InstanceName}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.344
    ///         - Windows：2.1.3.344
    ///     - `{{ACS::InvokeId}}`：命令执行ID。如需指定`{{ACS::InvokeId}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.309
    ///         - Windows：2.1.3.309
    ///     - `{{ACS::CommandId}}`：命令ID。通过调用本接口执行命令时，如需指定`{{ACS::CommandId}}`作为内置环境参数，需确保云助手Agent不低于以下版本：
    ///         - Linux：2.2.3.309
    ///         - Windows：2.1.3.309
    #[setters(generate = true, strip_option)]
    command_content: Option<String>,
    /// 修改命令中是否包含自定义参数。
    /// - 当您启用自定义参数或修改自定义参数`Parameters`时，该参数需设置为`true`。
    /// - 当您不修改自定义参数`Parameters`时，不设置该参数或设置为`false`。
    #[setters(generate = true, strip_option)]
    enable_parameter: Option<bool>,
    /// 命令中包含自定义参数时，修改执行命令时传入的自定义参数的键值对。
    ///
    /// 自定义参数的个数范围为0~10，且您需要注意：
    ///
    /// - 键不允许为空字符串，最多支持64个字符。
    /// - 值允许为空字符串。
    /// - 自定义参数与原始命令内容在Base64编码后，若创建待修改任务时选择了保存命令，命令内容在Base64编码后的大小不能超过 18 KB；若选择了不保存命令，命令内容在Base64编码后的大小不能超过 24 KB。
    /// - 设置的自定义参数名集合必须为创建命令时定义的参数集的子集。对于未传入的参数，您可以使用空字符串代替。
    ///
    /// 默认值为空，表示不涉及自定义参数键值对的修改。
    #[setters(generate = true, strip_option)]
    parameters: Option<crate::OpenObject>,
    /// 待修改的定时执行频率。仅当`RepeatMode`为`Period`时生效。目前支持三种定时执行方式：固定时间间隔执行（基于Rate表达式）、仅在指定时间执行一次、基于时钟定时执行（基于Cron表达式）。
    ///
    /// - 固定时间间隔执行：基于Rate表达式，按照设置的时间间隔执行命令。时间间隔支持按秒（s） 、分钟（m） 、小时（h）和天（d）来选择，适用于在固定时间间隔执行任务的场景。格式为`rate(<执行间隔数值><执行间隔单位>)`，如5分钟执行一次，格式为`rate(5m)`。使用固定时间间隔执行有以下限制：
    ///     - 设置的时间间隔不大于7天、不小于60秒，且需大于创建定时任务时指定的超时时间。
    ///     - 执行间隔只基于固定频率，与任务实际执行需要的时间无关。例如设置每5分钟执行一次命令，任务需要2分钟执行完成，则在任务完成3分钟后继续执行下一轮。
    ///     - 按照任务的创建时间（参见`DescribeInvocations`返回的[CreationTime](~~64840~~)，请注意不是修改时间）及修改后的执行间隔计算下一次执行时间。
    ///
    /// - 仅在指定时间执行一次：按照设置的时区和执行时间点执行一次命令。格式为`at(yyyy-MM-dd HH:mm:ss <时区>)`，即`at(年-月-日 时:分:秒 <时区>)`。如果不指定时区，默认为UTC时区。时区支持以下三种形式：
    ///     - 时区全称：  如`Asia/Shanghai`（中国/上海时间）、`America/Los_Angeles`（美国/洛杉矶时间）等。
    ///     - 时区相对于格林威治时间的偏移量：  如`GMT+8:00`（东八区）、`GMT-7:00`（西七区）等。使用GMT格式时，小时位不支持添加前导零。
    ///     - 时区缩写：  仅支持UTC（协调世界时间）。
    ///
    ///   如果指定在中国/上海时间2022年06月06日13时15分30秒执行一次，格式为：`at(2022-06-06 13:15:30 Asia/Shanghai)`；如果指定在西七区2022年06月06日13时15分30秒执行一次，格式为：`at(2022-06-06 13:15:30 GMT-7:00)`。
    ///
    /// - 基于时钟定时执行（基于Cron表达式）：基于Cron表达式，按照设置的定时任务执行命令。格式为`<秒> <分钟> <小时> <日期> <月份> <星期> <年份（可选）> <时区>`，即`<Cron表达式> <时区>`。在指定的时区下，根据Cron表达式推算定时任务执行时间并执行。若不指定时区，默认为执行定时任务实例的系统内部时区。关于Cron表达式的更多信息，请参见[Cron表达式](~~64769~~)。时区支持以下三种形式：
    ///     - 时区全称：  如`Asia/Shanghai`（中国/上海时间）、`America/Los_Angeles`（美国/洛杉矶时间）等。
    ///     - 时区相对于格林威治时间的偏移量：  如`GMT+8:00`（东八区）、`GMT-7:00`（西七区）等。使用GMT格式时，小时位不支持添加前导零。
    ///     - 时区缩写：  仅支持UTC（协调世界时间）。
    ///   例如，在中国/上海时间，2022年每天上午10:15执行一次命令，格式为`0 15 10 ? * * 2022 Asia/Shanghai`；在东八区时间，2022年每天上午10:00到11:30每隔半小时执行，格式为`0 0/30 10-11 * * ? 2022 GMT+8:00`；在UTC时间，从2022年开始，每隔两年的10月每天下午14:00到下午14:55时间段内每隔5分钟执行，格式为`0 0/5 14 * 10 ? 2022/2 UTC`。
    ///
    ///     >设置的最小时间间隔需大于或等于创建定时任务时指定的超时时间，且不小于 10 秒。
    #[setters(generate = true, strip_option)]
    frequency: Option<String>,
    /// 命令内容（`CommandContent`）的编码方式。取值范围（不区分大小写）：
    ///
    /// - PlainText：不编码，采用明文传输。
    /// - Base64：Base64编码。
    ///
    /// 默认值：PlainText，填写错误时会当作PlainText处理。
    #[setters(generate = true, strip_option)]
    content_encoding: Option<String>,
}

impl sealed::Bound for ModifyInvocationAttribute {}

impl ModifyInvocationAttribute {
    pub fn new(region_id: impl Into<String>, invoke_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: None,
            invoke_id: invoke_id.into(),
            command_content: None,
            enable_parameter: None,
            parameters: None,
            frequency: None,
            content_encoding: None,
        }
    }
}
impl crate::ToFormData for ModifyInvocationAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInvocationAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInvocationAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInvocationAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.command_content {
            params.push(("CommandContent".into(), (f).into()));
        }

        if let Some(f) = &self.content_encoding {
            params.push(("ContentEncoding".into(), (f).into()));
        }

        if let Some(f) = &self.enable_parameter {
            params.push(("EnableParameter".into(), (f).into()));
        }

        if let Some(f) = &self.frequency {
            params.push(("Frequency".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            crate::FlatSerialize::flat_serialize(f, "InstanceId", &mut params);
        }
        params.push(("InvokeId".into(), (&self.invoke_id).into()));

        if let Some(f) = &self.parameters {
            if let Ok(json) = serde_json::to_string(f) {
                params.push(("Parameters".into(), json.into()));
            }
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct StopInvocation {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 命令执行ID。您可以通过接口[DescribeInvocations](~~64840~~)查询所有的InvokeId。
    invoke_id: String,
    /// 要停止执行命令的实例列表，最多能指定50台实例ID。N的取值范围为1~50。
    #[setters(generate = true, strip_option)]
    instance_id: Option<Vec<String>>,
}

impl sealed::Bound for StopInvocation {}

impl StopInvocation {
    pub fn new(region_id: impl Into<String>, invoke_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            invoke_id: invoke_id.into(),
            instance_id: None,
        }
    }
}
impl crate::ToFormData for StopInvocation {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for StopInvocation {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "StopInvocation";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<StopInvocationResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.instance_id {
            crate::FlatSerialize::flat_serialize(f, "InstanceId", &mut params);
        }
        params.push(("InvokeId".into(), (&self.invoke_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeCommands {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 公共命令的提供者。参数值的具体说明如下：
    ///
    /// - 当该参数不传值时，默认查询您手动创建的所有云助手命令。
    /// - 当该参数取值为`AlibabaCloud`时，查询由阿里云提供的所有公共命令。
    /// - 当该参数的取值为具体的公共命令提供者时，查询该提供者提供的所有公共命令。例如：
    ///     - 当`Provider=AlibabaCloud.ECS.GuestOS`时，查询`AlibabaCloud.ECS.GuestOS`提供的公共命令。
    ///     - 当`Provider=AlibabaCloud.ECS.GuestOSDiagnose`时，查询`AlibabaCloud.ECS.GuestOSDiagnose`提供的公共命令。
    #[setters(generate = true, strip_option)]
    provider: Option<String>,
    /// 命令ID。
    #[setters(generate = true, strip_option)]
    command_id: Option<String>,
    /// 命令的名称。
    ///
    /// - 当指定了`Provider`参数查询公共命令时，默认支持模糊查询。
    ///
    /// - 当未指定`Provider`参数查询私有命令时，支持模糊查询，例如输入`command*`，可以搜索出所有名称以`command`开头的命令；输入`*command`，可以搜索出所有名称以`command`结尾的命令；输入`*command*`，可以搜索出所有名称包含`command`的命令。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// 命令的描述。
    ///
    /// - 当指定了`Provider`参数查询公共命令时，默认支持模糊查询。
    ///
    /// - 当未指定`Provider`参数查询私有命令时，支持模糊查询，例如输入`test*`，可以搜索出所有描述以`test`开头的命令；例如输入`*test`，可以搜索出所有描述以`test`结尾的命令；例如输入`*test*`，可以搜索出所有描述包含`test`的命令。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 命令的类型。取值范围：
    ///
    /// - RunBatScript：命令为在Windows实例中运行的Bat脚本。
    /// - RunPowerShellScript：命令为在Windows实例中运行的PowerShell脚本。
    /// - RunShellScript：命令为在Linux实例中运行的Shell脚本。
    #[setters(generate = true, strip_option, rename = "r#type")]
    r#type: Option<String>,
    /// 设置返回数据中`CommandContent`字段和`Output`字段的编码方式。取值范围：
    /// - PlainText：返回原始脚本内容和输出信息。
    /// - Base64：返回Base64编码后的脚本内容和输出信息。
    ///
    /// 默认值为Base64。
    #[setters(generate = true, strip_option)]
    content_encoding: Option<String>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i64>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i64>,
    /// 分页查询时每页的最大条目数。
    ///
    /// 最大值为50。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 查询凭证（Token），取值为上一次API调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 若查询结果包含公共命令，是否只查询最新版本的公共命令。该参数不影响私有命令的查询。
    ///
    /// - true：只查询最新版本的公共命令。
    ///
    /// - false：查询所有版本的公共命令。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    latest: Option<bool>,
    /// 命令所属的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<CommandsTag>>,
}

impl sealed::Bound for DescribeCommands {}

impl DescribeCommands {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            provider: None,
            command_id: None,
            name: None,
            description: None,
            r#type: None,
            content_encoding: None,
            page_number: None,
            page_size: None,
            max_results: None,
            next_token: None,
            latest: None,
            resource_group_id: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeCommands {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeCommands {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeCommands";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeCommandsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(14);

        if let Some(f) = &self.command_id {
            params.push(("CommandId".into(), (f).into()));
        }

        if let Some(f) = &self.content_encoding {
            params.push(("ContentEncoding".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.latest {
            params.push(("Latest".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }

        if let Some(f) = &self.provider {
            params.push(("Provider".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.r#type {
            params.push(("Type".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyCommand {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 命令ID。您可以通过接口[DescribeCommands](~~64843~~)查询所有可用的CommandId。
    command_id: String,
    /// 命令名称。支持全字符集，长度不得超过128个字符。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// 命令描述。支持全字符集，长度不得超过512个字符。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// > 该参数已废弃，传入该参数不会生效。
    #[setters(generate = true, strip_option)]
    command_content: Option<String>,
    /// 执行路径。长度不得超过200个字符。
    #[setters(generate = true, strip_option)]
    working_dir: Option<String>,
    /// 您创建的命令在ECS实例中执行时最大的超时时间，单位为秒。当无法在配置的时间内运行并完成您创建的命令时，会出现超时现象。超时后，会强制终止命令进程，即取消命令的PID。
    #[setters(generate = true, strip_option)]
    timeout: Option<i64>,
    /// 脚本执行的引导程序。长度不能超过 1 KB。
    #[setters(generate = true, strip_option)]
    launcher: Option<String>,
}

impl sealed::Bound for ModifyCommand {}

impl ModifyCommand {
    pub fn new(region_id: impl Into<String>, command_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            command_id: command_id.into(),
            name: None,
            description: None,
            command_content: None,
            working_dir: None,
            timeout: None,
            launcher: None,
        }
    }
}
impl crate::ToFormData for ModifyCommand {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyCommand {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyCommand";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyCommandResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.command_content {
            params.push(("CommandContent".into(), (f).into()));
        }
        params.push(("CommandId".into(), (&self.command_id).into()));

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.launcher {
            params.push(("Launcher".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.timeout {
            params.push(("Timeout".into(), (f).into()));
        }

        if let Some(f) = &self.working_dir {
            params.push(("WorkingDir".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteCommand {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 命令ID。您可以通过接口[DescribeCommands](~~64843~~)查询所有可用的CommandId。
    command_id: String,
}

impl sealed::Bound for DeleteCommand {}

impl DeleteCommand {
    pub fn new(region_id: impl Into<String>, command_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            command_id: command_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteCommand {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteCommand {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteCommand";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteCommandResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("CommandId".into(), (&self.command_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct SendFile {
    /// 目标ECS实例所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 文件下发的资源组ID，当指定该参数时：
    ///
    /// - InstanceId对应的ECS实例必须属于该资源组。
    ///
    /// - 支持通过指定该参数筛选出对应的文件下发结果（通过调用[DescribeSendFileResults](~~184117~~)）。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 文件名称。支持全字符集，长度不得超过255个字符。
    name: String,
    /// 描述信息。支持全字符集，长度不得超过512个字符。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 下发文件的超时时间。单位：秒。
    ///
    /// - 当因为进程原因、缺失模块、缺失云助手Agent等原因无法下发文件时，会出现超时现象。
    /// - 当设置的超时时间小于10秒时，为确保下发成功，系统会将超时时间自动设置为10秒。
    ///
    /// 默认值为60。
    #[setters(generate = true, strip_option)]
    timeout: Option<i64>,
    /// 文件下发目标ECS实例中的目录。如不存在则会自动创建。长度不得超过255个字符。
    target_dir: String,
    /// 文件内容类型。
    /// - PlainText：普通文本。
    /// - Base64：Base64编码。
    ///
    /// 默认值为PlainText。
    #[setters(generate = true, strip_option)]
    content_type: Option<String>,
    /// 文件内容。文件内容在Base64编码后，大小不能超过32 KB。
    ///
    /// - 当`ContentType`参数为`PlainText`时，该字段为明文格式的普通文本。
    /// - 当`ContentType`参数为`Base64`时，该字段为Base64编码的文本。
    content: String,
    /// 文件的用户。只对Linux实例生效，默认为root。长度不得超过64个字符。
    ///
    /// >使用其他用户时，请确保实例中存在该用户。
    #[setters(generate = true, strip_option)]
    file_owner: Option<String>,
    /// 文件的用户组。只对Linux实例生效，默认为root。长度不得超过64个字符。
    ///
    /// >使用其他用户组时，请确保实例中存在该用户组。
    #[setters(generate = true, strip_option)]
    file_group: Option<String>,
    /// 文件的权限。只对Linux实例生效，设置方式与chmod命令相同。
    ///
    /// 默认值为0644，表示用户具有读写权限，用户组和其它用户具有只读权限。
    #[setters(generate = true, strip_option)]
    file_mode: Option<String>,
    /// 如果同名文件在目标目录已存在，是否覆盖文件。
    /// - true：覆盖。
    /// - false：不覆盖。
    ///
    /// 默认值为false。
    #[setters(generate = true, strip_option)]
    overwrite: Option<bool>,
    /// 需要执行命令的ECS实例列表。最多能指定50台ECS实例ID。N的取值范围为1~50。
    instance_id: Vec<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<FileTag>>,
}

impl sealed::Bound for SendFile {}

impl SendFile {
    pub fn new(
        region_id: impl Into<String>,
        name: impl Into<String>,
        target_dir: impl Into<String>,
        content: impl Into<String>,
        instance_id: impl Into<Vec<String>>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            name: name.into(),
            description: None,
            timeout: None,
            target_dir: target_dir.into(),
            content_type: None,
            content: content.into(),
            file_owner: None,
            file_group: None,
            file_mode: None,
            overwrite: None,
            instance_id: instance_id.into(),
            tag: None,
        }
    }
}
impl crate::ToFormData for SendFile {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for SendFile {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "SendFile";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<SendFileResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(14);
        params.push(("Content".into(), (&self.content).into()));

        if let Some(f) = &self.content_type {
            params.push(("ContentType".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.file_group {
            params.push(("FileGroup".into(), (f).into()));
        }

        if let Some(f) = &self.file_mode {
            params.push(("FileMode".into(), (f).into()));
        }

        if let Some(f) = &self.file_owner {
            params.push(("FileOwner".into(), (f).into()));
        }
        crate::FlatSerialize::flat_serialize(&self.instance_id, "InstanceId", &mut params);

        params.push(("Name".into(), (&self.name).into()));

        if let Some(f) = &self.overwrite {
            params.push(("Overwrite".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }
        params.push(("TargetDir".into(), (&self.target_dir).into()));

        if let Some(f) = &self.timeout {
            params.push(("Timeout".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSendFileResults {
    /// ECS实例所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 文件下发的资源组ID。传入该参数后，需要在下发文件时指定ResourceGroupId，支持筛选出对应的文件下发结果。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 执行ID。
    #[setters(generate = true, strip_option)]
    invoke_id: Option<String>,
    /// 文件名称。传入该参数后，将查询该名称文件的所有的下发记录。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// 实例ID。传入该参数后，将查询该实例所有的文件下发记录。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i64>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i64>,
    /// 分页查询时每页的最大条目数。
    ///
    /// 最大值为50。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 查询凭证（Token），取值为上一次API调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 文件的总下发状态。总状态取决于本次下发的全部实例的共同执行状态，取值范围：
    ///
    /// - Pending：系统正在校验或下发文件。存在至少一台实例的文件下发状态为Pending，则总执行状态为Pending。
    /// - Running：正在实例上下发文件。存在至少一台实例的文件下发状态为Running，则总执行状态为Running。
    /// - Success：下发成功。各个实例上的文件下发状态均为Success，则总执行状态为Success。
    /// - Failed：下发失败。各个实例上的文件下发状态均为Failed，则总执行状态为Failed。
    /// - PartialFailed：部分实例文件下发成功且部分实例下发失败。各个实例的文件下发状态均为Success或Failed，则总执行状态为PartialFailed。
    #[setters(generate = true, strip_option)]
    invocation_status: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<FileResultsTag>>,
}

impl sealed::Bound for DescribeSendFileResults {}

impl DescribeSendFileResults {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_group_id: None,
            invoke_id: None,
            name: None,
            instance_id: None,
            page_number: None,
            page_size: None,
            max_results: None,
            next_token: None,
            invocation_status: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeSendFileResults {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSendFileResults {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSendFileResults";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSendFileResultsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(11);

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.invocation_status {
            params.push(("InvocationStatus".into(), (f).into()));
        }

        if let Some(f) = &self.invoke_id {
            params.push(("InvokeId".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeCloudAssistantStatus {
    /// 实例所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例的操作系统类型。取值范围：
    ///
    /// - Windows。
    /// - Linux。
    /// - FreeBSD。
    #[setters(generate = true, strip_option)]
    os_type: Option<String>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i64>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i64>,
    /// 分页查询时每页的最大条目数。若已设置**InstanceId**参数，则该参数无效。
    ///
    /// 最大值为50。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 查询凭证（Token），取值为上一次API调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 实例ID列表。
    #[setters(generate = true, strip_option)]
    instance_id: Option<Vec<String>>,
}

impl sealed::Bound for DescribeCloudAssistantStatus {}

impl DescribeCloudAssistantStatus {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            os_type: None,
            page_number: None,
            page_size: None,
            max_results: None,
            next_token: None,
            instance_id: None,
        }
    }
}
impl crate::ToFormData for DescribeCloudAssistantStatus {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeCloudAssistantStatus {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeCloudAssistantStatus";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeCloudAssistantStatusResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.instance_id {
            crate::FlatSerialize::flat_serialize(f, "InstanceId", &mut params);
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.os_type {
            params.push(("OSType".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct InstallCloudAssistant {
    /// 实例所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID列表。列表元素数量为1~50。
    instance_id: Vec<String>,
}

impl sealed::Bound for InstallCloudAssistant {}

impl InstallCloudAssistant {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<Vec<String>>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for InstallCloudAssistant {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for InstallCloudAssistant {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "InstallCloudAssistant";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<InstallCloudAssistantResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        crate::FlatSerialize::flat_serialize(&self.instance_id, "InstanceId", &mut params);

        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct StartTerminalSession {
    /// 实例所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID列表。
    instance_id: Vec<String>,
    /// 指定ECS实例的端口号，用于数据转发。一旦设置该参数，云助手Agent的数据转发会传到指定的端口号，用于端口转发。例如，SSH使用22端口。
    ///
    /// 默认值为空，表示不设置数据转发的端口号。
    #[setters(generate = true, strip_option)]
    port_number: Option<i32>,
    /// 发起会话后，指定执行的命令内容。长度不能超过512个字符。
    ///
    /// > 指定了`CommandLine`后，不能再指定`PortNumber`和`TargetServer`。
    #[setters(generate = true, strip_option)]
    command_line: Option<String>,
    /// 指定通过实例访问VPC内目标服务地址。
    ///
    /// >当该参数不为空时，`PortNumber`表示通过托管实例访问VPC内目标服务的端口号。
    #[setters(generate = true, strip_option)]
    target_server: Option<String>,
    /// 指定连接时的用户名称。
    #[setters(generate = true, strip_option)]
    username: Option<String>,
    /// 远程连接实例所需WebSocket URL的网络类型。
    /// - Internet：公网（默认）
    /// - Intranet：内网。
    #[setters(generate = true, strip_option)]
    connection_type: Option<String>,
    /// 在 Windows 实例中使用Session Manager时用户的密码名称。长度不得超过 255 个字符。
    /// 当您希望以非默认用户（System）在 Windows 实例中使用Session Manager时，需要同时传入Username和该参数。为降低密码泄露的风险，需要将密码明文托管在系统运维管理的参数仓库中，此处仅传入密码的名称。更多信息，请参见[加密参数](~~186828~~)。
    #[setters(generate = true, strip_option)]
    password_name: Option<String>,
    #[setters(generate = true, strip_option)]
    encryption_options: Option<EncryptionOptions>,
}

impl sealed::Bound for StartTerminalSession {}

impl StartTerminalSession {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<Vec<String>>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
            port_number: None,
            command_line: None,
            target_server: None,
            username: None,
            connection_type: None,
            password_name: None,
            encryption_options: None,
        }
    }
}
impl crate::ToFormData for StartTerminalSession {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for StartTerminalSession {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "StartTerminalSession";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<StartTerminalSessionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);

        if let Some(f) = &self.command_line {
            params.push(("CommandLine".into(), (f).into()));
        }

        if let Some(f) = &self.connection_type {
            params.push(("ConnectionType".into(), (f).into()));
        }

        if let Some(f) = &self.encryption_options {
            if let Ok(json) = serde_json::to_string(f) {
                params.push(("EncryptionOptions".into(), json.into()));
            }
        }
        crate::FlatSerialize::flat_serialize(&self.instance_id, "InstanceId", &mut params);

        if let Some(f) = &self.password_name {
            params.push(("PasswordName".into(), (f).into()));
        }

        if let Some(f) = &self.port_number {
            params.push(("PortNumber".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.target_server {
            params.push(("TargetServer".into(), (f).into()));
        }

        if let Some(f) = &self.username {
            params.push(("Username".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct EndTerminalSession {
    /// 会话所在地域的ID。
    region_id: String,
    /// 会话ID。
    session_id: String,
}

impl sealed::Bound for EndTerminalSession {}

impl EndTerminalSession {
    pub fn new(region_id: impl Into<String>, session_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            session_id: session_id.into(),
        }
    }
}
impl crate::ToFormData for EndTerminalSession {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for EndTerminalSession {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "EndTerminalSession";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<EndTerminalSessionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("SessionId".into(), (&self.session_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeTerminalSessions {
    /// 地域ID。
    region_id: String,
    /// 实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 会话ID。
    #[setters(generate = true, strip_option)]
    session_id: Option<String>,
    /// 分页查询时每页的最大条目数。
    ///
    /// 最大值为100。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 查询凭证（Token），取值为上一次API调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
}

impl sealed::Bound for DescribeTerminalSessions {}

impl DescribeTerminalSessions {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: None,
            session_id: None,
            max_results: None,
            next_token: None,
        }
    }
}
impl crate::ToFormData for DescribeTerminalSessions {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeTerminalSessions {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeTerminalSessions";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeTerminalSessionsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.session_id {
            params.push(("SessionId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyCloudAssistantSettings {
    /// 地域ID。
    region_id: String,
    /// 服务配置类型。当前取值范围：
    /// - SessionManagerDelivery：会话操作记录投递。
    /// - InvocationDelivery：任务执行记录投递。
    /// - AgentUpgradeConfig：云助手Agent升级配置。
    /// - SessionManagerConfig: 云助手SessionManager配置。
    setting_type: String,
    /// OSS投递配置信息。
    #[setters(generate = true, strip_option)]
    oss_delivery_config: Option<SettingsOssDeliveryConfig>,
    /// SLS投递配置信息。
    #[setters(generate = true, strip_option)]
    sls_delivery_config: Option<SettingsSlsDeliveryConfig>,
    /// 云助手Agent升级配置。
    #[setters(generate = true, strip_option)]
    agent_upgrade_config: Option<SettingsAgentUpgradeConfig>,
    /// 云助手会话功能配置。
    #[setters(generate = true, strip_option)]
    session_manager_config: Option<SettingsSessionManagerConfig>,
}

impl sealed::Bound for ModifyCloudAssistantSettings {}

impl ModifyCloudAssistantSettings {
    pub fn new(region_id: impl Into<String>, setting_type: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            setting_type: setting_type.into(),
            oss_delivery_config: None,
            sls_delivery_config: None,
            agent_upgrade_config: None,
            session_manager_config: None,
        }
    }
}
impl crate::ToFormData for ModifyCloudAssistantSettings {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyCloudAssistantSettings {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyCloudAssistantSettings";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyCloudAssistantSettingsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.agent_upgrade_config {
            if let Ok(json) = serde_json::to_string(f) {
                params.push(("AgentUpgradeConfig".into(), json.into()));
            }
        }

        if let Some(f) = &self.oss_delivery_config {
            if let Ok(json) = serde_json::to_string(f) {
                params.push(("OssDeliveryConfig".into(), json.into()));
            }
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.session_manager_config {
            if let Ok(json) = serde_json::to_string(f) {
                params.push(("SessionManagerConfig".into(), json.into()));
            }
        }
        params.push(("SettingType".into(), (&self.setting_type).into()));

        if let Some(f) = &self.sls_delivery_config {
            if let Ok(json) = serde_json::to_string(f) {
                params.push(("SlsDeliveryConfig".into(), json.into()));
            }
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeCloudAssistantSettings {
    /// 待查询的服务配置列表。
    setting_type: Vec<String>,
    /// 地域ID。
    region_id: String,
}

impl sealed::Bound for DescribeCloudAssistantSettings {}

impl DescribeCloudAssistantSettings {
    pub fn new(setting_type: impl Into<Vec<String>>, region_id: impl Into<String>) -> Self {
        Self {
            setting_type: setting_type.into(),
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeCloudAssistantSettings {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeCloudAssistantSettings {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeCloudAssistantSettings";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeCloudAssistantSettingsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        crate::FlatSerialize::flat_serialize(&self.setting_type, "SettingType", &mut params);

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateActivation {
    /// 地域ID。目前支持的地域：华北1（青岛）、华北2（北京）、华北3（张家口）、华北5（呼和浩特）、华北6（乌兰察布）、华东1（杭州）、华东2（上海）、华南1（深圳）、华南2（河源）、华南3（广州）、西南1（成都）、中国香港、新加坡、日本（东京）、美国（硅谷）、美国（弗吉尼亚）。
    /// 您可以调用[DescribeRegions](~~25609~~)查看地域对应的ID等信息。
    region_id: String,
    /// 默认的实例名称前缀。支持2~50个字符，且必须以字母开头，不能以特殊字符及数字开头，只可包含特殊字符中的半角句号（.）、下划线（_）、短划线（-）和半角冒号（:），不可以使用`http://`或`https://`开头。
    ///
    /// 使用该接口创建的激活码注册的实例，将使用该名称作为前缀，生成有序的实例名。您也可以在注册托管实例时，指定新的实例名称以覆盖此默认值。
    ///
    /// 注册托管实例时，如果指定了InstanceName的值，则会生成名称`<InstanceName>-001`，其中编号`001`数字的位数取决于`InstanceCount`数值的位数。如果未指定InstanceName的值，则会使用主机的主机名（Hostname）作为实例的名称。
    #[setters(generate = true, strip_option)]
    instance_name: Option<String>,
    /// 激活码对应的描述。支持1~100个字符。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 激活码用于注册托管实例的使用次数上限。取值范围为1~1000。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    instance_count: Option<i32>,
    /// 激活码的有效使用时间，过期后将不能用于注册新的实例。单位：小时。
    ///
    /// 默认值为4小时。
    #[setters(generate = true, strip_option)]
    time_to_live_in_hours: Option<i64>,
    /// 允许使用该激活码的主机IP。取值为对应的IPv4地址、IPv6地址或CIDR地址段。
    #[setters(generate = true, strip_option)]
    ip_address_range: Option<String>,
    /// 激活码所属的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ActivationTag>>,
}

impl sealed::Bound for CreateActivation {}

impl CreateActivation {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_name: None,
            description: None,
            instance_count: None,
            time_to_live_in_hours: None,
            ip_address_range: None,
            resource_group_id: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for CreateActivation {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateActivation {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateActivation";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateActivationResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.instance_count {
            params.push(("InstanceCount".into(), (f).into()));
        }

        if let Some(f) = &self.instance_name {
            params.push(("InstanceName".into(), (f).into()));
        }

        if let Some(f) = &self.ip_address_range {
            params.push(("IpAddressRange".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.time_to_live_in_hours {
            params.push(("TimeToLiveInHours".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeActivations {
    /// 地域ID。目前支持的地域：华北1（青岛）、华北2（北京）、华北3（张家口）、华北5（呼和浩特）、华北6（乌兰察布）、华东1（杭州）、华东2（上海）、华南1（深圳）、华南2（河源）、华南3（广州）、西南1（成都）、中国香港、新加坡、日本（东京）、美国（硅谷）、美国（弗吉尼亚）。
    ///
    /// 您可以调用[DescribeRegions](~~25609~~)查看地域对应的ID等信息。
    region_id: String,
    /// 激活码ID。
    #[setters(generate = true, strip_option)]
    activation_id: Option<String>,
    /// 默认的实例名称前缀。
    #[setters(generate = true, strip_option)]
    instance_name: Option<String>,
    /// 当前页码。
    ///
    /// 起始值为1。
    ///
    /// 默认值为1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i64>,
    /// 分页查询时设置的每页行数。
    ///
    /// 最大值为50。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i64>,
    /// 分页查询时每页的最大条目数。
    ///
    /// 最大值为50。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 查询凭证（Token），取值为上一次API调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 激活码所属的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ActivationsTag>>,
}

impl sealed::Bound for DescribeActivations {}

impl DescribeActivations {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            activation_id: None,
            instance_name: None,
            page_number: None,
            page_size: None,
            max_results: None,
            next_token: None,
            resource_group_id: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeActivations {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeActivations {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeActivations";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeActivationsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);

        if let Some(f) = &self.activation_id {
            params.push(("ActivationId".into(), (f).into()));
        }

        if let Some(f) = &self.instance_name {
            params.push(("InstanceName".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DisableActivation {
    /// 地域ID。目前支持的地域：华北1（青岛）、华北2（北京）、华北3（张家口）、华北5（呼和浩特）、华北6（乌兰察布）、华东1（杭州）、华东2（上海）、华南1（深圳）、华南2（河源）、华南3（广州）、西南1（成都）、中国香港、新加坡、日本（东京）、美国（硅谷）、美国（弗吉尼亚）。
    ///
    /// 您可以调用[DescribeRegions](~~25609~~)查看地域对应的ID等信息。
    region_id: String,
    /// 激活码ID。
    activation_id: String,
}

impl sealed::Bound for DisableActivation {}

impl DisableActivation {
    pub fn new(region_id: impl Into<String>, activation_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            activation_id: activation_id.into(),
        }
    }
}
impl crate::ToFormData for DisableActivation {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DisableActivation {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DisableActivation";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DisableActivationResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("ActivationId".into(), (&self.activation_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteActivation {
    /// 地域ID。目前支持的地域：华北1（青岛）、华北2（北京）、华北3（张家口）、华北5（呼和浩特）、华北6（乌兰察布）、华东1（杭州）、华东2（上海）、华南1（深圳）、华南2（河源）、华南3（广州）、西南1（成都）、中国香港、新加坡、日本（东京）、美国（硅谷）、美国（弗吉尼亚）。
    ///
    /// 您可以调用[DescribeRegions](~~25609~~)查看地域对应的ID等信息。
    region_id: String,
    /// 未被使用的激活码ID。
    activation_id: String,
}

impl sealed::Bound for DeleteActivation {}

impl DeleteActivation {
    pub fn new(region_id: impl Into<String>, activation_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            activation_id: activation_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteActivation {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteActivation {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteActivation";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteActivationResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("ActivationId".into(), (&self.activation_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeManagedInstances {
    /// 地域ID。目前支持的地域：华北1（青岛）、华北2（北京）、华北3（张家口）、华北5（呼和浩特）、华北6（乌兰察布）、华东1（杭州）、华东2（上海）、华南1（深圳）、华南2（河源）、华南3（广州）、西南1（成都）、中国香港、新加坡、日本（东京）、美国（硅谷）、美国（弗吉尼亚）。
    ///
    /// 您可以调用[DescribeRegions](~~25609~~)查看地域对应的ID等信息。
    region_id: String,
    /// 托管实例的操作系统类型，取值范围：
    ///
    /// - windows。
    /// - linux。
    /// - FreeBSD。
    #[setters(generate = true, strip_option)]
    os_type: Option<String>,
    /// 托管实例的内网IP或公网IP。
    #[setters(generate = true, strip_option)]
    instance_ip: Option<String>,
    /// 激活码ID。
    #[setters(generate = true, strip_option)]
    activation_id: Option<String>,
    /// 在注册托管实例时，所指定的MachineId参数的值，最多允许36字符。
    /// 注册脚本示例：
    /// ```ignore
    /// aliyun-service --register \
    ///   --RegionId=cn-hangznou \
    ///   --ActivationId=xxxxxxxxxxx \
    ///   --ActivationCode=xxxxxxxxx \
    ///   --MachineId=xxxxxx \ # 可选参数，表示此机器的唯一标识
    ///   --ForceResue                 
    /// ```
    ///
    /// - 若在注册时指定了MachineId与ForceResult参数，则云助手将为此MachineId生成固定不变的托管实例ID。
    /// - 若未显式指定MachineId参数，云助手将根据机器的硬件信息自动生成MachineId值。
    /// - 推荐：显式指定参数MachineId与ForceResult，用于标记托管实例与线下机器的对应关系。
    #[setters(generate = true, strip_option)]
    machine_id: Option<String>,
    /// 托管实例的名称。
    #[setters(generate = true, strip_option)]
    instance_name: Option<String>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i64>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i64>,
    /// 托管实例的ID。N的取值范围为1~50。
    #[setters(generate = true, strip_option)]
    instance_id: Option<Vec<String>>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ManagedInstancesTag>>,
    /// 分页查询时每页的最大条目数。
    ///
    /// 最大值为50。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 查询凭证（Token），取值为上一次API调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 托管实例所属的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
}

impl sealed::Bound for DescribeManagedInstances {}

impl DescribeManagedInstances {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            os_type: None,
            instance_ip: None,
            activation_id: None,
            machine_id: None,
            instance_name: None,
            page_number: None,
            page_size: None,
            instance_id: None,
            tag: None,
            max_results: None,
            next_token: None,
            resource_group_id: None,
        }
    }
}
impl crate::ToFormData for DescribeManagedInstances {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeManagedInstances {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeManagedInstances";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeManagedInstancesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(13);

        if let Some(f) = &self.activation_id {
            params.push(("ActivationId".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            crate::FlatSerialize::flat_serialize(f, "InstanceId", &mut params);
        }

        if let Some(f) = &self.instance_ip {
            params.push(("InstanceIp".into(), (f).into()));
        }

        if let Some(f) = &self.instance_name {
            params.push(("InstanceName".into(), (f).into()));
        }

        if let Some(f) = &self.machine_id {
            params.push(("MachineId".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.os_type {
            params.push(("OsType".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyManagedInstance {
    /// 地域ID。目前支持的地域：华北1（青岛）、华北2（北京）、华北3（张家口）、华北5（呼和浩特）、华北6（乌兰察布）、华东1（杭州）、华东2（上海）、华南1（深圳）、华南2（河源）、华南3（广州）、西南1（成都）、中国香港、新加坡、日本（东京）、美国（硅谷）、美国（弗吉尼亚）。
    ///
    /// 您可以调用[DescribeRegions](~~25609~~)查看地域对应的ID等信息。
    region_id: String,
    /// 托管实例的ID。
    instance_id: String,
    /// 托管实例的名称。支持2~128个字符，且必须以字母开头，不能以特殊字符及数字开头。只可包含特殊字符中的半角句号（.）、下划线（_）、短划线（-）和半角冒号（:），不可以使用`http://`或`https://`开头。
    instance_name: String,
}

impl sealed::Bound for ModifyManagedInstance {}

impl ModifyManagedInstance {
    pub fn new(
        region_id: impl Into<String>,
        instance_id: impl Into<String>,
        instance_name: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
            instance_name: instance_name.into(),
        }
    }
}
impl crate::ToFormData for ModifyManagedInstance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyManagedInstance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyManagedInstance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyManagedInstanceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("InstanceName".into(), (&self.instance_name).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeregisterManagedInstance {
    /// 地域ID。目前支持的地域：华北1（青岛）、华北2（北京）、华北3（张家口）、华北5（呼和浩特）、华北6（乌兰察布）、华东1（杭州）、华东2（上海）、华南1（深圳）、华南2（河源）、华南3（广州）、西南1（成都）、中国香港、新加坡、日本（东京）、美国（硅谷）、美国（弗吉尼亚）。
    ///
    /// 您可以调用[DescribeRegions](~~25609~~)查看地域对应的ID等信息。
    region_id: String,
    /// 托管实例ID。
    instance_id: String,
}

impl sealed::Bound for DeregisterManagedInstance {}

impl DeregisterManagedInstance {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for DeregisterManagedInstance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeregisterManagedInstance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeregisterManagedInstance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeregisterManagedInstanceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ListPluginStatus {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID，单次请求最多支持50台实例，N的取值范围为1~50。
    #[setters(generate = true, strip_option)]
    instance_id: Option<Vec<String>>,
    /// 插件名称，支持全字符集。长度不得超过255个字符。
    ///
    /// - 若不指定该参数，会查询实例中已安装插件的状态。
    ///
    ///     > 若不指定该参数，只能指定一个实例ID。
    ///
    /// - 若指定该参数，会查询出实例中指定插件的状态。
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i64>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i64>,
    /// 分页查询时每页的最大条目数。
    ///
    /// 最大值为50。
    ///
    /// 默认值为10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    /// 查询凭证（Token），取值为上一次API调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
}

impl sealed::Bound for ListPluginStatus {}

impl ListPluginStatus {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: None,
            name: None,
            page_number: None,
            page_size: None,
            max_results: None,
            next_token: None,
        }
    }
}
impl crate::ToFormData for ListPluginStatus {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ListPluginStatus {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ListPluginStatus";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ListPluginStatusResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.instance_id {
            crate::FlatSerialize::flat_serialize(f, "InstanceId", &mut params);
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstancesFullStatus {
    /// 实例所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 指定实例的生命周期状态。取值范围：
    /// - Starting：启动中。
    /// - Running：运行中。
    /// - Stopped：已停止。
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// 指定实例的健康状态。取值范围：
    ///
    /// - Impaired：服务损坏。
    /// - Warning：警告，实例性能可能因维护而降低。
    /// - Maintaining：维护中。
    /// - Initializing：初始化中。
    /// - InsufficientData：数据不足。
    /// - NotApplicable：不适用。
    ///
    /// 以上参数取值均区分大小写。
    #[setters(generate = true, strip_option)]
    health_status: Option<String>,
    /// 一个事件的类型。EventType参数只在未指定InstanceEventType.N参数时有效。取值范围：
    ///
    /// - SystemMaintenance.Reboot：因系统维护实例重启。
    /// - SystemFailure.Reboot：因系统错误实例重启。
    /// - InstanceFailure.Reboot：因实例错误实例重启。
    /// - InstanceExpiration.Stop：因包年包月期限到期，实例停止。
    /// - InstanceExpiration.Delete：因包年包月期限到期，实例释放。
    /// - AccountUnbalanced.Stop：因账号欠费，按量付费实例停止。
    /// - AccountUnbalanced.Delete：因账号欠费，按量付费实例释放。
    #[setters(generate = true, strip_option)]
    event_type: Option<String>,
    /// 查询事件计划执行时间的开始时间。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    not_before_start: Option<String>,
    /// 查询事件计划执行时间的结束时间。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    not_before_end: Option<String>,
    /// 查询事件发布时间的开始时间。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    event_publish_time_start: Option<String>,
    /// 查询事件发布时间的结束时间。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    event_publish_time_end: Option<String>,
    /// 查询结果的页码。取值范围：正整数
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 查询结果的分页大小。取值范围：1~100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 实例ID列表。可输入最大100个实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<Vec<String>>,
    /// 事件ID列表。可输入最多100个事件ID。
    #[setters(generate = true, strip_option)]
    event_id: Option<Vec<String>>,
    /// 实例事件的类型列表。可输入最大30个实例事件的类型。
    #[setters(generate = true, strip_option)]
    instance_event_type: Option<Vec<String>>,
}

impl sealed::Bound for DescribeInstancesFullStatus {}

impl DescribeInstancesFullStatus {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            status: None,
            health_status: None,
            event_type: None,
            not_before_start: None,
            not_before_end: None,
            event_publish_time_start: None,
            event_publish_time_end: None,
            page_number: None,
            page_size: None,
            instance_id: None,
            event_id: None,
            instance_event_type: None,
        }
    }
}
impl crate::ToFormData for DescribeInstancesFullStatus {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstancesFullStatus {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstancesFullStatus";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstancesFullStatusResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(13);

        if let Some(f) = &self.event_id {
            crate::FlatSerialize::flat_serialize(f, "EventId", &mut params);
        }

        if let Some(f) = &self.event_publish_time_end {
            params.push(("EventPublishTime.End".into(), (f).into()));
        }

        if let Some(f) = &self.event_publish_time_start {
            params.push(("EventPublishTime.Start".into(), (f).into()));
        }

        if let Some(f) = &self.event_type {
            params.push(("EventType".into(), (f).into()));
        }

        if let Some(f) = &self.health_status {
            params.push(("HealthStatus".into(), (f).into()));
        }

        if let Some(f) = &self.instance_event_type {
            crate::FlatSerialize::flat_serialize(f, "InstanceEventType", &mut params);
        }

        if let Some(f) = &self.instance_id {
            crate::FlatSerialize::flat_serialize(f, "InstanceId", &mut params);
        }

        if let Some(f) = &self.not_before_end {
            params.push(("NotBefore.End".into(), (f).into()));
        }

        if let Some(f) = &self.not_before_start {
            params.push(("NotBefore.Start".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDisksFullStatus {
    /// 块存储所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 指定块存储的生命周期状态，详情请参见[云盘状态表](~~25689~~)。取值范围：
    ///
    /// - In_use：使用中 。
    /// - Available：待挂载 。
    /// - Attaching：挂载中 。
    /// - Detaching：卸载中 。
    /// - Creating：创建中 。
    /// - ReIniting：初始化中 。
    ///          
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// 指定块存储的健康状态。取值范围：
    ///
    /// - Impaired：暂时性不可读写 。
    /// - Warning：服务降级 。
    /// - Initializing：初始化中 。
    /// - InsufficientData：数据不足 。
    /// - NotApplicable：不适用 。
    ///          
    #[setters(generate = true, strip_option)]
    health_status: Option<String>,
    /// 指定块存储的事件类型。取值范围：
    ///
    /// - Degraded：块存储性能降级。
    /// - SeverelyDegraded：块存储性能严重降级。
    /// - Stalled：块存储性能受到严重影响。
    /// - ErrorDetected：本地盘出现损坏。
    #[setters(generate = true, strip_option)]
    event_type: Option<String>,
    /// 查询事件发生时间的开始时间。
    ///
    /// 按照[ISO8601](~~25696~~)标准表示，并使用UTC+0时间，格式为`yyyy-MM-ddTHH:mm:ssZ`。
    #[setters(generate = true, strip_option)]
    event_time_start: Option<String>,
    /// 查询事件发生时间的结束时间。
    ///
    /// 按照[ISO8601](~~25696~~)标准表示，并使用UTC+0时间，格式为`yyyy-MM-ddTHH:mm:ssZ`。
    #[setters(generate = true, strip_option)]
    event_time_end: Option<String>,
    /// 查询结果的页码。取值范围：正整数。
    ///
    /// 默认值：1 。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 查询结果的分页大小。取值范围：1~100。
    ///
    /// 默认值：10 。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 块存储ID。N的取值范围：1~100。
    #[setters(generate = true, strip_option)]
    disk_id: Option<Vec<String>>,
    /// 事件ID。N的取值范围：1~100。
    #[setters(generate = true, strip_option)]
    event_id: Option<Vec<String>>,
    /// 块存储资源所属的资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<StatusTag>>,
}

impl sealed::Bound for DescribeDisksFullStatus {}

impl DescribeDisksFullStatus {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            status: None,
            health_status: None,
            event_type: None,
            event_time_start: None,
            event_time_end: None,
            page_number: None,
            page_size: None,
            disk_id: None,
            event_id: None,
            resource_group_id: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeDisksFullStatus {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDisksFullStatus {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDisksFullStatus";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDisksFullStatusResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(12);

        if let Some(f) = &self.disk_id {
            crate::FlatSerialize::flat_serialize(f, "DiskId", &mut params);
        }

        if let Some(f) = &self.event_id {
            crate::FlatSerialize::flat_serialize(f, "EventId", &mut params);
        }

        if let Some(f) = &self.event_time_end {
            params.push(("EventTime.End".into(), (f).into()));
        }

        if let Some(f) = &self.event_time_start {
            params.push(("EventTime.Start".into(), (f).into()));
        }

        if let Some(f) = &self.event_type {
            params.push(("EventType".into(), (f).into()));
        }

        if let Some(f) = &self.health_status {
            params.push(("HealthStatus".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceHistoryEvents {
    /// 资源所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID。不指定实例ID时，表示查询您指定地域下所有实例的系统事件信息。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 系统事件的生命周期状态。EventCycleStatus只在未指定InstanceEventCycleStatus.N参数时有效。取值范围：
    ///
    /// - Scheduled：等待执行事件。
    /// - Avoided：事件已避免。
    /// - Executing：事件执行中。
    /// - Executed：事件已完成执行。
    /// - Canceled：事件已取消。
    /// - Failed：事件执行失败。
    /// - Inquiring：事件问询中。
    ///          
    #[setters(generate = true, strip_option)]
    event_cycle_status: Option<String>,
    /// 系统事件的类型。EventType参数只在未指定InstanceEventType.N参数时有效。取值范围：
    ///
    /// - SystemMaintenance.Reboot：因系统维护实例重启。
    /// - SystemMaintenance.Redeploy：因系统维护实例重新部署。
    /// - SystemFailure.Reboot：因系统错误实例重启。
    /// - SystemFailure.Redeploy：因系统错误实例重新部署。
    /// - SystemFailure.Delete：因实例创建失败实例释放。
    /// - InstanceFailure.Reboot：因实例错误实例重启。
    /// - InstanceExpiration.Stop：因包年包月期限到期，实例停止。
    /// - InstanceExpiration.Delete：因包年包月期限到期，实例释放。
    /// - AccountUnbalanced.Stop：因账号欠费，按量付费实例停止。
    /// - AccountUnbalanced.Delete：因账号欠费，按量付费实例释放。
    ///
    /// > 事件类型说明请参见[系统事件概述](~~66574~~)。该参数的取值只能是实例系统事件，不能是磁盘系统事件。
    #[setters(generate = true, strip_option)]
    event_type: Option<String>,
    /// 查询系统事件计划执行时间的开始时间。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    not_before_start: Option<String>,
    /// 查询系统事件计划执行时间的结束时间。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    not_before_end: Option<String>,
    /// 查询系统事件发布时间的开始时间。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    event_publish_time_start: Option<String>,
    /// 查询系统事件发布时间的结束时间。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    event_publish_time_end: Option<String>,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    impact_level: Option<String>,
    /// >  该参数即将下线，建议您通过指定 MaxResults 或 NextToken 参数使用分页方式查询。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// > 该参数即将下线，建议您通过指定 MaxResults 或 NextToken 参数使用分页方式查询。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 资源类型。取值范围：
    ///
    /// - instance：ECS实例。
    /// - ddh：专有宿主机。
    /// - managedhost：智能全托管资源池中的物理机。
    ///
    /// 默认值：instance。
    #[setters(generate = true, strip_option)]
    resource_type: Option<String>,
    /// 一个或者多个系统事件ID。N的取值范围为1~100，多个取值使用重复列表的形式。
    #[setters(generate = true, strip_option)]
    event_id: Option<Vec<String>>,
    /// 一个或者多个系统事件的生命周期状态。N的取值范围：1~7，多个取值使用重复列表的形式。取值范围：
    ///
    /// - Scheduled：等待执行事件。
    /// - Avoided：事件已避免。
    /// - Executing：事件执行中。
    /// - Executed：事件已完成执行。
    /// - Canceled：事件已取消。
    /// - Failed：事件执行失败。
    /// - Inquiring：事件问询中。
    #[setters(generate = true, strip_option)]
    instance_event_cycle_status: Option<Vec<String>>,
    /// 一个或者多个系统事件的类型。N的取值范围：1~30，多个取值使用重复列表的形式。取值范围：
    ///
    /// - SystemMaintenance.Reboot：因系统维护实例重启。
    /// - SystemMaintenance.Redeploy：因系统维护实例重新部署。
    /// - SystemFailure.Reboot：因系统错误实例重启。
    /// - SystemFailure.Redeploy：因系统错误实例重新部署。
    /// - SystemFailure.Delete：因实例创建失败实例释放。
    /// - InstanceFailure.Reboot：因实例错误实例重启。
    /// - InstanceExpiration.Stop：因包年包月期限到期，实例停止。
    /// - InstanceExpiration.Delete：因包年包月期限到期，实例释放。
    /// - AccountUnbalanced.Stop：因账号欠费，按量付费实例停止。
    /// - AccountUnbalanced.Delete：因账号欠费，按量付费实例释放。
    ///
    /// > 事件类型说明请参见[系统事件概述](~~66574~~)。该参数的取值只能是实例系统事件，不能是磁盘系统事件。
    #[setters(generate = true, strip_option)]
    instance_event_type: Option<Vec<String>>,
    /// 一个或多个资源ID。N的取值范围为1~100。参数的多个取值使用重复列表的形式。取值范围：
    ///
    /// - 当`ResourceType=instance`时，资源ID表示ECS实例ID。
    /// - 当`ResourceType=ddh`时，资源ID表示专有宿主机ID。
    /// - 当`ResourceType=managedhost`时，资源ID表示智能全托管资源池中的物理机ID。
    ///
    /// 如果不指定该参数，表示查询指定地域（`RegionId`）和指定资源类型（`ResourceType`）下，所有资源的系统事件信息。
    ///
    /// > 推荐您使用`ResourceId.N`参数设置一个或多个资源ID。如果您同时指定了`ResourceId.N`参数和`InstanceId`参数，系统默认优先生效`ResourceId.N`参数。
    #[setters(generate = true, strip_option)]
    resource_id: Option<Vec<String>>,
    /// 系统事件支持的标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<EventsTag>>,
    /// 资源所在的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 查询凭证（Token），取值为上一次 API 调用返回的NextToken参数值。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页的最大条目数。取值范围：10~100。
    ///
    /// 默认值：
    ///
    /// * 当设置的值大于 0 小于 10 时，默认值为 10。
    /// * 当设置的值大于 100 时，默认值为 100。
    #[setters(generate = true, strip_option)]
    max_results: Option<i64>,
}

impl sealed::Bound for DescribeInstanceHistoryEvents {}

impl DescribeInstanceHistoryEvents {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: None,
            event_cycle_status: None,
            event_type: None,
            not_before_start: None,
            not_before_end: None,
            event_publish_time_start: None,
            event_publish_time_end: None,
            impact_level: None,
            page_number: None,
            page_size: None,
            resource_type: None,
            event_id: None,
            instance_event_cycle_status: None,
            instance_event_type: None,
            resource_id: None,
            tag: None,
            resource_group_id: None,
            next_token: None,
            max_results: None,
        }
    }
}
impl crate::ToFormData for DescribeInstanceHistoryEvents {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceHistoryEvents {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceHistoryEvents";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceHistoryEventsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(20);

        if let Some(f) = &self.event_cycle_status {
            params.push(("EventCycleStatus".into(), (f).into()));
        }

        if let Some(f) = &self.event_id {
            crate::FlatSerialize::flat_serialize(f, "EventId", &mut params);
        }

        if let Some(f) = &self.event_publish_time_end {
            params.push(("EventPublishTime.End".into(), (f).into()));
        }

        if let Some(f) = &self.event_publish_time_start {
            params.push(("EventPublishTime.Start".into(), (f).into()));
        }

        if let Some(f) = &self.event_type {
            params.push(("EventType".into(), (f).into()));
        }

        if let Some(f) = &self.impact_level {
            params.push(("ImpactLevel".into(), (f).into()));
        }

        if let Some(f) = &self.instance_event_cycle_status {
            crate::FlatSerialize::flat_serialize(f, "InstanceEventCycleStatus", &mut params);
        }

        if let Some(f) = &self.instance_event_type {
            crate::FlatSerialize::flat_serialize(f, "InstanceEventType", &mut params);
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.not_before_end {
            params.push(("NotBefore.End".into(), (f).into()));
        }

        if let Some(f) = &self.not_before_start {
            params.push(("NotBefore.Start".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.resource_id {
            crate::FlatSerialize::flat_serialize(f, "ResourceId", &mut params);
        }

        if let Some(f) = &self.resource_type {
            params.push(("ResourceType".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateSimulatedSystemEvents {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 系统事件的类型。取值范围：
    /// - SystemMaintenance.Reboot：因系统维护实例重启
    /// - SystemFailure.Reboot：因系统错误实例重启
    /// - InstanceFailure.Reboot：因实例错误实例重启
    /// - SystemMaintenance.Stop：因系统维护实例停止
    /// - SystemMaintenance.Redeploy：因系统维护实例重新部署
    /// - SystemFailure.Redeploy：因系统错误实例重新部署
    /// - SystemFailure.Stop：因系统错误实例重新停止
    /// - InstanceFailure.Reboot：因实例错误实例重启
    event_type: String,
    /// 事件计划执行的开始时间。按照[ISO8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    ///
    /// > 对于系统错误或实例错误导致的异常事件，创建事件后，事件已处于正在执行（`Executing`）状态，此时参数`NotBefore`为事件进入完成执行（`Executed`）状态的时间。
    not_before: String,
    /// ECS实例ID列表信息。可输入最多100个实例ID。
    instance_id: Vec<String>,
}

impl sealed::Bound for CreateSimulatedSystemEvents {}

impl CreateSimulatedSystemEvents {
    pub fn new(
        region_id: impl Into<String>,
        event_type: impl Into<String>,
        not_before: impl Into<String>,
        instance_id: impl Into<Vec<String>>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            event_type: event_type.into(),
            not_before: not_before.into(),
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for CreateSimulatedSystemEvents {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateSimulatedSystemEvents {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateSimulatedSystemEvents";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateSimulatedSystemEventsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("EventType".into(), (&self.event_type).into()));
        crate::FlatSerialize::flat_serialize(&self.instance_id, "InstanceId", &mut params);

        params.push(("NotBefore".into(), (&self.not_before).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CancelSimulatedSystemEvents {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 系统事件ID列表。可输入最多100个事件ID。
    event_id: Vec<String>,
}

impl sealed::Bound for CancelSimulatedSystemEvents {}

impl CancelSimulatedSystemEvents {
    pub fn new(region_id: impl Into<String>, event_id: impl Into<Vec<String>>) -> Self {
        Self {
            region_id: region_id.into(),
            event_id: event_id.into(),
        }
    }
}
impl crate::ToFormData for CancelSimulatedSystemEvents {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CancelSimulatedSystemEvents {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CancelSimulatedSystemEvents";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CancelSimulatedSystemEventsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        crate::FlatSerialize::flat_serialize(&self.event_id, "EventId", &mut params);

        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AcceptInquiredSystemEvent {
    /// 系统事件所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 系统事件ID。
    event_id: String,
    /// >该参数正在邀测中，暂不支持使用。
    #[setters(generate = true, strip_option)]
    choice: Option<String>,
}

impl sealed::Bound for AcceptInquiredSystemEvent {}

impl AcceptInquiredSystemEvent {
    pub fn new(region_id: impl Into<String>, event_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            event_id: event_id.into(),
            choice: None,
        }
    }
}
impl crate::ToFormData for AcceptInquiredSystemEvent {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AcceptInquiredSystemEvent {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AcceptInquiredSystemEvent";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AcceptInquiredSystemEventResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.choice {
            params.push(("Choice".into(), (f).into()));
        }
        params.push(("EventId".into(), (&self.event_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDiagnosticMetrics {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 诊断指标列表。
    #[setters(generate = true, strip_option)]
    metric_ids: Option<Vec<String>>,
    /// 支持的资源类型。
    #[setters(generate = true, strip_option)]
    resource_type: Option<MetricsResourceType>,
    /// 查询凭证（Token）。取值为上一次调用接口返回的`NextToken`参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。最大值为100。
    ///
    /// 默认值：
    ///
    /// - 当不设置值时，默认值为10。
    /// - 当设置的值大于100时，默认值为100。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
}

impl sealed::Bound for DescribeDiagnosticMetrics {}

impl DescribeDiagnosticMetrics {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            metric_ids: None,
            resource_type: None,
            next_token: None,
            max_results: None,
        }
    }
}
impl crate::ToFormData for DescribeDiagnosticMetrics {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDiagnosticMetrics {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDiagnosticMetrics";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDiagnosticMetricsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.metric_ids {
            crate::FlatSerialize::flat_serialize(f, "MetricIds", &mut params);
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_type {
            params.push(("ResourceType".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateDiagnosticMetricSet {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 诊断资源类型。
    ///
    /// 默认值：instance。
    resource_type: CreateDiagnosticMetricSetResourceType,
    /// 诊断指标集合的名称。
    #[setters(generate = true, strip_option)]
    metric_set_name: Option<String>,
    /// 诊断指标列表。最多支持100个。
    metric_ids: Vec<String>,
    /// 诊断指标集合的描述信息。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for CreateDiagnosticMetricSet {}

impl CreateDiagnosticMetricSet {
    pub fn new(
        region_id: impl Into<String>,
        resource_type: impl Into<CreateDiagnosticMetricSetResourceType>,
        metric_ids: impl Into<Vec<String>>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            resource_type: resource_type.into(),
            metric_set_name: None,
            metric_ids: metric_ids.into(),
            description: None,
        }
    }
}
impl crate::ToFormData for CreateDiagnosticMetricSet {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateDiagnosticMetricSet {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateDiagnosticMetricSet";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateDiagnosticMetricSetResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        crate::FlatSerialize::flat_serialize(&self.metric_ids, "MetricIds", &mut params);

        if let Some(f) = &self.metric_set_name {
            params.push(("MetricSetName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("ResourceType".into(), (&self.resource_type).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDiagnosticMetricSets {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 诊断项集合列表。
    #[setters(generate = true, strip_option)]
    metric_set_ids: Option<Vec<String>>,
    /// 诊断项集合类型。取值范围：
    ///
    /// - User：用户。
    /// - Common：公共。
    ///
    /// 默认值：User。
    #[setters(generate = true, strip_option, rename = "r#type")]
    r#type: Option<SetsType>,
    /// 资源类型。
    #[setters(generate = true, strip_option)]
    resource_type: Option<SetsResourceType>,
    /// 查询凭证（Token）。取值为上一次调用接口返回的`NextToken`参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。最大值为100。
    ///
    /// 默认值：
    ///
    /// - 当不设置值时，默认值为10。
    /// - 当设置的值大于100时，默认值为100。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
}

impl sealed::Bound for DescribeDiagnosticMetricSets {}

impl DescribeDiagnosticMetricSets {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            metric_set_ids: None,
            r#type: None,
            resource_type: None,
            next_token: None,
            max_results: None,
        }
    }
}
impl crate::ToFormData for DescribeDiagnosticMetricSets {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDiagnosticMetricSets {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDiagnosticMetricSets";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDiagnosticMetricSetsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.metric_set_ids {
            crate::FlatSerialize::flat_serialize(f, "MetricSetIds", &mut params);
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_type {
            params.push(("ResourceType".into(), (f).into()));
        }

        if let Some(f) = &self.r#type {
            params.push(("Type".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDiagnosticMetricSet {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 诊断指标集合ID。
    metric_set_id: String,
    /// 诊断指标列表。
    #[setters(generate = true, strip_option)]
    metric_ids: Option<Vec<String>>,
    /// 资源类型。
    #[setters(generate = true, strip_option)]
    resource_type: Option<ModifyDiagnosticMetricSetResourceType>,
    /// 诊断指标集合的名称。
    #[setters(generate = true, strip_option)]
    metric_set_name: Option<String>,
    /// 诊断指标集合的描述信息。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for ModifyDiagnosticMetricSet {}

impl ModifyDiagnosticMetricSet {
    pub fn new(region_id: impl Into<String>, metric_set_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            metric_set_id: metric_set_id.into(),
            metric_ids: None,
            resource_type: None,
            metric_set_name: None,
            description: None,
        }
    }
}
impl crate::ToFormData for ModifyDiagnosticMetricSet {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDiagnosticMetricSet {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDiagnosticMetricSet";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDiagnosticMetricSetResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.metric_ids {
            crate::FlatSerialize::flat_serialize(f, "MetricIds", &mut params);
        }
        params.push(("MetricSetId".into(), (&self.metric_set_id).into()));

        if let Some(f) = &self.metric_set_name {
            params.push(("MetricSetName".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_type {
            params.push(("ResourceType".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteDiagnosticMetricSets {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 诊断指标集合ID列表。最多支持10个。
    ///
    metric_set_ids: Vec<String>,
}

impl sealed::Bound for DeleteDiagnosticMetricSets {}

impl DeleteDiagnosticMetricSets {
    pub fn new(region_id: impl Into<String>, metric_set_ids: impl Into<Vec<String>>) -> Self {
        Self {
            region_id: region_id.into(),
            metric_set_ids: metric_set_ids.into(),
        }
    }
}
impl crate::ToFormData for DeleteDiagnosticMetricSets {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteDiagnosticMetricSets {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteDiagnosticMetricSets";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteDiagnosticMetricSetsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        crate::FlatSerialize::flat_serialize(&self.metric_set_ids, "MetricSetIds", &mut params);

        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateDiagnosticReport {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 资源ID。
    resource_id: String,
    /// 诊断指标集合ID。如果为空，则会使用ECS实例的默认诊断指标集合dms-instancedefault。
    #[setters(generate = true, strip_option)]
    metric_set_id: Option<String>,
    /// 开始时间。只对无需在GuestOS内执行云助手指令的诊断指标生效。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
    /// 结束时间。只对无需在GuestOS内执行云助手指令的诊断指标生效。
    #[setters(generate = true, strip_option)]
    end_time: Option<String>,
}

impl sealed::Bound for CreateDiagnosticReport {}

impl CreateDiagnosticReport {
    pub fn new(region_id: impl Into<String>, resource_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            resource_id: resource_id.into(),
            metric_set_id: None,
            start_time: None,
            end_time: None,
        }
    }
}
impl crate::ToFormData for CreateDiagnosticReport {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateDiagnosticReport {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateDiagnosticReport";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateDiagnosticReportResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.end_time {
            params.push(("EndTime".into(), (f).into()));
        }

        if let Some(f) = &self.metric_set_id {
            params.push(("MetricSetId".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("ResourceId".into(), (&self.resource_id).into()));

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDiagnosticReports {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 诊断报告ID列表。
    #[setters(generate = true, strip_option)]
    report_ids: Option<Vec<String>>,
    /// 资源ID列表。最多支持100个ID。
    #[setters(generate = true, strip_option)]
    resource_ids: Option<Vec<String>>,
    /// 报告状态。取值范围：
    ///
    /// - InProgress：诊断中。
    /// - Failed：诊断失败。
    /// - Finished：诊断完成。
    #[setters(generate = true, strip_option)]
    status: Option<ReportsStatus>,
    /// 严重等级。取值范围：
    ///
    /// - Unknown：初始状态，表示未开始诊断或者诊断过程程序异常退出，无诊断结论。
    /// - Normal：诊断正常，没有发现问题。
    /// - Info：有关联信息，可能与异常相关。
    /// - Warn：有关联信息，可能导致异常。
    /// - Critical：有关键异常。
    #[setters(generate = true, strip_option)]
    severity: Option<ReportsSeverity>,
    /// 查询凭证（Token）。取值为上一次调用接口返回的`NextToken`参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页行数。最大值为100。
    ///
    /// 默认值：
    ///
    /// - 当不设置值时，默认值为10。
    /// - 当设置的值大于100时，默认值为100。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
}

impl sealed::Bound for DescribeDiagnosticReports {}

impl DescribeDiagnosticReports {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            report_ids: None,
            resource_ids: None,
            status: None,
            severity: None,
            next_token: None,
            max_results: None,
        }
    }
}
impl crate::ToFormData for DescribeDiagnosticReports {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDiagnosticReports {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDiagnosticReports";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDiagnosticReportsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.report_ids {
            crate::FlatSerialize::flat_serialize(f, "ReportIds", &mut params);
        }

        if let Some(f) = &self.resource_ids {
            crate::FlatSerialize::flat_serialize(f, "ResourceIds", &mut params);
        }

        if let Some(f) = &self.severity {
            params.push(("Severity".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDiagnosticReportAttributes {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 诊断报告ID。
    report_id: String,
}

impl sealed::Bound for DescribeDiagnosticReportAttributes {}

impl DescribeDiagnosticReportAttributes {
    pub fn new(region_id: impl Into<String>, report_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            report_id: report_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeDiagnosticReportAttributes {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDiagnosticReportAttributes {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDiagnosticReportAttributes";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDiagnosticReportAttributesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("ReportId".into(), (&self.report_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteDiagnosticReports {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 诊断报告ID列表。最多支持100个ID。
    report_ids: Vec<String>,
}

impl sealed::Bound for DeleteDiagnosticReports {}

impl DeleteDiagnosticReports {
    pub fn new(region_id: impl Into<String>, report_ids: impl Into<Vec<String>>) -> Self {
        Self {
            region_id: region_id.into(),
            report_ids: report_ids.into(),
        }
    }
}
impl crate::ToFormData for DeleteDiagnosticReports {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteDiagnosticReports {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteDiagnosticReports";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteDiagnosticReportsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        crate::FlatSerialize::flat_serialize(&self.report_ids, "ReportIds", &mut params);

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct GetInstanceScreenshot {
    /// 实例所在地域ID。您可以调用 [DescribeRegions](~~25609~~) 查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID。
    instance_id: String,
    /// 是否唤醒处于休眠状态的实例。
    ///
    /// 默认值：false
    #[setters(generate = true, strip_option)]
    wake_up: Option<bool>,
}

impl sealed::Bound for GetInstanceScreenshot {}

impl GetInstanceScreenshot {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
            wake_up: None,
        }
    }
}
impl crate::ToFormData for GetInstanceScreenshot {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for GetInstanceScreenshot {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "GetInstanceScreenshot";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<GetInstanceScreenshotResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.wake_up {
            params.push(("WakeUp".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct GetInstanceConsoleOutput {
    /// 实例所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 实例ID。
    instance_id: String,
    /// 是否去除返回文本中的排版符号。取值范围：
    /// - true：去除
    /// - false：不去除
    ///
    /// 默认值：false
    #[setters(generate = true, strip_option)]
    remove_symbols: Option<bool>,
}

impl sealed::Bound for GetInstanceConsoleOutput {}

impl GetInstanceConsoleOutput {
    pub fn new(region_id: impl Into<String>, instance_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            instance_id: instance_id.into(),
            remove_symbols: None,
        }
    }
}
impl crate::ToFormData for GetInstanceConsoleOutput {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for GetInstanceConsoleOutput {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "GetInstanceConsoleOutput";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<GetInstanceConsoleOutputResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.remove_symbols {
            params.push(("RemoveSymbols".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDiskMonitorData {
    /// 待查询的云盘ID。
    disk_id: String,
    /// 数据的起始时间。按照[ISO 8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。如果秒（ss）不是00，则自动取为下一分钟开始时。
    ///
    /// > 一次最多能查询近30天内的监控信息，即参数`StartTime`距今不能超过30天。
    start_time: String,
    /// 数据的结束时间。按照[ISO 8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。如果秒（ss）不是00，则自动取为下一分钟开始时。
    end_time: String,
    /// 数据的精度，单位为秒。取值范围：
    ///
    /// - 60。
    /// - 600。
    /// - 3600。
    ///
    /// 默认值：60。
    ///
    /// > （EndTime–StartTime）/Period必须小于等于400，即一次最多返回400个周期的数据。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
}

impl sealed::Bound for DescribeDiskMonitorData {}

impl DescribeDiskMonitorData {
    pub fn new(
        disk_id: impl Into<String>,
        start_time: impl Into<String>,
        end_time: impl Into<String>,
    ) -> Self {
        Self {
            disk_id: disk_id.into(),
            start_time: start_time.into(),
            end_time: end_time.into(),
            period: None,
        }
    }
}
impl crate::ToFormData for DescribeDiskMonitorData {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDiskMonitorData {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDiskMonitorData";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDiskMonitorDataResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("DiskId".into(), (&self.disk_id).into()));
        params.push(("EndTime".into(), (&self.end_time).into()));

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }
        params.push(("StartTime".into(), (&self.start_time).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceMonitorData {
    /// 待查询的实例ID。
    instance_id: String,
    /// 获取数据的起始时间点。按照[ISO 8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。如果指定的秒（`ss`）不是`00`，则自动换算为下一分钟。
    start_time: String,
    /// 获取数据的结束时间点。按照[ISO 8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。如果指定的秒（`ss`）不是`00`，则自动换算为下一分钟。
    end_time: String,
    /// 获取监控数据的间隔时间，单位：秒。取值范围：
    ///
    /// - 60。
    /// - 600。
    /// - 3600。
    ///
    /// 默认值：60。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
}

impl sealed::Bound for DescribeInstanceMonitorData {}

impl DescribeInstanceMonitorData {
    pub fn new(
        instance_id: impl Into<String>,
        start_time: impl Into<String>,
        end_time: impl Into<String>,
    ) -> Self {
        Self {
            instance_id: instance_id.into(),
            start_time: start_time.into(),
            end_time: end_time.into(),
            period: None,
        }
    }
}
impl crate::ToFormData for DescribeInstanceMonitorData {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceMonitorData {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceMonitorData";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceMonitorDataResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("EndTime".into(), (&self.end_time).into()));
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }
        params.push(("StartTime".into(), (&self.start_time).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeEniMonitorData {
    /// 辅助网卡的ID。默认查询指定实例上所有已绑定的辅助网卡。
    #[setters(generate = true, strip_option)]
    eni_id: Option<String>,
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 辅助网卡绑定的实例ID。
    instance_id: String,
    /// 获取数据的起始时间点。按照[ISO 8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。如果指定的秒（ss）不是00，则自动换算为下一分钟。
    start_time: String,
    /// 获取数据的结束时间点。按照[ISO 8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。如果指定的秒（ss）不是00，则自动换算为下一分钟。
    end_time: String,
    /// 获取监控数据的间隔时间，单位：秒。取值范围：
    /// - 60。
    /// - 600。
    /// - 3600。
    ///
    /// 默认值：60。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
}

impl sealed::Bound for DescribeEniMonitorData {}

impl DescribeEniMonitorData {
    pub fn new(
        region_id: impl Into<String>,
        instance_id: impl Into<String>,
        start_time: impl Into<String>,
        end_time: impl Into<String>,
    ) -> Self {
        Self {
            eni_id: None,
            region_id: region_id.into(),
            instance_id: instance_id.into(),
            start_time: start_time.into(),
            end_time: end_time.into(),
            period: None,
        }
    }
}
impl crate::ToFormData for DescribeEniMonitorData {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeEniMonitorData {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeEniMonitorData";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeEniMonitorDataResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);
        params.push(("EndTime".into(), (&self.end_time).into()));

        if let Some(f) = &self.eni_id {
            params.push(("EniId".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("StartTime".into(), (&self.start_time).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeSnapshotMonitorData {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 获取快照容量变化数据的起始时间点。按照[ISO 8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。如果指定的秒（ss）不是 00，则自动换算为下一分钟。
    start_time: String,
    /// 获取快照容量变化数据的结束时间点。按照[ISO 8601](~~25696~~)标准表示，并使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。如果指定的秒（ss）不是 00，则自动换算为下一分钟。
    end_time: String,
    /// 获取快照容量变化数据的间隔时间，单位为秒。取值范围：
    ///
    /// - 60
    /// - 600
    /// - 3600
    ///
    /// 默认值：60。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 快照类型。取值范围：
    ///
    /// - Standard：标准快照。
    /// - Flash：本地快照。
    /// - Archive：归档快照。
    ///
    /// 默认值：Standard。
    #[setters(generate = true, strip_option)]
    category: Option<String>,
}

impl sealed::Bound for DescribeSnapshotMonitorData {}

impl DescribeSnapshotMonitorData {
    pub fn new(
        region_id: impl Into<String>,
        start_time: impl Into<String>,
        end_time: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            start_time: start_time.into(),
            end_time: end_time.into(),
            period: None,
            category: None,
        }
    }
}
impl crate::ToFormData for DescribeSnapshotMonitorData {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeSnapshotMonitorData {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeSnapshotMonitorData";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeSnapshotMonitorDataResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.category {
            params.push(("Category".into(), (f).into()));
        }
        params.push(("EndTime".into(), (&self.end_time).into()));

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("StartTime".into(), (&self.start_time).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeInstanceMaintenanceAttributes {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 维护属性列表的页码。
    ///
    /// 起始值：1
    ///
    /// 默认值：1
    #[setters(generate = true, strip_option)]
    page_number: Option<i64>,
    /// 单页返回的条数。取值范围：1~100
    ///
    /// 默认值：10
    #[setters(generate = true, strip_option)]
    page_size: Option<i64>,
    /// 实例ID列表。可输入最多100个实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<Vec<String>>,
}

impl sealed::Bound for DescribeInstanceMaintenanceAttributes {}

impl DescribeInstanceMaintenanceAttributes {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
            instance_id: None,
        }
    }
}
impl crate::ToFormData for DescribeInstanceMaintenanceAttributes {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeInstanceMaintenanceAttributes {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeInstanceMaintenanceAttributes";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeInstanceMaintenanceAttributesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.instance_id {
            crate::FlatSerialize::flat_serialize(f, "InstanceId", &mut params);
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyInstanceMaintenanceAttributes {
    /// 实例所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 维护动作。取值范围：
    ///
    /// - Stop：停止状态（即宕机）。
    /// - AutoRecover：自动恢复。
    /// - AutoRedeploy：宕机迁移，数据盘有损。
    #[setters(generate = true, strip_option)]
    action_on_maintenance: Option<String>,
    /// 实例宕机运维前是否发送事件通知。取值范围：
    ///
    /// - true：发送事件通知。
    /// - false：不发送事件通知。
    ///
    /// 默认值：false
    #[setters(generate = true, strip_option)]
    notify_on_maintenance: Option<bool>,
    /// 实例ID。N的取值范围为：1~100。
    #[setters(generate = true, strip_option)]
    instance_id: Option<Vec<String>>,
    /// 维护时间窗口列表。
    #[setters(generate = true, strip_option)]
    maintenance_window: Option<Vec<AttributesMaintenanceWindow>>,
}

impl sealed::Bound for ModifyInstanceMaintenanceAttributes {}

impl ModifyInstanceMaintenanceAttributes {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            action_on_maintenance: None,
            notify_on_maintenance: None,
            instance_id: None,
            maintenance_window: None,
        }
    }
}
impl crate::ToFormData for ModifyInstanceMaintenanceAttributes {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyInstanceMaintenanceAttributes {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyInstanceMaintenanceAttributes";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyInstanceMaintenanceAttributesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.action_on_maintenance {
            params.push(("ActionOnMaintenance".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            crate::FlatSerialize::flat_serialize(f, "InstanceId", &mut params);
        }

        if let Some(f) = &self.maintenance_window {
            crate::FlatSerialize::flat_serialize(f, "MaintenanceWindow", &mut params);
        }

        if let Some(f) = &self.notify_on_maintenance {
            params.push(("NotifyOnMaintenance".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RedeployInstance {
    /// 处于运行中或者已停止状态的实例ID。
    instance_id: String,
    /// 是否强制停止运行中（Running）的实例。
    ///
    /// 默认值：false。
    ///
    /// > 强制停止等同于典型的服务器断电关机，实例操作系统中暂未写入存储设备的数据会丢失。建议您尽量对已停止实例做重新部署操作。
    #[setters(generate = true, strip_option)]
    force_stop: Option<bool>,
}

impl sealed::Bound for RedeployInstance {}

impl RedeployInstance {
    pub fn new(instance_id: impl Into<String>) -> Self {
        Self {
            instance_id: instance_id.into(),
            force_stop: None,
        }
    }
}
impl crate::ToFormData for RedeployInstance {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RedeployInstance {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RedeployInstance";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RedeployInstanceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);

        if let Some(f) = &self.force_stop {
            params.push(("ForceStop".into(), (f).into()));
        }
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ReportInstancesStatus {
    /// 实例所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 异常问题对ECS实例造成的影响。取值范围：
    ///
    /// - instance-hang：ECS实例不可用，或无法连接。
    /// - instance-stuck-in-status：ECS实例长时间停留在某一个状态，如Starting或Stopping状态。
    /// - abnormal-network：ECS实例发生网络异常。
    /// - abnormal-local-disk：ECS实例挂载的本地盘出现异常。
    /// - abnormal-cloud-disk：ECS实例挂载的云盘或共享块存储出现异常。
    /// - others：其他异常类型。当以上影响类型不符合条件时，您可以设置`Reason=others`并在`Description`中描述更多信息。
    #[setters(generate = true, strip_option)]
    reason: Option<String>,
    /// 异常问题的详细描述。
    description: String,
    /// 实例异常问题开始时间。按照ISO8601标准表示，并需要使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
    /// 实例异常问题结束时间。按照ISO8601标准表示，并需要使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    end_time: Option<String>,
    /// 异常问题的类别。该参数仅适用于弹性裸金属服务器实例。取值范围：
    /// - hardware-cpu-error：CPU故障
    /// - hardware-motherboard-error：主板故障
    /// - hardware-mem-error：内存故障
    /// - hardware-power-error：电源故障
    /// - hardware-disk-error：磁盘故障
    /// - hardware-networkcard-error：网卡故障
    /// - hardware-raidcard-error：SAS/RAID卡故障
    /// - hardware-fan-error：风扇故障
    /// - others：其他
    #[setters(generate = true, strip_option)]
    issue_category: Option<String>,
    /// ECS实例ID列表。最多可输入100个实例ID。
    instance_id: Vec<String>,
    /// 发生相同异常问题的磁盘ID列表。可输入最多100个磁盘ID。如果您使用的是弹性裸金属服务器实例，请填写磁盘设备对应的SN列表。
    ///
    /// > 当参数`Reason`值为`abnormal-local-disk`或`abnormal-cloud-disk`，或者参数`IssueCategory`值为`hardware-disk-error`时，该参数为必填参数。
    #[setters(generate = true, strip_option)]
    disk_id: Option<Vec<String>>,
    /// 发生相同异常问题的磁盘的挂载的设备名列表。可输入最多100个设备名。
    ///
    /// 如果您使用的是弹性裸金属服务器实例，请填写磁盘设备对应SLOT槽位信息列表。
    ///
    /// > 对于弹性裸金属服务器实例，当参数`Reason`值为`abnormal-local-disk`或`abnormal-cloud-disk`，或者参数`IssueCategory`值为`hardware-disk-error`时，该参数为必填参数。
    #[setters(generate = true, strip_option)]
    device: Option<Vec<String>>,
}

impl sealed::Bound for ReportInstancesStatus {}

impl ReportInstancesStatus {
    pub fn new(
        region_id: impl Into<String>,
        description: impl Into<String>,
        instance_id: impl Into<Vec<String>>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            reason: None,
            description: description.into(),
            start_time: None,
            end_time: None,
            issue_category: None,
            instance_id: instance_id.into(),
            disk_id: None,
            device: None,
        }
    }
}
impl crate::ToFormData for ReportInstancesStatus {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ReportInstancesStatus {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ReportInstancesStatus";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ReportInstancesStatusResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);
        params.push(("Description".into(), (&self.description).into()));

        if let Some(f) = &self.device {
            crate::FlatSerialize::flat_serialize(f, "Device", &mut params);
        }

        if let Some(f) = &self.disk_id {
            crate::FlatSerialize::flat_serialize(f, "DiskId", &mut params);
        }

        if let Some(f) = &self.end_time {
            params.push(("EndTime".into(), (f).into()));
        }
        crate::FlatSerialize::flat_serialize(&self.instance_id, "InstanceId", &mut params);

        if let Some(f) = &self.issue_category {
            params.push(("IssueCategory".into(), (f).into()));
        }

        if let Some(f) = &self.reason {
            params.push(("Reason".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct TagResources {
    /// 资源所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 资源类型定义。取值范围：
    ///
    /// - instance：ECS实例。
    /// - disk：磁盘。
    /// - snapshot：快照。
    /// - image：镜像。
    /// - securitygroup：安全组。
    /// - volume：存储卷。
    /// - eni：弹性网卡。
    /// - ddh：专有宿主机。
    /// - ddhcluster：专有宿主机集群。
    /// - keypair：SSH密钥对。
    /// - launchtemplate：启动模板。
    /// - reservedinstance：预留实例券。
    /// - snapshotpolicy：自动快照策略。
    /// - elasticityassurance：弹性保障。
    /// - capacityreservation：容量预定。
    /// - command：云助手命令。
    /// - invocation：云助手命令执行或文件下发结果。
    /// - activation：云助手托管实例激活码。
    /// - managedinstance：云助手托管实例。
    resource_type: String,
    /// 资源ID数组。数组长度：1~50。
    resource_id: Vec<String>,
    /// 标签数组。数组长度：1~20。如果数组中有多个标签对象，标签键`Key`不允许重复。
    tag: Vec<TagResourcesTag>,
}

impl sealed::Bound for TagResources {}

impl TagResources {
    pub fn new(
        region_id: impl Into<String>,
        resource_type: impl Into<String>,
        resource_id: impl Into<Vec<String>>,
        tag: impl Into<Vec<TagResourcesTag>>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            resource_type: resource_type.into(),
            resource_id: resource_id.into(),
            tag: tag.into(),
        }
    }
}
impl crate::ToFormData for TagResources {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for TagResources {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "TagResources";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<TagResourcesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("RegionId".into(), (&self.region_id).into()));
        crate::FlatSerialize::flat_serialize(&self.resource_id, "ResourceId", &mut params);

        params.push(("ResourceType".into(), (&self.resource_type).into()));
        crate::FlatSerialize::flat_serialize(&self.tag, "Tag", &mut params);

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ListTagResources {
    /// 资源所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 下一个查询开始Token。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 资源类型定义。取值范围：
    ///
    /// - instance：ECS实例。
    /// - disk：磁盘。
    /// - snapshot：快照。
    /// - image：镜像。
    /// - securitygroup：安全组。
    /// - volume：存储卷。
    /// - eni：弹性网卡。
    /// - ddh：专有宿主机。
    /// - ddhcluster：专有宿主机集群。
    /// - keypair：SSH密钥对。
    /// - launchtemplate：启动模板。
    /// - reservedinstance：预留实例券。
    /// - snapshotpolicy：自动快照策略。
    /// - elasticityassurance：弹性保障。
    /// - capacityreservation：容量预定。
    /// - command：云助手命令。
    /// - invocation：云助手命令执行或文件下发结果。
    /// - activation：云助手托管实例激活码。
    /// - managedinstance：云助手托管实例。
    resource_type: String,
    /// ECS资源ID。N的取值范围为1~50。
    #[setters(generate = true, strip_option)]
    resource_id: Option<Vec<String>>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ListTagResourcesTag>>,
    /// Tag过滤规则。
    #[setters(generate = true, strip_option)]
    tag_filter: Option<Vec<TagFilter>>,
}

impl sealed::Bound for ListTagResources {}

impl ListTagResources {
    pub fn new(region_id: impl Into<String>, resource_type: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            next_token: None,
            resource_type: resource_type.into(),
            resource_id: None,
            tag: None,
            tag_filter: None,
        }
    }
}
impl crate::ToFormData for ListTagResources {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ListTagResources {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ListTagResources";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ListTagResourcesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_id {
            crate::FlatSerialize::flat_serialize(f, "ResourceId", &mut params);
        }
        params.push(("ResourceType".into(), (&self.resource_type).into()));

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.tag_filter {
            crate::FlatSerialize::flat_serialize(f, "TagFilter", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct UntagResources {
    /// 资源所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 资源类型定义。取值范围：
    ///
    /// - instance：ECS实例。
    /// - disk：磁盘。
    /// - snapshot：快照。
    /// - image：镜像。
    /// - securitygroup：安全组。
    /// - volume：存储卷。
    /// - eni：弹性网卡。
    /// - ddh：专有宿主机。
    /// - ddhcluster：专有宿主机集群。
    /// - keypair：SSH密钥对。
    /// - launchtemplate：启动模板。
    /// - reservedinstance：预留实例券。
    /// - snapshotpolicy：自动快照策略。
    /// - elasticityassurance：弹性保障。
    /// - capacityreservation：容量预定。
    /// - command：云助手命令。
    /// - invocation：云助手命令执行结果。
    resource_type: String,
    /// 是否解绑资源上全部的标签。当请求中未设置TagKey.N时，该参数才有效。取值范围：
    /// - true
    /// - false
    ///
    /// 默认值：false
    #[setters(generate = true, strip_option)]
    all: Option<bool>,
    /// 资源ID列表。可输入最多50个资源ID。
    resource_id: Vec<String>,
    /// 资源的标签键列表。可输入最多20个标签键。
    #[setters(generate = true, strip_option)]
    tag_key: Option<Vec<String>>,
}

impl sealed::Bound for UntagResources {}

impl UntagResources {
    pub fn new(
        region_id: impl Into<String>,
        resource_type: impl Into<String>,
        resource_id: impl Into<Vec<String>>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            resource_type: resource_type.into(),
            all: None,
            resource_id: resource_id.into(),
            tag_key: None,
        }
    }
}
impl crate::ToFormData for UntagResources {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for UntagResources {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "UntagResources";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<UntagResourcesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.all {
            params.push(("All".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        crate::FlatSerialize::flat_serialize(&self.resource_id, "ResourceId", &mut params);

        params.push(("ResourceType".into(), (&self.resource_type).into()));

        if let Some(f) = &self.tag_key {
            crate::FlatSerialize::flat_serialize(f, "TagKey", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct JoinResourceGroup {
    /// ECS资源的类型。取值范围：
    ///
    /// - instance：实例。
    /// - disk：块存储。
    /// - snapshot：快照。
    /// - image：镜像。
    /// - securitygroup：安全组。
    /// - ddh：专有宿主机。
    /// - ddhcluster：专有宿主机集群。
    /// - eni：弹性网卡。
    /// - keypair：密钥对。
    /// - launchtemplate：启动模板。
    /// - command：云助手命令。
    /// - activation：云助手托管实例激活码。
    /// - managedinstance：云助手托管实例。
    ///
    /// 以上参数取值均大小写敏感。
    #[setters(generate = true, strip_option)]
    resource_type: Option<String>,
    /// 资源类型的ID标识符。例如，当ResourceType=instance时，则ResourceId可以理解为InstanceId。
    #[setters(generate = true, strip_option)]
    resource_id: Option<String>,
    /// 资源所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    /// 目标资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
}

impl sealed::Bound for JoinResourceGroup {}

impl JoinResourceGroup {
    pub fn new() -> Self {
        Self {
            resource_type: None,
            resource_id: None,
            region_id: None,
            resource_group_id: None,
        }
    }
}
impl crate::ToFormData for JoinResourceGroup {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for JoinResourceGroup {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "JoinResourceGroup";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<JoinResourceGroupResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.resource_id {
            params.push(("ResourceId".into(), (f).into()));
        }

        if let Some(f) = &self.resource_type {
            params.push(("ResourceType".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AllocateDedicatedHosts {
    /// 专有宿主机所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<AllocateDedicatedHostsTag>>,
    /// 专有宿主机要加入的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 专有宿主机所属的可用区编号。
    ///
    /// 默认值：空，表示由系统选择。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 专有宿主机的名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    dedicated_host_name: Option<String>,
    /// 专有宿主机所属的专有宿主机集群ID。
    #[setters(generate = true, strip_option)]
    dedicated_host_cluster_id: Option<String>,
    /// 专有宿主机的规格。您可以调用[DescribeDedicatedHostTypes](~~134240~~)接口获得最新的专有宿主机规格表。
    dedicated_host_type: String,
    /// 当专有宿主机发生故障或者在线修复时，为其所宿实例设置迁移方案。取值范围：
    ///
    /// - Migrate：迁移实例到其他物理机并重新启动实例。
    ///
    ///   当专有宿主机上挂载云盘存储时，默认值：Migrate。
    ///
    /// - Stop：在当前专有宿主机上停止实例，确认无法修复专有宿主机后，迁移实例到其他物理机并重新启动实例。
    ///
    ///   当专有宿主机上挂载本地盘存储时，默认值：Stop。
    #[setters(generate = true, strip_option)]
    action_on_maintenance: Option<String>,
    /// 负载均衡连接的UDP会话超时时间，单位：秒。取值范围：15~310。
    #[setters(generate = true, strip_option)]
    network_attributes_slb_udp_timeout: Option<i32>,
    /// 为专有宿主机上运行的云服务设置用户访问的UDP会话超时时间，单位：秒。取值范围：15~310。
    #[setters(generate = true, strip_option)]
    network_attributes_udp_timeout: Option<i32>,
    /// 专有宿主机的描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 专有宿主机是否加入自动部署资源池。当您在专有宿主机上创建实例，却不指定**DedicatedHostId**时，阿里云将自动从加入资源池的专有宿主机中，为您选取适合的宿主机部署实例，更多信息，请参见[自动部署功能介绍](~~118938~~)。取值范围：
    ///
    /// - on：加入自动部署资源池。
    ///
    /// - off：不加入自动部署资源池。
    ///
    /// 默认值：on。
    ///
    /// > 若您不希望专有宿主机加入自动部署资源池，请将该参数设置为off。
    #[setters(generate = true, strip_option)]
    auto_placement: Option<String>,
    /// CPU超卖比。仅自定义规格g6s、c6s、r6s支持设置CPU超卖比。取值范围：1~5。
    ///
    /// CPU超卖比影响DDH的可用vCPU数，一台DDH的可用vCPU数=物理CPU核数\*2\*CPU超卖比。例如，g6s的物理CPU核数为52，如果设置CPU超卖比为4，则DDH创建完成后vCPU总数显示为416。针对CPU绝对稳定性要求不严苛或CPU负载不高的场景，例如开发测试环境，提升超卖比可以提升可用vCPU数，用于部署更多同等规格的ECS实例，降低单位部署成本。
    #[setters(generate = true, strip_option)]
    cpu_over_commit_ratio: Option<f32>,
    /// 指定专有宿主机的最小购买数量。取值范围：1~100。
    ///
    /// > 当专有宿主机的库存小于最小购买数量时，创建专有宿主机将会失败。
    #[setters(generate = true, strip_option)]
    min_quantity: Option<i32>,
    /// 专有宿主机的计费方式。取值范围：
    ///
    /// <props="china">
    /// - PrePaid：包年包月。选择包年包月时，请确认您的支付方式支持余额或者信用额度支付，否则会提示`InvalidPayMethod`。
    ///
    /// - PostPaid：按量付费。
    ///
    /// </props>
    ///
    ///
    /// <props="intl">
    /// - PrePaid：包年包月。选择包年包月时，请确认您的支付方式支持信用额度支付，否则会提示`InvalidPayMethod`。
    ///
    /// - PostPaid：按量付费。
    ///
    /// </props>
    ///
    /// 默认值：PostPaid。
    #[setters(generate = true, strip_option)]
    charge_type: Option<String>,
    /// 本次创建的专有宿主机的数量。取值范围：1~100。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    quantity: Option<i32>,
    /// 购买专有宿主机的包年包月时长。当参数`ChargeType`取值为`PrePaid`时，`Period`参数方可生效并为必选参数。取值范围：
    ///
    /// <props="china">
    /// - PeriodUnit=Week时：1、2、3、4。
    /// - PeriodUnit=Month时：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
    /// - PeriodUnit=Year时：1、2、3、4、5。
    ///
    /// </props>
    ///
    /// <props="intl">
    /// - PeriodUnit=Month时：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
    /// - PeriodUnit=Year时：1、2、3、4、5。
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 购买专有宿主机的时长单位。取值范围：
    ///
    /// <props="china">
    /// - Week
    /// - Month
    /// - Year
    ///
    /// </props>
    ///
    /// <props="intl">
    /// - Month
    /// - Year
    ///
    /// </props>
    ///
    /// 默认值：Month。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 是否自动续费包年包月专有宿主机。
    /// >当参数**ChargeType**取值PrePaid时，**AutoRenew**参数方可生效。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    auto_renew: Option<bool>,
    /// 单次自动续费的周期。当参数**AutoRenew**为true时，**AutoRenewPeriod**参数方可生效，并为必选参数。取值范围：
    ///
    /// <props="china">
    /// - PeriodUnit=Week时：1、2、3。
    /// - PeriodUnit=Month时：1、2、3、6、12、24、36、48、60。
    ///
    /// </props>
    ///
    /// <props="intl">PeriodUnit=Month时：1、2、3、6、12。</props>
    #[setters(generate = true, strip_option)]
    auto_renew_period: Option<i32>,
    /// 专有宿主机自动释放时间。需按照ISO 8601标准表示，并使用UTC+0时间，格式为`yyyy-MM-ddTHH:mm:ssZ`。
    ///
    /// > - 最短设置为当前时间之后半小时。
    /// > - 最长不能超过当前时间之后三年。
    /// > - 若参数值中的秒（ss）不是00，则自动取为00。
    #[setters(generate = true, strip_option)]
    auto_release_time: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for AllocateDedicatedHosts {}

impl AllocateDedicatedHosts {
    pub fn new(region_id: impl Into<String>, dedicated_host_type: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            tag: None,
            resource_group_id: None,
            zone_id: None,
            dedicated_host_name: None,
            dedicated_host_cluster_id: None,
            dedicated_host_type: dedicated_host_type.into(),
            action_on_maintenance: None,
            network_attributes_slb_udp_timeout: None,
            network_attributes_udp_timeout: None,
            description: None,
            auto_placement: None,
            cpu_over_commit_ratio: None,
            min_quantity: None,
            charge_type: None,
            quantity: None,
            period: None,
            period_unit: None,
            auto_renew: None,
            auto_renew_period: None,
            auto_release_time: None,
            client_token: None,
        }
    }
}
impl crate::ToFormData for AllocateDedicatedHosts {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AllocateDedicatedHosts {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AllocateDedicatedHosts";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AllocateDedicatedHostsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(22);

        if let Some(f) = &self.action_on_maintenance {
            params.push(("ActionOnMaintenance".into(), (f).into()));
        }

        if let Some(f) = &self.auto_placement {
            params.push(("AutoPlacement".into(), (f).into()));
        }

        if let Some(f) = &self.auto_release_time {
            params.push(("AutoReleaseTime".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew {
            params.push(("AutoRenew".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew_period {
            params.push(("AutoRenewPeriod".into(), (f).into()));
        }

        if let Some(f) = &self.charge_type {
            params.push(("ChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.cpu_over_commit_ratio {
            params.push(("CpuOverCommitRatio".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_cluster_id {
            params.push(("DedicatedHostClusterId".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_name {
            params.push(("DedicatedHostName".into(), (f).into()));
        }
        params.push((
            "DedicatedHostType".into(),
            (&self.dedicated_host_type).into(),
        ));

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.min_quantity {
            params.push(("MinQuantity".into(), (f).into()));
        }

        if let Some(f) = &self.network_attributes_slb_udp_timeout {
            params.push(("NetworkAttributes.SlbUdpTimeout".into(), (f).into()));
        }

        if let Some(f) = &self.network_attributes_udp_timeout {
            params.push(("NetworkAttributes.UdpTimeout".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }

        if let Some(f) = &self.quantity {
            params.push(("Quantity".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDedicatedHosts {
    /// 专有宿主机所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 可用区ID。您可以调用[DescribeZones](~~25610~~)查看最新的阿里云可用区列表。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 专有宿主机ID列表。最多支持100个ID ，ID之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    dedicated_host_ids: Option<String>,
    /// 专有宿主机的名称。
    #[setters(generate = true, strip_option)]
    dedicated_host_name: Option<String>,
    /// 专有宿主机的使用状态。取值范围：
    ///
    /// - Available：运行中。专有宿主机的正常运行状态。
    ///
    /// - UnderAssessment：物理机风险，即故障潜伏期，其物理机处于可用状态，但可能导致专有宿主机中的ECS实例出现问题。
    ///
    /// - PermanentFailure：永久性故障，专有宿主机不可用。
    ///
    /// - TempUnavailable：宿主机临时不可用。
    ///
    /// - Redeploying：宿主机恢复中。
    ///
    /// 默认值：Available。
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// 专有宿主机的规格。您可以调用[DescribeDedicatedHostTypes](~~134240~~)接口获得最新的专有宿主机规格列表。
    #[setters(generate = true, strip_option)]
    dedicated_host_type: Option<String>,
    /// 专有宿主机被锁定的原因。取值范围：
    /// - financial：因欠费被锁定。
    /// - security：因安全原因被锁定。
    #[setters(generate = true, strip_option)]
    lock_reason: Option<String>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// > 该参数即将下线，推荐您使用NextToken与MaxResults完成分页查询操作。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 专有宿主机所在资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。列表长度范围：0~20。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<DescribeDedicatedHostsTag>>,
    /// 专有宿主机集群ID。
    #[setters(generate = true, strip_option)]
    dedicated_host_cluster_id: Option<String>,
    /// 是否展示Socket维度容量信息。您可以通过Socket维度容量信息查看剩余资源信息（vCPU、内存使用量、剩余量和总量信息），从而判断是否可以创建出对应规格的ECS实例。取值范围：
    ///
    /// - true：展示。仅部分规格的DDH支持显示Socket维度资源信息，详情请参见[查看和导出DDH信息](~~68989~~)。
    /// - false：不展示。
    ///
    /// ><notice>
    ///
    /// 每个DDH一般有两个CPU，每个CPU对应的编号为Socket 0、Socket 1。在独享的DDH中，为保证DDH上的ECS发挥最大性能，ECS不会跨Socket创建，即ECS仅会基于一个Socket创建。
    ///
    /// - 如果其中一个Socket剩余的算力资源大于等于待创建的ECS规格，ECS将创建成功。
    /// - 如果每个Socket剩余的算力资源小于待创建的ECS规格，ECS将创建失败。虽然DDH上两个Socket剩余的资源大于ECS规格，但是仍然无法创建出ECS实例。
    /// </notice>
    #[setters(generate = true, strip_option)]
    socket_details: Option<String>,
    /// 查询凭证（Token）。取值为上一次调用该接口返回的 NextToken 参数值，初次调用接口时无需设置该参数。
    #[setters(generate = true, strip_option)]
    next_token: Option<String>,
    /// 分页查询时每页的最大条目数。一旦设置该参数，即表示使用MaxResults与NextToken组合参数的查询方式。
    ///
    /// 最大值为 100。
    ///
    /// 默认值为 10。
    #[setters(generate = true, strip_option)]
    max_results: Option<i32>,
    #[setters(generate = true, strip_option)]
    query_inventory: Option<bool>,
}

impl sealed::Bound for DescribeDedicatedHosts {}

impl DescribeDedicatedHosts {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            zone_id: None,
            dedicated_host_ids: None,
            dedicated_host_name: None,
            status: None,
            dedicated_host_type: None,
            lock_reason: None,
            page_number: None,
            page_size: None,
            resource_group_id: None,
            tag: None,
            dedicated_host_cluster_id: None,
            socket_details: None,
            next_token: None,
            max_results: None,
            query_inventory: None,
        }
    }
}
impl crate::ToFormData for DescribeDedicatedHosts {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDedicatedHosts {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDedicatedHosts";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDedicatedHostsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(16);

        if let Some(f) = &self.dedicated_host_cluster_id {
            params.push(("DedicatedHostClusterId".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_ids {
            params.push(("DedicatedHostIds".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_name {
            params.push(("DedicatedHostName".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_type {
            params.push(("DedicatedHostType".into(), (f).into()));
        }

        if let Some(f) = &self.lock_reason {
            params.push(("LockReason".into(), (f).into()));
        }

        if let Some(f) = &self.max_results {
            params.push(("MaxResults".into(), (f).into()));
        }

        if let Some(f) = &self.next_token {
            params.push(("NextToken".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }

        if let Some(f) = &self.query_inventory {
            params.push(("QueryInventory".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.socket_details {
            params.push(("SocketDetails".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDedicatedHostTypes {
    /// 专有宿主机所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 专有宿主机规格。更多详情，请参见[宿主机规格](~~68564~~)。
    #[setters(generate = true, strip_option)]
    dedicated_host_type: Option<String>,
    /// 专有宿主机规格支持的ECS实例规格族。
    #[setters(generate = true, strip_option)]
    supported_instance_type_family: Option<String>,
}

impl sealed::Bound for DescribeDedicatedHostTypes {}

impl DescribeDedicatedHostTypes {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            dedicated_host_type: None,
            supported_instance_type_family: None,
        }
    }
}
impl crate::ToFormData for DescribeDedicatedHostTypes {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDedicatedHostTypes {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDedicatedHostTypes";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDedicatedHostTypesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.dedicated_host_type {
            params.push(("DedicatedHostType".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.supported_instance_type_family {
            params.push(("SupportedInstanceTypeFamily".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDedicatedHostAttribute {
    /// 专有宿主机所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 专有宿主机ID。
    dedicated_host_id: String,
    /// 专有宿主机名称。长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以http://和https://开头。可以包含数字、半角冒号（:）、下划线（_）或者短划线（-）。
    #[setters(generate = true, strip_option)]
    dedicated_host_name: Option<String>,
    /// 专有宿主机的描述。长度为2~256个英文或中文字符，不能以`http://`或`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// 当专有宿主机发生故障或者在线修复时，为其所宿实例设置迁移方案。取值范围：
    ///
    /// - Migrate：迁移实例到其他物理机并重新启动实例。
    ///
    /// - Stop：在当前专有宿主机上停止实例，确认无法修复专有宿主机后，迁移实例到其他物理机并重新启动实例。
    ///
    /// 当专有宿主机上挂载的是云盘时，默认值：Migrate。
    ///
    /// 当专有宿主机上挂载的是本地盘时，默认值：Stop。
    #[setters(generate = true, strip_option)]
    action_on_maintenance: Option<String>,
    /// 负载均衡连接的UDP会话超时时间，单位：秒。取值范围：15~310。
    #[setters(generate = true, strip_option)]
    network_attributes_slb_udp_timeout: Option<i32>,
    /// 为专有宿主机上运行的云服务设置用户访问的UDP会话超时时间，单位：秒。取值范围：15~310。
    #[setters(generate = true, strip_option)]
    network_attributes_udp_timeout: Option<i32>,
    /// 设置专有宿主机是否加入自动部署资源池。当您在专有宿主机上创建实例，却不指定**DedicatedHostId**时，阿里云自动从资源池中选取专有宿主机放置实例。取值范围：
    ///
    /// - on：加入自动部署资源池。
    ///
    /// - off：不加入自动部署资源池。
    ///
    /// 自动部署功能详情，请参见[功能特性](~~118938~~)。
    #[setters(generate = true, strip_option)]
    auto_placement: Option<String>,
    /// 专有宿主机集群ID。
    #[setters(generate = true, strip_option)]
    dedicated_host_cluster_id: Option<String>,
    /// CPU超卖比。仅自定义规格g6s、c6s、r6s支持设置CPU超卖比。取值范围：1~5。
    ///
    /// CPU超卖比影响DDH的可用vCPU数，一台DDH的可用vCPU数=物理CPU核数\*2\*CPU超卖比。例如，g6s的物理CPU核数为52，如果设置CPU超卖比为4，则修改完成后vCPU总数显示为416。针对CPU绝对稳定性要求不严苛或者CPU负载不高的场景，例如开发测试环境，提升超卖比可以提升可用vCPU数，用于部署更多同等规格的ECS实例，降低单位部署成本。
    ///
    #[setters(generate = true, strip_option)]
    cpu_over_commit_ratio: Option<f32>,
}

impl sealed::Bound for ModifyDedicatedHostAttribute {}

impl ModifyDedicatedHostAttribute {
    pub fn new(region_id: impl Into<String>, dedicated_host_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            dedicated_host_id: dedicated_host_id.into(),
            dedicated_host_name: None,
            description: None,
            action_on_maintenance: None,
            network_attributes_slb_udp_timeout: None,
            network_attributes_udp_timeout: None,
            auto_placement: None,
            dedicated_host_cluster_id: None,
            cpu_over_commit_ratio: None,
        }
    }
}
impl crate::ToFormData for ModifyDedicatedHostAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDedicatedHostAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDedicatedHostAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDedicatedHostAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.action_on_maintenance {
            params.push(("ActionOnMaintenance".into(), (f).into()));
        }

        if let Some(f) = &self.auto_placement {
            params.push(("AutoPlacement".into(), (f).into()));
        }

        if let Some(f) = &self.cpu_over_commit_ratio {
            params.push(("CpuOverCommitRatio".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_cluster_id {
            params.push(("DedicatedHostClusterId".into(), (f).into()));
        }
        params.push(("DedicatedHostId".into(), (&self.dedicated_host_id).into()));

        if let Some(f) = &self.dedicated_host_name {
            params.push(("DedicatedHostName".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.network_attributes_slb_udp_timeout {
            params.push(("NetworkAttributes.SlbUdpTimeout".into(), (f).into()));
        }

        if let Some(f) = &self.network_attributes_udp_timeout {
            params.push(("NetworkAttributes.UdpTimeout".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDedicatedHostsChargeType {
    /// 专有宿主机ID。取值可以由多台专有宿主机ID组成一个JSON数组，最多支持20个ID，ID之间用半角逗号（,）隔开。
    dedicated_host_ids: String,
    /// 专有宿主机所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 包年包月续费时长。取值范围：
    /// - `PeriodUnit=Week`时，`Period`的有效取值：1、2、3、4。
    /// - `PeriodUnit=Month`时，`Period`的有效取值：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    /// 续费时长的时间单位，即参数`Period`的单位。取值范围：
    /// - Week：周。
    /// - Month：月。
    ///
    /// 默认值为Month。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 是否只预检此次请求。取值范围：
    /// - true：发送检查请求，不会查询资源状况。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，会返回错误码`DryRunOperation`。
    /// - false：发送正常请求，通过检查后返回2XX的HTTP状态码并直接查询资源状况。
    ///
    /// 默认值为false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 是否自动支付。取值范围：
    /// - true：自动支付。您需要确保账户余额充足，如果账户余额不足会生成异常订单，并只能作废订单。
    /// - false：只生成订单不扣费。
    ///
    /// 默认值为true。
    ///
    /// >如果您的支付方式余额不足，可以将参数`AutoPay`置为`false`，此时会生成未支付订单，您可以自行支付。
    ///
    #[setters(generate = true, strip_option)]
    auto_pay: Option<bool>,
    /// 专有宿主机需要修改的目标计费方式。取值范围：
    /// - PrePaid：将按量付费转换为包年包月。
    /// - PostPaid：将包年包月转换为按量付费。
    ///
    /// 默认值为PrePaid。
    #[setters(generate = true, strip_option)]
    dedicated_host_charge_type: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。`ClientToken`只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// 包年包月转换为按量付费时，是否返回订单费用详情。
    ///
    /// 默认值为false。
    #[setters(generate = true, strip_option)]
    detail_fee: Option<bool>,
}

impl sealed::Bound for ModifyDedicatedHostsChargeType {}

impl ModifyDedicatedHostsChargeType {
    pub fn new(dedicated_host_ids: impl Into<String>, region_id: impl Into<String>) -> Self {
        Self {
            dedicated_host_ids: dedicated_host_ids.into(),
            region_id: region_id.into(),
            period: None,
            period_unit: None,
            dry_run: None,
            auto_pay: None,
            dedicated_host_charge_type: None,
            client_token: None,
            detail_fee: None,
        }
    }
}
impl crate::ToFormData for ModifyDedicatedHostsChargeType {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDedicatedHostsChargeType {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDedicatedHostsChargeType";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDedicatedHostsChargeTypeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);

        if let Some(f) = &self.auto_pay {
            params.push(("AutoPay".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_charge_type {
            params.push(("DedicatedHostChargeType".into(), (f).into()));
        }
        params.push(("DedicatedHostIds".into(), (&self.dedicated_host_ids).into()));

        if let Some(f) = &self.detail_fee {
            params.push(("DetailFee".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDedicatedHostAutoRenew {
    /// 专有宿主机ID。最多可以输入100个包年包月专有宿主机ID，ID之间用半角逗号（,）隔开。
    dedicated_host_ids: String,
    /// 专有宿主机所属的地域ID。
    region_id: String,
}

impl sealed::Bound for DescribeDedicatedHostAutoRenew {}

impl DescribeDedicatedHostAutoRenew {
    pub fn new(dedicated_host_ids: impl Into<String>, region_id: impl Into<String>) -> Self {
        Self {
            dedicated_host_ids: dedicated_host_ids.into(),
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeDedicatedHostAutoRenew {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDedicatedHostAutoRenew {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDedicatedHostAutoRenew";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDedicatedHostAutoRenewResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("DedicatedHostIds".into(), (&self.dedicated_host_ids).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDedicatedHostAutoRenewAttribute {
    /// 专有宿主机ID。最多可以输入100个包年包月专有宿主机ID，ID之间用半角逗号（,）隔开。
    dedicated_host_ids: String,
    /// 专有宿主机所属的地域ID。
    region_id: String,
    /// 续费周期。取值范围：
    ///
    /// <props="china">
    /// - PeriodUnit=Week时：1、2、3、4。
    /// - PeriodUnit=Month时：1、2、3、6、12、24、36、48、60。
    /// - PeriodUnit=Year时：1、2、3、4、5。
    ///
    /// </props>
    ///
    /// <props="intl">
    /// - PeriodUnit=Month时：1、12。
    /// - PeriodUnit=Year时：1、12。
    ///
    /// </props>
    #[setters(generate = true, strip_option)]
    duration: Option<i32>,
    /// 续费时长单位。取值范围：
    ///
    /// <props="china">
    /// - Week
    /// - Month
    /// - Year
    ///
    /// </props>
    ///
    /// <props="intl">
    /// - Month
    /// - Year
    ///
    /// </props>
    ///
    /// 默认值：Month。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 是否自动续费包年包月专有宿主机。取值范围：
    ///
    /// - true：自动续费包年包月专有宿主机。
    ///
    /// - false：不自动续费包年包月专有宿主机。
    ///
    /// 默认值：false
    #[setters(generate = true, strip_option)]
    auto_renew: Option<bool>,
    /// 是否自动续费包年包月专有宿主机，参数`RenewalStatus`的优先级高于`AutoRenew`。取值范围：
    ///
    /// - AutoRenewal：自动续费。
    ///
    /// - Normal：待续费。
    ///
    /// - NotRenewal：不续费，也不发送到期提醒。到期前第三天系统会自动发送不续费提醒。不续费的专有宿主机可以设置成待续费（Normal），再自行续费（[RenewDedicatedHosts](~~134250~~)）或设置为自动续费（AutoRenewal）。
    #[setters(generate = true, strip_option)]
    renewal_status: Option<String>,
    /// 设置是否跟随专有宿主机内的包年包月ECS实例自动续费。
    ///
    /// 如果您的专有宿主机（简称DDH）为包年包月计费方式，且该DDH内包年包月ECS实例开启了自动续费。您可以通过该参数设置DDH跟随ECS实例自动续费。当DDH内ECS实例自动续费时，如果DDH的到期时间比该ECS实例续费后的到期时间短，则DDH也会自动续费。DDH跟随ECS实例自动续费的原则说明：
    ///
    /// DDH会自动判断对应ECS实例续费后的到期时间，然后在自动续费DDH时长时，选择大于ECS实例到期时间，且满足DDH续费周期的最小续费时长进行续费。DDH支持的续费周期详情，请参见`PeriodUnit`和`Duration`参数说明。
    ///
    /// 例如：包年包月DDH在当年01月15日到期，DDH内的包年包月ECS实例在自动续费后，将时长延长至当年11月15日到期，则DDH生命周期比ECS实例的生命周期少10个月。此时，DDH在自动续费时，会选择大于10个月，且符合DDH续费周期的最小续费时长12个月（即`PeriodUnit=Month`且`Duration=12`）进行续费。
    ///
    /// 取值范围：
    ///
    /// - AutoRenewWithEcs：跟随专有宿主机内包年包月ECS实例自动续费。
    /// - StopRenewWithEcs：不跟随专有宿主机内包年包月ECS实例自动续费。
    /// - NoOperation：不改变专有宿主机当前的设置。
    ///
    /// > 如果您设置该参数为AutoRenewWithEcs，需要确保专有宿主机已开启自动续费（即`AutoRenew=true`）。否则，该参数只是改变了参数值，实际的跟随ECS实例自动续费功能并不生效。
    ///
    /// 默认值：NoOperation
    ///
    #[setters(generate = true, strip_option)]
    auto_renew_with_ecs: Option<String>,
}

impl sealed::Bound for ModifyDedicatedHostAutoRenewAttribute {}

impl ModifyDedicatedHostAutoRenewAttribute {
    pub fn new(dedicated_host_ids: impl Into<String>, region_id: impl Into<String>) -> Self {
        Self {
            dedicated_host_ids: dedicated_host_ids.into(),
            region_id: region_id.into(),
            duration: None,
            period_unit: None,
            auto_renew: None,
            renewal_status: None,
            auto_renew_with_ecs: None,
        }
    }
}
impl crate::ToFormData for ModifyDedicatedHostAutoRenewAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDedicatedHostAutoRenewAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDedicatedHostAutoRenewAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDedicatedHostAutoRenewAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.auto_renew {
            params.push(("AutoRenew".into(), (f).into()));
        }

        if let Some(f) = &self.auto_renew_with_ecs {
            params.push(("AutoRenewWithEcs".into(), (f).into()));
        }
        params.push(("DedicatedHostIds".into(), (&self.dedicated_host_ids).into()));

        if let Some(f) = &self.duration {
            params.push(("Duration".into(), (f).into()));
        }

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.renewal_status {
            params.push(("RenewalStatus".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RenewDedicatedHosts {
    /// 专有宿主机的编号列表。最多可以输入100个预付费专有宿主机ID。多个专有宿主机ID用一个格式类似`["dh-xxxxxxxxx", "dh-yyyyyyyyy", … "dh-zzzzzzzzz"]`的JSON数组表示，ID之间用半角逗号（,）隔开。
    dedicated_host_ids: String,
    /// 专有宿主机所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 续费周期。取值范围：
    ///
    /// <props="china">
    /// - PeriodUnit=Week时：1、2、3、4。
    /// - PeriodUnit=Month时：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
    /// - PeriodUnit=Year时：1、2、3、4、5。
    ///
    /// </props>
    ///
    /// <props="intl">
    /// - PeriodUnit=Month时：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
    /// - PeriodUnit=Year时：1、2、3、4、5。
    ///
    /// </props>
    period: i32,
    /// 续费时长单位。取值范围：
    ///
    /// <props="china">
    /// - Week
    /// - Month
    /// - Year
    ///
    /// </props>
    ///
    /// <props="intl">
    /// - Month
    /// - Year
    ///
    /// </props>
    ///
    /// 默认值：Month。
    #[setters(generate = true, strip_option)]
    period_unit: Option<String>,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for RenewDedicatedHosts {}

impl RenewDedicatedHosts {
    pub fn new(
        dedicated_host_ids: impl Into<String>,
        region_id: impl Into<String>,
        period: impl Into<i32>,
    ) -> Self {
        Self {
            dedicated_host_ids: dedicated_host_ids.into(),
            region_id: region_id.into(),
            period: period.into(),
            period_unit: None,
            client_token: None,
        }
    }
}
impl crate::ToFormData for RenewDedicatedHosts {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RenewDedicatedHosts {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RenewDedicatedHosts";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RenewDedicatedHostsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("DedicatedHostIds".into(), (&self.dedicated_host_ids).into()));
        params.push(("Period".into(), (&self.period).into()));

        if let Some(f) = &self.period_unit {
            params.push(("PeriodUnit".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDedicatedHostAutoReleaseTime {
    /// 专有宿主机所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 需要自动释放的专有宿主机ID。
    dedicated_host_id: String,
    /// 专有宿主机的自动释放时间。按照ISO 8601标准表示，并使用UTC+0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    ///
    /// - 必须晚于当前时间起算的半小时及以后。
    /// - 必须早于当前时间起算的三年及以前。
    /// - 如果参数值中的秒（ss）不是00，则自动取为00。
    /// - 如果不输入`AutoReleaseTime`参数，表示取消自动释放，专有宿主机在预约时间点不再自动释放。
    #[setters(generate = true, strip_option)]
    auto_release_time: Option<String>,
}

impl sealed::Bound for ModifyDedicatedHostAutoReleaseTime {}

impl ModifyDedicatedHostAutoReleaseTime {
    pub fn new(region_id: impl Into<String>, dedicated_host_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            dedicated_host_id: dedicated_host_id.into(),
            auto_release_time: None,
        }
    }
}
impl crate::ToFormData for ModifyDedicatedHostAutoReleaseTime {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDedicatedHostAutoReleaseTime {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDedicatedHostAutoReleaseTime";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDedicatedHostAutoReleaseTimeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.auto_release_time {
            params.push(("AutoReleaseTime".into(), (f).into()));
        }
        params.push(("DedicatedHostId".into(), (&self.dedicated_host_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RedeployDedicatedHost {
    /// 专有宿主机所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 专有宿主机ID。
    dedicated_host_id: String,
    /// 是否先停止实例，再迁移到目标专有宿主机。取值范围：
    ///
    /// - Reboot：先停止实例再迁移。
    ///
    /// - LiveMigrationFirst：不停止实例，直接迁移。此时，您必须指定参数DedicatedHostId。该取值不支持在迁移ECS实例的同时变更实例规格。如果在线迁移失败会默认走关机迁移。
    ///
    /// 默认值：Reboot。
    #[setters(generate = true, strip_option)]
    migration_type: Option<MigrationType>,
}

impl sealed::Bound for RedeployDedicatedHost {}

impl RedeployDedicatedHost {
    pub fn new(region_id: impl Into<String>, dedicated_host_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            dedicated_host_id: dedicated_host_id.into(),
            migration_type: None,
        }
    }
}
impl crate::ToFormData for RedeployDedicatedHost {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RedeployDedicatedHost {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RedeployDedicatedHost";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RedeployDedicatedHostResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("DedicatedHostId".into(), (&self.dedicated_host_id).into()));

        if let Some(f) = &self.migration_type {
            params.push(("MigrationType".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ReleaseDedicatedHost {
    /// 专有宿主机所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 专有宿主机ID。
    dedicated_host_id: String,
    /// 是否释放已到期的包年包月专有宿主机。
    ///
    /// - true：释放。
    /// - false：不释放。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    terminate_subscription: Option<bool>,
}

impl sealed::Bound for ReleaseDedicatedHost {}

impl ReleaseDedicatedHost {
    pub fn new(region_id: impl Into<String>, dedicated_host_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            dedicated_host_id: dedicated_host_id.into(),
            terminate_subscription: None,
        }
    }
}
impl crate::ToFormData for ReleaseDedicatedHost {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ReleaseDedicatedHost {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ReleaseDedicatedHost";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ReleaseDedicatedHostResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("DedicatedHostId".into(), (&self.dedicated_host_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.terminate_subscription {
            params.push(("TerminateSubscription".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateDedicatedHostCluster {
    /// 专有宿主机组所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 是否只预检此次请求。取值范围：
    ///
    /// - true：发送检查请求，不会查询资源状况。检查项包括AccessKey是否有效、RAM用户的授权情况和是否填写了必需参数。如果检查不通过，则返回对应错误。如果检查通过，会返回错误码`DryRunOperation`。
    /// - false：发送正常请求，通过检查后返回2XX HTTP状态码并直接查询资源状况。
    ///
    /// 默认值：false。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ClusterTag>>,
    /// 专有宿主机组要加入的资源组ID。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 专有宿主机组所在的可用区ID。您可以调用[DescribeZones](~~25610~~)查看阿里云地域下的可用区。
    zone_id: String,
    /// 专有宿主机组的名称。长度为2~128个字符，支持Unicode中letter分类下的字符（其中包括英文、中文和数字等）。可以包含半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    dedicated_host_cluster_name: Option<String>,
    /// 专有宿主机组的描述。长度为2~256个字符。不能以`http://`或`https://`开头。
    ///
    /// 默认值：空。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for CreateDedicatedHostCluster {}

impl CreateDedicatedHostCluster {
    pub fn new(region_id: impl Into<String>, zone_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            dry_run: None,
            tag: None,
            resource_group_id: None,
            zone_id: zone_id.into(),
            dedicated_host_cluster_name: None,
            description: None,
        }
    }
}
impl crate::ToFormData for CreateDedicatedHostCluster {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateDedicatedHostCluster {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateDedicatedHostCluster";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateDedicatedHostClusterResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.dedicated_host_cluster_name {
            params.push(("DedicatedHostClusterName".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }
        params.push(("ZoneId".into(), (&self.zone_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyDedicatedHostClusterAttribute {
    /// 专有宿主机组所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 专有宿主机组ID。
    dedicated_host_cluster_id: String,
    /// 专有宿主机组的名称。长度为2~128个英文或中文字符，必须以大小写字母或中文开头，可包含数字、英文句号（.）、下划线（_）或连字符（-）。不能包含`http://`和`https://`。
    #[setters(generate = true, strip_option)]
    dedicated_host_cluster_name: Option<String>,
    /// 专有宿主机组的描述。长度为2~256个字符。不能以`http://`和`https://`开头。
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for ModifyDedicatedHostClusterAttribute {}

impl ModifyDedicatedHostClusterAttribute {
    pub fn new(region_id: impl Into<String>, dedicated_host_cluster_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            dedicated_host_cluster_id: dedicated_host_cluster_id.into(),
            dedicated_host_cluster_name: None,
            description: None,
        }
    }
}
impl crate::ToFormData for ModifyDedicatedHostClusterAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyDedicatedHostClusterAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyDedicatedHostClusterAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyDedicatedHostClusterAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push((
            "DedicatedHostClusterId".into(),
            (&self.dedicated_host_cluster_id).into(),
        ));

        if let Some(f) = &self.dedicated_host_cluster_name {
            params.push(("DedicatedHostClusterName".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeDedicatedHostClusters {
    /// >该参数暂未上线，不支持使用。
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    /// >该参数暂未上线，不支持使用。
    #[setters(generate = true, strip_option)]
    lock_reason: Option<String>,
    /// 专有宿主机组要加入的资源组ID。使用该参数过滤资源时，资源数量不能超过1000个。
    ///
    /// >不支持默认资源组过滤。
    #[setters(generate = true, strip_option)]
    resource_group_id: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ClustersTag>>,
    /// 专有宿主机组所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 专有宿主机组所在的可用区ID。您可以调用[DescribeZones](~~25610~~)查看阿里云地域下的可用区。
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    /// 专有宿主机组ID列表。取值可以由多个专有宿主机组ID组成一个JSON数组，格式为`["dc-xxxxxxxxx", "dc-yyyyyyyyy", … ,"dc-zzzzzzzzz"]`。支持最多100个ID，用半角逗号字符隔开。
    #[setters(generate = true, strip_option)]
    dedicated_host_cluster_ids: Option<String>,
    /// 专有宿主机组名称。
    #[setters(generate = true, strip_option)]
    dedicated_host_cluster_name: Option<String>,
    /// 专有宿主机组状态列表的页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeDedicatedHostClusters {}

impl DescribeDedicatedHostClusters {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            status: None,
            lock_reason: None,
            resource_group_id: None,
            tag: None,
            region_id: region_id.into(),
            zone_id: None,
            dedicated_host_cluster_ids: None,
            dedicated_host_cluster_name: None,
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeDedicatedHostClusters {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeDedicatedHostClusters {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeDedicatedHostClusters";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeDedicatedHostClustersResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.dedicated_host_cluster_ids {
            params.push(("DedicatedHostClusterIds".into(), (f).into()));
        }

        if let Some(f) = &self.dedicated_host_cluster_name {
            params.push(("DedicatedHostClusterName".into(), (f).into()));
        }

        if let Some(f) = &self.lock_reason {
            params.push(("LockReason".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_group_id {
            params.push(("ResourceGroupId".into(), (f).into()));
        }

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteDedicatedHostCluster {
    /// 专有宿主机组所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 专有宿主机组ID。
    dedicated_host_cluster_id: String,
}

impl sealed::Bound for DeleteDedicatedHostCluster {}

impl DeleteDedicatedHostCluster {
    pub fn new(region_id: impl Into<String>, dedicated_host_cluster_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            dedicated_host_cluster_id: dedicated_host_cluster_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteDedicatedHostCluster {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteDedicatedHostCluster {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteDedicatedHostCluster";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteDedicatedHostClusterResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push((
            "DedicatedHostClusterId".into(),
            (&self.dedicated_host_cluster_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateHpcCluster {
    /// HPC集群所在的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// HPC集群描述。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。
    ///
    /// 默认值：空
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// HPC集群名称。长度为2~128个英文或中文字符。必须以大小字母或中文开头，不能以`http://`和`https://`开头。可以包含数字、英文句号（.）、下划线（_）或者短划线（-）。
    name: String,
}

impl sealed::Bound for CreateHpcCluster {}

impl CreateHpcCluster {
    pub fn new(region_id: impl Into<String>, name: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            description: None,
            name: name.into(),
        }
    }
}
impl crate::ToFormData for CreateHpcCluster {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateHpcCluster {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateHpcCluster";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateHpcClusterResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("Name".into(), (&self.name).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeHpcClusters {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// HPC集群ID。
    /// 取值可以由多个HPC集群ID组成一个JSON数组，最多支持100个ID，ID之间用半角逗号（,）隔开。
    #[setters(generate = true, strip_option)]
    hpc_cluster_ids: Option<String>,
    /// HPC集群列表的页码。
    ///
    /// 起始值：1
    ///
    /// 默认值：1
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页行数。
    ///
    /// 最大值：100
    ///
    /// 默认值：10
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeHpcClusters {}

impl DescribeHpcClusters {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            hpc_cluster_ids: None,
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeHpcClusters {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeHpcClusters {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeHpcClusters";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeHpcClustersResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.hpc_cluster_ids {
            params.push(("HpcClusterIds".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyHpcClusterAttribute {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// HPC集群ID。
    hpc_cluster_id: String,
    /// HPC集群描述。长度为2~256个英文或中文字符，不能以http://和https://开头。
    ///
    /// 默认值：空
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    /// HPC集群名称。长度为2~128个英文或中文字符。必须以大小字母或中文开头，不能以http://和https://开头。可以包含数字、下划线（_）或者连字符（-）。
    ///
    /// 默认值：空
    #[setters(generate = true, strip_option)]
    name: Option<String>,
}

impl sealed::Bound for ModifyHpcClusterAttribute {}

impl ModifyHpcClusterAttribute {
    pub fn new(region_id: impl Into<String>, hpc_cluster_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            hpc_cluster_id: hpc_cluster_id.into(),
            description: None,
            name: None,
        }
    }
}
impl crate::ToFormData for ModifyHpcClusterAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyHpcClusterAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyHpcClusterAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyHpcClusterAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("HpcClusterId".into(), (&self.hpc_cluster_id).into()));

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteHpcCluster {
    /// HPC集群所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。**ClientToken**只支持ASCII字符，且不能超过64个字符。更多详情，请参见[如何保证幂等性](~~25693~~)。
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    /// HPC集群ID。
    hpc_cluster_id: String,
}

impl sealed::Bound for DeleteHpcCluster {}

impl DeleteHpcCluster {
    pub fn new(region_id: impl Into<String>, hpc_cluster_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            client_token: None,
            hpc_cluster_id: hpc_cluster_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteHpcCluster {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteHpcCluster {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteHpcCluster";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteHpcClusterResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("HpcClusterId".into(), (&self.hpc_cluster_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeTasks {
    /// 查询结果的页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 分页查询时设置的每页记录数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：10。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 任务ID。单次最多支持指定100个，ID之间使用半角逗号（,）分隔。
    #[setters(generate = true, strip_option)]
    task_ids: Option<String>,
    /// 任务操作的接口名称。取值范围：
    ///
    /// - ImportImage：导入镜像。
    /// - ExportImage：导出镜像。
    /// - RedeployInstance：重新部署ECS实例。
    /// - ModifyDiskSpec：变更云盘类型。
    /// - ArchiveSnapshot ：归档快照。
    #[setters(generate = true, strip_option)]
    task_action: Option<String>,
    /// 任务状态。取值范围：
    ///
    /// - Finished：已完成。
    /// - Processing：运行中。
    /// - Failed：失败。
    ///
    /// 默认值：无。
    ///
    /// > 只支持查询状态为Finished、Processing和Failed的任务，填入其他取值将不会生效。
    #[setters(generate = true, strip_option)]
    task_status: Option<String>,
    /// 按创建时间查询，创建时间区间的起始点。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    start_time: Option<String>,
    /// 按创建时间查询，创建时间区间的终止点。按照[ISO 8601](~~25696~~)标准表示，并需要使用UTC +0时间，格式为yyyy-MM-ddTHH:mm:ssZ。
    #[setters(generate = true, strip_option)]
    end_time: Option<String>,
    /// 资源ID。N的取值范围：1~100。
    #[setters(generate = true, strip_option)]
    resource_ids: Option<Vec<String>>,
}

impl sealed::Bound for DescribeTasks {}

impl DescribeTasks {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            page_number: None,
            page_size: None,
            region_id: region_id.into(),
            task_ids: None,
            task_action: None,
            task_status: None,
            start_time: None,
            end_time: None,
            resource_ids: None,
        }
    }
}
impl crate::ToFormData for DescribeTasks {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeTasks {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeTasks";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeTasksResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(9);

        if let Some(f) = &self.end_time {
            params.push(("EndTime".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_ids {
            crate::FlatSerialize::flat_serialize(f, "ResourceIds", &mut params);
        }

        if let Some(f) = &self.start_time {
            params.push(("StartTime".into(), (f).into()));
        }

        if let Some(f) = &self.task_action {
            params.push(("TaskAction".into(), (f).into()));
        }

        if let Some(f) = &self.task_ids {
            params.push(("TaskIds".into(), (f).into()));
        }

        if let Some(f) = &self.task_status {
            params.push(("TaskStatus".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeTaskAttribute {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 任务ID。您可以调用[DescribeTasks](~~25622~~)查看任务ID。
    task_id: String,
}

impl sealed::Bound for DescribeTaskAttribute {}

impl DescribeTaskAttribute {
    pub fn new(region_id: impl Into<String>, task_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            task_id: task_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeTaskAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeTaskAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeTaskAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeTaskAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("TaskId".into(), (&self.task_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CancelTask {
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 任务ID。您可以调用[DescribeTasks](~~25622~~)查看任务ID列表。
    task_id: String,
}

impl sealed::Bound for CancelTask {}

impl CancelTask {
    pub fn new(region_id: impl Into<String>, task_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            task_id: task_id.into(),
        }
    }
}
impl crate::ToFormData for CancelTask {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CancelTask {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CancelTask";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CancelTaskResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("TaskId".into(), (&self.task_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeUserBusinessBehavior {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    status_key: String,
}

impl sealed::Bound for DescribeUserBusinessBehavior {}

impl DescribeUserBusinessBehavior {
    pub fn new(status_key: impl Into<String>) -> Self {
        Self {
            region_id: None,
            status_key: status_key.into(),
        }
    }
}
impl crate::ToFormData for DescribeUserBusinessBehavior {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeUserBusinessBehavior {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeUserBusinessBehavior";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeUserBusinessBehaviorResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("statusKey".into(), (&self.status_key).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyUserBusinessBehavior {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    status_key: String,
    status_value: String,
}

impl sealed::Bound for ModifyUserBusinessBehavior {}

impl ModifyUserBusinessBehavior {
    pub fn new(status_key: impl Into<String>, status_value: impl Into<String>) -> Self {
        Self {
            region_id: None,
            status_key: status_key.into(),
            status_value: status_value.into(),
        }
    }
}
impl crate::ToFormData for ModifyUserBusinessBehavior {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyUserBusinessBehavior {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyUserBusinessBehavior";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyUserBusinessBehaviorResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("statusKey".into(), (&self.status_key).into()));
        params.push(("statusValue".into(), (&self.status_value).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeLimitation {
    limitation: String,
}

impl sealed::Bound for DescribeLimitation {}

impl DescribeLimitation {
    pub fn new(limitation: impl Into<String>) -> Self {
        Self {
            limitation: limitation.into(),
        }
    }
}
impl crate::ToFormData for DescribeLimitation {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeLimitation {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeLimitation";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeLimitationResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(1);
        params.push(("Limitation".into(), (&self.limitation).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeClusters {
    region_id: String,
}

impl sealed::Bound for DescribeClusters {}

impl DescribeClusters {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for DescribeClusters {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeClusters {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeClusters";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeClustersResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(1);
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteNetworkInterfacePermission {
    region_id: String,
    network_interface_permission_id: String,
    #[setters(generate = true, strip_option)]
    force: Option<bool>,
}

impl sealed::Bound for DeleteNetworkInterfacePermission {}

impl DeleteNetworkInterfacePermission {
    pub fn new(
        region_id: impl Into<String>,
        network_interface_permission_id: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_permission_id: network_interface_permission_id.into(),
            force: None,
        }
    }
}
impl crate::ToFormData for DeleteNetworkInterfacePermission {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteNetworkInterfacePermission {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteNetworkInterfacePermission";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteNetworkInterfacePermissionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.force {
            params.push(("Force".into(), (f).into()));
        }
        params.push((
            "NetworkInterfacePermissionId".into(),
            (&self.network_interface_permission_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteBandwidthPackage {
    region_id: String,
    bandwidth_package_id: String,
}

impl sealed::Bound for DeleteBandwidthPackage {}

impl DeleteBandwidthPackage {
    pub fn new(region_id: impl Into<String>, bandwidth_package_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            bandwidth_package_id: bandwidth_package_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteBandwidthPackage {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteBandwidthPackage {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteBandwidthPackage";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteBandwidthPackageResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push((
            "BandwidthPackageId".into(),
            (&self.bandwidth_package_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyBandwidthPackageSpec {
    region_id: String,
    bandwidth_package_id: String,
    bandwidth: String,
}

impl sealed::Bound for ModifyBandwidthPackageSpec {}

impl ModifyBandwidthPackageSpec {
    pub fn new(
        region_id: impl Into<String>,
        bandwidth_package_id: impl Into<String>,
        bandwidth: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            bandwidth_package_id: bandwidth_package_id.into(),
            bandwidth: bandwidth.into(),
        }
    }
}
impl crate::ToFormData for ModifyBandwidthPackageSpec {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyBandwidthPackageSpec {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyBandwidthPackageSpec";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyBandwidthPackageSpecResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("Bandwidth".into(), (&self.bandwidth).into()));
        params.push((
            "BandwidthPackageId".into(),
            (&self.bandwidth_package_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeBandwidthPackages {
    region_id: String,
    #[setters(generate = true, strip_option)]
    bandwidth_package_id: Option<String>,
    #[setters(generate = true, strip_option)]
    nat_gateway_id: Option<String>,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeBandwidthPackages {}

impl DescribeBandwidthPackages {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            bandwidth_package_id: None,
            nat_gateway_id: None,
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeBandwidthPackages {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeBandwidthPackages {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeBandwidthPackages";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeBandwidthPackagesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.bandwidth_package_id {
            params.push(("BandwidthPackageId".into(), (f).into()));
        }

        if let Some(f) = &self.nat_gateway_id {
            params.push(("NatGatewayId".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateVSwitch {
    zone_id: String,
    cidr_block: String,
    vpc_id: String,
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    #[setters(generate = true, strip_option)]
    v_switch_name: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for CreateVSwitch {}

impl CreateVSwitch {
    pub fn new(
        zone_id: impl Into<String>,
        cidr_block: impl Into<String>,
        vpc_id: impl Into<String>,
    ) -> Self {
        Self {
            zone_id: zone_id.into(),
            cidr_block: cidr_block.into(),
            vpc_id: vpc_id.into(),
            region_id: None,
            v_switch_name: None,
            description: None,
            client_token: None,
        }
    }
}
impl crate::ToFormData for CreateVSwitch {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateVSwitch {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateVSwitch";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateVSwitchResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);
        params.push(("CidrBlock".into(), (&self.cidr_block).into()));

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        if let Some(f) = &self.v_switch_name {
            params.push(("VSwitchName".into(), (f).into()));
        }
        params.push(("VpcId".into(), (&self.vpc_id).into()));
        params.push(("ZoneId".into(), (&self.zone_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteVSwitch {
    v_switch_id: String,
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
}

impl sealed::Bound for DeleteVSwitch {}

impl DeleteVSwitch {
    pub fn new(v_switch_id: impl Into<String>) -> Self {
        Self {
            v_switch_id: v_switch_id.into(),
            region_id: None,
        }
    }
}
impl crate::ToFormData for DeleteVSwitch {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteVSwitch {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteVSwitch";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteVSwitchResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("VSwitchId".into(), (&self.v_switch_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyVSwitchAttribute {
    v_switch_id: String,
    #[setters(generate = true, strip_option)]
    v_switch_name: Option<String>,
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for ModifyVSwitchAttribute {}

impl ModifyVSwitchAttribute {
    pub fn new(v_switch_id: impl Into<String>) -> Self {
        Self {
            v_switch_id: v_switch_id.into(),
            v_switch_name: None,
            region_id: None,
            description: None,
        }
    }
}
impl crate::ToFormData for ModifyVSwitchAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyVSwitchAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyVSwitchAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyVSwitchAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("VSwitchId".into(), (&self.v_switch_id).into()));

        if let Some(f) = &self.v_switch_name {
            params.push(("VSwitchName".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeVSwitches {
    #[setters(generate = true, strip_option)]
    vpc_id: Option<String>,
    #[setters(generate = true, strip_option)]
    v_switch_id: Option<String>,
    #[setters(generate = true, strip_option)]
    zone_id: Option<String>,
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    #[setters(generate = true, strip_option)]
    is_default: Option<bool>,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeVSwitches {}

impl DescribeVSwitches {
    pub fn new() -> Self {
        Self {
            vpc_id: None,
            v_switch_id: None,
            zone_id: None,
            region_id: None,
            is_default: None,
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeVSwitches {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeVSwitches {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeVSwitches";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeVSwitchesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.is_default {
            params.push(("IsDefault".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        if let Some(f) = &self.v_switch_id {
            params.push(("VSwitchId".into(), (f).into()));
        }

        if let Some(f) = &self.vpc_id {
            params.push(("VpcId".into(), (f).into()));
        }

        if let Some(f) = &self.zone_id {
            params.push(("ZoneId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreatePhysicalConnection {
    region_id: String,
    access_point_id: String,
    #[setters(generate = true, strip_option, rename = "r#type")]
    r#type: Option<String>,
    line_operator: String,
    #[setters(generate = true, strip_option)]
    bandwidth: Option<i32>,
    peer_location: String,
    #[setters(generate = true, strip_option)]
    port_type: Option<String>,
    #[setters(generate = true, strip_option)]
    redundant_physical_connection_id: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    #[setters(generate = true, strip_option)]
    circuit_code: Option<String>,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for CreatePhysicalConnection {}

impl CreatePhysicalConnection {
    pub fn new(
        region_id: impl Into<String>,
        access_point_id: impl Into<String>,
        line_operator: impl Into<String>,
        peer_location: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            access_point_id: access_point_id.into(),
            r#type: None,
            line_operator: line_operator.into(),
            bandwidth: None,
            peer_location: peer_location.into(),
            port_type: None,
            redundant_physical_connection_id: None,
            description: None,
            name: None,
            circuit_code: None,
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for CreatePhysicalConnection {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreatePhysicalConnection {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreatePhysicalConnection";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreatePhysicalConnectionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(13);
        params.push(("AccessPointId".into(), (&self.access_point_id).into()));

        if let Some(f) = &self.circuit_code {
            params.push(("CircuitCode".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("LineOperator".into(), (&self.line_operator).into()));

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }
        params.push(("PeerLocation".into(), (&self.peer_location).into()));

        if let Some(f) = &self.port_type {
            params.push(("PortType".into(), (f).into()));
        }

        if let Some(f) = &self.redundant_physical_connection_id {
            params.push(("RedundantPhysicalConnectionId".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.r#type {
            params.push(("Type".into(), (f).into()));
        }

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }

        if let Some(f) = &self.bandwidth {
            params.push(("bandwidth".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeletePhysicalConnection {
    region_id: String,
    physical_connection_id: String,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for DeletePhysicalConnection {}

impl DeletePhysicalConnection {
    pub fn new(region_id: impl Into<String>, physical_connection_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            physical_connection_id: physical_connection_id.into(),
            client_token: None,
        }
    }
}
impl crate::ToFormData for DeletePhysicalConnection {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeletePhysicalConnection {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeletePhysicalConnection";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeletePhysicalConnectionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push((
            "PhysicalConnectionId".into(),
            (&self.physical_connection_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyPhysicalConnectionAttribute {
    region_id: String,
    physical_connection_id: String,
    #[setters(generate = true, strip_option)]
    line_operator: Option<String>,
    #[setters(generate = true, strip_option)]
    bandwidth: Option<i32>,
    #[setters(generate = true, strip_option)]
    peer_location: Option<String>,
    #[setters(generate = true, strip_option)]
    port_type: Option<String>,
    #[setters(generate = true, strip_option)]
    redundant_physical_connection_id: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
    #[setters(generate = true, strip_option)]
    circuit_code: Option<String>,
}

impl sealed::Bound for ModifyPhysicalConnectionAttribute {}

impl ModifyPhysicalConnectionAttribute {
    pub fn new(region_id: impl Into<String>, physical_connection_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            physical_connection_id: physical_connection_id.into(),
            line_operator: None,
            bandwidth: None,
            peer_location: None,
            port_type: None,
            redundant_physical_connection_id: None,
            description: None,
            name: None,
            client_token: None,
            user_cidr: None,
            circuit_code: None,
        }
    }
}
impl crate::ToFormData for ModifyPhysicalConnectionAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyPhysicalConnectionAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyPhysicalConnectionAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyPhysicalConnectionAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(12);

        if let Some(f) = &self.circuit_code {
            params.push(("CircuitCode".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.line_operator {
            params.push(("LineOperator".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.peer_location {
            params.push(("PeerLocation".into(), (f).into()));
        }
        params.push((
            "PhysicalConnectionId".into(),
            (&self.physical_connection_id).into(),
        ));

        if let Some(f) = &self.port_type {
            params.push(("PortType".into(), (f).into()));
        }

        if let Some(f) = &self.redundant_physical_connection_id {
            params.push(("RedundantPhysicalConnectionId".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }

        if let Some(f) = &self.bandwidth {
            params.push(("bandwidth".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct EnablePhysicalConnection {
    region_id: String,
    physical_connection_id: String,
    client_token: String,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for EnablePhysicalConnection {}

impl EnablePhysicalConnection {
    pub fn new(
        region_id: impl Into<String>,
        physical_connection_id: impl Into<String>,
        client_token: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            physical_connection_id: physical_connection_id.into(),
            client_token: client_token.into(),
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for EnablePhysicalConnection {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for EnablePhysicalConnection {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "EnablePhysicalConnection";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<EnablePhysicalConnectionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("ClientToken".into(), (&self.client_token).into()));
        params.push((
            "PhysicalConnectionId".into(),
            (&self.physical_connection_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribePhysicalConnections {
    region_id: String,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
    #[setters(generate = true, strip_option)]
    filter: Option<Vec<ConnectionsFilter>>,
}

impl sealed::Bound for DescribePhysicalConnections {}

impl DescribePhysicalConnections {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
            client_token: None,
            user_cidr: None,
            filter: None,
        }
    }
}
impl crate::ToFormData for DescribePhysicalConnections {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribePhysicalConnections {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribePhysicalConnections";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribePhysicalConnectionsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.filter {
            crate::FlatSerialize::flat_serialize(f, "Filter", &mut params);
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CancelPhysicalConnection {
    region_id: String,
    physical_connection_id: String,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for CancelPhysicalConnection {}

impl CancelPhysicalConnection {
    pub fn new(region_id: impl Into<String>, physical_connection_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            physical_connection_id: physical_connection_id.into(),
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for CancelPhysicalConnection {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CancelPhysicalConnection {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CancelPhysicalConnection";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CancelPhysicalConnectionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push((
            "PhysicalConnectionId".into(),
            (&self.physical_connection_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct TerminatePhysicalConnection {
    region_id: String,
    physical_connection_id: String,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for TerminatePhysicalConnection {}

impl TerminatePhysicalConnection {
    pub fn new(region_id: impl Into<String>, physical_connection_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            physical_connection_id: physical_connection_id.into(),
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for TerminatePhysicalConnection {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for TerminatePhysicalConnection {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "TerminatePhysicalConnection";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<TerminatePhysicalConnectionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push((
            "PhysicalConnectionId".into(),
            (&self.physical_connection_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateVpc {
    region_id: String,
    #[setters(generate = true, strip_option)]
    cidr_block: Option<String>,
    #[setters(generate = true, strip_option)]
    vpc_name: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for CreateVpc {}

impl CreateVpc {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            cidr_block: None,
            vpc_name: None,
            description: None,
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for CreateVpc {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateVpc {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateVpc";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateVpcResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.cidr_block {
            params.push(("CidrBlock".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }

        if let Some(f) = &self.vpc_name {
            params.push(("VpcName".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteVpc {
    vpc_id: String,
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
}

impl sealed::Bound for DeleteVpc {}

impl DeleteVpc {
    pub fn new(vpc_id: impl Into<String>) -> Self {
        Self {
            vpc_id: vpc_id.into(),
            region_id: None,
        }
    }
}
impl crate::ToFormData for DeleteVpc {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteVpc {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteVpc";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteVpcResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("VpcId".into(), (&self.vpc_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeVpcs {
    #[setters(generate = true, strip_option)]
    vpc_id: Option<String>,
    region_id: String,
    #[setters(generate = true, strip_option)]
    is_default: Option<bool>,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeVpcs {}

impl DescribeVpcs {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            vpc_id: None,
            region_id: region_id.into(),
            is_default: None,
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeVpcs {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeVpcs {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeVpcs";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeVpcsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.is_default {
            params.push(("IsDefault".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.vpc_id {
            params.push(("VpcId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyVpcAttribute {
    vpc_id: String,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    #[setters(generate = true, strip_option)]
    vpc_name: Option<String>,
    #[setters(generate = true, strip_option)]
    cidr_block: Option<String>,
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for ModifyVpcAttribute {}

impl ModifyVpcAttribute {
    pub fn new(vpc_id: impl Into<String>) -> Self {
        Self {
            vpc_id: vpc_id.into(),
            description: None,
            vpc_name: None,
            cidr_block: None,
            region_id: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for ModifyVpcAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyVpcAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyVpcAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyVpcAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.cidr_block {
            params.push(("CidrBlock".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }
        params.push(("VpcId".into(), (&self.vpc_id).into()));

        if let Some(f) = &self.vpc_name {
            params.push(("VpcName".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RemoveBandwidthPackageIps {
    region_id: String,
    bandwidth_package_id: String,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    removed_ip_addresses: Vec<String>,
}

impl sealed::Bound for RemoveBandwidthPackageIps {}

impl RemoveBandwidthPackageIps {
    pub fn new(
        region_id: impl Into<String>,
        bandwidth_package_id: impl Into<String>,
        removed_ip_addresses: impl Into<Vec<String>>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            bandwidth_package_id: bandwidth_package_id.into(),
            client_token: None,
            removed_ip_addresses: removed_ip_addresses.into(),
        }
    }
}
impl crate::ToFormData for RemoveBandwidthPackageIps {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RemoveBandwidthPackageIps {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RemoveBandwidthPackageIps";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RemoveBandwidthPackageIpsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push((
            "BandwidthPackageId".into(),
            (&self.bandwidth_package_id).into(),
        ));

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        crate::FlatSerialize::flat_serialize(
            &self.removed_ip_addresses,
            "RemovedIpAddresses",
            &mut params,
        );

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateHaVip {
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    region_id: String,
    v_switch_id: String,
    #[setters(generate = true, strip_option)]
    ip_address: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for CreateHaVip {}

impl CreateHaVip {
    pub fn new(region_id: impl Into<String>, v_switch_id: impl Into<String>) -> Self {
        Self {
            client_token: None,
            region_id: region_id.into(),
            v_switch_id: v_switch_id.into(),
            ip_address: None,
            description: None,
        }
    }
}
impl crate::ToFormData for CreateHaVip {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateHaVip {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateHaVip";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateHaVipResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.ip_address {
            params.push(("IpAddress".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("VSwitchId".into(), (&self.v_switch_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteHaVip {
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    region_id: String,
    ha_vip_id: String,
}

impl sealed::Bound for DeleteHaVip {}

impl DeleteHaVip {
    pub fn new(region_id: impl Into<String>, ha_vip_id: impl Into<String>) -> Self {
        Self {
            client_token: None,
            region_id: region_id.into(),
            ha_vip_id: ha_vip_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteHaVip {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteHaVip {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteHaVip";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteHaVipResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("HaVipId".into(), (&self.ha_vip_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AssociateHaVip {
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    region_id: String,
    ha_vip_id: String,
    instance_id: String,
}

impl sealed::Bound for AssociateHaVip {}

impl AssociateHaVip {
    pub fn new(
        region_id: impl Into<String>,
        ha_vip_id: impl Into<String>,
        instance_id: impl Into<String>,
    ) -> Self {
        Self {
            client_token: None,
            region_id: region_id.into(),
            ha_vip_id: ha_vip_id.into(),
            instance_id: instance_id.into(),
        }
    }
}
impl crate::ToFormData for AssociateHaVip {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AssociateHaVip {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AssociateHaVip";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AssociateHaVipResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("HaVipId".into(), (&self.ha_vip_id).into()));
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyHaVipAttribute {
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    region_id: String,
    ha_vip_id: String,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for ModifyHaVipAttribute {}

impl ModifyHaVipAttribute {
    pub fn new(region_id: impl Into<String>, ha_vip_id: impl Into<String>) -> Self {
        Self {
            client_token: None,
            region_id: region_id.into(),
            ha_vip_id: ha_vip_id.into(),
            description: None,
        }
    }
}
impl crate::ToFormData for ModifyHaVipAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyHaVipAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyHaVipAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyHaVipAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }
        params.push(("HaVipId".into(), (&self.ha_vip_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeHaVips {
    region_id: String,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    filter: Vec<VipsFilter>,
}

impl sealed::Bound for DescribeHaVips {}

impl DescribeHaVips {
    pub fn new(region_id: impl Into<String>, filter: impl Into<Vec<VipsFilter>>) -> Self {
        Self {
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
            filter: filter.into(),
        }
    }
}
impl crate::ToFormData for DescribeHaVips {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeHaVips {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeHaVips";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeHaVipsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        crate::FlatSerialize::flat_serialize(&self.filter, "Filter", &mut params);

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct UnassociateHaVip {
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    region_id: String,
    ha_vip_id: String,
    instance_id: String,
    #[setters(generate = true, strip_option)]
    force: Option<String>,
}

impl sealed::Bound for UnassociateHaVip {}

impl UnassociateHaVip {
    pub fn new(
        region_id: impl Into<String>,
        ha_vip_id: impl Into<String>,
        instance_id: impl Into<String>,
    ) -> Self {
        Self {
            client_token: None,
            region_id: region_id.into(),
            ha_vip_id: ha_vip_id.into(),
            instance_id: instance_id.into(),
            force: None,
        }
    }
}
impl crate::ToFormData for UnassociateHaVip {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for UnassociateHaVip {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "UnassociateHaVip";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<UnassociateHaVipResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.force {
            params.push(("Force".into(), (f).into()));
        }
        params.push(("HaVipId".into(), (&self.ha_vip_id).into()));
        params.push(("InstanceId".into(), (&self.instance_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateVirtualBorderRouter {
    region_id: String,
    physical_connection_id: String,
    #[setters(generate = true, strip_option)]
    vbr_owner_id: Option<i64>,
    vlan_id: i32,
    #[setters(generate = true, strip_option)]
    circuit_code: Option<String>,
    #[setters(generate = true, strip_option)]
    local_gateway_ip: Option<String>,
    #[setters(generate = true, strip_option)]
    peer_gateway_ip: Option<String>,
    #[setters(generate = true, strip_option)]
    peering_subnet_mask: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for CreateVirtualBorderRouter {}

impl CreateVirtualBorderRouter {
    pub fn new(
        region_id: impl Into<String>,
        physical_connection_id: impl Into<String>,
        vlan_id: impl Into<i32>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            physical_connection_id: physical_connection_id.into(),
            vbr_owner_id: None,
            vlan_id: vlan_id.into(),
            circuit_code: None,
            local_gateway_ip: None,
            peer_gateway_ip: None,
            peering_subnet_mask: None,
            description: None,
            name: None,
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for CreateVirtualBorderRouter {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateVirtualBorderRouter {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateVirtualBorderRouter";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateVirtualBorderRouterResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(12);

        if let Some(f) = &self.circuit_code {
            params.push(("CircuitCode".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.local_gateway_ip {
            params.push(("LocalGatewayIp".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.peer_gateway_ip {
            params.push(("PeerGatewayIp".into(), (f).into()));
        }

        if let Some(f) = &self.peering_subnet_mask {
            params.push(("PeeringSubnetMask".into(), (f).into()));
        }
        params.push((
            "PhysicalConnectionId".into(),
            (&self.physical_connection_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }

        if let Some(f) = &self.vbr_owner_id {
            params.push(("VbrOwnerId".into(), (f).into()));
        }
        params.push(("VlanId".into(), (&self.vlan_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteVirtualBorderRouter {
    region_id: String,
    vbr_id: String,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for DeleteVirtualBorderRouter {}

impl DeleteVirtualBorderRouter {
    pub fn new(region_id: impl Into<String>, vbr_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            vbr_id: vbr_id.into(),
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for DeleteVirtualBorderRouter {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteVirtualBorderRouter {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteVirtualBorderRouter";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteVirtualBorderRouterResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }
        params.push(("VbrId".into(), (&self.vbr_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyVirtualBorderRouterAttribute {
    region_id: String,
    vbr_id: String,
    #[setters(generate = true, strip_option)]
    vlan_id: Option<i32>,
    #[setters(generate = true, strip_option)]
    circuit_code: Option<String>,
    #[setters(generate = true, strip_option)]
    local_gateway_ip: Option<String>,
    #[setters(generate = true, strip_option)]
    peer_gateway_ip: Option<String>,
    #[setters(generate = true, strip_option)]
    peering_subnet_mask: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for ModifyVirtualBorderRouterAttribute {}

impl ModifyVirtualBorderRouterAttribute {
    pub fn new(region_id: impl Into<String>, vbr_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            vbr_id: vbr_id.into(),
            vlan_id: None,
            circuit_code: None,
            local_gateway_ip: None,
            peer_gateway_ip: None,
            peering_subnet_mask: None,
            description: None,
            name: None,
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for ModifyVirtualBorderRouterAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyVirtualBorderRouterAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyVirtualBorderRouterAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyVirtualBorderRouterAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(11);

        if let Some(f) = &self.circuit_code {
            params.push(("CircuitCode".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.local_gateway_ip {
            params.push(("LocalGatewayIp".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.peer_gateway_ip {
            params.push(("PeerGatewayIp".into(), (f).into()));
        }

        if let Some(f) = &self.peering_subnet_mask {
            params.push(("PeeringSubnetMask".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }
        params.push(("VbrId".into(), (&self.vbr_id).into()));

        if let Some(f) = &self.vlan_id {
            params.push(("VlanId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RecoverVirtualBorderRouter {
    region_id: String,
    vbr_id: String,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for RecoverVirtualBorderRouter {}

impl RecoverVirtualBorderRouter {
    pub fn new(region_id: impl Into<String>, vbr_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            vbr_id: vbr_id.into(),
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for RecoverVirtualBorderRouter {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RecoverVirtualBorderRouter {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RecoverVirtualBorderRouter";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RecoverVirtualBorderRouterResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }
        params.push(("VbrId".into(), (&self.vbr_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct TerminateVirtualBorderRouter {
    region_id: String,
    vbr_id: String,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for TerminateVirtualBorderRouter {}

impl TerminateVirtualBorderRouter {
    pub fn new(region_id: impl Into<String>, vbr_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            vbr_id: vbr_id.into(),
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for TerminateVirtualBorderRouter {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for TerminateVirtualBorderRouter {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "TerminateVirtualBorderRouter";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<TerminateVirtualBorderRouterResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }
        params.push(("VbrId".into(), (&self.vbr_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeVirtualBorderRouters {
    region_id: String,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    #[setters(generate = true, strip_option)]
    filter: Option<Vec<RoutersFilter>>,
}

impl sealed::Bound for DescribeVirtualBorderRouters {}

impl DescribeVirtualBorderRouters {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
            filter: None,
        }
    }
}
impl crate::ToFormData for DescribeVirtualBorderRouters {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeVirtualBorderRouters {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeVirtualBorderRouters";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeVirtualBorderRoutersResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.filter {
            crate::FlatSerialize::flat_serialize(f, "Filter", &mut params);
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeVirtualBorderRoutersForPhysicalConnection {
    region_id: String,
    physical_connection_id: String,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    #[setters(generate = true, strip_option)]
    filter: Option<Vec<ConnectionFilter>>,
}

impl sealed::Bound for DescribeVirtualBorderRoutersForPhysicalConnection {}

impl DescribeVirtualBorderRoutersForPhysicalConnection {
    pub fn new(region_id: impl Into<String>, physical_connection_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            physical_connection_id: physical_connection_id.into(),
            page_number: None,
            page_size: None,
            filter: None,
        }
    }
}
impl crate::ToFormData for DescribeVirtualBorderRoutersForPhysicalConnection {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeVirtualBorderRoutersForPhysicalConnection {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeVirtualBorderRoutersForPhysicalConnection";

    type Body = crate::Form<Self>;

    type ResponseWrap =
        crate::JsonResponseWrap<DescribeVirtualBorderRoutersForPhysicalConnectionResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.filter {
            crate::FlatSerialize::flat_serialize(f, "Filter", &mut params);
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push((
            "PhysicalConnectionId".into(),
            (&self.physical_connection_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateRouterInterface {
    region_id: String,
    role: String,
    opposite_region_id: String,
    spec: String,
    router_type: String,
    router_id: String,
    #[setters(generate = true, strip_option)]
    opposite_interface_id: Option<String>,
    #[setters(generate = true, strip_option)]
    opposite_router_id: Option<String>,
    #[setters(generate = true, strip_option)]
    opposite_router_type: Option<String>,
    #[setters(generate = true, strip_option)]
    opposite_interface_owner_id: Option<String>,
    #[setters(generate = true, strip_option)]
    health_check_source_ip: Option<String>,
    #[setters(generate = true, strip_option)]
    health_check_target_ip: Option<String>,
    #[setters(generate = true, strip_option)]
    access_point_id: Option<String>,
    #[setters(generate = true, strip_option)]
    opposite_access_point_id: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
    #[setters(generate = true, strip_option)]
    instance_charge_type: Option<String>,
    #[setters(generate = true, strip_option)]
    auto_pay: Option<bool>,
    #[setters(generate = true, strip_option)]
    pricing_cycle: Option<String>,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for CreateRouterInterface {}

impl CreateRouterInterface {
    pub fn new(
        region_id: impl Into<String>,
        role: impl Into<String>,
        opposite_region_id: impl Into<String>,
        spec: impl Into<String>,
        router_type: impl Into<String>,
        router_id: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            role: role.into(),
            opposite_region_id: opposite_region_id.into(),
            spec: spec.into(),
            router_type: router_type.into(),
            router_id: router_id.into(),
            opposite_interface_id: None,
            opposite_router_id: None,
            opposite_router_type: None,
            opposite_interface_owner_id: None,
            health_check_source_ip: None,
            health_check_target_ip: None,
            access_point_id: None,
            opposite_access_point_id: None,
            description: None,
            name: None,
            period: None,
            instance_charge_type: None,
            auto_pay: None,
            pricing_cycle: None,
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for CreateRouterInterface {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateRouterInterface {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateRouterInterface";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateRouterInterfaceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(22);

        if let Some(f) = &self.access_point_id {
            params.push(("AccessPointId".into(), (f).into()));
        }

        if let Some(f) = &self.auto_pay {
            params.push(("AutoPay".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.health_check_source_ip {
            params.push(("HealthCheckSourceIp".into(), (f).into()));
        }

        if let Some(f) = &self.health_check_target_ip {
            params.push(("HealthCheckTargetIp".into(), (f).into()));
        }

        if let Some(f) = &self.instance_charge_type {
            params.push(("InstanceChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.opposite_access_point_id {
            params.push(("OppositeAccessPointId".into(), (f).into()));
        }

        if let Some(f) = &self.opposite_interface_id {
            params.push(("OppositeInterfaceId".into(), (f).into()));
        }

        if let Some(f) = &self.opposite_interface_owner_id {
            params.push(("OppositeInterfaceOwnerId".into(), (f).into()));
        }
        params.push(("OppositeRegionId".into(), (&self.opposite_region_id).into()));

        if let Some(f) = &self.opposite_router_id {
            params.push(("OppositeRouterId".into(), (f).into()));
        }

        if let Some(f) = &self.opposite_router_type {
            params.push(("OppositeRouterType".into(), (f).into()));
        }

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.pricing_cycle {
            params.push(("PricingCycle".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("Role".into(), (&self.role).into()));
        params.push(("RouterId".into(), (&self.router_id).into()));
        params.push(("RouterType".into(), (&self.router_type).into()));
        params.push(("Spec".into(), (&self.spec).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteRouterInterface {
    region_id: String,
    router_interface_id: String,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for DeleteRouterInterface {}

impl DeleteRouterInterface {
    pub fn new(region_id: impl Into<String>, router_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            router_interface_id: router_interface_id.into(),
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for DeleteRouterInterface {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteRouterInterface {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteRouterInterface";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteRouterInterfaceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push((
            "RouterInterfaceId".into(),
            (&self.router_interface_id).into(),
        ));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ActivateRouterInterface {
    region_id: String,
    router_interface_id: String,
}

impl sealed::Bound for ActivateRouterInterface {}

impl ActivateRouterInterface {
    pub fn new(region_id: impl Into<String>, router_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            router_interface_id: router_interface_id.into(),
        }
    }
}
impl crate::ToFormData for ActivateRouterInterface {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ActivateRouterInterface {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ActivateRouterInterface";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ActivateRouterInterfaceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push((
            "RouterInterfaceId".into(),
            (&self.router_interface_id).into(),
        ));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeactivateRouterInterface {
    region_id: String,
    router_interface_id: String,
}

impl sealed::Bound for DeactivateRouterInterface {}

impl DeactivateRouterInterface {
    pub fn new(region_id: impl Into<String>, router_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            router_interface_id: router_interface_id.into(),
        }
    }
}
impl crate::ToFormData for DeactivateRouterInterface {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeactivateRouterInterface {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeactivateRouterInterface";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeactivateRouterInterfaceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push((
            "RouterInterfaceId".into(),
            (&self.router_interface_id).into(),
        ));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyRouterInterfaceAttribute {
    region_id: String,
    router_interface_id: String,
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    #[setters(generate = true, strip_option)]
    opposite_interface_id: Option<String>,
    #[setters(generate = true, strip_option)]
    opposite_router_id: Option<String>,
    #[setters(generate = true, strip_option)]
    opposite_router_type: Option<String>,
    #[setters(generate = true, strip_option)]
    opposite_interface_owner_id: Option<i64>,
    #[setters(generate = true, strip_option)]
    health_check_source_ip: Option<String>,
    #[setters(generate = true, strip_option)]
    health_check_target_ip: Option<String>,
}

impl sealed::Bound for ModifyRouterInterfaceAttribute {}

impl ModifyRouterInterfaceAttribute {
    pub fn new(region_id: impl Into<String>, router_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            router_interface_id: router_interface_id.into(),
            name: None,
            description: None,
            opposite_interface_id: None,
            opposite_router_id: None,
            opposite_router_type: None,
            opposite_interface_owner_id: None,
            health_check_source_ip: None,
            health_check_target_ip: None,
        }
    }
}
impl crate::ToFormData for ModifyRouterInterfaceAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyRouterInterfaceAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyRouterInterfaceAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyRouterInterfaceAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(10);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.health_check_source_ip {
            params.push(("HealthCheckSourceIp".into(), (f).into()));
        }

        if let Some(f) = &self.health_check_target_ip {
            params.push(("HealthCheckTargetIp".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }

        if let Some(f) = &self.opposite_interface_id {
            params.push(("OppositeInterfaceId".into(), (f).into()));
        }

        if let Some(f) = &self.opposite_interface_owner_id {
            params.push(("OppositeInterfaceOwnerId".into(), (f).into()));
        }

        if let Some(f) = &self.opposite_router_id {
            params.push(("OppositeRouterId".into(), (f).into()));
        }

        if let Some(f) = &self.opposite_router_type {
            params.push(("OppositeRouterType".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push((
            "RouterInterfaceId".into(),
            (&self.router_interface_id).into(),
        ));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyRouterInterfaceSpec {
    region_id: String,
    router_interface_id: String,
    spec: String,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    user_cidr: Option<String>,
}

impl sealed::Bound for ModifyRouterInterfaceSpec {}

impl ModifyRouterInterfaceSpec {
    pub fn new(
        region_id: impl Into<String>,
        router_interface_id: impl Into<String>,
        spec: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            router_interface_id: router_interface_id.into(),
            spec: spec.into(),
            client_token: None,
            user_cidr: None,
        }
    }
}
impl crate::ToFormData for ModifyRouterInterfaceSpec {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyRouterInterfaceSpec {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyRouterInterfaceSpec";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyRouterInterfaceSpecResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push((
            "RouterInterfaceId".into(),
            (&self.router_interface_id).into(),
        ));
        params.push(("Spec".into(), (&self.spec).into()));

        if let Some(f) = &self.user_cidr {
            params.push(("UserCidr".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyVRouterAttribute {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    v_router_id: String,
    #[setters(generate = true, strip_option)]
    v_router_name: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
}

impl sealed::Bound for ModifyVRouterAttribute {}

impl ModifyVRouterAttribute {
    pub fn new(v_router_id: impl Into<String>) -> Self {
        Self {
            region_id: None,
            v_router_id: v_router_id.into(),
            v_router_name: None,
            description: None,
        }
    }
}
impl crate::ToFormData for ModifyVRouterAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyVRouterAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyVRouterAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyVRouterAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("VRouterId".into(), (&self.v_router_id).into()));

        if let Some(f) = &self.v_router_name {
            params.push(("VRouterName".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeRouterInterfaces {
    region_id: String,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    #[setters(generate = true, strip_option)]
    filter: Option<Vec<InterfacesFilter>>,
}

impl sealed::Bound for DescribeRouterInterfaces {}

impl DescribeRouterInterfaces {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
            filter: None,
        }
    }
}
impl crate::ToFormData for DescribeRouterInterfaces {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeRouterInterfaces {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeRouterInterfaces";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeRouterInterfacesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.filter {
            crate::FlatSerialize::flat_serialize(f, "Filter", &mut params);
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct UnassociateEipAddress {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    allocation_id: String,
    instance_id: String,
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
}

impl sealed::Bound for UnassociateEipAddress {}

impl UnassociateEipAddress {
    pub fn new(allocation_id: impl Into<String>, instance_id: impl Into<String>) -> Self {
        Self {
            region_id: None,
            allocation_id: allocation_id.into(),
            instance_id: instance_id.into(),
            instance_type: None,
        }
    }
}
impl crate::ToFormData for UnassociateEipAddress {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for UnassociateEipAddress {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "UnassociateEipAddress";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<UnassociateEipAddressResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("AllocationId".into(), (&self.allocation_id).into()));
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AllocateEipAddress {
    region_id: String,
    #[setters(generate = true, strip_option)]
    bandwidth: Option<String>,
    #[setters(generate = true, strip_option)]
    isp: Option<String>,
    #[setters(generate = true, strip_option)]
    internet_charge_type: Option<String>,
    #[setters(generate = true, strip_option)]
    activity_id: Option<i64>,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for AllocateEipAddress {}

impl AllocateEipAddress {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            bandwidth: None,
            isp: None,
            internet_charge_type: None,
            activity_id: None,
            client_token: None,
        }
    }
}
impl crate::ToFormData for AllocateEipAddress {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AllocateEipAddress {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AllocateEipAddress";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AllocateEipAddressResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);

        if let Some(f) = &self.activity_id {
            params.push(("ActivityId".into(), (f).into()));
        }

        if let Some(f) = &self.bandwidth {
            params.push(("Bandwidth".into(), (f).into()));
        }

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.isp {
            params.push(("ISP".into(), (f).into()));
        }

        if let Some(f) = &self.internet_charge_type {
            params.push(("InternetChargeType".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyEipAddressAttribute {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    allocation_id: String,
    bandwidth: String,
}

impl sealed::Bound for ModifyEipAddressAttribute {}

impl ModifyEipAddressAttribute {
    pub fn new(allocation_id: impl Into<String>, bandwidth: impl Into<String>) -> Self {
        Self {
            region_id: None,
            allocation_id: allocation_id.into(),
            bandwidth: bandwidth.into(),
        }
    }
}
impl crate::ToFormData for ModifyEipAddressAttribute {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyEipAddressAttribute {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyEipAddressAttribute";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyEipAddressAttributeResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("AllocationId".into(), (&self.allocation_id).into()));
        params.push(("Bandwidth".into(), (&self.bandwidth).into()));

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ReleaseEipAddress {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    allocation_id: String,
}

impl sealed::Bound for ReleaseEipAddress {}

impl ReleaseEipAddress {
    pub fn new(allocation_id: impl Into<String>) -> Self {
        Self {
            region_id: None,
            allocation_id: allocation_id.into(),
        }
    }
}
impl crate::ToFormData for ReleaseEipAddress {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ReleaseEipAddress {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ReleaseEipAddress";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ReleaseEipAddressResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("AllocationId".into(), (&self.allocation_id).into()));

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AssociateEipAddress {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    allocation_id: String,
    instance_id: String,
    #[setters(generate = true, strip_option)]
    instance_type: Option<String>,
}

impl sealed::Bound for AssociateEipAddress {}

impl AssociateEipAddress {
    pub fn new(allocation_id: impl Into<String>, instance_id: impl Into<String>) -> Self {
        Self {
            region_id: None,
            allocation_id: allocation_id.into(),
            instance_id: instance_id.into(),
            instance_type: None,
        }
    }
}
impl crate::ToFormData for AssociateEipAddress {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AssociateEipAddress {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AssociateEipAddress";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AssociateEipAddressResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("AllocationId".into(), (&self.allocation_id).into()));
        params.push(("InstanceId".into(), (&self.instance_id).into()));

        if let Some(f) = &self.instance_type {
            params.push(("InstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeEipAddresses {
    region_id: String,
    #[setters(generate = true, strip_option)]
    status: Option<String>,
    #[setters(generate = true, strip_option)]
    eip_address: Option<String>,
    #[setters(generate = true, strip_option)]
    allocation_id: Option<String>,
    #[setters(generate = true, strip_option)]
    isp: Option<String>,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    #[setters(generate = true, strip_option)]
    filter1_key: Option<String>,
    #[setters(generate = true, strip_option)]
    filter2_key: Option<String>,
    #[setters(generate = true, strip_option)]
    filter1_value: Option<String>,
    #[setters(generate = true, strip_option)]
    filter2_value: Option<String>,
    #[setters(generate = true, strip_option)]
    lock_reason: Option<String>,
    #[setters(generate = true, strip_option)]
    associated_instance_type: Option<String>,
    #[setters(generate = true, strip_option)]
    associated_instance_id: Option<String>,
    #[setters(generate = true, strip_option)]
    charge_type: Option<String>,
}

impl sealed::Bound for DescribeEipAddresses {}

impl DescribeEipAddresses {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            status: None,
            eip_address: None,
            allocation_id: None,
            isp: None,
            page_number: None,
            page_size: None,
            filter1_key: None,
            filter2_key: None,
            filter1_value: None,
            filter2_value: None,
            lock_reason: None,
            associated_instance_type: None,
            associated_instance_id: None,
            charge_type: None,
        }
    }
}
impl crate::ToFormData for DescribeEipAddresses {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeEipAddresses {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeEipAddresses";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeEipAddressesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(15);

        if let Some(f) = &self.allocation_id {
            params.push(("AllocationId".into(), (f).into()));
        }

        if let Some(f) = &self.associated_instance_id {
            params.push(("AssociatedInstanceId".into(), (f).into()));
        }

        if let Some(f) = &self.associated_instance_type {
            params.push(("AssociatedInstanceType".into(), (f).into()));
        }

        if let Some(f) = &self.charge_type {
            params.push(("ChargeType".into(), (f).into()));
        }

        if let Some(f) = &self.eip_address {
            params.push(("EipAddress".into(), (f).into()));
        }

        if let Some(f) = &self.filter1_key {
            params.push(("Filter.1.Key".into(), (f).into()));
        }

        if let Some(f) = &self.filter1_value {
            params.push(("Filter.1.Value".into(), (f).into()));
        }

        if let Some(f) = &self.filter2_key {
            params.push(("Filter.2.Key".into(), (f).into()));
        }

        if let Some(f) = &self.filter2_value {
            params.push(("Filter.2.Value".into(), (f).into()));
        }

        if let Some(f) = &self.isp {
            params.push(("ISP".into(), (f).into()));
        }

        if let Some(f) = &self.lock_reason {
            params.push(("LockReason".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.status {
            params.push(("Status".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeEipMonitorData {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    allocation_id: String,
    start_time: String,
    end_time: String,
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
}

impl sealed::Bound for DescribeEipMonitorData {}

impl DescribeEipMonitorData {
    pub fn new(
        allocation_id: impl Into<String>,
        start_time: impl Into<String>,
        end_time: impl Into<String>,
    ) -> Self {
        Self {
            region_id: None,
            allocation_id: allocation_id.into(),
            start_time: start_time.into(),
            end_time: end_time.into(),
            period: None,
        }
    }
}
impl crate::ToFormData for DescribeEipMonitorData {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeEipMonitorData {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeEipMonitorData";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeEipMonitorDataResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);
        params.push(("AllocationId".into(), (&self.allocation_id).into()));
        params.push(("EndTime".into(), (&self.end_time).into()));

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("StartTime".into(), (&self.start_time).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateNatGateway {
    region_id: String,
    vpc_id: String,
    #[setters(generate = true, strip_option)]
    name: Option<String>,
    #[setters(generate = true, strip_option)]
    description: Option<String>,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    bandwidth_package: Vec<GatewayBandwidthPackage>,
}

impl sealed::Bound for CreateNatGateway {}

impl CreateNatGateway {
    pub fn new(
        region_id: impl Into<String>,
        vpc_id: impl Into<String>,
        bandwidth_package: impl Into<Vec<GatewayBandwidthPackage>>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            vpc_id: vpc_id.into(),
            name: None,
            description: None,
            client_token: None,
            bandwidth_package: bandwidth_package.into(),
        }
    }
}
impl crate::ToFormData for CreateNatGateway {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateNatGateway {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateNatGateway";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateNatGatewayResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(6);
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_package,
            "BandwidthPackage",
            &mut params,
        );

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }

        if let Some(f) = &self.description {
            params.push(("Description".into(), (f).into()));
        }

        if let Some(f) = &self.name {
            params.push(("Name".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("VpcId".into(), (&self.vpc_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteNatGateway {
    region_id: String,
    nat_gateway_id: String,
}

impl sealed::Bound for DeleteNatGateway {}

impl DeleteNatGateway {
    pub fn new(region_id: impl Into<String>, nat_gateway_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            nat_gateway_id: nat_gateway_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteNatGateway {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteNatGateway {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteNatGateway";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteNatGatewayResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("NatGatewayId".into(), (&self.nat_gateway_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeNatGateways {
    region_id: String,
    #[setters(generate = true, strip_option)]
    nat_gateway_id: Option<String>,
    #[setters(generate = true, strip_option)]
    vpc_id: Option<String>,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeNatGateways {}

impl DescribeNatGateways {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            nat_gateway_id: None,
            vpc_id: None,
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeNatGateways {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeNatGateways {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeNatGateways";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeNatGatewaysResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.nat_gateway_id {
            params.push(("NatGatewayId".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.vpc_id {
            params.push(("VpcId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeNewProjectEipMonitorData {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    allocation_id: String,
    start_time: String,
    end_time: String,
    #[setters(generate = true, strip_option)]
    period: Option<i32>,
}

impl sealed::Bound for DescribeNewProjectEipMonitorData {}

impl DescribeNewProjectEipMonitorData {
    pub fn new(
        allocation_id: impl Into<String>,
        start_time: impl Into<String>,
        end_time: impl Into<String>,
    ) -> Self {
        Self {
            region_id: None,
            allocation_id: allocation_id.into(),
            start_time: start_time.into(),
            end_time: end_time.into(),
            period: None,
        }
    }
}
impl crate::ToFormData for DescribeNewProjectEipMonitorData {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeNewProjectEipMonitorData {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeNewProjectEipMonitorData";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeNewProjectEipMonitorDataResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);
        params.push(("AllocationId".into(), (&self.allocation_id).into()));
        params.push(("EndTime".into(), (&self.end_time).into()));

        if let Some(f) = &self.period {
            params.push(("Period".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("StartTime".into(), (&self.start_time).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteRouteEntry {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    route_table_id: String,
    destination_cidr_block: String,
    #[setters(generate = true, strip_option)]
    next_hop_id: Option<String>,
    #[setters(generate = true, strip_option)]
    next_hop_list: Option<Vec<DeleteRouteEntryNextHopList>>,
}

impl sealed::Bound for DeleteRouteEntry {}

impl DeleteRouteEntry {
    pub fn new(
        route_table_id: impl Into<String>,
        destination_cidr_block: impl Into<String>,
    ) -> Self {
        Self {
            region_id: None,
            route_table_id: route_table_id.into(),
            destination_cidr_block: destination_cidr_block.into(),
            next_hop_id: None,
            next_hop_list: None,
        }
    }
}
impl crate::ToFormData for DeleteRouteEntry {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteRouteEntry {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteRouteEntry";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteRouteEntryResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);
        params.push((
            "DestinationCidrBlock".into(),
            (&self.destination_cidr_block).into(),
        ));

        if let Some(f) = &self.next_hop_id {
            params.push(("NextHopId".into(), (f).into()));
        }

        if let Some(f) = &self.next_hop_list {
            crate::FlatSerialize::flat_serialize(f, "NextHopList", &mut params);
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("RouteTableId".into(), (&self.route_table_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DeleteForwardEntry {
    region_id: String,
    forward_table_id: String,
    forward_entry_id: String,
}

impl sealed::Bound for DeleteForwardEntry {}

impl DeleteForwardEntry {
    pub fn new(
        region_id: impl Into<String>,
        forward_table_id: impl Into<String>,
        forward_entry_id: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            forward_table_id: forward_table_id.into(),
            forward_entry_id: forward_entry_id.into(),
        }
    }
}
impl crate::ToFormData for DeleteForwardEntry {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DeleteForwardEntry {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DeleteForwardEntry";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DeleteForwardEntryResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push(("ForwardEntryId".into(), (&self.forward_entry_id).into()));
        params.push(("ForwardTableId".into(), (&self.forward_table_id).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateForwardEntry {
    region_id: String,
    forward_table_id: String,
    external_ip: String,
    external_port: String,
    internal_ip: String,
    internal_port: String,
    ip_protocol: String,
}

impl sealed::Bound for CreateForwardEntry {}

impl CreateForwardEntry {
    pub fn new(
        region_id: impl Into<String>,
        forward_table_id: impl Into<String>,
        external_ip: impl Into<String>,
        external_port: impl Into<String>,
        internal_ip: impl Into<String>,
        internal_port: impl Into<String>,
        ip_protocol: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            forward_table_id: forward_table_id.into(),
            external_ip: external_ip.into(),
            external_port: external_port.into(),
            internal_ip: internal_ip.into(),
            internal_port: internal_port.into(),
            ip_protocol: ip_protocol.into(),
        }
    }
}
impl crate::ToFormData for CreateForwardEntry {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateForwardEntry {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateForwardEntry";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateForwardEntryResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);
        params.push(("ExternalIp".into(), (&self.external_ip).into()));
        params.push(("ExternalPort".into(), (&self.external_port).into()));
        params.push(("ForwardTableId".into(), (&self.forward_table_id).into()));
        params.push(("InternalIp".into(), (&self.internal_ip).into()));
        params.push(("InternalPort".into(), (&self.internal_port).into()));
        params.push(("IpProtocol".into(), (&self.ip_protocol).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AddBandwidthPackageIps {
    region_id: String,
    bandwidth_package_id: String,
    ip_count: String,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
}

impl sealed::Bound for AddBandwidthPackageIps {}

impl AddBandwidthPackageIps {
    pub fn new(
        region_id: impl Into<String>,
        bandwidth_package_id: impl Into<String>,
        ip_count: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            bandwidth_package_id: bandwidth_package_id.into(),
            ip_count: ip_count.into(),
            client_token: None,
        }
    }
}
impl crate::ToFormData for AddBandwidthPackageIps {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AddBandwidthPackageIps {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AddBandwidthPackageIps";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AddBandwidthPackageIpsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push((
            "BandwidthPackageId".into(),
            (&self.bandwidth_package_id).into(),
        ));

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push(("IpCount".into(), (&self.ip_count).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeVRouters {
    #[setters(generate = true, strip_option)]
    v_router_id: Option<String>,
    region_id: String,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeVRouters {}

impl DescribeVRouters {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            v_router_id: None,
            region_id: region_id.into(),
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeVRouters {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeVRouters {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeVRouters";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeVRoutersResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.v_router_id {
            params.push(("VRouterId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct CreateRouteEntry {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    route_table_id: String,
    destination_cidr_block: String,
    #[setters(generate = true, strip_option)]
    next_hop_id: Option<String>,
    #[setters(generate = true, strip_option)]
    client_token: Option<String>,
    #[setters(generate = true, strip_option)]
    next_hop_type: Option<String>,
    #[setters(generate = true, strip_option)]
    next_hop_list: Option<Vec<CreateRouteEntryNextHopList>>,
}

impl sealed::Bound for CreateRouteEntry {}

impl CreateRouteEntry {
    pub fn new(
        route_table_id: impl Into<String>,
        destination_cidr_block: impl Into<String>,
    ) -> Self {
        Self {
            region_id: None,
            route_table_id: route_table_id.into(),
            destination_cidr_block: destination_cidr_block.into(),
            next_hop_id: None,
            client_token: None,
            next_hop_type: None,
            next_hop_list: None,
        }
    }
}
impl crate::ToFormData for CreateRouteEntry {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for CreateRouteEntry {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "CreateRouteEntry";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<CreateRouteEntryResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.client_token {
            params.push(("ClientToken".into(), (f).into()));
        }
        params.push((
            "DestinationCidrBlock".into(),
            (&self.destination_cidr_block).into(),
        ));

        if let Some(f) = &self.next_hop_id {
            params.push(("NextHopId".into(), (f).into()));
        }

        if let Some(f) = &self.next_hop_list {
            crate::FlatSerialize::flat_serialize(f, "NextHopList", &mut params);
        }

        if let Some(f) = &self.next_hop_type {
            params.push(("NextHopType".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }
        params.push(("RouteTableId".into(), (&self.route_table_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeForwardTableEntries {
    region_id: String,
    forward_table_id: String,
    #[setters(generate = true, strip_option)]
    forward_entry_id: Option<String>,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeForwardTableEntries {}

impl DescribeForwardTableEntries {
    pub fn new(region_id: impl Into<String>, forward_table_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            forward_table_id: forward_table_id.into(),
            forward_entry_id: None,
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeForwardTableEntries {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeForwardTableEntries {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeForwardTableEntries";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeForwardTableEntriesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.forward_entry_id {
            params.push(("ForwardEntryId".into(), (f).into()));
        }
        params.push(("ForwardTableId".into(), (&self.forward_table_id).into()));

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ModifyForwardEntry {
    forward_table_id: String,
    forward_entry_id: String,
    #[setters(generate = true, strip_option)]
    external_ip: Option<String>,
    #[setters(generate = true, strip_option)]
    external_port: Option<String>,
    #[setters(generate = true, strip_option)]
    internal_ip: Option<String>,
    #[setters(generate = true, strip_option)]
    internal_port: Option<String>,
    #[setters(generate = true, strip_option)]
    ip_protocol: Option<String>,
    region_id: String,
}

impl sealed::Bound for ModifyForwardEntry {}

impl ModifyForwardEntry {
    pub fn new(
        forward_table_id: impl Into<String>,
        forward_entry_id: impl Into<String>,
        region_id: impl Into<String>,
    ) -> Self {
        Self {
            forward_table_id: forward_table_id.into(),
            forward_entry_id: forward_entry_id.into(),
            external_ip: None,
            external_port: None,
            internal_ip: None,
            internal_port: None,
            ip_protocol: None,
            region_id: region_id.into(),
        }
    }
}
impl crate::ToFormData for ModifyForwardEntry {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ModifyForwardEntry {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ModifyForwardEntry";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ModifyForwardEntryResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.external_ip {
            params.push(("ExternalIp".into(), (f).into()));
        }

        if let Some(f) = &self.external_port {
            params.push(("ExternalPort".into(), (f).into()));
        }
        params.push(("ForwardEntryId".into(), (&self.forward_entry_id).into()));
        params.push(("ForwardTableId".into(), (&self.forward_table_id).into()));

        if let Some(f) = &self.internal_ip {
            params.push(("InternalIp".into(), (f).into()));
        }

        if let Some(f) = &self.internal_port {
            params.push(("InternalPort".into(), (f).into()));
        }

        if let Some(f) = &self.ip_protocol {
            params.push(("IpProtocol".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeAccessPoints {
    region_id: String,
    #[setters(generate = true, strip_option, rename = "r#type")]
    r#type: Option<String>,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    #[setters(generate = true, strip_option)]
    filter: Option<Vec<PointsFilter>>,
}

impl sealed::Bound for DescribeAccessPoints {}

impl DescribeAccessPoints {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            r#type: None,
            page_number: None,
            page_size: None,
            filter: None,
        }
    }
}
impl crate::ToFormData for DescribeAccessPoints {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeAccessPoints {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeAccessPoints";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeAccessPointsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.filter {
            crate::FlatSerialize::flat_serialize(f, "Filter", &mut params);
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.r#type {
            params.push(("Type".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeRouteTables {
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    #[setters(generate = true, strip_option)]
    v_router_id: Option<String>,
    #[setters(generate = true, strip_option)]
    route_table_id: Option<String>,
    #[setters(generate = true, strip_option)]
    router_type: Option<String>,
    #[setters(generate = true, strip_option)]
    router_id: Option<String>,
    #[setters(generate = true, strip_option)]
    route_table_name: Option<String>,
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
}

impl sealed::Bound for DescribeRouteTables {}

impl DescribeRouteTables {
    pub fn new() -> Self {
        Self {
            region_id: None,
            v_router_id: None,
            route_table_id: None,
            router_type: None,
            router_id: None,
            route_table_name: None,
            page_number: None,
            page_size: None,
        }
    }
}
impl crate::ToFormData for DescribeRouteTables {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeRouteTables {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeRouteTables";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeRouteTablesResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(8);

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        if let Some(f) = &self.route_table_id {
            params.push(("RouteTableId".into(), (f).into()));
        }

        if let Some(f) = &self.route_table_name {
            params.push(("RouteTableName".into(), (f).into()));
        }

        if let Some(f) = &self.router_id {
            params.push(("RouterId".into(), (f).into()));
        }

        if let Some(f) = &self.router_type {
            params.push(("RouterType".into(), (f).into()));
        }

        if let Some(f) = &self.v_router_id {
            params.push(("VRouterId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ConnectRouterInterface {
    region_id: String,
    router_interface_id: String,
}

impl sealed::Bound for ConnectRouterInterface {}

impl ConnectRouterInterface {
    pub fn new(region_id: impl Into<String>, router_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            router_interface_id: router_interface_id.into(),
        }
    }
}
impl crate::ToFormData for ConnectRouterInterface {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ConnectRouterInterface {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ConnectRouterInterface";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ConnectRouterInterfaceResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push((
            "RouterInterfaceId".into(),
            (&self.router_interface_id).into(),
        ));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ExportSnapshot {
    snapshot_id: String,
    region_id: String,
    oss_bucket: String,
    #[setters(generate = true, strip_option)]
    role_name: Option<String>,
}

impl sealed::Bound for ExportSnapshot {}

impl ExportSnapshot {
    pub fn new(
        snapshot_id: impl Into<String>,
        region_id: impl Into<String>,
        oss_bucket: impl Into<String>,
    ) -> Self {
        Self {
            snapshot_id: snapshot_id.into(),
            region_id: region_id.into(),
            oss_bucket: oss_bucket.into(),
            role_name: None,
        }
    }
}
impl crate::ToFormData for ExportSnapshot {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ExportSnapshot {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ExportSnapshot";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ExportSnapshotResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("OssBucket".into(), (&self.oss_bucket).into()));
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.role_name {
            params.push(("RoleName".into(), (f).into()));
        }
        params.push(("SnapshotId".into(), (&self.snapshot_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct ReleasePublicIpAddress {
    /// 实例所属地域ID。
    #[setters(generate = true, strip_option)]
    region_id: Option<String>,
    /// 指定的实例ID。
    #[setters(generate = true, strip_option)]
    instance_id: Option<String>,
    /// 实例公网IP地址。
    public_ip_address: String,
    /// >该参数暂未开放使用。
    #[setters(generate = true, strip_option)]
    dry_run: Option<bool>,
}

impl sealed::Bound for ReleasePublicIpAddress {}

impl ReleasePublicIpAddress {
    pub fn new(public_ip_address: impl Into<String>) -> Self {
        Self {
            region_id: None,
            instance_id: None,
            public_ip_address: public_ip_address.into(),
            dry_run: None,
        }
    }
}
impl crate::ToFormData for ReleasePublicIpAddress {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for ReleasePublicIpAddress {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "ReleasePublicIpAddress";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<ReleasePublicIpAddressResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);

        if let Some(f) = &self.dry_run {
            params.push(("DryRun".into(), (f).into()));
        }

        if let Some(f) = &self.instance_id {
            params.push(("InstanceId".into(), (f).into()));
        }
        params.push(("PublicIpAddress".into(), (&self.public_ip_address).into()));

        if let Some(f) = &self.region_id {
            params.push(("RegionId".into(), (f).into()));
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct AddTags {
    /// 资源所在的地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 资源类型定义。取值范围：
    ///
    /// - instance：ECS实例
    /// - disk：磁盘
    /// - snapshot：快照
    /// - image：镜像
    /// - securitygroup：安全组
    /// - volume：存储卷
    /// - eni：弹性网卡
    /// - ddh：专有宿主机
    /// - keypair：SSH密钥对
    /// - launchtemplate：启动模板
    /// - reservedinstance：预留实例券
    /// - snapshotpolicy：自动快照策略
    ///
    /// 以上取值均为小写。
    resource_type: String,
    /// 要绑定标签的资源ID。例如，当资源类型（ResourceType）为实例（instance）时，资源ID可以理解为实例ID。
    resource_id: String,
    /// 标签列表
    tag: Vec<AddTagsTag>,
}

impl sealed::Bound for AddTags {}

impl AddTags {
    pub fn new(
        region_id: impl Into<String>,
        resource_type: impl Into<String>,
        resource_id: impl Into<String>,
        tag: impl Into<Vec<AddTagsTag>>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            resource_type: resource_type.into(),
            resource_id: resource_id.into(),
            tag: tag.into(),
        }
    }
}
impl crate::ToFormData for AddTags {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for AddTags {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "AddTags";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<AddTagsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("ResourceId".into(), (&self.resource_id).into()));
        params.push(("ResourceType".into(), (&self.resource_type).into()));
        crate::FlatSerialize::flat_serialize(&self.tag, "Tag", &mut params);

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeResourceByTags {
    /// 查询结果显示的每页的信息条目数。最大值：100。
    ///
    /// 默认值：50。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    /// 查询结果显示的页码。起始值：1。
    ///
    /// 默认值：1。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 资源类型。取值范围：
    ///
    /// - instance：ECS实例。
    /// - disk：磁盘。
    /// - snapshot：快照。
    /// - image：镜像。
    /// - securitygroup：安全组。
    /// - volume：存储卷。
    /// - eni：弹性网卡。
    /// - ddh：专有宿主机。
    /// - keypair：SSH密钥对。
    /// - launchtemplate：启动模板。
    ///
    /// 以上取值均为小写。
    #[setters(generate = true, strip_option)]
    resource_type: Option<String>,
    /// 资源所属的地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<ByTagsTag>>,
}

impl sealed::Bound for DescribeResourceByTags {}

impl DescribeResourceByTags {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            page_size: None,
            page_number: None,
            resource_type: None,
            region_id: region_id.into(),
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeResourceByTags {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeResourceByTags {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeResourceByTags";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeResourceByTagsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(5);

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_type {
            params.push(("ResourceType".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DescribeTags {
    ///  分页查询时设置的每页行数。
    ///
    /// 最大值：100。
    ///
    /// 默认值：50 。
    #[setters(generate = true, strip_option)]
    page_size: Option<i32>,
    ///  标签列表的页码。
    ///
    /// 起始值：1。
    ///
    /// 默认值：1 。
    #[setters(generate = true, strip_option)]
    page_number: Option<i32>,
    /// 资源类型定义。取值范围：
    ///
    /// - instance：ECS实例。
    /// - disk：磁盘。
    /// - snapshot：快照。
    /// - image：镜像。
    /// - securitygroup：安全组。
    /// - volume：存储卷。
    /// - eni：弹性网卡。
    /// - ddh：专有宿主机。
    /// - keypair：SSH密钥对。
    /// - launchtemplate：启动模板。
    /// - reservedinstance：预留实例券。
    /// - snapshotpolicy：自动快照策略。
    ///
    /// 以上取值均为小写。
    #[setters(generate = true, strip_option)]
    resource_type: Option<String>,
    /// 标签绑定的资源ID。例如，当资源类型（ResourceType）为实例（instance）时，资源ID可以理解为实例ID。
    #[setters(generate = true, strip_option)]
    resource_id: Option<String>,
    /// 地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    ///
    /// > 该参数即将被弃用，为提高兼容性，建议您尽量使用其他参数。
    #[setters(generate = true, strip_option)]
    category: Option<String>,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<DescribeTagsTag>>,
}

impl sealed::Bound for DescribeTags {}

impl DescribeTags {
    pub fn new(region_id: impl Into<String>) -> Self {
        Self {
            page_size: None,
            page_number: None,
            resource_type: None,
            resource_id: None,
            region_id: region_id.into(),
            category: None,
            tag: None,
        }
    }
}
impl crate::ToFormData for DescribeTags {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DescribeTags {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DescribeTags";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DescribeTagsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(7);

        if let Some(f) = &self.category {
            params.push(("Category".into(), (f).into()));
        }

        if let Some(f) = &self.page_number {
            params.push(("PageNumber".into(), (f).into()));
        }

        if let Some(f) = &self.page_size {
            params.push(("PageSize".into(), (f).into()));
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        if let Some(f) = &self.resource_id {
            params.push(("ResourceId".into(), (f).into()));
        }

        if let Some(f) = &self.resource_type {
            params.push(("ResourceType".into(), (f).into()));
        }

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

///  
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct RemoveTags {
    /// 资源所属地域。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 资源类型定义。取值范围：
    ///
    /// - instance：ECS实例。
    /// - disk：磁盘。
    /// - snapshot：快照。
    /// - image：镜像。
    /// - securitygroup：安全组。
    /// - volume：存储卷。
    /// - eni：弹性网卡。
    /// - ddh：专有宿主机。
    /// - keypair：SSH密钥对。
    /// - launchtemplate：启动模板。
    /// - reservedinstance：预留实例券。
    /// - snapshotpolicy：自动快照策略。
    ///
    /// 以上取值均为小写。
    resource_type: String,
    /// 要解绑标签的资源ID。例如，当资源类型（ResourceType）为实例（instance）时，资源ID可以理解为实例ID。
    resource_id: String,
    /// 标签列表。
    #[setters(generate = true, strip_option)]
    tag: Option<Vec<RemoveTagsTag>>,
}

impl sealed::Bound for RemoveTags {}

impl RemoveTags {
    pub fn new(
        region_id: impl Into<String>,
        resource_type: impl Into<String>,
        resource_id: impl Into<String>,
    ) -> Self {
        Self {
            region_id: region_id.into(),
            resource_type: resource_type.into(),
            resource_id: resource_id.into(),
            tag: None,
        }
    }
}
impl crate::ToFormData for RemoveTags {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for RemoveTags {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "RemoveTags";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<RemoveTagsResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(4);
        params.push(("RegionId".into(), (&self.region_id).into()));
        params.push(("ResourceId".into(), (&self.resource_id).into()));
        params.push(("ResourceType".into(), (&self.resource_type).into()));

        if let Some(f) = &self.tag {
            crate::FlatSerialize::flat_serialize(f, "Tag", &mut params);
        }

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct EnableNetworkInterfaceQoS {
    /// 地域ID。您可以调用DescribeRegions查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡的ID。
    network_interface_id: String,
    /// QoS 限速设置
    #[setters(generate = true, strip_option)]
    qo_s: Option<SQoS>,
}

impl sealed::Bound for EnableNetworkInterfaceQoS {}

impl EnableNetworkInterfaceQoS {
    pub fn new(region_id: impl Into<String>, network_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_id: network_interface_id.into(),
            qo_s: None,
        }
    }
}
impl crate::ToFormData for EnableNetworkInterfaceQoS {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for EnableNetworkInterfaceQoS {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "EnableNetworkInterfaceQoS";
    const URL_PATH: &'static str = "";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<EnableNetworkInterfaceQoSResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(3);
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));

        if let Some(f) = &self.qo_s {
            crate::FlatSerialize::flat_serialize(f, "QoS", &mut params);
        }
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}
#[derive(derive_setters::Setters, Debug)]
#[setters(generate = false)]
pub struct DisableNetworkInterfaceQoS {
    /// 所在地域ID。您可以调用[DescribeRegions](~~25609~~)查看最新的阿里云地域列表。
    region_id: String,
    /// 弹性网卡ID。
    network_interface_id: String,
}

impl sealed::Bound for DisableNetworkInterfaceQoS {}

impl DisableNetworkInterfaceQoS {
    pub fn new(region_id: impl Into<String>, network_interface_id: impl Into<String>) -> Self {
        Self {
            region_id: region_id.into(),
            network_interface_id: network_interface_id.into(),
        }
    }
}
impl crate::ToFormData for DisableNetworkInterfaceQoS {
    fn to_form_data(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        Default::default()
    }
}

impl crate::Request for DisableNetworkInterfaceQoS {
    const METHOD: http::Method = http::Method::POST;

    const ACTION: &'static str = "DisableNetworkInterfaceQoS";
    const URL_PATH: &'static str = "";

    type Body = crate::Form<Self>;

    type ResponseWrap = crate::JsonResponseWrap<DisableNetworkInterfaceQoSResponse>;

    fn to_query_params(&self) -> Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'_>)> {
        let mut params = Vec::with_capacity(2);
        params.push((
            "NetworkInterfaceId".into(),
            (&self.network_interface_id).into(),
        ));
        params.push(("RegionId".into(), (&self.region_id).into()));

        params
    }

    fn to_headers(&self) -> Vec<(std::borrow::Cow<'static, str>, String)> {
        Default::default()
    }

    fn to_body(self) -> Self::Body {
        crate::Form(self)
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RegionsRegion {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "RegionEndpoint")]
    pub region_endpoint: String,
    #[serde(rename = "LocalName")]
    pub local_name: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
}

impl crate::FlatSerialize for RegionsRegion {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.region_endpoint,
            &format!("{}.RegionEndpoint", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_name,
            &format!("{}.LocalName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseRegions {
    #[serde(rename = "Region")]
    pub region: Vec<RegionsRegion>,
}

impl crate::FlatSerialize for ResponseRegions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.region, &format!("{}.Region", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SystemDiskCategories {
    #[serde(rename = "supportedSystemDiskCategory")]
    pub supported_system_disk_category: Vec<String>,
}

impl crate::FlatSerialize for SystemDiskCategories {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_system_disk_category,
            &format!("{}.supportedSystemDiskCategory", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceGenerations {
    #[serde(rename = "supportedInstanceGeneration")]
    pub supported_instance_generation: Vec<String>,
}

impl crate::FlatSerialize for InstanceGenerations {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_instance_generation,
            &format!("{}.supportedInstanceGeneration", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DataDiskCategories {
    #[serde(rename = "supportedDataDiskCategory")]
    pub supported_data_disk_category: Vec<String>,
}

impl crate::FlatSerialize for DataDiskCategories {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_data_disk_category,
            &format!("{}.supportedDataDiskCategory", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemInstanceTypes {
    #[serde(rename = "supportedInstanceType")]
    pub supported_instance_type: Vec<String>,
}

impl crate::FlatSerialize for ItemInstanceTypes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_instance_type,
            &format!("{}.supportedInstanceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemInstanceTypeFamilies {
    #[serde(rename = "supportedInstanceTypeFamily")]
    pub supported_instance_type_family: Vec<String>,
}

impl crate::FlatSerialize for ItemInstanceTypeFamilies {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_instance_type_family,
            &format!("{}.supportedInstanceTypeFamily", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InfoItemNetworkTypes {
    #[serde(rename = "supportedNetworkCategory")]
    pub supported_network_category: Vec<String>,
}

impl crate::FlatSerialize for InfoItemNetworkTypes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_network_category,
            &format!("{}.supportedNetworkCategory", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResourcesInfo {
    #[serde(rename = "IoOptimized")]
    pub io_optimized: bool,
    #[serde(rename = "SystemDiskCategories")]
    pub system_disk_categories: SystemDiskCategories,
    #[serde(rename = "InstanceGenerations")]
    pub instance_generations: InstanceGenerations,
    #[serde(rename = "DataDiskCategories")]
    pub data_disk_categories: DataDiskCategories,
    #[serde(rename = "InstanceTypes")]
    pub instance_types: ItemInstanceTypes,
    #[serde(rename = "InstanceTypeFamilies")]
    pub instance_type_families: ItemInstanceTypeFamilies,
    #[serde(rename = "NetworkTypes")]
    pub network_types: InfoItemNetworkTypes,
}

impl crate::FlatSerialize for ResourcesInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.io_optimized,
            &format!("{}.IoOptimized", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_categories,
            &format!("{}.SystemDiskCategories", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_generations,
            &format!("{}.InstanceGenerations", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.data_disk_categories,
            &format!("{}.DataDiskCategories", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_types,
            &format!("{}.InstanceTypes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type_families,
            &format!("{}.InstanceTypeFamilies", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_types,
            &format!("{}.NetworkTypes", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ZonesZoneItemAvailableResources {
    #[serde(rename = "ResourcesInfo")]
    pub resources_info: Vec<ResourcesInfo>,
}

impl crate::FlatSerialize for ZonesZoneItemAvailableResources {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.resources_info,
            &format!("{}.ResourcesInfo", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResourceCreation {
    #[serde(rename = "ResourceTypes")]
    pub resource_types: Vec<String>,
}

impl crate::FlatSerialize for ResourceCreation {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.resource_types,
            &format!("{}.ResourceTypes", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostGenerations {
    #[serde(rename = "DedicatedHostGeneration")]
    pub dedicated_host_generation: Vec<String>,
}

impl crate::FlatSerialize for HostGenerations {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_generation,
            &format!("{}.DedicatedHostGeneration", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemAvailableInstanceTypes {
    #[serde(rename = "InstanceTypes")]
    pub instance_types: Vec<String>,
}

impl crate::FlatSerialize for ItemAvailableInstanceTypes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_types,
            &format!("{}.InstanceTypes", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AvailableDiskCategories {
    #[serde(rename = "DiskCategories")]
    pub disk_categories: Vec<String>,
}

impl crate::FlatSerialize for AvailableDiskCategories {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.disk_categories,
            &format!("{}.DiskCategories", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AvailableDedicatedHostTypes {
    #[serde(rename = "DedicatedHostType")]
    pub dedicated_host_type: Vec<String>,
}

impl crate::FlatSerialize for AvailableDedicatedHostTypes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_type,
            &format!("{}.DedicatedHostType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VolumeCategories {
    #[serde(rename = "VolumeCategories")]
    pub volume_categories: Vec<String>,
}

impl crate::FlatSerialize for VolumeCategories {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.volume_categories,
            &format!("{}.VolumeCategories", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseZonesZone {
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "ZoneType")]
    pub zone_type: String,
    #[serde(rename = "LocalName")]
    pub local_name: String,
    #[serde(rename = "AvailableResources")]
    pub available_resources: ZonesZoneItemAvailableResources,
    #[serde(rename = "AvailableResourceCreation")]
    pub available_resource_creation: ResourceCreation,
    #[serde(rename = "DedicatedHostGenerations")]
    pub dedicated_host_generations: HostGenerations,
    #[serde(rename = "AvailableInstanceTypes")]
    pub available_instance_types: ItemAvailableInstanceTypes,
    #[serde(rename = "AvailableDiskCategories")]
    pub available_disk_categories: AvailableDiskCategories,
    #[serde(rename = "AvailableDedicatedHostTypes")]
    pub available_dedicated_host_types: AvailableDedicatedHostTypes,
    #[serde(rename = "AvailableVolumeCategories")]
    pub available_volume_categories: VolumeCategories,
}

impl crate::FlatSerialize for ResponseZonesZone {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.zone_type,
            &format!("{}.ZoneType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_name,
            &format!("{}.LocalName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_resources,
            &format!("{}.AvailableResources", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_resource_creation,
            &format!("{}.AvailableResourceCreation", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_generations,
            &format!("{}.DedicatedHostGenerations", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_instance_types,
            &format!("{}.AvailableInstanceTypes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_disk_categories,
            &format!("{}.AvailableDiskCategories", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_dedicated_host_types,
            &format!("{}.AvailableDedicatedHostTypes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_volume_categories,
            &format!("{}.AvailableVolumeCategories", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseZones {
    #[serde(rename = "Zone")]
    pub zone: Vec<ResponseZonesZone>,
}

impl crate::FlatSerialize for ResponseZones {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.zone, &format!("{}.Zone", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResourceResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResourcesSupportedResource
{
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Max")]
    pub max: i32,
    #[serde(rename = "Unit")]
    pub unit: String,
    #[serde(rename = "StatusCategory")]
    pub status_category: String,
    #[serde(rename = "Min")]
    pub min: i32,
}

impl crate::FlatSerialize for ResourceResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResourcesSupportedResource {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.max, &format!("{}.Max", name), params);
        crate::FlatSerialize::flat_serialize(&self.unit, &format!("{}.Unit", name), params);
        crate::FlatSerialize::flat_serialize(&self.status_category, &format!("{}.StatusCategory", name), params);
        crate::FlatSerialize::flat_serialize(&self.min, &format!("{}.Min", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResourceResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResources {
    #[serde(rename = "SupportedResource")]
    pub supported_resource: Vec<ResourceResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResourcesSupportedResource>,
}

impl crate::FlatSerialize for ResourceResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResources {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.supported_resource, &format!("{}.SupportedResource", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResourceResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResource {
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "SupportedResources")]
    pub supported_resources: ResourceResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResources,
}

impl crate::FlatSerialize
    for ResourceResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResource
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.supported_resources,
            &format!("{}.SupportedResources", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResourceResponseAvailableZonesAvailableZoneItemAvailableResources {
    #[serde(rename = "AvailableResource")]
    pub available_resource:
        Vec<ResourceResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResource>,
}

impl crate::FlatSerialize for ResourceResponseAvailableZonesAvailableZoneItemAvailableResources {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.available_resource,
            &format!("{}.AvailableResource", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResourceResponseAvailableZonesAvailableZone {
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "StatusCategory")]
    pub status_category: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "AvailableResources")]
    pub available_resources: ResourceResponseAvailableZonesAvailableZoneItemAvailableResources,
}

impl crate::FlatSerialize for ResourceResponseAvailableZonesAvailableZone {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.status_category,
            &format!("{}.StatusCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_resources,
            &format!("{}.AvailableResources", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResourceResponseAvailableZones {
    #[serde(rename = "AvailableZone")]
    pub available_zone: Vec<ResourceResponseAvailableZonesAvailableZone>,
}

impl crate::FlatSerialize for ResourceResponseAvailableZones {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.available_zone,
            &format!("{}.AvailableZone", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ValueItem {
    #[serde(rename = "DiskCategory")]
    pub disk_category: String,
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "ExpiredTime")]
    pub expired_time: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "Count")]
    pub count: i32,
    #[serde(rename = "InstanceChargeType")]
    pub instance_charge_type: String,
}

impl crate::FlatSerialize for ValueItem {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.disk_category,
            &format!("{}.DiskCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.expired_time,
            &format!("{}.ExpiredTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.count, &format!("{}.Count", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_charge_type,
            &format!("{}.InstanceChargeType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeValues {
    #[serde(rename = "ValueItem")]
    pub value_item: Vec<ValueItem>,
}

impl crate::FlatSerialize for AttributeValues {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.value_item,
            &format!("{}.ValueItem", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeItem {
    #[serde(rename = "AttributeName")]
    pub attribute_name: String,
    #[serde(rename = "AttributeValues")]
    pub attribute_values: AttributeValues,
}

impl crate::FlatSerialize for AttributeItem {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.attribute_name,
            &format!("{}.AttributeName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.attribute_values,
            &format!("{}.AttributeValues", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeItems {
    #[serde(rename = "AccountAttributeItem")]
    pub account_attribute_item: Vec<AttributeItem>,
}

impl crate::FlatSerialize for AttributeItems {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.account_attribute_item,
            &format!("{}.AccountAttributeItem", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResourcesSupportedResource
{
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Max")]
    pub max: i32,
    #[serde(rename = "Unit")]
    pub unit: String,
    #[serde(rename = "StatusCategory")]
    pub status_category: String,
    #[serde(rename = "Min")]
    pub min: i32,
}

impl crate::FlatSerialize for ModificationResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResourcesSupportedResource {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.max, &format!("{}.Max", name), params);
        crate::FlatSerialize::flat_serialize(&self.unit, &format!("{}.Unit", name), params);
        crate::FlatSerialize::flat_serialize(&self.status_category, &format!("{}.StatusCategory", name), params);
        crate::FlatSerialize::flat_serialize(&self.min, &format!("{}.Min", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResources {
    #[serde(rename = "SupportedResource")]
    pub supported_resource: Vec<ModificationResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResourcesSupportedResource>,
}

impl crate::FlatSerialize for ModificationResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResources {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.supported_resource, &format!("{}.SupportedResource", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConditionsCondition {
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for ConditionsCondition {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemConditions {
    #[serde(rename = "Condition")]
    pub condition: Vec<ConditionsCondition>,
}

impl crate::FlatSerialize for ItemConditions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.condition,
            &format!("{}.Condition", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConditionSupportedResource {
    #[serde(rename = "Conditions")]
    pub conditions: ItemConditions,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Max")]
    pub max: i32,
    #[serde(rename = "Unit")]
    pub unit: String,
    #[serde(rename = "StatusCategory")]
    pub status_category: String,
    #[serde(rename = "Min")]
    pub min: i32,
}

impl crate::FlatSerialize for ConditionSupportedResource {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.conditions,
            &format!("{}.Conditions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.max, &format!("{}.Max", name), params);
        crate::FlatSerialize::flat_serialize(&self.unit, &format!("{}.Unit", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.status_category,
            &format!("{}.StatusCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.min, &format!("{}.Min", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConditionSupportedResources {
    #[serde(rename = "ConditionSupportedResource")]
    pub condition_supported_resource: Vec<ConditionSupportedResource>,
}

impl crate::FlatSerialize for ConditionSupportedResources {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.condition_supported_resource,
            &format!("{}.ConditionSupportedResource", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResource {
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "SupportedResources")]
    pub supported_resources: ModificationResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResourceItemSupportedResources,
    #[serde(rename = "ConditionSupportedResources")]
    pub condition_supported_resources: ConditionSupportedResources,
}

impl crate::FlatSerialize
    for ModificationResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResource
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.supported_resources,
            &format!("{}.SupportedResources", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.condition_supported_resources,
            &format!("{}.ConditionSupportedResources", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationResponseAvailableZonesAvailableZoneItemAvailableResources {
    #[serde(rename = "AvailableResource")]
    pub available_resource:
        Vec<ModificationResponseAvailableZonesAvailableZoneItemAvailableResourcesAvailableResource>,
}

impl crate::FlatSerialize
    for ModificationResponseAvailableZonesAvailableZoneItemAvailableResources
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.available_resource,
            &format!("{}.AvailableResource", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationResponseAvailableZonesAvailableZone {
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "StatusCategory")]
    pub status_category: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "AvailableResources")]
    pub available_resources: ModificationResponseAvailableZonesAvailableZoneItemAvailableResources,
}

impl crate::FlatSerialize for ModificationResponseAvailableZonesAvailableZone {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.status_category,
            &format!("{}.StatusCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_resources,
            &format!("{}.AvailableResources", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationResponseAvailableZones {
    #[serde(rename = "AvailableZone")]
    pub available_zone: Vec<ModificationResponseAvailableZonesAvailableZone>,
}

impl crate::FlatSerialize for ModificationResponseAvailableZones {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.available_zone,
            &format!("{}.AvailableZone", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ZoneItemNetworkTypes {
    #[serde(rename = "NetworkType")]
    pub network_type: Vec<String>,
}

impl crate::FlatSerialize for ZoneItemNetworkTypes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.network_type,
            &format!("{}.NetworkType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemZonesZone {
    #[serde(rename = "ZoneNo")]
    pub zone_no: String,
    #[serde(rename = "NetworkTypes")]
    pub network_types: ZoneItemNetworkTypes,
}

impl crate::FlatSerialize for ItemZonesZone {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.zone_no, &format!("{}.ZoneNo", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.network_types,
            &format!("{}.NetworkTypes", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemZones {
    #[serde(rename = "zone")]
    pub zone: Vec<ItemZonesZone>,
}

impl crate::FlatSerialize for ItemZones {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.zone, &format!("{}.zone", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemInstanceType {
    #[serde(rename = "SupportIoOptimized")]
    pub support_io_optimized: String,
    #[serde(rename = "Cores")]
    pub cores: i32,
    #[serde(rename = "Memory")]
    pub memory: i32,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "InstanceTypeFamily")]
    pub instance_type_family: String,
    #[serde(rename = "Generation")]
    pub generation: String,
}

impl crate::FlatSerialize for ItemInstanceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.support_io_optimized,
            &format!("{}.SupportIoOptimized", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.cores, &format!("{}.Cores", name), params);
        crate::FlatSerialize::flat_serialize(&self.memory, &format!("{}.Memory", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type_family,
            &format!("{}.InstanceTypeFamily", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.generation,
            &format!("{}.Generation", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RecommendInstanceType {
    #[serde(rename = "CommodityCode")]
    pub commodity_code: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "Priority")]
    pub priority: i32,
    #[serde(rename = "NetworkType")]
    pub network_type: String,
    #[serde(rename = "Scene")]
    pub scene: String,
    #[serde(rename = "SpotStrategy")]
    pub spot_strategy: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "InstanceChargeType")]
    pub instance_charge_type: String,
    #[serde(rename = "Zones")]
    pub zones: ItemZones,
    #[serde(rename = "InstanceType")]
    pub instance_type: ItemInstanceType,
}

impl crate::FlatSerialize for RecommendInstanceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.commodity_code,
            &format!("{}.CommodityCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(&self.priority, &format!("{}.Priority", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.network_type,
            &format!("{}.NetworkType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.scene, &format!("{}.Scene", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.spot_strategy,
            &format!("{}.SpotStrategy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_charge_type,
            &format!("{}.InstanceChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zones, &format!("{}.Zones", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseData {
    #[serde(rename = "RecommendInstanceType")]
    pub recommend_instance_type: Vec<RecommendInstanceType>,
}

impl crate::FlatSerialize for ResponseData {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.recommend_instance_type,
            &format!("{}.RecommendInstanceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribePriceDataDisk {
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "Size")]
    pub size: i64,
    #[serde(rename = "PerformanceLevel")]
    pub performance_level: String,
    #[serde(rename = "ProvisionedIops")]
    pub provisioned_iops: i64,
}

impl crate::FlatSerialize for DescribePriceDataDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.performance_level,
            &format!("{}.PerformanceLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.provisioned_iops,
            &format!("{}.ProvisionedIops", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PriceRecurrenceRule {
    #[serde(rename = "StartHour")]
    pub start_hour: i32,
    #[serde(rename = "RecurrenceType")]
    pub recurrence_type: String,
    #[serde(rename = "EndHour")]
    pub end_hour: i32,
    #[serde(rename = "RecurrenceValue")]
    pub recurrence_value: String,
}

impl crate::FlatSerialize for PriceRecurrenceRule {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.start_hour,
            &format!("{}.StartHour", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.recurrence_type,
            &format!("{}.RecurrenceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.end_hour, &format!("{}.EndHour", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.recurrence_value,
            &format!("{}.RecurrenceValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribePriceResponsePriceInfoRulesRule {
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RuleId")]
    pub rule_id: i64,
}

impl crate::FlatSerialize for DescribePriceResponsePriceInfoRulesRule {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rule_id, &format!("{}.RuleId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribePriceResponsePriceInfoRules {
    #[serde(rename = "Rule")]
    pub rule: Vec<DescribePriceResponsePriceInfoRulesRule>,
}

impl crate::FlatSerialize for DescribePriceResponsePriceInfoRules {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.rule, &format!("{}.Rule", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribePriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRulesRule {
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RuleId")]
    pub rule_id: i64,
}

impl crate::FlatSerialize
    for DescribePriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRulesRule
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rule_id, &format!("{}.RuleId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribePriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRules {
    #[serde(rename = "Rule")]
    pub rule: Vec<DescribePriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRulesRule>,
}

impl crate::FlatSerialize for DescribePriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRules {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.rule, &format!("{}.Rule", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribePriceResponsePriceInfoPriceDetailInfosDetailInfo {
    #[serde(rename = "OriginalPrice")]
    pub original_price: f32,
    #[serde(rename = "DiscountPrice")]
    pub discount_price: f32,
    #[serde(rename = "Resource")]
    pub resource: String,
    #[serde(rename = "SubRules")]
    pub sub_rules: DescribePriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRules,
    #[serde(rename = "TradePrice")]
    pub trade_price: f32,
}

impl crate::FlatSerialize for DescribePriceResponsePriceInfoPriceDetailInfosDetailInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.original_price,
            &format!("{}.OriginalPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.discount_price,
            &format!("{}.DiscountPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.resource, &format!("{}.Resource", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.sub_rules,
            &format!("{}.SubRules", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.trade_price,
            &format!("{}.TradePrice", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribePriceResponsePriceInfoPriceDetailInfos {
    #[serde(rename = "DetailInfo")]
    pub detail_info: Vec<DescribePriceResponsePriceInfoPriceDetailInfosDetailInfo>,
}

impl crate::FlatSerialize for DescribePriceResponsePriceInfoPriceDetailInfos {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.detail_info,
            &format!("{}.DetailInfo", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribePriceResponsePriceInfoPrice {
    #[serde(rename = "OriginalPrice")]
    pub original_price: f32,
    #[serde(rename = "ReservedInstanceHourPrice")]
    pub reserved_instance_hour_price: f32,
    #[serde(rename = "DiscountPrice")]
    pub discount_price: f32,
    #[serde(rename = "Currency")]
    pub currency: String,
    #[serde(rename = "TradePrice")]
    pub trade_price: f32,
    #[serde(rename = "DetailInfos")]
    pub detail_infos: DescribePriceResponsePriceInfoPriceDetailInfos,
}

impl crate::FlatSerialize for DescribePriceResponsePriceInfoPrice {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.original_price,
            &format!("{}.OriginalPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance_hour_price,
            &format!("{}.ReservedInstanceHourPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.discount_price,
            &format!("{}.DiscountPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.currency, &format!("{}.Currency", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.trade_price,
            &format!("{}.TradePrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.detail_infos,
            &format!("{}.DetailInfos", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImagePrice {
    #[serde(rename = "Currency")]
    pub currency: String,
    #[serde(rename = "OriginalPrice")]
    pub original_price: f32,
    #[serde(rename = "DiscountPrice")]
    pub discount_price: f32,
    #[serde(rename = "TradePrice")]
    pub trade_price: f32,
}

impl crate::FlatSerialize for ImagePrice {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.currency, &format!("{}.Currency", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.original_price,
            &format!("{}.OriginalPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.discount_price,
            &format!("{}.DiscountPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.trade_price,
            &format!("{}.TradePrice", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RelatedPrice {
    #[serde(rename = "MarketplaceImagePrice")]
    pub marketplace_image_price: ImagePrice,
}

impl crate::FlatSerialize for RelatedPrice {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.marketplace_image_price,
            &format!("{}.MarketplaceImagePrice", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribePriceResponsePriceInfo {
    #[serde(rename = "Rules")]
    pub rules: DescribePriceResponsePriceInfoRules,
    #[serde(rename = "Price")]
    pub price: DescribePriceResponsePriceInfoPrice,
    #[serde(rename = "RelatedPrice")]
    pub related_price: RelatedPrice,
}

impl crate::FlatSerialize for DescribePriceResponsePriceInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.rules, &format!("{}.Rules", name), params);
        crate::FlatSerialize::flat_serialize(&self.price, &format!("{}.Price", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.related_price,
            &format!("{}.RelatedPrice", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RenewalPriceResponsePriceInfoRulesRule {
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RuleId")]
    pub rule_id: i64,
}

impl crate::FlatSerialize for RenewalPriceResponsePriceInfoRulesRule {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rule_id, &format!("{}.RuleId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RenewalPriceResponsePriceInfoRules {
    #[serde(rename = "Rule")]
    pub rule: Vec<RenewalPriceResponsePriceInfoRulesRule>,
}

impl crate::FlatSerialize for RenewalPriceResponsePriceInfoRules {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.rule, &format!("{}.Rule", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RenewalPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRulesRule {
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RuleId")]
    pub rule_id: i64,
}

impl crate::FlatSerialize
    for RenewalPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRulesRule
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rule_id, &format!("{}.RuleId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RenewalPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRules {
    #[serde(rename = "Rule")]
    pub rule: Vec<RenewalPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRulesRule>,
}

impl crate::FlatSerialize for RenewalPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRules {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.rule, &format!("{}.Rule", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RenewalPriceResponsePriceInfoPriceDetailInfosDetailInfo {
    #[serde(rename = "Resource")]
    pub resource: String,
    #[serde(rename = "OriginalPrice")]
    pub original_price: f32,
    #[serde(rename = "DiscountPrice")]
    pub discount_price: f32,
    #[serde(rename = "TradePrice")]
    pub trade_price: f32,
    #[serde(rename = "SubRules")]
    pub sub_rules: RenewalPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRules,
}

impl crate::FlatSerialize for RenewalPriceResponsePriceInfoPriceDetailInfosDetailInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.resource, &format!("{}.Resource", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.original_price,
            &format!("{}.OriginalPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.discount_price,
            &format!("{}.DiscountPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.trade_price,
            &format!("{}.TradePrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.sub_rules,
            &format!("{}.SubRules", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RenewalPriceResponsePriceInfoPriceDetailInfos {
    #[serde(rename = "DetailInfo")]
    pub detail_info: Vec<RenewalPriceResponsePriceInfoPriceDetailInfosDetailInfo>,
}

impl crate::FlatSerialize for RenewalPriceResponsePriceInfoPriceDetailInfos {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.detail_info,
            &format!("{}.DetailInfo", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RenewalPriceResponsePriceInfoPrice {
    #[serde(rename = "OriginalPrice")]
    pub original_price: f32,
    #[serde(rename = "DiscountPrice")]
    pub discount_price: f32,
    #[serde(rename = "Currency")]
    pub currency: String,
    #[serde(rename = "TradePrice")]
    pub trade_price: f32,
    #[serde(rename = "DetailInfos")]
    pub detail_infos: RenewalPriceResponsePriceInfoPriceDetailInfos,
}

impl crate::FlatSerialize for RenewalPriceResponsePriceInfoPrice {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.original_price,
            &format!("{}.OriginalPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.discount_price,
            &format!("{}.DiscountPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.currency, &format!("{}.Currency", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.trade_price,
            &format!("{}.TradePrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.detail_infos,
            &format!("{}.DetailInfos", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RenewalPriceResponsePriceInfo {
    #[serde(rename = "Rules")]
    pub rules: RenewalPriceResponsePriceInfoRules,
    #[serde(rename = "Price")]
    pub price: RenewalPriceResponsePriceInfoPrice,
}

impl crate::FlatSerialize for RenewalPriceResponsePriceInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.rules, &format!("{}.Rules", name), params);
        crate::FlatSerialize::flat_serialize(&self.price, &format!("{}.Price", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationPriceDataDisk {
    #[serde(rename = "PerformanceLevel")]
    pub performance_level: String,
    #[serde(rename = "Size")]
    pub size: i32,
    #[serde(rename = "Category")]
    pub category: String,
}

impl crate::FlatSerialize for ModificationPriceDataDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.performance_level,
            &format!("{}.PerformanceLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationPriceResponsePriceInfoRulesRule {
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RuleId")]
    pub rule_id: i64,
}

impl crate::FlatSerialize for ModificationPriceResponsePriceInfoRulesRule {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rule_id, &format!("{}.RuleId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationPriceResponsePriceInfoRules {
    #[serde(rename = "Rule")]
    pub rule: Vec<ModificationPriceResponsePriceInfoRulesRule>,
}

impl crate::FlatSerialize for ModificationPriceResponsePriceInfoRules {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.rule, &format!("{}.Rule", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRulesRule {
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RuleId")]
    pub rule_id: i64,
}

impl crate::FlatSerialize
    for ModificationPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRulesRule
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rule_id, &format!("{}.RuleId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRules {
    #[serde(rename = "Rule")]
    pub rule: Vec<ModificationPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRulesRule>,
}

impl crate::FlatSerialize
    for ModificationPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRules
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.rule, &format!("{}.Rule", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationPriceResponsePriceInfoPriceDetailInfosDetailInfo {
    #[serde(rename = "Resource")]
    pub resource: String,
    #[serde(rename = "OriginalPrice")]
    pub original_price: f32,
    #[serde(rename = "DiscountPrice")]
    pub discount_price: f32,
    #[serde(rename = "TradePrice")]
    pub trade_price: f32,
    #[serde(rename = "SubRules")]
    pub sub_rules: ModificationPriceResponsePriceInfoPriceDetailInfosDetailInfoItemSubRules,
}

impl crate::FlatSerialize for ModificationPriceResponsePriceInfoPriceDetailInfosDetailInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.resource, &format!("{}.Resource", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.original_price,
            &format!("{}.OriginalPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.discount_price,
            &format!("{}.DiscountPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.trade_price,
            &format!("{}.TradePrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.sub_rules,
            &format!("{}.SubRules", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationPriceResponsePriceInfoPriceDetailInfos {
    #[serde(rename = "DetailInfo")]
    pub detail_info: Vec<ModificationPriceResponsePriceInfoPriceDetailInfosDetailInfo>,
}

impl crate::FlatSerialize for ModificationPriceResponsePriceInfoPriceDetailInfos {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.detail_info,
            &format!("{}.DetailInfo", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationPriceResponsePriceInfoPrice {
    #[serde(rename = "OriginalPrice")]
    pub original_price: f32,
    #[serde(rename = "DiscountPrice")]
    pub discount_price: f32,
    #[serde(rename = "Currency")]
    pub currency: String,
    #[serde(rename = "TradePrice")]
    pub trade_price: f32,
    #[serde(rename = "DetailInfos")]
    pub detail_infos: ModificationPriceResponsePriceInfoPriceDetailInfos,
}

impl crate::FlatSerialize for ModificationPriceResponsePriceInfoPrice {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.original_price,
            &format!("{}.OriginalPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.discount_price,
            &format!("{}.DiscountPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.currency, &format!("{}.Currency", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.trade_price,
            &format!("{}.TradePrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.detail_infos,
            &format!("{}.DetailInfos", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModificationPriceResponsePriceInfo {
    #[serde(rename = "Rules")]
    pub rules: ModificationPriceResponsePriceInfoRules,
    #[serde(rename = "Price")]
    pub price: ModificationPriceResponsePriceInfoPrice,
}

impl crate::FlatSerialize for ModificationPriceResponsePriceInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.rules, &format!("{}.Rules", name), params);
        crate::FlatSerialize::flat_serialize(&self.price, &format!("{}.Price", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesDataDisk {
    #[serde(rename = "PerformanceLevel")]
    pub performance_level: String,
    #[serde(rename = "AutoSnapshotPolicyId")]
    pub auto_snapshot_policy_id: String,
    #[serde(rename = "Encrypted")]
    pub encrypted: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "Size")]
    pub size: i32,
    #[serde(rename = "DiskName")]
    pub disk_name: String,
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "EncryptAlgorithm")]
    pub encrypt_algorithm: String,
    #[serde(rename = "DeleteWithInstance")]
    pub delete_with_instance: bool,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
    #[serde(rename = "StorageClusterId")]
    pub storage_cluster_id: String,
    #[serde(rename = "ProvisionedIops")]
    pub provisioned_iops: i64,
    #[serde(rename = "BurstingEnabled")]
    pub bursting_enabled: bool,
}

impl crate::FlatSerialize for InstancesDataDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.performance_level,
            &format!("{}.PerformanceLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy_id,
            &format!("{}.AutoSnapshotPolicyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.disk_name,
            &format!("{}.DiskName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.encrypt_algorithm,
            &format!("{}.EncryptAlgorithm", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.delete_with_instance,
            &format!("{}.DeleteWithInstance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.storage_cluster_id,
            &format!("{}.StorageClusterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.provisioned_iops,
            &format!("{}.ProvisionedIops", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bursting_enabled,
            &format!("{}.BurstingEnabled", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesArn {
    #[serde(rename = "RoleType")]
    pub role_type: String,
    #[serde(rename = "Rolearn")]
    pub rolearn: String,
    #[serde(rename = "AssumeRoleFor")]
    pub assume_role_for: i64,
}

impl crate::FlatSerialize for InstancesArn {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.role_type,
            &format!("{}.RoleType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rolearn, &format!("{}.Rolearn", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.assume_role_for,
            &format!("{}.AssumeRoleFor", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesNetworkInterface {
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "NetworkInterfaceName")]
    pub network_interface_name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: String,
    #[serde(rename = "PrimaryIpAddress")]
    pub primary_ip_address: String,
    #[serde(rename = "QueueNumber")]
    pub queue_number: i32,
    #[serde(rename = "SecurityGroupIds")]
    pub security_group_ids: Vec<String>,
    #[serde(rename = "NetworkInterfaceTrafficMode")]
    pub network_interface_traffic_mode: String,
    #[serde(rename = "QueuePairNumber")]
    pub queue_pair_number: i64,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "Ipv6AddressCount")]
    pub ipv6_address_count: i64,
    #[serde(rename = "Ipv6Address")]
    pub ipv6_address: Vec<String>,
    #[serde(rename = "NetworkCardIndex")]
    pub network_card_index: i32,
    #[serde(rename = "DeleteOnRelease")]
    pub delete_on_release: bool,
    #[serde(rename = "NetworkInterfaceId")]
    pub network_interface_id: String,
    #[serde(rename = "RxQueueSize")]
    pub rx_queue_size: i32,
    #[serde(rename = "TxQueueSize")]
    pub tx_queue_size: i32,
    #[serde(rename = "SourceDestCheck")]
    pub source_dest_check: bool,
}

impl crate::FlatSerialize for InstancesNetworkInterface {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_name,
            &format!("{}.NetworkInterfaceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.primary_ip_address,
            &format!("{}.PrimaryIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.queue_number,
            &format!("{}.QueueNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_ids,
            &format!("{}.SecurityGroupIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_traffic_mode,
            &format!("{}.NetworkInterfaceTrafficMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.queue_pair_number,
            &format!("{}.QueuePairNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_address_count,
            &format!("{}.Ipv6AddressCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_address,
            &format!("{}.Ipv6Address", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_card_index,
            &format!("{}.NetworkCardIndex", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.delete_on_release,
            &format!("{}.DeleteOnRelease", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_id,
            &format!("{}.NetworkInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.rx_queue_size,
            &format!("{}.RxQueueSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.tx_queue_size,
            &format!("{}.TxQueueSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_dest_check,
            &format!("{}.SourceDestCheck", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RunInstancesTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for RunInstancesTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesSystemDisk {
    #[serde(rename = "StorageClusterId")]
    pub storage_cluster_id: String,
    #[serde(rename = "ProvisionedIops")]
    pub provisioned_iops: i64,
    #[serde(rename = "BurstingEnabled")]
    pub bursting_enabled: bool,
    #[serde(rename = "Encrypted")]
    pub encrypted: String,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
    #[serde(rename = "EncryptAlgorithm")]
    pub encrypt_algorithm: String,
}

impl crate::FlatSerialize for InstancesSystemDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.storage_cluster_id,
            &format!("{}.StorageClusterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.provisioned_iops,
            &format!("{}.ProvisionedIops", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bursting_enabled,
            &format!("{}.BurstingEnabled", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypt_algorithm,
            &format!("{}.EncryptAlgorithm", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesImageOptions {
    #[serde(rename = "LoginAsNonRoot")]
    pub login_as_non_root: bool,
}

impl crate::FlatSerialize for InstancesImageOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.login_as_non_root,
            &format!("{}.LoginAsNonRoot", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesNetworkOptions {
    #[serde(rename = "EnableJumboFrame")]
    pub enable_jumbo_frame: bool,
    #[serde(rename = "EnableNetworkEncryption")]
    pub enable_network_encryption: bool,
    #[serde(rename = "BandwidthWeighting")]
    pub bandwidth_weighting: String,
}

impl crate::FlatSerialize for InstancesNetworkOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.enable_jumbo_frame,
            &format!("{}.EnableJumboFrame", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_network_encryption,
            &format!("{}.EnableNetworkEncryption", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_weighting,
            &format!("{}.BandwidthWeighting", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesPrivateDnsNameOptions {
    #[serde(rename = "EnableInstanceIdDnsARecord")]
    pub enable_instance_id_dns_a_record: bool,
    #[serde(rename = "EnableInstanceIdDnsAAAARecord")]
    pub enable_instance_id_dns_aaaa_record: bool,
    #[serde(rename = "EnableIpDnsARecord")]
    pub enable_ip_dns_a_record: bool,
    #[serde(rename = "EnableIpDnsPtrRecord")]
    pub enable_ip_dns_ptr_record: bool,
    #[serde(rename = "HostnameType")]
    pub hostname_type: String,
}

impl crate::FlatSerialize for InstancesPrivateDnsNameOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.enable_instance_id_dns_a_record,
            &format!("{}.EnableInstanceIdDnsARecord", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_instance_id_dns_aaaa_record,
            &format!("{}.EnableInstanceIdDnsAAAARecord", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_ip_dns_a_record,
            &format!("{}.EnableIpDnsARecord", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_ip_dns_ptr_record,
            &format!("{}.EnableIpDnsPtrRecord", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.hostname_type,
            &format!("{}.HostnameType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesClockOptions {
    #[serde(rename = "PtpStatus")]
    pub ptp_status: String,
}

impl crate::FlatSerialize for InstancesClockOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ptp_status,
            &format!("{}.PtpStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseInstanceIdSets {
    #[serde(rename = "InstanceIdSet")]
    pub instance_id_set: Vec<String>,
}

impl crate::FlatSerialize for ResponseInstanceIdSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id_set,
            &format!("{}.InstanceIdSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceDataDisk {
    #[serde(rename = "PerformanceLevel")]
    pub performance_level: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "Size")]
    pub size: i32,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "DiskName")]
    pub disk_name: String,
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "DeleteWithInstance")]
    pub delete_with_instance: bool,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
    #[serde(rename = "EncryptAlgorithm")]
    pub encrypt_algorithm: String,
    #[serde(rename = "Encrypted")]
    pub encrypted: bool,
    #[serde(rename = "StorageClusterId")]
    pub storage_cluster_id: String,
}

impl crate::FlatSerialize for InstanceDataDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.performance_level,
            &format!("{}.PerformanceLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.disk_name,
            &format!("{}.DiskName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.delete_with_instance,
            &format!("{}.DeleteWithInstance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypt_algorithm,
            &format!("{}.EncryptAlgorithm", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.storage_cluster_id,
            &format!("{}.StorageClusterId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceArn {
    #[serde(rename = "RoleType")]
    pub role_type: String,
    #[serde(rename = "Rolearn")]
    pub rolearn: String,
    #[serde(rename = "AssumeRoleFor")]
    pub assume_role_for: i64,
}

impl crate::FlatSerialize for InstanceArn {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.role_type,
            &format!("{}.RoleType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rolearn, &format!("{}.Rolearn", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.assume_role_for,
            &format!("{}.AssumeRoleFor", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CreateInstanceTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for CreateInstanceTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceSystemDisk {
    #[serde(rename = "StorageClusterId")]
    pub storage_cluster_id: String,
}

impl crate::FlatSerialize for InstanceSystemDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.storage_cluster_id,
            &format!("{}.StorageClusterId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct StartInstancesResponseInstanceResponsesInstanceResponse {
    #[serde(rename = "Code")]
    pub code: String,
    #[serde(rename = "Message")]
    pub message: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "CurrentStatus")]
    pub current_status: String,
    #[serde(rename = "PreviousStatus")]
    pub previous_status: String,
}

impl crate::FlatSerialize for StartInstancesResponseInstanceResponsesInstanceResponse {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
        crate::FlatSerialize::flat_serialize(&self.message, &format!("{}.Message", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.current_status,
            &format!("{}.CurrentStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.previous_status,
            &format!("{}.PreviousStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct StartInstancesResponseInstanceResponses {
    #[serde(rename = "InstanceResponse")]
    pub instance_response: Vec<StartInstancesResponseInstanceResponsesInstanceResponse>,
}

impl crate::FlatSerialize for StartInstancesResponseInstanceResponses {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_response,
            &format!("{}.InstanceResponse", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct StopInstancesResponseInstanceResponsesInstanceResponse {
    #[serde(rename = "Code")]
    pub code: String,
    #[serde(rename = "Message")]
    pub message: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "CurrentStatus")]
    pub current_status: String,
    #[serde(rename = "PreviousStatus")]
    pub previous_status: String,
}

impl crate::FlatSerialize for StopInstancesResponseInstanceResponsesInstanceResponse {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
        crate::FlatSerialize::flat_serialize(&self.message, &format!("{}.Message", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.current_status,
            &format!("{}.CurrentStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.previous_status,
            &format!("{}.PreviousStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct StopInstancesResponseInstanceResponses {
    #[serde(rename = "InstanceResponse")]
    pub instance_response: Vec<StopInstancesResponseInstanceResponsesInstanceResponse>,
}

impl crate::FlatSerialize for StopInstancesResponseInstanceResponses {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_response,
            &format!("{}.InstanceResponse", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RebootInstancesResponseInstanceResponsesInstanceResponse {
    #[serde(rename = "Code")]
    pub code: String,
    #[serde(rename = "Message")]
    pub message: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "CurrentStatus")]
    pub current_status: String,
    #[serde(rename = "PreviousStatus")]
    pub previous_status: String,
}

impl crate::FlatSerialize for RebootInstancesResponseInstanceResponsesInstanceResponse {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
        crate::FlatSerialize::flat_serialize(&self.message, &format!("{}.Message", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.current_status,
            &format!("{}.CurrentStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.previous_status,
            &format!("{}.PreviousStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RebootInstancesResponseInstanceResponses {
    #[serde(rename = "InstanceResponse")]
    pub instance_response: Vec<RebootInstancesResponseInstanceResponsesInstanceResponse>,
}

impl crate::FlatSerialize for RebootInstancesResponseInstanceResponses {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_response,
            &format!("{}.InstanceResponse", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceStatus {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
}

impl crate::FlatSerialize for InstanceStatus {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceStatuses {
    #[serde(rename = "InstanceStatus")]
    pub instance_status: Vec<InstanceStatus>,
}

impl crate::FlatSerialize for InstanceStatuses {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_status,
            &format!("{}.InstanceStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstancesTag {
    #[serde(rename = "value")]
    pub value: String,
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for DescribeInstancesTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemInnerIpAddress {
    #[serde(rename = "IpAddress")]
    pub ip_address: Vec<String>,
}

impl crate::FlatSerialize for ItemInnerIpAddress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemEipAddress {
    #[serde(rename = "Bandwidth")]
    pub bandwidth: i32,
    #[serde(rename = "AllocationId")]
    pub allocation_id: String,
    #[serde(rename = "IpAddress")]
    pub ip_address: String,
    #[serde(rename = "IsSupportUnassociate")]
    pub is_support_unassociate: bool,
    #[serde(rename = "InternetChargeType")]
    pub internet_charge_type: String,
}

impl crate::FlatSerialize for ItemEipAddress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth,
            &format!("{}.Bandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocation_id,
            &format!("{}.AllocationId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.is_support_unassociate,
            &format!("{}.IsSupportUnassociate", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_charge_type,
            &format!("{}.InternetChargeType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceItemImageOptions {
    #[serde(rename = "LoginAsNonRoot")]
    pub login_as_non_root: bool,
    #[serde(rename = "CurrentOSNVMeSupported")]
    pub current_osnv_me_supported: bool,
}

impl crate::FlatSerialize for InstanceItemImageOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.login_as_non_root,
            &format!("{}.LoginAsNonRoot", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.current_osnv_me_supported,
            &format!("{}.CurrentOSNVMeSupported", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesInstanceItemTagsTag {
    #[serde(rename = "TagKey")]
    pub tag_key: String,
    #[serde(rename = "TagValue")]
    pub tag_value: String,
}

impl crate::FlatSerialize for InstancesInstanceItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesInstanceItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<InstancesInstanceItemTagsTag>,
}

impl crate::FlatSerialize for InstancesInstanceItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HibernationOptions {
    #[serde(rename = "Configured")]
    pub configured: bool,
}

impl crate::FlatSerialize for HibernationOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.configured,
            &format!("{}.Configured", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AdditionalInfo {
    #[serde(rename = "EnableHighDensityMode")]
    pub enable_high_density_mode: bool,
}

impl crate::FlatSerialize for AdditionalInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.enable_high_density_mode,
            &format!("{}.EnableHighDensityMode", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct MetadataOptions {
    #[serde(rename = "HttpPutResponseHopLimit")]
    pub http_put_response_hop_limit: i32,
    #[serde(rename = "HttpTokens")]
    pub http_tokens: String,
    #[serde(rename = "HttpEndpoint")]
    pub http_endpoint: String,
}

impl crate::FlatSerialize for MetadataOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.http_put_response_hop_limit,
            &format!("{}.HttpPutResponseHopLimit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.http_tokens,
            &format!("{}.HttpTokens", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.http_endpoint,
            &format!("{}.HttpEndpoint", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceItemCpuOptions {
    #[serde(rename = "TopologyType")]
    pub topology_type: String,
    #[serde(rename = "TurboMode")]
    pub turbo_mode: String,
    #[serde(rename = "EnableVISST")]
    pub enable_visst: bool,
    #[serde(rename = "EnableVRDT")]
    pub enable_vrdt: bool,
    #[serde(rename = "ThreadsPerCore")]
    pub threads_per_core: i32,
    #[serde(rename = "Numa")]
    pub numa: String,
    #[serde(rename = "CoreCount")]
    pub core_count: i32,
}

impl crate::FlatSerialize for InstanceItemCpuOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.topology_type,
            &format!("{}.TopologyType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.turbo_mode,
            &format!("{}.TurboMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_visst,
            &format!("{}.EnableVISST", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_vrdt,
            &format!("{}.EnableVRDT", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.threads_per_core,
            &format!("{}.ThreadsPerCore", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.numa, &format!("{}.Numa", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.core_count,
            &format!("{}.CoreCount", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemPrivateDnsNameOptions {
    #[serde(rename = "EnableInstanceIdDnsARecord")]
    pub enable_instance_id_dns_a_record: bool,
    #[serde(rename = "HostnameType")]
    pub hostname_type: String,
    #[serde(rename = "EnableIpDnsPtrRecord")]
    pub enable_ip_dns_ptr_record: bool,
    #[serde(rename = "EnableIpDnsARecord")]
    pub enable_ip_dns_a_record: bool,
    #[serde(rename = "EnableInstanceIdDnsAAAARecord")]
    pub enable_instance_id_dns_aaaa_record: bool,
}

impl crate::FlatSerialize for ItemPrivateDnsNameOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.enable_instance_id_dns_a_record,
            &format!("{}.EnableInstanceIdDnsARecord", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.hostname_type,
            &format!("{}.HostnameType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_ip_dns_ptr_record,
            &format!("{}.EnableIpDnsPtrRecord", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_ip_dns_a_record,
            &format!("{}.EnableIpDnsARecord", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_instance_id_dns_aaaa_record,
            &format!("{}.EnableInstanceIdDnsAAAARecord", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceItemSecurityGroupIds {
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: Vec<String>,
}

impl crate::FlatSerialize for InstanceItemSecurityGroupIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemVpcAttributesPrivateIpAddress {
    #[serde(rename = "IpAddress")]
    pub ip_address: Vec<String>,
}

impl crate::FlatSerialize for ItemVpcAttributesPrivateIpAddress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemVpcAttributes {
    #[serde(rename = "PrivateIpAddress")]
    pub private_ip_address: ItemVpcAttributesPrivateIpAddress,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "NatIpAddress")]
    pub nat_ip_address: String,
}

impl crate::FlatSerialize for ItemVpcAttributes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_address,
            &format!("{}.PrivateIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.vpc_id, &format!("{}.VpcId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.nat_ip_address,
            &format!("{}.NatIpAddress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceAttribute {
    #[serde(rename = "Tenancy")]
    pub tenancy: String,
    #[serde(rename = "Affinity")]
    pub affinity: String,
}

impl crate::FlatSerialize for InstanceAttribute {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tenancy, &format!("{}.Tenancy", name), params);
        crate::FlatSerialize::flat_serialize(&self.affinity, &format!("{}.Affinity", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemPublicIpAddress {
    #[serde(rename = "IpAddress")]
    pub ip_address: Vec<String>,
}

impl crate::FlatSerialize for ItemPublicIpAddress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceItemIpv6SetsIpv6Set {
    #[serde(rename = "Ipv6Address")]
    pub ipv6_address: String,
}

impl crate::FlatSerialize for InterfaceItemIpv6SetsIpv6Set {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_address,
            &format!("{}.Ipv6Address", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceItemIpv6Sets {
    #[serde(rename = "Ipv6Set")]
    pub ipv6_set: Vec<InterfaceItemIpv6SetsIpv6Set>,
}

impl crate::FlatSerialize for InterfaceItemIpv6Sets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.ipv6_set, &format!("{}.Ipv6Set", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceItemIpv6PrefixSetsIpv6PrefixSet {
    #[serde(rename = "Ipv6Prefix")]
    pub ipv6_prefix: String,
}

impl crate::FlatSerialize for InterfaceItemIpv6PrefixSetsIpv6PrefixSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_prefix,
            &format!("{}.Ipv6Prefix", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceItemIpv6PrefixSets {
    #[serde(rename = "Ipv6PrefixSet")]
    pub ipv6_prefix_set: Vec<InterfaceItemIpv6PrefixSetsIpv6PrefixSet>,
}

impl crate::FlatSerialize for InterfaceItemIpv6PrefixSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_prefix_set,
            &format!("{}.Ipv6PrefixSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceItemIpv4PrefixSetsIpv4PrefixSet {
    #[serde(rename = "Ipv4Prefix")]
    pub ipv4_prefix: String,
}

impl crate::FlatSerialize for InterfaceItemIpv4PrefixSetsIpv4PrefixSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefix,
            &format!("{}.Ipv4Prefix", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceItemIpv4PrefixSets {
    #[serde(rename = "Ipv4PrefixSet")]
    pub ipv4_prefix_set: Vec<InterfaceItemIpv4PrefixSetsIpv4PrefixSet>,
}

impl crate::FlatSerialize for InterfaceItemIpv4PrefixSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefix_set,
            &format!("{}.Ipv4PrefixSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceItemPrivateIpSetsPrivateIpSet {
    #[serde(rename = "PrivateIpAddress")]
    pub private_ip_address: String,
    #[serde(rename = "PrivateDnsName")]
    pub private_dns_name: String,
    #[serde(rename = "Primary")]
    pub primary: bool,
}

impl crate::FlatSerialize for InterfaceItemPrivateIpSetsPrivateIpSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_address,
            &format!("{}.PrivateIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_dns_name,
            &format!("{}.PrivateDnsName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.primary, &format!("{}.Primary", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceItemPrivateIpSets {
    #[serde(rename = "PrivateIpSet")]
    pub private_ip_set: Vec<InterfaceItemPrivateIpSetsPrivateIpSet>,
}

impl crate::FlatSerialize for InterfaceItemPrivateIpSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_set,
            &format!("{}.PrivateIpSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemNetworkInterfacesNetworkInterface {
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "Ipv6Sets")]
    pub ipv6_sets: InterfaceItemIpv6Sets,
    #[serde(rename = "Ipv6PrefixSets")]
    pub ipv6_prefix_sets: InterfaceItemIpv6PrefixSets,
    #[serde(rename = "PrimaryIpAddress")]
    pub primary_ip_address: String,
    #[serde(rename = "MacAddress")]
    pub mac_address: String,
    #[serde(rename = "NetworkInterfaceId")]
    pub network_interface_id: String,
    #[serde(rename = "Ipv4PrefixSets")]
    pub ipv4_prefix_sets: InterfaceItemIpv4PrefixSets,
    #[serde(rename = "PrivateIpSets")]
    pub private_ip_sets: InterfaceItemPrivateIpSets,
}

impl crate::FlatSerialize for ItemNetworkInterfacesNetworkInterface {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_sets,
            &format!("{}.Ipv6Sets", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_prefix_sets,
            &format!("{}.Ipv6PrefixSets", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.primary_ip_address,
            &format!("{}.PrimaryIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.mac_address,
            &format!("{}.MacAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_id,
            &format!("{}.NetworkInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefix_sets,
            &format!("{}.Ipv4PrefixSets", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_sets,
            &format!("{}.PrivateIpSets", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemNetworkInterfaces {
    #[serde(rename = "NetworkInterface")]
    pub network_interface: Vec<ItemNetworkInterfacesNetworkInterface>,
}

impl crate::FlatSerialize for ItemNetworkInterfaces {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.network_interface,
            &format!("{}.NetworkInterface", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationAttr {
    #[serde(rename = "CapacityReservationPreference")]
    pub capacity_reservation_preference: String,
    #[serde(rename = "CapacityReservationId")]
    pub capacity_reservation_id: String,
}

impl crate::FlatSerialize for ReservationAttr {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.capacity_reservation_preference,
            &format!("{}.CapacityReservationPreference", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.capacity_reservation_id,
            &format!("{}.CapacityReservationId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemDedicatedHostAttribute {
    #[serde(rename = "DedicatedHostId")]
    pub dedicated_host_id: String,
    #[serde(rename = "DedicatedHostName")]
    pub dedicated_host_name: String,
    #[serde(rename = "DedicatedHostClusterId")]
    pub dedicated_host_cluster_id: String,
}

impl crate::FlatSerialize for ItemDedicatedHostAttribute {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_id,
            &format!("{}.DedicatedHostId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_name,
            &format!("{}.DedicatedHostName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_cluster_id,
            &format!("{}.DedicatedHostClusterId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceItemOperationLocksLockReason {
    #[serde(rename = "LockReason")]
    pub lock_reason: String,
    #[serde(rename = "LockMsg")]
    pub lock_msg: String,
}

impl crate::FlatSerialize for InstanceItemOperationLocksLockReason {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.lock_reason,
            &format!("{}.LockReason", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.lock_msg, &format!("{}.LockMsg", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesInstanceItemOperationLocks {
    #[serde(rename = "LockReason")]
    pub lock_reason: Vec<InstanceItemOperationLocksLockReason>,
}

impl crate::FlatSerialize for InstancesInstanceItemOperationLocks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.lock_reason,
            &format!("{}.LockReason", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RdmaIpAddress {
    #[serde(rename = "IpAddress")]
    pub ip_address: Vec<String>,
}

impl crate::FlatSerialize for RdmaIpAddress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemClockOptions {
    #[serde(rename = "PtpStatus")]
    pub ptp_status: String,
}

impl crate::FlatSerialize for ItemClockOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ptp_status,
            &format!("{}.PtpStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstancesResponseInstancesInstance {
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "Memory")]
    pub memory: i32,
    #[serde(rename = "InstanceChargeType")]
    pub instance_charge_type: String,
    #[serde(rename = "Cpu")]
    pub cpu: i32,
    #[serde(rename = "OSName")]
    pub os_name: String,
    #[serde(rename = "InstanceNetworkType")]
    pub instance_network_type: String,
    #[serde(rename = "InnerIpAddress")]
    pub inner_ip_address: ItemInnerIpAddress,
    #[serde(rename = "ExpiredTime")]
    pub expired_time: String,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "EipAddress")]
    pub eip_address: ItemEipAddress,
    #[serde(rename = "ImageOptions")]
    pub image_options: InstanceItemImageOptions,
    #[serde(rename = "VlanId")]
    pub vlan_id: String,
    #[serde(rename = "HostName")]
    pub host_name: String,
    #[serde(rename = "Tags")]
    pub tags: InstancesInstanceItemTags,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "HibernationOptions")]
    pub hibernation_options: HibernationOptions,
    #[serde(rename = "AdditionalInfo")]
    pub additional_info: AdditionalInfo,
    #[serde(rename = "MetadataOptions")]
    pub metadata_options: MetadataOptions,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "StoppedMode")]
    pub stopped_mode: String,
    #[serde(rename = "CpuOptions")]
    pub cpu_options: InstanceItemCpuOptions,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "PrivateDnsNameOptions")]
    pub private_dns_name_options: ItemPrivateDnsNameOptions,
    #[serde(rename = "DeletionProtection")]
    pub deletion_protection: bool,
    #[serde(rename = "SecurityGroupIds")]
    pub security_group_ids: InstanceItemSecurityGroupIds,
    #[serde(rename = "VpcAttributes")]
    pub vpc_attributes: ItemVpcAttributes,
    #[serde(rename = "InternetChargeType")]
    pub internet_charge_type: String,
    #[serde(rename = "DeploymentSetId")]
    pub deployment_set_id: String,
    #[serde(rename = "InstanceName")]
    pub instance_name: String,
    #[serde(rename = "SpotInterruptionBehavior")]
    pub spot_interruption_behavior: String,
    #[serde(rename = "InternetMaxBandwidthOut")]
    pub internet_max_bandwidth_out: i32,
    #[serde(rename = "SerialNumber")]
    pub serial_number: String,
    #[serde(rename = "OSType")]
    pub os_type: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "AutoReleaseTime")]
    pub auto_release_time: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "EnableNVS")]
    pub enable_nvs: bool,
    #[serde(rename = "LocalStorageCapacity")]
    pub local_storage_capacity: i64,
    #[serde(rename = "InstanceTypeFamily")]
    pub instance_type_family: String,
    #[serde(rename = "DedicatedInstanceAttribute")]
    pub dedicated_instance_attribute: InstanceAttribute,
    #[serde(rename = "SpotDuration")]
    pub spot_duration: i32,
    #[serde(rename = "LocalStorageAmount")]
    pub local_storage_amount: i32,
    #[serde(rename = "PublicIpAddress")]
    pub public_ip_address: ItemPublicIpAddress,
    #[serde(rename = "GPUSpec")]
    pub gpu_spec: String,
    #[serde(rename = "NetworkInterfaces")]
    pub network_interfaces: ItemNetworkInterfaces,
    #[serde(rename = "SpotPriceLimit")]
    pub spot_price_limit: f32,
    #[serde(rename = "SaleCycle")]
    pub sale_cycle: String,
    #[serde(rename = "DeviceAvailable")]
    pub device_available: bool,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "SpotStrategy")]
    pub spot_strategy: String,
    #[serde(rename = "OSNameEn")]
    pub os_name_en: String,
    #[serde(rename = "KeyPairName")]
    pub key_pair_name: String,
    #[serde(rename = "IoOptimized")]
    pub io_optimized: bool,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "ClusterId")]
    pub cluster_id: String,
    #[serde(rename = "HpcClusterId")]
    pub hpc_cluster_id: String,
    #[serde(rename = "ISP")]
    pub isp: String,
    #[serde(rename = "DeploymentSetGroupNo")]
    pub deployment_set_group_no: i32,
    #[serde(rename = "EcsCapacityReservationAttr")]
    pub ecs_capacity_reservation_attr: ReservationAttr,
    #[serde(rename = "DedicatedHostAttribute")]
    pub dedicated_host_attribute: ItemDedicatedHostAttribute,
    #[serde(rename = "GPUAmount")]
    pub gpu_amount: i32,
    #[serde(rename = "OperationLocks")]
    pub operation_locks: InstancesInstanceItemOperationLocks,
    #[serde(rename = "RdmaIpAddress")]
    pub rdma_ip_address: RdmaIpAddress,
    #[serde(rename = "InternetMaxBandwidthIn")]
    pub internet_max_bandwidth_in: i32,
    #[serde(rename = "ClockOptions")]
    pub clock_options: ItemClockOptions,
    #[serde(rename = "Recyclable")]
    pub recyclable: bool,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "CreditSpecification")]
    pub credit_specification: String,
}

impl crate::FlatSerialize for DescribeInstancesResponseInstancesInstance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.memory, &format!("{}.Memory", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_charge_type,
            &format!("{}.InstanceChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.cpu, &format!("{}.Cpu", name), params);
        crate::FlatSerialize::flat_serialize(&self.os_name, &format!("{}.OSName", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_network_type,
            &format!("{}.InstanceNetworkType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.inner_ip_address,
            &format!("{}.InnerIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.expired_time,
            &format!("{}.ExpiredTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.image_id, &format!("{}.ImageId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.eip_address,
            &format!("{}.EipAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_options,
            &format!("{}.ImageOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.vlan_id, &format!("{}.VlanId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.host_name,
            &format!("{}.HostName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.hibernation_options,
            &format!("{}.HibernationOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.additional_info,
            &format!("{}.AdditionalInfo", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.metadata_options,
            &format!("{}.MetadataOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.stopped_mode,
            &format!("{}.StoppedMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_options,
            &format!("{}.CpuOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_dns_name_options,
            &format!("{}.PrivateDnsNameOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.deletion_protection,
            &format!("{}.DeletionProtection", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_ids,
            &format!("{}.SecurityGroupIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.vpc_attributes,
            &format!("{}.VpcAttributes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_charge_type,
            &format!("{}.InternetChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.deployment_set_id,
            &format!("{}.DeploymentSetId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_name,
            &format!("{}.InstanceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.spot_interruption_behavior,
            &format!("{}.SpotInterruptionBehavior", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_max_bandwidth_out,
            &format!("{}.InternetMaxBandwidthOut", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.serial_number,
            &format!("{}.SerialNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.os_type, &format!("{}.OSType", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_release_time,
            &format!("{}.AutoReleaseTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_nvs,
            &format!("{}.EnableNVS", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_storage_capacity,
            &format!("{}.LocalStorageCapacity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type_family,
            &format!("{}.InstanceTypeFamily", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_instance_attribute,
            &format!("{}.DedicatedInstanceAttribute", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.spot_duration,
            &format!("{}.SpotDuration", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_storage_amount,
            &format!("{}.LocalStorageAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.public_ip_address,
            &format!("{}.PublicIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.gpu_spec, &format!("{}.GPUSpec", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.network_interfaces,
            &format!("{}.NetworkInterfaces", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.spot_price_limit,
            &format!("{}.SpotPriceLimit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.sale_cycle,
            &format!("{}.SaleCycle", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.device_available,
            &format!("{}.DeviceAvailable", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.spot_strategy,
            &format!("{}.SpotStrategy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.os_name_en,
            &format!("{}.OSNameEn", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.key_pair_name,
            &format!("{}.KeyPairName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.io_optimized,
            &format!("{}.IoOptimized", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.cluster_id,
            &format!("{}.ClusterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.hpc_cluster_id,
            &format!("{}.HpcClusterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.isp, &format!("{}.ISP", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.deployment_set_group_no,
            &format!("{}.DeploymentSetGroupNo", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ecs_capacity_reservation_attr,
            &format!("{}.EcsCapacityReservationAttr", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_attribute,
            &format!("{}.DedicatedHostAttribute", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.gpu_amount,
            &format!("{}.GPUAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.operation_locks,
            &format!("{}.OperationLocks", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.rdma_ip_address,
            &format!("{}.RdmaIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_max_bandwidth_in,
            &format!("{}.InternetMaxBandwidthIn", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.clock_options,
            &format!("{}.ClockOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.recyclable,
            &format!("{}.Recyclable", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.credit_specification,
            &format!("{}.CreditSpecification", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstancesResponseInstances {
    #[serde(rename = "Instance")]
    pub instance: Vec<DescribeInstancesResponseInstancesInstance>,
}

impl crate::FlatSerialize for DescribeInstancesResponseInstances {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.instance, &format!("{}.Instance", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TypeFamily {
    #[serde(rename = "Generation")]
    pub generation: String,
    #[serde(rename = "InstanceTypeFamilyId")]
    pub instance_type_family_id: String,
}

impl crate::FlatSerialize for TypeFamily {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.generation,
            &format!("{}.Generation", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type_family_id,
            &format!("{}.InstanceTypeFamilyId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseInstanceTypeFamilies {
    #[serde(rename = "InstanceTypeFamily")]
    pub instance_type_family: Vec<TypeFamily>,
}

impl crate::FlatSerialize for ResponseInstanceTypeFamilies {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_type_family,
            &format!("{}.InstanceTypeFamily", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CardInfo {
    #[serde(rename = "NetworkCardIndex")]
    pub network_card_index: i32,
}

impl crate::FlatSerialize for CardInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.network_card_index,
            &format!("{}.NetworkCardIndex", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct NetworkCards {
    #[serde(rename = "NetworkCardInfo")]
    pub network_card_info: Vec<CardInfo>,
}

impl crate::FlatSerialize for NetworkCards {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.network_card_info,
            &format!("{}.NetworkCardInfo", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct BootModes {
    #[serde(rename = "SupportedBootMode")]
    pub supported_boot_mode: Vec<String>,
}

impl crate::FlatSerialize for BootModes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_boot_mode,
            &format!("{}.SupportedBootMode", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemEnhancedNetwork {
    #[serde(rename = "SriovSupport")]
    pub sriov_support: bool,
    #[serde(rename = "VfQueueNumberPerEni")]
    pub vf_queue_number_per_eni: i32,
    #[serde(rename = "RssSupport")]
    pub rss_support: bool,
}

impl crate::FlatSerialize for ItemEnhancedNetwork {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.sriov_support,
            &format!("{}.SriovSupport", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.vf_queue_number_per_eni,
            &format!("{}.VfQueueNumberPerEni", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.rss_support,
            &format!("{}.RssSupport", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TopologyTypes {
    #[serde(rename = "SupportedTopologyType")]
    pub supported_topology_type: Vec<String>,
}

impl crate::FlatSerialize for TopologyTypes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_topology_type,
            &format!("{}.SupportedTopologyType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TypeItemCpuOptions {
    #[serde(rename = "SupportedTopologyTypes")]
    pub supported_topology_types: TopologyTypes,
    #[serde(rename = "ThreadsPerCore")]
    pub threads_per_core: i32,
    #[serde(rename = "Core")]
    pub core: i32,
    #[serde(rename = "CoreFactor")]
    pub core_factor: i32,
    #[serde(rename = "HyperThreadingAdjustable")]
    pub hyper_threading_adjustable: bool,
}

impl crate::FlatSerialize for TypeItemCpuOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_topology_types,
            &format!("{}.SupportedTopologyTypes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.threads_per_core,
            &format!("{}.ThreadsPerCore", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.core, &format!("{}.Core", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.core_factor,
            &format!("{}.CoreFactor", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.hyper_threading_adjustable,
            &format!("{}.HyperThreadingAdjustable", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemClock {
    #[serde(rename = "PtpSupport")]
    pub ptp_support: String,
}

impl crate::FlatSerialize for ItemClock {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ptp_support,
            &format!("{}.PtpSupport", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributesAttribute {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for AttributesAttribute {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemAttributes {
    #[serde(rename = "Attribute")]
    pub attribute: Vec<AttributesAttribute>,
}

impl crate::FlatSerialize for ItemAttributes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.attribute,
            &format!("{}.Attribute", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct WeightingInfo {
    #[serde(rename = "VpcBandwidth")]
    pub vpc_bandwidth: i64,
    #[serde(rename = "EbsBurstBandwidth")]
    pub ebs_burst_bandwidth: i64,
    #[serde(rename = "EbsBandwidth")]
    pub ebs_bandwidth: i64,
    #[serde(rename = "VpcBurstBandwidth")]
    pub vpc_burst_bandwidth: i64,
    #[serde(rename = "Name")]
    pub name: String,
}

impl crate::FlatSerialize for WeightingInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.vpc_bandwidth,
            &format!("{}.VpcBandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ebs_burst_bandwidth,
            &format!("{}.EbsBurstBandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ebs_bandwidth,
            &format!("{}.EbsBandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.vpc_burst_bandwidth,
            &format!("{}.VpcBurstBandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct WeightingInfos {
    #[serde(rename = "WeightingInfo")]
    pub weighting_info: Vec<WeightingInfo>,
}

impl crate::FlatSerialize for WeightingInfos {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.weighting_info,
            &format!("{}.WeightingInfo", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct BandwidthWeighting {
    #[serde(rename = "WeightingInfos")]
    pub weighting_infos: WeightingInfos,
}

impl crate::FlatSerialize for BandwidthWeighting {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.weighting_infos,
            &format!("{}.WeightingInfos", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct NetworkInfo {
    #[serde(rename = "BandwidthWeighting")]
    pub bandwidth_weighting: BandwidthWeighting,
}

impl crate::FlatSerialize for NetworkInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_weighting,
            &format!("{}.BandwidthWeighting", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceTypesResponseInstanceTypesInstanceType {
    #[serde(rename = "EniTotalQuantity")]
    pub eni_total_quantity: i32,
    #[serde(rename = "LocalStorageCategory")]
    pub local_storage_category: String,
    #[serde(rename = "PrimaryEniQueueNumber")]
    pub primary_eni_queue_number: i32,
    #[serde(rename = "MemorySize")]
    pub memory_size: f32,
    #[serde(rename = "LocalStorageCapacity")]
    pub local_storage_capacity: i64,
    #[serde(rename = "InstanceFamilyLevel")]
    pub instance_family_level: String,
    #[serde(rename = "InstancePpsRx")]
    pub instance_pps_rx: i64,
    #[serde(rename = "EniIpv6AddressQuantity")]
    pub eni_ipv6_address_quantity: i32,
    #[serde(rename = "MaximumQueueNumberPerEni")]
    pub maximum_queue_number_per_eni: i32,
    #[serde(rename = "InstanceTypeId")]
    pub instance_type_id: String,
    #[serde(rename = "InstanceBandwidthRx")]
    pub instance_bandwidth_rx: i32,
    #[serde(rename = "SecondaryEniQueueNumber")]
    pub secondary_eni_queue_number: i32,
    #[serde(rename = "GPUSpec")]
    pub gpu_spec: String,
    #[serde(rename = "InstanceBandwidthTx")]
    pub instance_bandwidth_tx: i32,
    #[serde(rename = "QueuePairNumber")]
    pub queue_pair_number: i32,
    #[serde(rename = "EriQuantity")]
    pub eri_quantity: i32,
    #[serde(rename = "GPUAmount")]
    pub gpu_amount: i32,
    #[serde(rename = "TotalEniQueueQuantity")]
    pub total_eni_queue_quantity: i32,
    #[serde(rename = "NvmeSupport")]
    pub nvme_support: String,
    #[serde(rename = "DiskQuantity")]
    pub disk_quantity: i32,
    #[serde(rename = "InitialCredit")]
    pub initial_credit: i32,
    #[serde(rename = "LocalStorageAmount")]
    pub local_storage_amount: i32,
    #[serde(rename = "BaselineCredit")]
    pub baseline_credit: i32,
    #[serde(rename = "InstancePpsTx")]
    pub instance_pps_tx: i64,
    #[serde(rename = "EniPrivateIpAddressQuantity")]
    pub eni_private_ip_address_quantity: i32,
    #[serde(rename = "CpuCoreCount")]
    pub cpu_core_count: i32,
    #[serde(rename = "InstanceTypeFamily")]
    pub instance_type_family: String,
    #[serde(rename = "EniQuantity")]
    pub eni_quantity: i32,
    #[serde(rename = "EniTrunkSupported")]
    pub eni_trunk_supported: bool,
    #[serde(rename = "CpuSpeedFrequency")]
    pub cpu_speed_frequency: f32,
    #[serde(rename = "CpuTurboFrequency")]
    pub cpu_turbo_frequency: f32,
    #[serde(rename = "PhysicalProcessorModel")]
    pub physical_processor_model: String,
    #[serde(rename = "NetworkEncryptionSupport")]
    pub network_encryption_support: bool,
    #[serde(rename = "InstanceCategory")]
    pub instance_category: String,
    #[serde(rename = "CpuArchitecture")]
    pub cpu_architecture: String,
    #[serde(rename = "GPUMemorySize")]
    pub gpu_memory_size: f32,
    #[serde(rename = "NetworkCardQuantity")]
    pub network_card_quantity: i32,
    #[serde(rename = "NetworkCards")]
    pub network_cards: NetworkCards,
    #[serde(rename = "SupportedBootModes")]
    pub supported_boot_modes: BootModes,
    #[serde(rename = "EnhancedNetwork")]
    pub enhanced_network: ItemEnhancedNetwork,
    #[serde(rename = "CpuOptions")]
    pub cpu_options: TypeItemCpuOptions,
    #[serde(rename = "JumboFrameSupport")]
    pub jumbo_frame_support: bool,
    #[serde(rename = "Clock")]
    pub clock: ItemClock,
    #[serde(rename = "Attributes")]
    pub attributes: ItemAttributes,
    #[serde(rename = "NetworkInfo")]
    pub network_info: NetworkInfo,
}

impl crate::FlatSerialize for DescribeInstanceTypesResponseInstanceTypesInstanceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.eni_total_quantity,
            &format!("{}.EniTotalQuantity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_storage_category,
            &format!("{}.LocalStorageCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.primary_eni_queue_number,
            &format!("{}.PrimaryEniQueueNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.memory_size,
            &format!("{}.MemorySize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_storage_capacity,
            &format!("{}.LocalStorageCapacity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_family_level,
            &format!("{}.InstanceFamilyLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_pps_rx,
            &format!("{}.InstancePpsRx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.eni_ipv6_address_quantity,
            &format!("{}.EniIpv6AddressQuantity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.maximum_queue_number_per_eni,
            &format!("{}.MaximumQueueNumberPerEni", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type_id,
            &format!("{}.InstanceTypeId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_bandwidth_rx,
            &format!("{}.InstanceBandwidthRx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.secondary_eni_queue_number,
            &format!("{}.SecondaryEniQueueNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.gpu_spec, &format!("{}.GPUSpec", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_bandwidth_tx,
            &format!("{}.InstanceBandwidthTx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.queue_pair_number,
            &format!("{}.QueuePairNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.eri_quantity,
            &format!("{}.EriQuantity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.gpu_amount,
            &format!("{}.GPUAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_eni_queue_quantity,
            &format!("{}.TotalEniQueueQuantity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.nvme_support,
            &format!("{}.NvmeSupport", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.disk_quantity,
            &format!("{}.DiskQuantity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.initial_credit,
            &format!("{}.InitialCredit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_storage_amount,
            &format!("{}.LocalStorageAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.baseline_credit,
            &format!("{}.BaselineCredit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_pps_tx,
            &format!("{}.InstancePpsTx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.eni_private_ip_address_quantity,
            &format!("{}.EniPrivateIpAddressQuantity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_core_count,
            &format!("{}.CpuCoreCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type_family,
            &format!("{}.InstanceTypeFamily", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.eni_quantity,
            &format!("{}.EniQuantity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.eni_trunk_supported,
            &format!("{}.EniTrunkSupported", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_speed_frequency,
            &format!("{}.CpuSpeedFrequency", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_turbo_frequency,
            &format!("{}.CpuTurboFrequency", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.physical_processor_model,
            &format!("{}.PhysicalProcessorModel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_encryption_support,
            &format!("{}.NetworkEncryptionSupport", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_category,
            &format!("{}.InstanceCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_architecture,
            &format!("{}.CpuArchitecture", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.gpu_memory_size,
            &format!("{}.GPUMemorySize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_card_quantity,
            &format!("{}.NetworkCardQuantity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_cards,
            &format!("{}.NetworkCards", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.supported_boot_modes,
            &format!("{}.SupportedBootModes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enhanced_network,
            &format!("{}.EnhancedNetwork", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_options,
            &format!("{}.CpuOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.jumbo_frame_support,
            &format!("{}.JumboFrameSupport", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.clock, &format!("{}.Clock", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.attributes,
            &format!("{}.Attributes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_info,
            &format!("{}.NetworkInfo", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceTypesResponseInstanceTypes {
    #[serde(rename = "InstanceType")]
    pub instance_type: Vec<DescribeInstanceTypesResponseInstanceTypesInstanceType>,
}

impl crate::FlatSerialize for DescribeInstanceTypesResponseInstanceTypes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceAttributeResponseSecurityGroupIds {
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: Vec<String>,
}

impl crate::FlatSerialize for InstanceAttributeResponseSecurityGroupIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponsePublicIpAddress {
    #[serde(rename = "IpAddress")]
    pub ip_address: Vec<String>,
}

impl crate::FlatSerialize for ResponsePublicIpAddress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseInnerIpAddress {
    #[serde(rename = "IpAddress")]
    pub ip_address: Vec<String>,
}

impl crate::FlatSerialize for ResponseInnerIpAddress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseVpcAttributesPrivateIpAddress {
    #[serde(rename = "IpAddress")]
    pub ip_address: Vec<String>,
}

impl crate::FlatSerialize for ResponseVpcAttributesPrivateIpAddress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseVpcAttributes {
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "NatIpAddress")]
    pub nat_ip_address: String,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "PrivateIpAddress")]
    pub private_ip_address: ResponseVpcAttributesPrivateIpAddress,
}

impl crate::FlatSerialize for ResponseVpcAttributes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.vpc_id, &format!("{}.VpcId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.nat_ip_address,
            &format!("{}.NatIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_address,
            &format!("{}.PrivateIpAddress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseEipAddress {
    #[serde(rename = "InternetChargeType")]
    pub internet_charge_type: String,
    #[serde(rename = "IpAddress")]
    pub ip_address: String,
    #[serde(rename = "Bandwidth")]
    pub bandwidth: i32,
    #[serde(rename = "AllocationId")]
    pub allocation_id: String,
}

impl crate::FlatSerialize for ResponseEipAddress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.internet_charge_type,
            &format!("{}.InternetChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth,
            &format!("{}.Bandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocation_id,
            &format!("{}.AllocationId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseDedicatedHostAttribute {
    #[serde(rename = "DedicatedHostName")]
    pub dedicated_host_name: String,
    #[serde(rename = "DedicatedHostId")]
    pub dedicated_host_id: String,
}

impl crate::FlatSerialize for ResponseDedicatedHostAttribute {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_name,
            &format!("{}.DedicatedHostName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_id,
            &format!("{}.DedicatedHostId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseOperationLocksLockReason {
    #[serde(rename = "LockReason")]
    pub lock_reason: String,
}

impl crate::FlatSerialize for ResponseOperationLocksLockReason {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.lock_reason,
            &format!("{}.LockReason", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseOperationLocks {
    #[serde(rename = "LockReason")]
    pub lock_reason: Vec<ResponseOperationLocksLockReason>,
}

impl crate::FlatSerialize for ResponseOperationLocks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.lock_reason,
            &format!("{}.LockReason", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseNetworkOptions {
    #[serde(rename = "EnableJumboFrame")]
    pub enable_jumbo_frame: bool,
    #[serde(rename = "EnableNetworkEncryption")]
    pub enable_network_encryption: bool,
    #[serde(rename = "BandwidthWeighting")]
    pub bandwidth_weighting: String,
}

impl crate::FlatSerialize for ResponseNetworkOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.enable_jumbo_frame,
            &format!("{}.EnableJumboFrame", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_network_encryption,
            &format!("{}.EnableNetworkEncryption", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_weighting,
            &format!("{}.BandwidthWeighting", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConnectionOptions {
    #[serde(rename = "Password")]
    pub password: String,
    #[serde(rename = "Type")]
    pub r#type: String,
}

impl crate::FlatSerialize for ConnectionOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.password, &format!("{}.Password", name), params);
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributePrivateDnsNameOptions {
    #[serde(rename = "EnableInstanceIdDnsARecord")]
    pub enable_instance_id_dns_a_record: bool,
    #[serde(rename = "EnableInstanceIdDnsAAAARecord")]
    pub enable_instance_id_dns_aaaa_record: bool,
    #[serde(rename = "EnableIpDnsARecord")]
    pub enable_ip_dns_a_record: bool,
    #[serde(rename = "EnableIpDnsPtrRecord")]
    pub enable_ip_dns_ptr_record: bool,
    #[serde(rename = "HostnameType")]
    pub hostname_type: String,
}

impl crate::FlatSerialize for AttributePrivateDnsNameOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.enable_instance_id_dns_a_record,
            &format!("{}.EnableInstanceIdDnsARecord", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_instance_id_dns_aaaa_record,
            &format!("{}.EnableInstanceIdDnsAAAARecord", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_ip_dns_a_record,
            &format!("{}.EnableIpDnsARecord", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_ip_dns_ptr_record,
            &format!("{}.EnableIpDnsPtrRecord", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.hostname_type,
            &format!("{}.HostnameType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceChargeTypeResponseFeeOfInstancesFeeOfInstance {
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Currency")]
    pub currency: String,
    #[serde(rename = "Fee")]
    pub fee: String,
}

impl crate::FlatSerialize for InstanceChargeTypeResponseFeeOfInstancesFeeOfInstance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.currency, &format!("{}.Currency", name), params);
        crate::FlatSerialize::flat_serialize(&self.fee, &format!("{}.Fee", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceChargeTypeResponseFeeOfInstances {
    #[serde(rename = "FeeOfInstance")]
    pub fee_of_instance: Vec<InstanceChargeTypeResponseFeeOfInstancesFeeOfInstance>,
}

impl crate::FlatSerialize for InstanceChargeTypeResponseFeeOfInstances {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.fee_of_instance,
            &format!("{}.FeeOfInstance", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceSpecDisk {
    #[serde(rename = "DiskId")]
    pub disk_id: String,
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "PerformanceLevel")]
    pub performance_level: String,
}

impl crate::FlatSerialize for ModifyInstanceSpecDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.disk_id, &format!("{}.DiskId", name), params);
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.performance_level,
            &format!("{}.PerformanceLevel", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PrepayInstanceSpecDisk {
    #[serde(rename = "DiskId")]
    pub disk_id: String,
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "PerformanceLevel")]
    pub performance_level: String,
}

impl crate::FlatSerialize for PrepayInstanceSpecDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.disk_id, &format!("{}.DiskId", name), params);
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.performance_level,
            &format!("{}.PerformanceLevel", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttachInstanceRamRoleResult {
    #[serde(rename = "Code")]
    pub code: String,
    #[serde(rename = "Message")]
    pub message: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Success")]
    pub success: bool,
}

impl crate::FlatSerialize for AttachInstanceRamRoleResult {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
        crate::FlatSerialize::flat_serialize(&self.message, &format!("{}.Message", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.success, &format!("{}.Success", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttachInstanceRamRoleResults {
    #[serde(rename = "AttachInstanceRamRoleResult")]
    pub attach_instance_ram_role_result: Vec<AttachInstanceRamRoleResult>,
}

impl crate::FlatSerialize for AttachInstanceRamRoleResults {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.attach_instance_ram_role_result,
            &format!("{}.AttachInstanceRamRoleResult", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseInstanceRamRoleSetsInstanceRamRoleSet {
    #[serde(rename = "RamRoleName")]
    pub ram_role_name: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
}

impl crate::FlatSerialize for ResponseInstanceRamRoleSetsInstanceRamRoleSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ram_role_name,
            &format!("{}.RamRoleName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseInstanceRamRoleSets {
    #[serde(rename = "InstanceRamRoleSet")]
    pub instance_ram_role_set: Vec<ResponseInstanceRamRoleSetsInstanceRamRoleSet>,
}

impl crate::FlatSerialize for ResponseInstanceRamRoleSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_ram_role_set,
            &format!("{}.InstanceRamRoleSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemInstanceRamRoleSetsInstanceRamRoleSet {
    #[serde(rename = "RamRoleName")]
    pub ram_role_name: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
}

impl crate::FlatSerialize for ItemInstanceRamRoleSetsInstanceRamRoleSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ram_role_name,
            &format!("{}.RamRoleName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemInstanceRamRoleSets {
    #[serde(rename = "InstanceRamRoleSet")]
    pub instance_ram_role_set: Vec<ItemInstanceRamRoleSetsInstanceRamRoleSet>,
}

impl crate::FlatSerialize for ItemInstanceRamRoleSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_ram_role_set,
            &format!("{}.InstanceRamRoleSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DetachInstanceRamRoleResult {
    #[serde(rename = "Code")]
    pub code: String,
    #[serde(rename = "Message")]
    pub message: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Success")]
    pub success: bool,
    #[serde(rename = "InstanceRamRoleSets")]
    pub instance_ram_role_sets: ItemInstanceRamRoleSets,
}

impl crate::FlatSerialize for DetachInstanceRamRoleResult {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
        crate::FlatSerialize::flat_serialize(&self.message, &format!("{}.Message", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.success, &format!("{}.Success", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_ram_role_sets,
            &format!("{}.InstanceRamRoleSets", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DetachInstanceRamRoleResults {
    #[serde(rename = "DetachInstanceRamRoleResult")]
    pub detach_instance_ram_role_result: Vec<DetachInstanceRamRoleResult>,
}

impl crate::FlatSerialize for DetachInstanceRamRoleResults {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.detach_instance_ram_role_result,
            &format!("{}.DetachInstanceRamRoleResult", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributesInstanceRenewAttribute {
    #[serde(rename = "PeriodUnit")]
    pub period_unit: String,
    #[serde(rename = "Duration")]
    pub duration: i32,
    #[serde(rename = "RenewalStatus")]
    pub renewal_status: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "AutoRenewEnabled")]
    pub auto_renew_enabled: bool,
}

impl crate::FlatSerialize for AttributesInstanceRenewAttribute {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.period_unit,
            &format!("{}.PeriodUnit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.duration, &format!("{}.Duration", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.renewal_status,
            &format!("{}.RenewalStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_renew_enabled,
            &format!("{}.AutoRenewEnabled", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseInstanceRenewAttributes {
    #[serde(rename = "InstanceRenewAttribute")]
    pub instance_renew_attribute: Vec<AttributesInstanceRenewAttribute>,
}

impl crate::FlatSerialize for ResponseInstanceRenewAttributes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_renew_attribute,
            &format!("{}.InstanceRenewAttribute", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PriceType {
    #[serde(rename = "IoOptimized")]
    pub io_optimized: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "SpotPrice")]
    pub spot_price: f32,
    #[serde(rename = "Timestamp")]
    pub timestamp: String,
    #[serde(rename = "NetworkType")]
    pub network_type: String,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "OriginPrice")]
    pub origin_price: f32,
}

impl crate::FlatSerialize for PriceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.io_optimized,
            &format!("{}.IoOptimized", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.spot_price,
            &format!("{}.SpotPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.timestamp,
            &format!("{}.Timestamp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_type,
            &format!("{}.NetworkType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.origin_price,
            &format!("{}.OriginPrice", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SpotPrices {
    #[serde(rename = "SpotPriceType")]
    pub spot_price_type: Vec<PriceType>,
}

impl crate::FlatSerialize for SpotPrices {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.spot_price_type,
            &format!("{}.SpotPriceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SpotResource {
    #[serde(rename = "InterruptRateDesc")]
    pub interrupt_rate_desc: String,
    #[serde(rename = "AverageSpotDiscount")]
    pub average_spot_discount: i32,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "InterruptionRate")]
    pub interruption_rate: f32,
}

impl crate::FlatSerialize for SpotResource {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.interrupt_rate_desc,
            &format!("{}.InterruptRateDesc", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.average_spot_discount,
            &format!("{}.AverageSpotDiscount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.interruption_rate,
            &format!("{}.InterruptionRate", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SpotResources {
    #[serde(rename = "AvailableSpotResource")]
    pub available_spot_resource: Vec<SpotResource>,
}

impl crate::FlatSerialize for SpotResources {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.available_spot_resource,
            &format!("{}.AvailableSpotResource", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SpotZone {
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "AvailableSpotResources")]
    pub available_spot_resources: SpotResources,
}

impl crate::FlatSerialize for SpotZone {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.available_spot_resources,
            &format!("{}.AvailableSpotResources", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SpotZones {
    #[serde(rename = "AvailableSpotZone")]
    pub available_spot_zone: Vec<SpotZone>,
}

impl crate::FlatSerialize for SpotZones {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.available_spot_zone,
            &format!("{}.AvailableSpotZone", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CreateImageDiskDeviceMapping {
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "Size")]
    pub size: i32,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "DiskType")]
    pub disk_type: String,
}

impl crate::FlatSerialize for CreateImageDiskDeviceMapping {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.disk_type,
            &format!("{}.DiskType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CreateImageTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for CreateImageTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CreateImageFeatures {
    #[serde(rename = "ImdsSupport")]
    pub imds_support: String,
}

impl crate::FlatSerialize for CreateImageFeatures {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.imds_support,
            &format!("{}.ImdsSupport", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImagesTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for ImagesTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImagesFilter {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ImagesFilter {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemDiskDeviceMappingsDiskDeviceMapping {
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "ImportOSSBucket")]
    pub import_oss_bucket: String,
    #[serde(rename = "Progress")]
    pub progress: String,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "ImportOSSObject")]
    pub import_oss_object: String,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "Size")]
    pub size: String,
    #[serde(rename = "RemainTime")]
    pub remain_time: i32,
    #[serde(rename = "Format")]
    pub format: String,
    #[serde(rename = "Encrypted")]
    pub encrypted: bool,
}

impl crate::FlatSerialize for ItemDiskDeviceMappingsDiskDeviceMapping {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.import_oss_bucket,
            &format!("{}.ImportOSSBucket", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.progress, &format!("{}.Progress", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.import_oss_object,
            &format!("{}.ImportOSSObject", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.remain_time,
            &format!("{}.RemainTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.format, &format!("{}.Format", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemDiskDeviceMappings {
    #[serde(rename = "DiskDeviceMapping")]
    pub disk_device_mapping: Vec<ItemDiskDeviceMappingsDiskDeviceMapping>,
}

impl crate::FlatSerialize for ItemDiskDeviceMappings {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.disk_device_mapping,
            &format!("{}.DiskDeviceMapping", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImageItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for ImageItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImageItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ImageItemTagsTag>,
}

impl crate::FlatSerialize for ImageItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemsItem {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "RiskLevel")]
    pub risk_level: String,
    #[serde(rename = "RiskCode")]
    pub risk_code: String,
}

impl crate::FlatSerialize for ItemsItem {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.risk_level,
            &format!("{}.RiskLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.risk_code,
            &format!("{}.RiskCode", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OptionsItems {
    #[serde(rename = "Item")]
    pub item: Vec<ItemsItem>,
}

impl crate::FlatSerialize for OptionsItems {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.item, &format!("{}.Item", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DetectionOptions {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Items")]
    pub items: OptionsItems,
}

impl crate::FlatSerialize for DetectionOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.items, &format!("{}.Items", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemFeatures {
    #[serde(rename = "NvmeSupport")]
    pub nvme_support: String,
    #[serde(rename = "ImdsSupport")]
    pub imds_support: String,
    #[serde(rename = "CpuOnlineUpgrade")]
    pub cpu_online_upgrade: String,
    #[serde(rename = "CpuOnlineDowngrade")]
    pub cpu_online_downgrade: String,
    #[serde(rename = "MemoryOnlineUpgrade")]
    pub memory_online_upgrade: String,
    #[serde(rename = "MemoryOnlineDowngrade")]
    pub memory_online_downgrade: String,
}

impl crate::FlatSerialize for ItemFeatures {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.nvme_support,
            &format!("{}.NvmeSupport", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.imds_support,
            &format!("{}.ImdsSupport", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_online_upgrade,
            &format!("{}.CpuOnlineUpgrade", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_online_downgrade,
            &format!("{}.CpuOnlineDowngrade", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.memory_online_upgrade,
            &format!("{}.MemoryOnlineUpgrade", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.memory_online_downgrade,
            &format!("{}.MemoryOnlineDowngrade", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImagesImage {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "ImageFamily")]
    pub image_family: String,
    #[serde(rename = "Progress")]
    pub progress: String,
    #[serde(rename = "IsCopied")]
    pub is_copied: bool,
    #[serde(rename = "IsSupportIoOptimized")]
    pub is_support_io_optimized: bool,
    #[serde(rename = "ImageOwnerAlias")]
    pub image_owner_alias: String,
    #[serde(rename = "IsSupportCloudinit")]
    pub is_support_cloudinit: bool,
    #[serde(rename = "ImageVersion")]
    pub image_version: String,
    #[serde(rename = "Usage")]
    pub usage: String,
    #[serde(rename = "IsSelfShared")]
    pub is_self_shared: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Size")]
    pub size: i32,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "Platform")]
    pub platform: String,
    #[serde(rename = "OSNameEn")]
    pub os_name_en: String,
    #[serde(rename = "ImageName")]
    pub image_name: String,
    #[serde(rename = "OSName")]
    pub os_name: String,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "OSType")]
    pub os_type: String,
    #[serde(rename = "IsSubscribed")]
    pub is_subscribed: bool,
    #[serde(rename = "ProductCode")]
    pub product_code: String,
    #[serde(rename = "Architecture")]
    pub architecture: String,
    #[serde(rename = "BootMode")]
    pub boot_mode: String,
    #[serde(rename = "DiskDeviceMappings")]
    pub disk_device_mappings: ItemDiskDeviceMappings,
    #[serde(rename = "Tags")]
    pub tags: ImageItemTags,
    #[serde(rename = "IsPublic")]
    pub is_public: bool,
    #[serde(rename = "ImageOwnerId")]
    pub image_owner_id: i64,
    #[serde(rename = "LoginAsNonRootSupported")]
    pub login_as_non_root_supported: bool,
    #[serde(rename = "SupplierName")]
    pub supplier_name: String,
    #[serde(rename = "DetectionOptions")]
    pub detection_options: DetectionOptions,
    #[serde(rename = "Features")]
    pub features: ItemFeatures,
    #[serde(rename = "LicenseType")]
    pub license_type: String,
}

impl crate::FlatSerialize for ImagesImage {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.image_family,
            &format!("{}.ImageFamily", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.progress, &format!("{}.Progress", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.is_copied,
            &format!("{}.IsCopied", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.is_support_io_optimized,
            &format!("{}.IsSupportIoOptimized", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_owner_alias,
            &format!("{}.ImageOwnerAlias", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.is_support_cloudinit,
            &format!("{}.IsSupportCloudinit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_version,
            &format!("{}.ImageVersion", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.usage, &format!("{}.Usage", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.is_self_shared,
            &format!("{}.IsSelfShared", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.platform, &format!("{}.Platform", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.os_name_en,
            &format!("{}.OSNameEn", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_name,
            &format!("{}.ImageName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.os_name, &format!("{}.OSName", name), params);
        crate::FlatSerialize::flat_serialize(&self.image_id, &format!("{}.ImageId", name), params);
        crate::FlatSerialize::flat_serialize(&self.os_type, &format!("{}.OSType", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.is_subscribed,
            &format!("{}.IsSubscribed", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.product_code,
            &format!("{}.ProductCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.architecture,
            &format!("{}.Architecture", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.boot_mode,
            &format!("{}.BootMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.disk_device_mappings,
            &format!("{}.DiskDeviceMappings", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.is_public,
            &format!("{}.IsPublic", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_owner_id,
            &format!("{}.ImageOwnerId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.login_as_non_root_supported,
            &format!("{}.LoginAsNonRootSupported", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.supplier_name,
            &format!("{}.SupplierName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.detection_options,
            &format!("{}.DetectionOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.features, &format!("{}.Features", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.license_type,
            &format!("{}.LicenseType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseImages {
    #[serde(rename = "Image")]
    pub image: Vec<ImagesImage>,
}

impl crate::FlatSerialize for ResponseImages {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.image, &format!("{}.Image", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeFeatures {
    #[serde(rename = "NvmeSupport")]
    pub nvme_support: String,
    #[serde(rename = "ImdsSupport")]
    pub imds_support: String,
}

impl crate::FlatSerialize for AttributeFeatures {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.nvme_support,
            &format!("{}.NvmeSupport", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.imds_support,
            &format!("{}.ImdsSupport", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImageDiskDeviceMappingsDiskDeviceMapping {
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "ImportOSSBucket")]
    pub import_oss_bucket: String,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "ImportOSSObject")]
    pub import_oss_object: String,
    #[serde(rename = "Size")]
    pub size: String,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "Format")]
    pub format: String,
}

impl crate::FlatSerialize for ImageDiskDeviceMappingsDiskDeviceMapping {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.import_oss_bucket,
            &format!("{}.ImportOSSBucket", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.import_oss_object,
            &format!("{}.ImportOSSObject", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(&self.format, &format!("{}.Format", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImageDiskDeviceMappings {
    #[serde(rename = "DiskDeviceMapping")]
    pub disk_device_mapping: Vec<ImageDiskDeviceMappingsDiskDeviceMapping>,
}

impl crate::FlatSerialize for ImageDiskDeviceMappings {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.disk_device_mapping,
            &format!("{}.DiskDeviceMapping", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImageTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for ImageTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseImageTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ImageTagsTag>,
}

impl crate::FlatSerialize for ResponseImageTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseImage {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "ImageFamily")]
    pub image_family: String,
    #[serde(rename = "Progress")]
    pub progress: String,
    #[serde(rename = "IsCopied")]
    pub is_copied: bool,
    #[serde(rename = "IsSupportIoOptimized")]
    pub is_support_io_optimized: bool,
    #[serde(rename = "ImageOwnerAlias")]
    pub image_owner_alias: String,
    #[serde(rename = "IsSupportCloudinit")]
    pub is_support_cloudinit: bool,
    #[serde(rename = "ImageVersion")]
    pub image_version: String,
    #[serde(rename = "Usage")]
    pub usage: String,
    #[serde(rename = "IsSelfShared")]
    pub is_self_shared: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Size")]
    pub size: i32,
    #[serde(rename = "Platform")]
    pub platform: String,
    #[serde(rename = "ImageName")]
    pub image_name: String,
    #[serde(rename = "OSName")]
    pub os_name: String,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "OSType")]
    pub os_type: String,
    #[serde(rename = "IsSubscribed")]
    pub is_subscribed: bool,
    #[serde(rename = "ProductCode")]
    pub product_code: String,
    #[serde(rename = "Architecture")]
    pub architecture: String,
    #[serde(rename = "DiskDeviceMappings")]
    pub disk_device_mappings: ImageDiskDeviceMappings,
    #[serde(rename = "Tags")]
    pub tags: ResponseImageTags,
}

impl crate::FlatSerialize for ResponseImage {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.image_family,
            &format!("{}.ImageFamily", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.progress, &format!("{}.Progress", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.is_copied,
            &format!("{}.IsCopied", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.is_support_io_optimized,
            &format!("{}.IsSupportIoOptimized", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_owner_alias,
            &format!("{}.ImageOwnerAlias", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.is_support_cloudinit,
            &format!("{}.IsSupportCloudinit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_version,
            &format!("{}.ImageVersion", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.usage, &format!("{}.Usage", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.is_self_shared,
            &format!("{}.IsSelfShared", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(&self.platform, &format!("{}.Platform", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.image_name,
            &format!("{}.ImageName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.os_name, &format!("{}.OSName", name), params);
        crate::FlatSerialize::flat_serialize(&self.image_id, &format!("{}.ImageId", name), params);
        crate::FlatSerialize::flat_serialize(&self.os_type, &format!("{}.OSType", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.is_subscribed,
            &format!("{}.IsSubscribed", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.product_code,
            &format!("{}.ProductCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.architecture,
            &format!("{}.Architecture", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.disk_device_mappings,
            &format!("{}.DiskDeviceMappings", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TypesFilter {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for TypesFilter {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SupportInstanceTypesResponseInstanceTypesInstanceType {
    #[serde(rename = "InstanceTypeId")]
    pub instance_type_id: String,
    #[serde(rename = "InstanceTypeFamily")]
    pub instance_type_family: String,
    #[serde(rename = "CpuCoreCount")]
    pub cpu_core_count: i32,
    #[serde(rename = "MemorySize")]
    pub memory_size: f32,
}

impl crate::FlatSerialize for SupportInstanceTypesResponseInstanceTypesInstanceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_type_id,
            &format!("{}.InstanceTypeId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type_family,
            &format!("{}.InstanceTypeFamily", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_core_count,
            &format!("{}.CpuCoreCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.memory_size,
            &format!("{}.MemorySize", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SupportInstanceTypesResponseInstanceTypes {
    #[serde(rename = "InstanceType")]
    pub instance_type: Vec<SupportInstanceTypesResponseInstanceTypesInstanceType>,
}

impl crate::FlatSerialize for SupportInstanceTypesResponseInstanceTypes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ShareGroup {
    #[serde(rename = "Group")]
    pub group: String,
}

impl crate::FlatSerialize for ShareGroup {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.group, &format!("{}.Group", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ShareGroups {
    #[serde(rename = "ShareGroup")]
    pub share_group: Vec<ShareGroup>,
}

impl crate::FlatSerialize for ShareGroups {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.share_group,
            &format!("{}.ShareGroup", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AccountsAccount {
    #[serde(rename = "AliyunId")]
    pub aliyun_id: String,
    #[serde(rename = "SharedTime")]
    pub shared_time: String,
}

impl crate::FlatSerialize for AccountsAccount {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.aliyun_id,
            &format!("{}.AliyunId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.shared_time,
            &format!("{}.SharedTime", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseAccounts {
    #[serde(rename = "Account")]
    pub account: Vec<AccountsAccount>,
}

impl crate::FlatSerialize for ResponseAccounts {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.account, &format!("{}.Account", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImportImageDiskDeviceMapping {
    #[serde(rename = "DiskImSize")]
    pub disk_im_size: i32,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "OSSBucket")]
    pub oss_bucket: String,
    #[serde(rename = "Format")]
    pub format: String,
    #[serde(rename = "OSSObject")]
    pub oss_object: String,
    #[serde(rename = "DiskImageSize")]
    pub disk_image_size: i32,
}

impl crate::FlatSerialize for ImportImageDiskDeviceMapping {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.disk_im_size,
            &format!("{}.DiskImSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.oss_bucket,
            &format!("{}.OSSBucket", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.format, &format!("{}.Format", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.oss_object,
            &format!("{}.OSSObject", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.disk_image_size,
            &format!("{}.DiskImageSize", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImportImageTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ImportImageTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImportImageFeatures {
    #[serde(rename = "NvmeSupport")]
    pub nvme_support: String,
    #[serde(rename = "ImdsSupport")]
    pub imds_support: String,
}

impl crate::FlatSerialize for ImportImageFeatures {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.nvme_support,
            &format!("{}.NvmeSupport", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.imds_support,
            &format!("{}.ImdsSupport", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CopyImageTag {
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for CopyImageTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ComponentTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ComponentTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ComponentsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ComponentsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ComponentSetItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for ComponentSetItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ComponentSetItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ComponentSetItemTagsTag>,
}

impl crate::FlatSerialize for ComponentSetItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ParametersParameter {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "DefaultValue")]
    pub default_value: String,
}

impl crate::FlatSerialize for ParametersParameter {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.default_value,
            &format!("{}.DefaultValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemParameters {
    #[serde(rename = "Parameter")]
    pub parameter: Vec<ParametersParameter>,
}

impl crate::FlatSerialize for ItemParameters {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.parameter,
            &format!("{}.Parameter", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ComponentSet {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SystemType")]
    pub system_type: String,
    #[serde(rename = "ImageComponentId")]
    pub image_component_id: String,
    #[serde(rename = "ComponentType")]
    pub component_type: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Content")]
    pub content: String,
    #[serde(rename = "Owner")]
    pub owner: String,
    #[serde(rename = "Tags")]
    pub tags: ComponentSetItemTags,
    #[serde(rename = "ComponentVersion")]
    pub component_version: String,
    #[serde(rename = "Parameters")]
    pub parameters: ItemParameters,
}

impl crate::FlatSerialize for ComponentSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_type,
            &format!("{}.SystemType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_component_id,
            &format!("{}.ImageComponentId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.component_type,
            &format!("{}.ComponentType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.content, &format!("{}.Content", name), params);
        crate::FlatSerialize::flat_serialize(&self.owner, &format!("{}.Owner", name), params);
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.component_version,
            &format!("{}.ComponentVersion", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.parameters,
            &format!("{}.Parameters", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImageComponent {
    #[serde(rename = "ImageComponentSet")]
    pub image_component_set: Vec<ComponentSet>,
}

impl crate::FlatSerialize for ImageComponent {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.image_component_set,
            &format!("{}.ImageComponentSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PipelineTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for PipelineTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OptionsDiskDeviceMapping {
    #[serde(rename = "OSSBucket")]
    pub oss_bucket: String,
    #[serde(rename = "OSSObject")]
    pub oss_object: String,
    #[serde(rename = "Format")]
    pub format: String,
    #[serde(rename = "DiskImageSize")]
    pub disk_image_size: i32,
}

impl crate::FlatSerialize for OptionsDiskDeviceMapping {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.oss_bucket,
            &format!("{}.OSSBucket", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.oss_object,
            &format!("{}.OSSObject", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.format, &format!("{}.Format", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.disk_image_size,
            &format!("{}.DiskImageSize", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PipelineImportImageOptionsFeatures {
    #[serde(rename = "NvmeSupport")]
    pub nvme_support: String,
    #[serde(rename = "ImdsSupport")]
    pub imds_support: String,
}

impl crate::FlatSerialize for PipelineImportImageOptionsFeatures {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.nvme_support,
            &format!("{}.NvmeSupport", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.imds_support,
            &format!("{}.ImdsSupport", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OptionsImportImageTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for OptionsImportImageTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PipelineImportImageOptions {
    #[serde(rename = "Architecture")]
    pub architecture: String,
    #[serde(rename = "OSType")]
    pub os_type: String,
    #[serde(rename = "Platform")]
    pub platform: String,
    #[serde(rename = "BootMode")]
    pub boot_mode: String,
    #[serde(rename = "LicenseType")]
    pub license_type: String,
    #[serde(rename = "DiskDeviceMappings")]
    pub disk_device_mappings: Vec<OptionsDiskDeviceMapping>,
    #[serde(rename = "Features")]
    pub features: PipelineImportImageOptionsFeatures,
    #[serde(rename = "RetainImportedImage")]
    pub retain_imported_image: bool,
    #[serde(rename = "RetentionStrategy")]
    pub retention_strategy: String,
    #[serde(rename = "ImageName")]
    pub image_name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RoleName")]
    pub role_name: String,
    #[serde(rename = "ImportImageTags")]
    pub import_image_tags: Vec<OptionsImportImageTag>,
}

impl crate::FlatSerialize for PipelineImportImageOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.architecture,
            &format!("{}.Architecture", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.os_type, &format!("{}.OSType", name), params);
        crate::FlatSerialize::flat_serialize(&self.platform, &format!("{}.Platform", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.boot_mode,
            &format!("{}.BootMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.license_type,
            &format!("{}.LicenseType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.disk_device_mappings,
            &format!("{}.DiskDeviceMappings", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.features, &format!("{}.Features", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.retain_imported_image,
            &format!("{}.RetainImportedImage", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.retention_strategy,
            &format!("{}.RetentionStrategy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_name,
            &format!("{}.ImageName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.role_name,
            &format!("{}.RoleName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.import_image_tags,
            &format!("{}.ImportImageTags", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PipelineAdvancedOptions {
    #[serde(rename = "RetainCloudAssistant")]
    pub retain_cloud_assistant: bool,
    #[serde(rename = "ImageNameSuffix")]
    pub image_name_suffix: String,
}

impl crate::FlatSerialize for PipelineAdvancedOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.retain_cloud_assistant,
            &format!("{}.RetainCloudAssistant", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_name_suffix,
            &format!("{}.ImageNameSuffix", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PipelineImageOptionsImageFeatures {
    #[serde(rename = "NvmeSupport")]
    pub nvme_support: String,
}

impl crate::FlatSerialize for PipelineImageOptionsImageFeatures {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.nvme_support,
            &format!("{}.NvmeSupport", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OptionsImageTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for OptionsImageTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PipelineImageOptions {
    #[serde(rename = "ImageName")]
    pub image_name: String,
    #[serde(rename = "ImageFamily")]
    pub image_family: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "ImageFeatures")]
    pub image_features: PipelineImageOptionsImageFeatures,
    #[serde(rename = "ImageTags")]
    pub image_tags: Vec<OptionsImageTag>,
}

impl crate::FlatSerialize for PipelineImageOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.image_name,
            &format!("{}.ImageName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_family,
            &format!("{}.ImageFamily", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_features,
            &format!("{}.ImageFeatures", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_tags,
            &format!("{}.ImageTags", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PipelinesTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for PipelinesTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PipelineSetItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for PipelineSetItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PipelineSetItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<PipelineSetItemTagsTag>,
}

impl crate::FlatSerialize for PipelineSetItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RegionIds {
    #[serde(rename = "ToRegionId")]
    pub to_region_id: Vec<String>,
}

impl crate::FlatSerialize for RegionIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.to_region_id,
            &format!("{}.ToRegionId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AddAccounts {
    #[serde(rename = "AddAccount")]
    pub add_account: Vec<String>,
}

impl crate::FlatSerialize for AddAccounts {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.add_account,
            &format!("{}.AddAccount", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OptionsDiskDeviceMappingsDiskDeviceMapping {
    #[serde(rename = "OSSBucket")]
    pub oss_bucket: String,
    #[serde(rename = "OSSObject")]
    pub oss_object: String,
    #[serde(rename = "Format")]
    pub format: String,
    #[serde(rename = "DiskImageSize")]
    pub disk_image_size: i32,
}

impl crate::FlatSerialize for OptionsDiskDeviceMappingsDiskDeviceMapping {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.oss_bucket,
            &format!("{}.OSSBucket", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.oss_object,
            &format!("{}.OSSObject", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.format, &format!("{}.Format", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.disk_image_size,
            &format!("{}.DiskImageSize", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OptionsDiskDeviceMappings {
    #[serde(rename = "DiskDeviceMapping")]
    pub disk_device_mapping: Vec<OptionsDiskDeviceMappingsDiskDeviceMapping>,
}

impl crate::FlatSerialize for OptionsDiskDeviceMappings {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.disk_device_mapping,
            &format!("{}.DiskDeviceMapping", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemImportImageOptionsFeatures {
    #[serde(rename = "NvmeSupport")]
    pub nvme_support: String,
    #[serde(rename = "ImdsSupport")]
    pub imds_support: String,
}

impl crate::FlatSerialize for ItemImportImageOptionsFeatures {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.nvme_support,
            &format!("{}.NvmeSupport", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.imds_support,
            &format!("{}.ImdsSupport", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TagsImportImageTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for TagsImportImageTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImportImageTags {
    #[serde(rename = "ImportImageTag")]
    pub import_image_tag: Vec<TagsImportImageTag>,
}

impl crate::FlatSerialize for ImportImageTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.import_image_tag,
            &format!("{}.ImportImageTag", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemImportImageOptions {
    #[serde(rename = "Architecture")]
    pub architecture: String,
    #[serde(rename = "OSType")]
    pub os_type: String,
    #[serde(rename = "Platform")]
    pub platform: String,
    #[serde(rename = "BootMode")]
    pub boot_mode: String,
    #[serde(rename = "LicenseType")]
    pub license_type: String,
    #[serde(rename = "DiskDeviceMappings")]
    pub disk_device_mappings: OptionsDiskDeviceMappings,
    #[serde(rename = "Features")]
    pub features: ItemImportImageOptionsFeatures,
    #[serde(rename = "RetainImportedImage")]
    pub retain_imported_image: bool,
    #[serde(rename = "RetentionStrategy")]
    pub retention_strategy: String,
    #[serde(rename = "ImageName")]
    pub image_name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RoleName")]
    pub role_name: String,
    #[serde(rename = "ImportImageTags")]
    pub import_image_tags: ImportImageTags,
}

impl crate::FlatSerialize for ItemImportImageOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.architecture,
            &format!("{}.Architecture", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.os_type, &format!("{}.OSType", name), params);
        crate::FlatSerialize::flat_serialize(&self.platform, &format!("{}.Platform", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.boot_mode,
            &format!("{}.BootMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.license_type,
            &format!("{}.LicenseType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.disk_device_mappings,
            &format!("{}.DiskDeviceMappings", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.features, &format!("{}.Features", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.retain_imported_image,
            &format!("{}.RetainImportedImage", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.retention_strategy,
            &format!("{}.RetentionStrategy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_name,
            &format!("{}.ImageName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.role_name,
            &format!("{}.RoleName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.import_image_tags,
            &format!("{}.ImportImageTags", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemAdvancedOptions {
    #[serde(rename = "RetainCloudAssistant")]
    pub retain_cloud_assistant: bool,
    #[serde(rename = "ImageNameSuffix")]
    pub image_name_suffix: String,
}

impl crate::FlatSerialize for ItemAdvancedOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.retain_cloud_assistant,
            &format!("{}.RetainCloudAssistant", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_name_suffix,
            &format!("{}.ImageNameSuffix", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemImageOptionsImageFeatures {
    #[serde(rename = "NvmeSupport")]
    pub nvme_support: String,
}

impl crate::FlatSerialize for ItemImageOptionsImageFeatures {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.nvme_support,
            &format!("{}.NvmeSupport", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TagsImageTag {
    #[serde(rename = "TagKey")]
    pub tag_key: String,
    #[serde(rename = "TagValue")]
    pub tag_value: String,
}

impl crate::FlatSerialize for TagsImageTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OptionsImageTags {
    #[serde(rename = "ImageTag")]
    pub image_tag: Vec<TagsImageTag>,
}

impl crate::FlatSerialize for OptionsImageTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.image_tag,
            &format!("{}.ImageTag", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetItemImageOptions {
    #[serde(rename = "ImageName")]
    pub image_name: String,
    #[serde(rename = "ImageFamily")]
    pub image_family: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "ImageFeatures")]
    pub image_features: ItemImageOptionsImageFeatures,
    #[serde(rename = "ImageTags")]
    pub image_tags: OptionsImageTags,
}

impl crate::FlatSerialize for SetItemImageOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.image_name,
            &format!("{}.ImageName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_family,
            &format!("{}.ImageFamily", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_features,
            &format!("{}.ImageFeatures", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_tags,
            &format!("{}.ImageTags", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PipelineSet {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "DeleteInstanceOnFailure")]
    pub delete_instance_on_failure: bool,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "InternetMaxBandwidthOut")]
    pub internet_max_bandwidth_out: i32,
    #[serde(rename = "ImagePipelineId")]
    pub image_pipeline_id: String,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "SystemDiskSize")]
    pub system_disk_size: i32,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "BaseImage")]
    pub base_image: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "ImageName")]
    pub image_name: String,
    #[serde(rename = "BaseImageType")]
    pub base_image_type: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "BuildContent")]
    pub build_content: String,
    #[serde(rename = "Tags")]
    pub tags: PipelineSetItemTags,
    #[serde(rename = "ToRegionIds")]
    pub to_region_ids: RegionIds,
    #[serde(rename = "AddAccounts")]
    pub add_accounts: AddAccounts,
    #[serde(rename = "RepairMode")]
    pub repair_mode: String,
    #[serde(rename = "TestContent")]
    pub test_content: String,
    #[serde(rename = "ImageFamily")]
    pub image_family: String,
    #[serde(rename = "NvmeSupport")]
    pub nvme_support: String,
    #[serde(rename = "ImportImageOptions")]
    pub import_image_options: ItemImportImageOptions,
    #[serde(rename = "AdvancedOptions")]
    pub advanced_options: ItemAdvancedOptions,
    #[serde(rename = "ImageOptions")]
    pub image_options: SetItemImageOptions,
}

impl crate::FlatSerialize for PipelineSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.delete_instance_on_failure,
            &format!("{}.DeleteInstanceOnFailure", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_max_bandwidth_out,
            &format!("{}.InternetMaxBandwidthOut", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_pipeline_id,
            &format!("{}.ImagePipelineId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_size,
            &format!("{}.SystemDiskSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.base_image,
            &format!("{}.BaseImage", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_name,
            &format!("{}.ImageName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.base_image_type,
            &format!("{}.BaseImageType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.build_content,
            &format!("{}.BuildContent", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.to_region_ids,
            &format!("{}.ToRegionIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.add_accounts,
            &format!("{}.AddAccounts", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.repair_mode,
            &format!("{}.RepairMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.test_content,
            &format!("{}.TestContent", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_family,
            &format!("{}.ImageFamily", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.nvme_support,
            &format!("{}.NvmeSupport", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.import_image_options,
            &format!("{}.ImportImageOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.advanced_options,
            &format!("{}.AdvancedOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_options,
            &format!("{}.ImageOptions", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImagePipeline {
    #[serde(rename = "ImagePipelineSet")]
    pub image_pipeline_set: Vec<PipelineSet>,
}

impl crate::FlatSerialize for ImagePipeline {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.image_pipeline_set,
            &format!("{}.ImagePipelineSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct StartImagePipelineExecutionTemplateTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for StartImagePipelineExecutionTemplateTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ExecutionTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ExecutionTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ExecutionsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ExecutionsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ExecutionSetItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for ExecutionSetItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ExecutionSetItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ExecutionSetItemTagsTag>,
}

impl crate::FlatSerialize for ExecutionSetItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ExecutionSet {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "ImagePipelineId")]
    pub image_pipeline_id: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "ModifiedTime")]
    pub modified_time: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "Message")]
    pub message: String,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "ExecutionId")]
    pub execution_id: String,
    #[serde(rename = "Tags")]
    pub tags: ExecutionSetItemTags,
}

impl crate::FlatSerialize for ExecutionSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_pipeline_id,
            &format!("{}.ImagePipelineId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.modified_time,
            &format!("{}.ModifiedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.message, &format!("{}.Message", name), params);
        crate::FlatSerialize::flat_serialize(&self.image_id, &format!("{}.ImageId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.execution_id,
            &format!("{}.ExecutionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PipelineExecution {
    #[serde(rename = "ImagePipelineExecutionSet")]
    pub image_pipeline_execution_set: Vec<ExecutionSet>,
}

impl crate::FlatSerialize for PipelineExecution {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.image_pipeline_execution_set,
            &format!("{}.ImagePipelineExecutionSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CancelImagePipelineExecutionTemplateTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for CancelImagePipelineExecutionTemplateTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for DiskTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CreateDiskArn {
    #[serde(rename = "RoleType")]
    pub role_type: String,
    #[serde(rename = "Rolearn")]
    pub rolearn: String,
    #[serde(rename = "AssumeRoleFor")]
    pub assume_role_for: i64,
}

impl crate::FlatSerialize for CreateDiskArn {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.role_type,
            &format!("{}.RoleType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rolearn, &format!("{}.Rolearn", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.assume_role_for,
            &format!("{}.AssumeRoleFor", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DisksTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for DisksTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskItemOperationLocksOperationLock {
    #[serde(rename = "LockReason")]
    pub lock_reason: String,
}

impl crate::FlatSerialize for DiskItemOperationLocksOperationLock {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.lock_reason,
            &format!("{}.LockReason", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskItemOperationLocks {
    #[serde(rename = "OperationLock")]
    pub operation_lock: Vec<DiskItemOperationLocksOperationLock>,
}

impl crate::FlatSerialize for DiskItemOperationLocks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.operation_lock,
            &format!("{}.OperationLock", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct MountInstance {
    #[serde(rename = "AttachedTime")]
    pub attached_time: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Device")]
    pub device: String,
}

impl crate::FlatSerialize for MountInstance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.attached_time,
            &format!("{}.AttachedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct MountInstances {
    #[serde(rename = "MountInstance")]
    pub mount_instance: Vec<MountInstance>,
}

impl crate::FlatSerialize for MountInstances {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.mount_instance,
            &format!("{}.MountInstance", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for DiskItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<DiskItemTagsTag>,
}

impl crate::FlatSerialize for DiskItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttachmentsAttachment {
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "AttachedTime")]
    pub attached_time: String,
}

impl crate::FlatSerialize for AttachmentsAttachment {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.attached_time,
            &format!("{}.AttachedTime", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemAttachments {
    #[serde(rename = "Attachment")]
    pub attachment: Vec<AttachmentsAttachment>,
}

impl crate::FlatSerialize for ItemAttachments {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.attachment,
            &format!("{}.Attachment", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemPlacement {
    #[serde(rename = "ZoneIds")]
    pub zone_ids: String,
}

impl crate::FlatSerialize for ItemPlacement {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.zone_ids, &format!("{}.ZoneIds", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseDisksDisk {
    #[serde(rename = "SerialNumber")]
    pub serial_number: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "PerformanceLevel")]
    pub performance_level: String,
    #[serde(rename = "BdfId")]
    pub bdf_id: String,
    #[serde(rename = "EnableAutoSnapshot")]
    pub enable_auto_snapshot: bool,
    #[serde(rename = "StorageSetId")]
    pub storage_set_id: String,
    #[serde(rename = "StorageSetPartitionNumber")]
    pub storage_set_partition_number: i32,
    #[serde(rename = "DiskId")]
    pub disk_id: String,
    #[serde(rename = "DeleteAutoSnapshot")]
    pub delete_auto_snapshot: bool,
    #[serde(rename = "StorageClusterId")]
    pub storage_cluster_id: String,
    #[serde(rename = "Encrypted")]
    pub encrypted: bool,
    #[serde(rename = "IOPSRead")]
    pub iops_read: i32,
    #[serde(rename = "MountInstanceNum")]
    pub mount_instance_num: i32,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "DiskName")]
    pub disk_name: String,
    #[serde(rename = "Portable")]
    pub portable: bool,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
    #[serde(rename = "DeleteWithInstance")]
    pub delete_with_instance: bool,
    #[serde(rename = "DetachedTime")]
    pub detached_time: String,
    #[serde(rename = "SourceSnapshotId")]
    pub source_snapshot_id: String,
    #[serde(rename = "AutoSnapshotPolicyId")]
    pub auto_snapshot_policy_id: String,
    #[serde(rename = "EnableAutomatedSnapshotPolicy")]
    pub enable_automated_snapshot_policy: bool,
    #[serde(rename = "IOPSWrite")]
    pub iops_write: i32,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "IOPS")]
    pub iops: i32,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "ExpiredTime")]
    pub expired_time: String,
    #[serde(rename = "Size")]
    pub size: i32,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "DiskChargeType")]
    pub disk_charge_type: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "AttachedTime")]
    pub attached_time: String,
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "ProductCode")]
    pub product_code: String,
    #[serde(rename = "MultiAttach")]
    pub multi_attach: String,
    #[serde(rename = "OperationLocks")]
    pub operation_locks: DiskItemOperationLocks,
    #[serde(rename = "MountInstances")]
    pub mount_instances: MountInstances,
    #[serde(rename = "Tags")]
    pub tags: DiskItemTags,
    #[serde(rename = "Attachments")]
    pub attachments: ItemAttachments,
    #[serde(rename = "ProvisionedIops")]
    pub provisioned_iops: i64,
    #[serde(rename = "BurstingEnabled")]
    pub bursting_enabled: bool,
    #[serde(rename = "Throughput")]
    pub throughput: i32,
    #[serde(rename = "ThroughputRead")]
    pub throughput_read: i32,
    #[serde(rename = "ThroughputWrite")]
    pub throughput_write: i32,
    #[serde(rename = "Placement")]
    pub placement: ItemPlacement,
}

impl crate::FlatSerialize for ResponseDisksDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.serial_number,
            &format!("{}.SerialNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.performance_level,
            &format!("{}.PerformanceLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.bdf_id, &format!("{}.BdfId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.enable_auto_snapshot,
            &format!("{}.EnableAutoSnapshot", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.storage_set_id,
            &format!("{}.StorageSetId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.storage_set_partition_number,
            &format!("{}.StorageSetPartitionNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.disk_id, &format!("{}.DiskId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.delete_auto_snapshot,
            &format!("{}.DeleteAutoSnapshot", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.storage_cluster_id,
            &format!("{}.StorageClusterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.iops_read,
            &format!("{}.IOPSRead", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.mount_instance_num,
            &format!("{}.MountInstanceNum", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.disk_name,
            &format!("{}.DiskName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.portable, &format!("{}.Portable", name), params);
        crate::FlatSerialize::flat_serialize(&self.image_id, &format!("{}.ImageId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.delete_with_instance,
            &format!("{}.DeleteWithInstance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.detached_time,
            &format!("{}.DetachedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_snapshot_id,
            &format!("{}.SourceSnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy_id,
            &format!("{}.AutoSnapshotPolicyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_automated_snapshot_policy,
            &format!("{}.EnableAutomatedSnapshotPolicy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.iops_write,
            &format!("{}.IOPSWrite", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.iops, &format!("{}.IOPS", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.expired_time,
            &format!("{}.ExpiredTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.disk_charge_type,
            &format!("{}.DiskChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.attached_time,
            &format!("{}.AttachedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.product_code,
            &format!("{}.ProductCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.multi_attach,
            &format!("{}.MultiAttach", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.operation_locks,
            &format!("{}.OperationLocks", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.mount_instances,
            &format!("{}.MountInstances", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.attachments,
            &format!("{}.Attachments", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.provisioned_iops,
            &format!("{}.ProvisionedIops", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bursting_enabled,
            &format!("{}.BurstingEnabled", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.throughput,
            &format!("{}.Throughput", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.throughput_read,
            &format!("{}.ThroughputRead", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.throughput_write,
            &format!("{}.ThroughputWrite", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.placement,
            &format!("{}.Placement", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseDisks {
    #[serde(rename = "Disk")]
    pub disk: Vec<ResponseDisksDisk>,
}

impl crate::FlatSerialize for ResponseDisks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.disk, &format!("{}.Disk", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ControlOptions {
    #[serde(rename = "IOPS")]
    pub iops: i32,
    #[serde(rename = "Throughput")]
    pub throughput: i32,
    #[serde(rename = "Recover")]
    pub recover: OptionsRecover,
}

impl crate::FlatSerialize for ControlOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.iops, &format!("{}.IOPS", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.throughput,
            &format!("{}.Throughput", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.recover, &format!("{}.Recover", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SystemDiskArn {
    #[serde(rename = "RoleType")]
    pub role_type: String,
    #[serde(rename = "Rolearn")]
    pub rolearn: String,
    #[serde(rename = "AssumeRoleFor")]
    pub assume_role_for: i64,
}

impl crate::FlatSerialize for SystemDiskArn {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.role_type,
            &format!("{}.RoleType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rolearn, &format!("{}.Rolearn", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.assume_role_for,
            &format!("{}.AssumeRoleFor", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResetDisksDisk {
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "DiskId")]
    pub disk_id: String,
}

impl crate::FlatSerialize for ResetDisksDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.disk_id, &format!("{}.DiskId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DisksResponseOperationProgressSetOperationProgressItemRelatedItemSetRelatedItem {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize
    for DisksResponseOperationProgressSetOperationProgressItemRelatedItemSetRelatedItem
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DisksResponseOperationProgressSetOperationProgressItemRelatedItemSet {
    #[serde(rename = "RelatedItem")]
    pub related_item:
        Vec<DisksResponseOperationProgressSetOperationProgressItemRelatedItemSetRelatedItem>,
}

impl crate::FlatSerialize for DisksResponseOperationProgressSetOperationProgressItemRelatedItemSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.related_item,
            &format!("{}.RelatedItem", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DisksResponseOperationProgressSetOperationProgress {
    #[serde(rename = "ErrorMsg")]
    pub error_msg: String,
    #[serde(rename = "ErrorCode")]
    pub error_code: String,
    #[serde(rename = "OperationStatus")]
    pub operation_status: String,
    #[serde(rename = "RelatedItemSet")]
    pub related_item_set: DisksResponseOperationProgressSetOperationProgressItemRelatedItemSet,
}

impl crate::FlatSerialize for DisksResponseOperationProgressSetOperationProgress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.error_msg,
            &format!("{}.ErrorMsg", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.error_code,
            &format!("{}.ErrorCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.operation_status,
            &format!("{}.OperationStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.related_item_set,
            &format!("{}.RelatedItemSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DisksResponseOperationProgressSet {
    #[serde(rename = "OperationProgress")]
    pub operation_progress: Vec<DisksResponseOperationProgressSetOperationProgress>,
}

impl crate::FlatSerialize for DisksResponseOperationProgressSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.operation_progress,
            &format!("{}.OperationProgress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CreateSnapshotTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for CreateSnapshotTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for SnapshotsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseSnapshotsSnapshotItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for ResponseSnapshotsSnapshotItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseSnapshotsSnapshotItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ResponseSnapshotsSnapshotItemTagsTag>,
}

impl crate::FlatSerialize for ResponseSnapshotsSnapshotItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseSnapshotsSnapshot {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Progress")]
    pub progress: String,
    #[serde(rename = "InstantAccess")]
    pub instant_access: bool,
    #[serde(rename = "Available")]
    pub available: bool,
    #[serde(rename = "RemainTime")]
    pub remain_time: i32,
    #[serde(rename = "SourceDiskSize")]
    pub source_disk_size: String,
    #[serde(rename = "RetentionDays")]
    pub retention_days: i32,
    #[serde(rename = "SourceDiskType")]
    pub source_disk_type: String,
    #[serde(rename = "SourceStorageType")]
    pub source_storage_type: String,
    #[serde(rename = "Usage")]
    pub usage: String,
    #[serde(rename = "LastModifiedTime")]
    pub last_modified_time: String,
    #[serde(rename = "Encrypted")]
    pub encrypted: bool,
    #[serde(rename = "SnapshotType")]
    pub snapshot_type: String,
    #[serde(rename = "SourceDiskId")]
    pub source_disk_id: String,
    #[serde(rename = "SnapshotName")]
    pub snapshot_name: String,
    #[serde(rename = "InstantAccessRetentionDays")]
    pub instant_access_retention_days: i32,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
    #[serde(rename = "SnapshotSN")]
    pub snapshot_sn: String,
    #[serde(rename = "ProductCode")]
    pub product_code: String,
    #[serde(rename = "SourceSnapshotId")]
    pub source_snapshot_id: String,
    #[serde(rename = "SourceRegionId")]
    pub source_region_id: String,
    #[serde(rename = "SnapshotLinkId")]
    pub snapshot_link_id: String,
    #[serde(rename = "Tags")]
    pub tags: ResponseSnapshotsSnapshotItemTags,
}

impl crate::FlatSerialize for ResponseSnapshotsSnapshot {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.progress, &format!("{}.Progress", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instant_access,
            &format!("{}.InstantAccess", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available,
            &format!("{}.Available", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.remain_time,
            &format!("{}.RemainTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_disk_size,
            &format!("{}.SourceDiskSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.retention_days,
            &format!("{}.RetentionDays", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_disk_type,
            &format!("{}.SourceDiskType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_storage_type,
            &format!("{}.SourceStorageType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.usage, &format!("{}.Usage", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.last_modified_time,
            &format!("{}.LastModifiedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_type,
            &format!("{}.SnapshotType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_disk_id,
            &format!("{}.SourceDiskId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_name,
            &format!("{}.SnapshotName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instant_access_retention_days,
            &format!("{}.InstantAccessRetentionDays", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_sn,
            &format!("{}.SnapshotSN", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.product_code,
            &format!("{}.ProductCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_snapshot_id,
            &format!("{}.SourceSnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_region_id,
            &format!("{}.SourceRegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_link_id,
            &format!("{}.SnapshotLinkId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseSnapshots {
    #[serde(rename = "Snapshot")]
    pub snapshot: Vec<ResponseSnapshotsSnapshot>,
}

impl crate::FlatSerialize for ResponseSnapshots {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.snapshot, &format!("{}.Snapshot", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CopySnapshotTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for CopySnapshotTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotArn {
    #[serde(rename = "RoleType")]
    pub role_type: String,
    #[serde(rename = "Rolearn")]
    pub rolearn: String,
    #[serde(rename = "AssumeRoleFor")]
    pub assume_role_for: i64,
}

impl crate::FlatSerialize for SnapshotArn {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.role_type,
            &format!("{}.RoleType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rolearn, &format!("{}.Rolearn", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.assume_role_for,
            &format!("{}.AssumeRoleFor", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotLink {
    #[serde(rename = "InstantAccess")]
    pub instant_access: bool,
    #[serde(rename = "TotalSize")]
    pub total_size: i64,
    #[serde(rename = "SourceDiskName")]
    pub source_disk_name: String,
    #[serde(rename = "SourceDiskSize")]
    pub source_disk_size: i32,
    #[serde(rename = "SourceDiskType")]
    pub source_disk_type: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "SnapshotLinkId")]
    pub snapshot_link_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "SourceDiskId")]
    pub source_disk_id: String,
    #[serde(rename = "InstanceName")]
    pub instance_name: String,
    #[serde(rename = "Category")]
    pub category: String,
}

impl crate::FlatSerialize for SnapshotLink {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instant_access,
            &format!("{}.InstantAccess", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_size,
            &format!("{}.TotalSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_disk_name,
            &format!("{}.SourceDiskName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_disk_size,
            &format!("{}.SourceDiskSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_disk_type,
            &format!("{}.SourceDiskType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_link_id,
            &format!("{}.SnapshotLinkId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_count,
            &format!("{}.TotalCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_disk_id,
            &format!("{}.SourceDiskId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_name,
            &format!("{}.InstanceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotLinks {
    #[serde(rename = "SnapshotLink")]
    pub snapshot_link: Vec<SnapshotLink>,
}

impl crate::FlatSerialize for SnapshotLinks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_link,
            &format!("{}.SnapshotLink", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotGroupTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for SnapshotGroupTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotGroupsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for SnapshotGroupsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotGroupItemTagsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for SnapshotGroupItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotGroupItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<SnapshotGroupItemTagsTag>,
}

impl crate::FlatSerialize for SnapshotGroupItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemSnapshotsSnapshotItemTagsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ItemSnapshotsSnapshotItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemSnapshotsSnapshotItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ItemSnapshotsSnapshotItemTagsTag>,
}

impl crate::FlatSerialize for ItemSnapshotsSnapshotItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemSnapshotsSnapshot {
    #[serde(rename = "SourceDiskId")]
    pub source_disk_id: String,
    #[serde(rename = "Progress")]
    pub progress: String,
    #[serde(rename = "Available")]
    pub available: bool,
    #[serde(rename = "InstantAccessRetentionDays")]
    pub instant_access_retention_days: i32,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "InstantAccess")]
    pub instant_access: bool,
    #[serde(rename = "SourceDiskType")]
    pub source_disk_type: String,
    #[serde(rename = "Tags")]
    pub tags: ItemSnapshotsSnapshotItemTags,
}

impl crate::FlatSerialize for ItemSnapshotsSnapshot {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.source_disk_id,
            &format!("{}.SourceDiskId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.progress, &format!("{}.Progress", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.available,
            &format!("{}.Available", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instant_access_retention_days,
            &format!("{}.InstantAccessRetentionDays", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instant_access,
            &format!("{}.InstantAccess", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_disk_type,
            &format!("{}.SourceDiskType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemSnapshots {
    #[serde(rename = "Snapshot")]
    pub snapshot: Vec<ItemSnapshotsSnapshot>,
}

impl crate::FlatSerialize for ItemSnapshots {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.snapshot, &format!("{}.Snapshot", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotGroup {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "ProgressStatus")]
    pub progress_status: String,
    #[serde(rename = "SnapshotGroupId")]
    pub snapshot_group_id: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "Tags")]
    pub tags: SnapshotGroupItemTags,
    #[serde(rename = "Snapshots")]
    pub snapshots: ItemSnapshots,
}

impl crate::FlatSerialize for SnapshotGroup {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.progress_status,
            &format!("{}.ProgressStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_group_id,
            &format!("{}.SnapshotGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.snapshots,
            &format!("{}.Snapshots", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotGroups {
    #[serde(rename = "SnapshotGroup")]
    pub snapshot_group: Vec<SnapshotGroup>,
}

impl crate::FlatSerialize for SnapshotGroups {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_group,
            &format!("{}.SnapshotGroup", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GroupResponseOperationProgressSetOperationProgressItemRelatedItemSetRelatedItem {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize
    for GroupResponseOperationProgressSetOperationProgressItemRelatedItemSetRelatedItem
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GroupResponseOperationProgressSetOperationProgressItemRelatedItemSet {
    #[serde(rename = "RelatedItem")]
    pub related_item:
        Vec<GroupResponseOperationProgressSetOperationProgressItemRelatedItemSetRelatedItem>,
}

impl crate::FlatSerialize for GroupResponseOperationProgressSetOperationProgressItemRelatedItemSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.related_item,
            &format!("{}.RelatedItem", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GroupResponseOperationProgressSetOperationProgress {
    #[serde(rename = "ErrorMsg")]
    pub error_msg: String,
    #[serde(rename = "ErrorCode")]
    pub error_code: String,
    #[serde(rename = "OperationStatus")]
    pub operation_status: String,
    #[serde(rename = "RelatedItemSet")]
    pub related_item_set: GroupResponseOperationProgressSetOperationProgressItemRelatedItemSet,
}

impl crate::FlatSerialize for GroupResponseOperationProgressSetOperationProgress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.error_msg,
            &format!("{}.ErrorMsg", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.error_code,
            &format!("{}.ErrorCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.operation_status,
            &format!("{}.OperationStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.related_item_set,
            &format!("{}.RelatedItemSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GroupResponseOperationProgressSet {
    #[serde(rename = "OperationProgress")]
    pub operation_progress: Vec<GroupResponseOperationProgressSetOperationProgress>,
}

impl crate::FlatSerialize for GroupResponseOperationProgressSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.operation_progress,
            &format!("{}.OperationProgress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PolicyTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for PolicyTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PolicyCopyEncryptionConfigurationArn {
    #[serde(rename = "RoleType")]
    pub role_type: String,
    #[serde(rename = "Rolearn")]
    pub rolearn: String,
    #[serde(rename = "AssumeRoleFor")]
    pub assume_role_for: i64,
}

impl crate::FlatSerialize for PolicyCopyEncryptionConfigurationArn {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.role_type,
            &format!("{}.RoleType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rolearn, &format!("{}.Rolearn", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.assume_role_for,
            &format!("{}.AssumeRoleFor", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PolicyCopyEncryptionConfiguration {
    #[serde(rename = "Encrypted")]
    pub encrypted: bool,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
    #[serde(rename = "Arn")]
    pub arn: Vec<PolicyCopyEncryptionConfigurationArn>,
}

impl crate::FlatSerialize for PolicyCopyEncryptionConfiguration {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.arn, &format!("{}.Arn", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ExTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ExTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PolicyItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for PolicyItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PolicyItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<PolicyItemTagsTag>,
}

impl crate::FlatSerialize for PolicyItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemCopyEncryptionConfiguration {
    #[serde(rename = "Encrypted")]
    pub encrypted: bool,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
}

impl crate::FlatSerialize for ItemCopyEncryptionConfiguration {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotPolicy {
    #[serde(rename = "TimePoints")]
    pub time_points: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "AutoSnapshotPolicyName")]
    pub auto_snapshot_policy_name: String,
    #[serde(rename = "TargetCopyRegions")]
    pub target_copy_regions: String,
    #[serde(rename = "CopiedSnapshotsRetentionDays")]
    pub copied_snapshots_retention_days: i32,
    #[serde(rename = "AutoSnapshotPolicyId")]
    pub auto_snapshot_policy_id: String,
    #[serde(rename = "RetentionDays")]
    pub retention_days: i32,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "DiskNums")]
    pub disk_nums: i32,
    #[serde(rename = "EnableCrossRegionCopy")]
    pub enable_cross_region_copy: bool,
    #[serde(rename = "RepeatWeekdays")]
    pub repeat_weekdays: String,
    #[serde(rename = "VolumeNums")]
    pub volume_nums: i32,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "Tags")]
    pub tags: PolicyItemTags,
    #[serde(rename = "CopyEncryptionConfiguration")]
    pub copy_encryption_configuration: ItemCopyEncryptionConfiguration,
    #[serde(rename = "Type")]
    pub r#type: String,
}

impl crate::FlatSerialize for SnapshotPolicy {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.time_points,
            &format!("{}.TimePoints", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy_name,
            &format!("{}.AutoSnapshotPolicyName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.target_copy_regions,
            &format!("{}.TargetCopyRegions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.copied_snapshots_retention_days,
            &format!("{}.CopiedSnapshotsRetentionDays", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy_id,
            &format!("{}.AutoSnapshotPolicyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.retention_days,
            &format!("{}.RetentionDays", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.disk_nums,
            &format!("{}.DiskNums", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_cross_region_copy,
            &format!("{}.EnableCrossRegionCopy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.repeat_weekdays,
            &format!("{}.RepeatWeekdays", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.volume_nums,
            &format!("{}.VolumeNums", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.copy_encryption_configuration,
            &format!("{}.CopyEncryptionConfiguration", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotPolicies {
    #[serde(rename = "AutoSnapshotPolicy")]
    pub auto_snapshot_policy: Vec<SnapshotPolicy>,
}

impl crate::FlatSerialize for SnapshotPolicies {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy,
            &format!("{}.AutoSnapshotPolicy", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PolicyAssociation {
    #[serde(rename = "AutoSnapshotPolicyId")]
    pub auto_snapshot_policy_id: String,
    #[serde(rename = "DiskId")]
    pub disk_id: String,
}

impl crate::FlatSerialize for PolicyAssociation {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy_id,
            &format!("{}.AutoSnapshotPolicyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.disk_id, &format!("{}.DiskId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PolicyAssociations {
    #[serde(rename = "AutoSnapshotPolicyAssociation")]
    pub auto_snapshot_policy_association: Vec<PolicyAssociation>,
}

impl crate::FlatSerialize for PolicyAssociations {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy_association,
            &format!("{}.AutoSnapshotPolicyAssociation", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ExCopyEncryptionConfigurationArn {
    #[serde(rename = "RoleType")]
    pub role_type: String,
    #[serde(rename = "Rolearn")]
    pub rolearn: String,
    #[serde(rename = "AssumeRoleFor")]
    pub assume_role_for: i64,
}

impl crate::FlatSerialize for ExCopyEncryptionConfigurationArn {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.role_type,
            &format!("{}.RoleType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rolearn, &format!("{}.Rolearn", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.assume_role_for,
            &format!("{}.AssumeRoleFor", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ExCopyEncryptionConfiguration {
    #[serde(rename = "Encrypted")]
    pub encrypted: bool,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
    #[serde(rename = "Arn")]
    pub arn: Vec<ExCopyEncryptionConfigurationArn>,
}

impl crate::FlatSerialize for ExCopyEncryptionConfiguration {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.arn, &format!("{}.Arn", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotPackage {
    #[serde(rename = "DisplayName")]
    pub display_name: String,
    #[serde(rename = "EndTime")]
    pub end_time: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "InitCapacity")]
    pub init_capacity: i64,
}

impl crate::FlatSerialize for SnapshotPackage {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.display_name,
            &format!("{}.DisplayName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.end_time, &format!("{}.EndTime", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.init_capacity,
            &format!("{}.InitCapacity", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotPackages {
    #[serde(rename = "SnapshotPackage")]
    pub snapshot_package: Vec<SnapshotPackage>,
}

impl crate::FlatSerialize for SnapshotPackages {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_package,
            &format!("{}.SnapshotPackage", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct BandwidthsBandwidth {
    #[serde(rename = "InternetChargeType")]
    pub internet_charge_type: String,
    #[serde(rename = "Max")]
    pub max: i32,
    #[serde(rename = "Min")]
    pub min: i32,
    #[serde(rename = "Unit")]
    pub unit: String,
}

impl crate::FlatSerialize for BandwidthsBandwidth {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.internet_charge_type,
            &format!("{}.InternetChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.max, &format!("{}.Max", name), params);
        crate::FlatSerialize::flat_serialize(&self.min, &format!("{}.Min", name), params);
        crate::FlatSerialize::flat_serialize(&self.unit, &format!("{}.Unit", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseBandwidths {
    #[serde(rename = "Bandwidth")]
    pub bandwidth: Vec<BandwidthsBandwidth>,
}

impl crate::FlatSerialize for ResponseBandwidths {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth,
            &format!("{}.Bandwidth", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct LinksLink {
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
}

impl crate::FlatSerialize for LinksLink {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.vpc_id, &format!("{}.VpcId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseLinks {
    #[serde(rename = "Link")]
    pub link: Vec<LinksLink>,
}

impl crate::FlatSerialize for ResponseLinks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.link, &format!("{}.Link", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for InterfaceTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceNetworkInterfaceTrafficConfig {
    #[serde(rename = "QueueNumber")]
    pub queue_number: i32,
    #[serde(rename = "NetworkInterfaceTrafficMode")]
    pub network_interface_traffic_mode: String,
    #[serde(rename = "QueuePairNumber")]
    pub queue_pair_number: i32,
    #[serde(rename = "TxQueueSize")]
    pub tx_queue_size: i32,
    #[serde(rename = "RxQueueSize")]
    pub rx_queue_size: i32,
}

impl crate::FlatSerialize for InterfaceNetworkInterfaceTrafficConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.queue_number,
            &format!("{}.QueueNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_traffic_mode,
            &format!("{}.NetworkInterfaceTrafficMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.queue_pair_number,
            &format!("{}.QueuePairNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.tx_queue_size,
            &format!("{}.TxQueueSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.rx_queue_size,
            &format!("{}.RxQueueSize", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceConnectionTrackingConfiguration {
    #[serde(rename = "TcpEstablishedTimeout")]
    pub tcp_established_timeout: i32,
    #[serde(rename = "TcpClosedAndTimeWaitTimeout")]
    pub tcp_closed_and_time_wait_timeout: i32,
    #[serde(rename = "UdpTimeout")]
    pub udp_timeout: i32,
}

impl crate::FlatSerialize for InterfaceConnectionTrackingConfiguration {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tcp_established_timeout,
            &format!("{}.TcpEstablishedTimeout", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.tcp_closed_and_time_wait_timeout,
            &format!("{}.TcpClosedAndTimeWaitTimeout", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.udp_timeout,
            &format!("{}.UdpTimeout", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceEnhancedNetwork {
    #[serde(rename = "EnableSriov")]
    pub enable_sriov: bool,
    #[serde(rename = "EnableRss")]
    pub enable_rss: bool,
    #[serde(rename = "VirtualFunctionTotalQueueNumber")]
    pub virtual_function_total_queue_number: i32,
    #[serde(rename = "VirtualFunctionQuantity")]
    pub virtual_function_quantity: i32,
}

impl crate::FlatSerialize for InterfaceEnhancedNetwork {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.enable_sriov,
            &format!("{}.EnableSriov", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_rss,
            &format!("{}.EnableRss", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.virtual_function_total_queue_number,
            &format!("{}.VirtualFunctionTotalQueueNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.virtual_function_quantity,
            &format!("{}.VirtualFunctionQuantity", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceResponseSecurityGroupIds {
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: Vec<String>,
}

impl crate::FlatSerialize for InterfaceResponseSecurityGroupIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceResponsePrivateIpSetsPrivateIpSet {
    #[serde(rename = "PrivateIpAddress")]
    pub private_ip_address: String,
    #[serde(rename = "Primary")]
    pub primary: bool,
}

impl crate::FlatSerialize for InterfaceResponsePrivateIpSetsPrivateIpSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_address,
            &format!("{}.PrivateIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.primary, &format!("{}.Primary", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceResponsePrivateIpSets {
    #[serde(rename = "PrivateIpSet")]
    pub private_ip_set: Vec<InterfaceResponsePrivateIpSetsPrivateIpSet>,
}

impl crate::FlatSerialize for InterfaceResponsePrivateIpSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_set,
            &format!("{}.PrivateIpSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceResponseTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for InterfaceResponseTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceResponseTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<InterfaceResponseTagsTag>,
}

impl crate::FlatSerialize for InterfaceResponseTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceResponseIpv6SetsIpv6Set {
    #[serde(rename = "Ipv6Address")]
    pub ipv6_address: String,
}

impl crate::FlatSerialize for InterfaceResponseIpv6SetsIpv6Set {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_address,
            &format!("{}.Ipv6Address", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceResponseIpv6Sets {
    #[serde(rename = "Ipv6Set")]
    pub ipv6_set: Vec<InterfaceResponseIpv6SetsIpv6Set>,
}

impl crate::FlatSerialize for InterfaceResponseIpv6Sets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.ipv6_set, &format!("{}.Ipv6Set", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceResponseIpv4PrefixSetsIpv4PrefixSet {
    #[serde(rename = "Ipv4Prefix")]
    pub ipv4_prefix: String,
}

impl crate::FlatSerialize for InterfaceResponseIpv4PrefixSetsIpv4PrefixSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefix,
            &format!("{}.Ipv4Prefix", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceResponseIpv4PrefixSets {
    #[serde(rename = "Ipv4PrefixSet")]
    pub ipv4_prefix_set: Vec<InterfaceResponseIpv4PrefixSetsIpv4PrefixSet>,
}

impl crate::FlatSerialize for InterfaceResponseIpv4PrefixSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefix_set,
            &format!("{}.Ipv4PrefixSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceResponseIpv6PrefixSetsIpv6PrefixSet {
    #[serde(rename = "Ipv6Prefix")]
    pub ipv6_prefix: String,
}

impl crate::FlatSerialize for InterfaceResponseIpv6PrefixSetsIpv6PrefixSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_prefix,
            &format!("{}.Ipv6Prefix", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceResponseIpv6PrefixSets {
    #[serde(rename = "Ipv6PrefixSet")]
    pub ipv6_prefix_set: Vec<InterfaceResponseIpv6PrefixSetsIpv6PrefixSet>,
}

impl crate::FlatSerialize for InterfaceResponseIpv6PrefixSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_prefix_set,
            &format!("{}.Ipv6PrefixSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfacesTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for InterfacesTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemPrivateIpSetsPrivateIpSetItemAssociatedPublicIp {
    #[serde(rename = "PublicIpAddress")]
    pub public_ip_address: String,
    #[serde(rename = "AllocationId")]
    pub allocation_id: String,
}

impl crate::FlatSerialize for ItemPrivateIpSetsPrivateIpSetItemAssociatedPublicIp {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.public_ip_address,
            &format!("{}.PublicIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocation_id,
            &format!("{}.AllocationId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetItemPrivateIpSetsPrivateIpSet {
    #[serde(rename = "PrivateIpAddress")]
    pub private_ip_address: String,
    #[serde(rename = "Primary")]
    pub primary: bool,
    #[serde(rename = "AssociatedPublicIp")]
    pub associated_public_ip: ItemPrivateIpSetsPrivateIpSetItemAssociatedPublicIp,
    #[serde(rename = "PrivateDnsName")]
    pub private_dns_name: String,
}

impl crate::FlatSerialize for SetItemPrivateIpSetsPrivateIpSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_address,
            &format!("{}.PrivateIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.primary, &format!("{}.Primary", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.associated_public_ip,
            &format!("{}.AssociatedPublicIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_dns_name,
            &format!("{}.PrivateDnsName", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetItemPrivateIpSets {
    #[serde(rename = "PrivateIpSet")]
    pub private_ip_set: Vec<SetItemPrivateIpSetsPrivateIpSet>,
}

impl crate::FlatSerialize for SetItemPrivateIpSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_set,
            &format!("{}.PrivateIpSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetItemIpv6SetsIpv6Set {
    #[serde(rename = "Ipv6Address")]
    pub ipv6_address: String,
}

impl crate::FlatSerialize for SetItemIpv6SetsIpv6Set {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_address,
            &format!("{}.Ipv6Address", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetItemIpv6Sets {
    #[serde(rename = "Ipv6Set")]
    pub ipv6_set: Vec<SetItemIpv6SetsIpv6Set>,
}

impl crate::FlatSerialize for SetItemIpv6Sets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.ipv6_set, &format!("{}.Ipv6Set", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetItemIpv4PrefixSetsIpv4PrefixSet {
    #[serde(rename = "Ipv4Prefix")]
    pub ipv4_prefix: String,
}

impl crate::FlatSerialize for SetItemIpv4PrefixSetsIpv4PrefixSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefix,
            &format!("{}.Ipv4Prefix", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetItemIpv4PrefixSets {
    #[serde(rename = "Ipv4PrefixSet")]
    pub ipv4_prefix_set: Vec<SetItemIpv4PrefixSetsIpv4PrefixSet>,
}

impl crate::FlatSerialize for SetItemIpv4PrefixSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefix_set,
            &format!("{}.Ipv4PrefixSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetItemIpv6PrefixSetsIpv6PrefixSet {
    #[serde(rename = "Ipv6Prefix")]
    pub ipv6_prefix: String,
}

impl crate::FlatSerialize for SetItemIpv6PrefixSetsIpv6PrefixSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_prefix,
            &format!("{}.Ipv6Prefix", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetItemIpv6PrefixSets {
    #[serde(rename = "Ipv6PrefixSet")]
    pub ipv6_prefix_set: Vec<SetItemIpv6PrefixSetsIpv6PrefixSet>,
}

impl crate::FlatSerialize for SetItemIpv6PrefixSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_prefix_set,
            &format!("{}.Ipv6PrefixSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceSetItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for InterfaceSetItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceSetItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<InterfaceSetItemTagsTag>,
}

impl crate::FlatSerialize for InterfaceSetItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetItemSecurityGroupIds {
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: Vec<String>,
}

impl crate::FlatSerialize for SetItemSecurityGroupIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceSetItemAssociatedPublicIp {
    #[serde(rename = "PublicIpAddress")]
    pub public_ip_address: String,
    #[serde(rename = "AllocationId")]
    pub allocation_id: String,
}

impl crate::FlatSerialize for InterfaceSetItemAssociatedPublicIp {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.public_ip_address,
            &format!("{}.PublicIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocation_id,
            &format!("{}.AllocationId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemAttachment {
    #[serde(rename = "DeviceIndex")]
    pub device_index: i32,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "TrunkNetworkInterfaceId")]
    pub trunk_network_interface_id: String,
    #[serde(rename = "NetworkCardIndex")]
    pub network_card_index: i32,
}

impl crate::FlatSerialize for ItemAttachment {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.device_index,
            &format!("{}.DeviceIndex", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.trunk_network_interface_id,
            &format!("{}.TrunkNetworkInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_card_index,
            &format!("{}.NetworkCardIndex", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct NetworkInterfaceSet {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "NetworkInterfaceTrafficMode")]
    pub network_interface_traffic_mode: String,
    #[serde(rename = "NetworkInterfaceName")]
    pub network_interface_name: String,
    #[serde(rename = "MacAddress")]
    pub mac_address: String,
    #[serde(rename = "QueuePairNumber")]
    pub queue_pair_number: i32,
    #[serde(rename = "NetworkInterfaceId")]
    pub network_interface_id: String,
    #[serde(rename = "ServiceID")]
    pub service_id: i64,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "OwnerId")]
    pub owner_id: String,
    #[serde(rename = "ServiceManaged")]
    pub service_managed: bool,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "PrivateIpAddress")]
    pub private_ip_address: String,
    #[serde(rename = "QueueNumber")]
    pub queue_number: i32,
    #[serde(rename = "PrivateIpSets")]
    pub private_ip_sets: SetItemPrivateIpSets,
    #[serde(rename = "Ipv6Sets")]
    pub ipv6_sets: SetItemIpv6Sets,
    #[serde(rename = "Ipv4PrefixSets")]
    pub ipv4_prefix_sets: SetItemIpv4PrefixSets,
    #[serde(rename = "Ipv6PrefixSets")]
    pub ipv6_prefix_sets: SetItemIpv6PrefixSets,
    #[serde(rename = "Tags")]
    pub tags: InterfaceSetItemTags,
    #[serde(rename = "SecurityGroupIds")]
    pub security_group_ids: SetItemSecurityGroupIds,
    #[serde(rename = "AssociatedPublicIp")]
    pub associated_public_ip: InterfaceSetItemAssociatedPublicIp,
    #[serde(rename = "Attachment")]
    pub attachment: ItemAttachment,
    #[serde(rename = "DeleteOnRelease")]
    pub delete_on_release: bool,
    #[serde(rename = "SourceDestCheck")]
    pub source_dest_check: bool,
}

impl crate::FlatSerialize for NetworkInterfaceSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.vpc_id, &format!("{}.VpcId", name), params);
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_traffic_mode,
            &format!("{}.NetworkInterfaceTrafficMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_name,
            &format!("{}.NetworkInterfaceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.mac_address,
            &format!("{}.MacAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.queue_pair_number,
            &format!("{}.QueuePairNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_id,
            &format!("{}.NetworkInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.service_id,
            &format!("{}.ServiceID", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.owner_id, &format!("{}.OwnerId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.service_managed,
            &format!("{}.ServiceManaged", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_address,
            &format!("{}.PrivateIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.queue_number,
            &format!("{}.QueueNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_sets,
            &format!("{}.PrivateIpSets", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_sets,
            &format!("{}.Ipv6Sets", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefix_sets,
            &format!("{}.Ipv4PrefixSets", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_prefix_sets,
            &format!("{}.Ipv6PrefixSets", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.security_group_ids,
            &format!("{}.SecurityGroupIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.associated_public_ip,
            &format!("{}.AssociatedPublicIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.attachment,
            &format!("{}.Attachment", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.delete_on_release,
            &format!("{}.DeleteOnRelease", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_dest_check,
            &format!("{}.SourceDestCheck", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceSets {
    #[serde(rename = "NetworkInterfaceSet")]
    pub network_interface_set: Vec<NetworkInterfaceSet>,
}

impl crate::FlatSerialize for InterfaceSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_set,
            &format!("{}.NetworkInterfaceSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for AttributeTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceAttributeResponseSecurityGroupIds {
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: Vec<String>,
}

impl crate::FlatSerialize for InterfaceAttributeResponseSecurityGroupIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseAssociatedPublicIp {
    #[serde(rename = "PublicIpAddress")]
    pub public_ip_address: String,
    #[serde(rename = "AllocationId")]
    pub allocation_id: String,
}

impl crate::FlatSerialize for ResponseAssociatedPublicIp {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.public_ip_address,
            &format!("{}.PublicIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocation_id,
            &format!("{}.AllocationId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceIds {
    #[serde(rename = "MemberNetworkInterfaceId")]
    pub member_network_interface_id: Vec<String>,
}

impl crate::FlatSerialize for InterfaceIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.member_network_interface_id,
            &format!("{}.MemberNetworkInterfaceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseAttachment {
    #[serde(rename = "DeviceIndex")]
    pub device_index: i32,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "TrunkNetworkInterfaceId")]
    pub trunk_network_interface_id: String,
    #[serde(rename = "MemberNetworkInterfaceIds")]
    pub member_network_interface_ids: InterfaceIds,
    #[serde(rename = "NetworkCardIndex")]
    pub network_card_index: i32,
}

impl crate::FlatSerialize for ResponseAttachment {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.device_index,
            &format!("{}.DeviceIndex", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.trunk_network_interface_id,
            &format!("{}.TrunkNetworkInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.member_network_interface_ids,
            &format!("{}.MemberNetworkInterfaceIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_card_index,
            &format!("{}.NetworkCardIndex", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponsePrivateIpSetsPrivateIpSetItemAssociatedPublicIp {
    #[serde(rename = "PublicIpAddress")]
    pub public_ip_address: String,
    #[serde(rename = "AllocationId")]
    pub allocation_id: String,
}

impl crate::FlatSerialize for ResponsePrivateIpSetsPrivateIpSetItemAssociatedPublicIp {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.public_ip_address,
            &format!("{}.PublicIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocation_id,
            &format!("{}.AllocationId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponsePrivateIpSetsPrivateIpSet {
    #[serde(rename = "PrivateIpAddress")]
    pub private_ip_address: String,
    #[serde(rename = "Primary")]
    pub primary: bool,
    #[serde(rename = "AssociatedPublicIp")]
    pub associated_public_ip: ResponsePrivateIpSetsPrivateIpSetItemAssociatedPublicIp,
}

impl crate::FlatSerialize for AttributeResponsePrivateIpSetsPrivateIpSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_address,
            &format!("{}.PrivateIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.primary, &format!("{}.Primary", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.associated_public_ip,
            &format!("{}.AssociatedPublicIp", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponsePrivateIpSets {
    #[serde(rename = "PrivateIpSet")]
    pub private_ip_set: Vec<AttributeResponsePrivateIpSetsPrivateIpSet>,
}

impl crate::FlatSerialize for AttributeResponsePrivateIpSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_set,
            &format!("{}.PrivateIpSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseIpv6SetsIpv6Set {
    #[serde(rename = "Ipv6Address")]
    pub ipv6_address: String,
}

impl crate::FlatSerialize for AttributeResponseIpv6SetsIpv6Set {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_address,
            &format!("{}.Ipv6Address", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseIpv6Sets {
    #[serde(rename = "Ipv6Set")]
    pub ipv6_set: Vec<AttributeResponseIpv6SetsIpv6Set>,
}

impl crate::FlatSerialize for AttributeResponseIpv6Sets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.ipv6_set, &format!("{}.Ipv6Set", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseIpv4PrefixSetsIpv4PrefixSet {
    #[serde(rename = "Ipv4Prefix")]
    pub ipv4_prefix: String,
}

impl crate::FlatSerialize for AttributeResponseIpv4PrefixSetsIpv4PrefixSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefix,
            &format!("{}.Ipv4Prefix", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseIpv4PrefixSets {
    #[serde(rename = "Ipv4PrefixSet")]
    pub ipv4_prefix_set: Vec<AttributeResponseIpv4PrefixSetsIpv4PrefixSet>,
}

impl crate::FlatSerialize for AttributeResponseIpv4PrefixSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefix_set,
            &format!("{}.Ipv4PrefixSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseIpv6PrefixSetsIpv6PrefixSet {
    #[serde(rename = "Ipv6Prefix")]
    pub ipv6_prefix: String,
}

impl crate::FlatSerialize for AttributeResponseIpv6PrefixSetsIpv6PrefixSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_prefix,
            &format!("{}.Ipv6Prefix", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseIpv6PrefixSets {
    #[serde(rename = "Ipv6PrefixSet")]
    pub ipv6_prefix_set: Vec<AttributeResponseIpv6PrefixSetsIpv6PrefixSet>,
}

impl crate::FlatSerialize for AttributeResponseIpv6PrefixSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_prefix_set,
            &format!("{}.Ipv6PrefixSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for AttributeResponseTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<AttributeResponseTagsTag>,
}

impl crate::FlatSerialize for AttributeResponseTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SpecificationSet {
    #[serde(rename = "SlaveNetworkInterfaceId")]
    pub slave_network_interface_id: String,
    #[serde(rename = "WorkState")]
    pub work_state: String,
    #[serde(rename = "BondNetworkInterfaceId")]
    pub bond_network_interface_id: String,
}

impl crate::FlatSerialize for SpecificationSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.slave_network_interface_id,
            &format!("{}.SlaveNetworkInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.work_state,
            &format!("{}.WorkState", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bond_network_interface_id,
            &format!("{}.BondNetworkInterfaceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SpecificationSlaveInterfaceSpecification {
    #[serde(rename = "SlaveInterfaceSpecificationSet")]
    pub slave_interface_specification_set: Vec<SpecificationSet>,
}

impl crate::FlatSerialize for SpecificationSlaveInterfaceSpecification {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.slave_interface_specification_set,
            &format!("{}.SlaveInterfaceSpecificationSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct BondInterfaceSpecification {
    #[serde(rename = "BondMode")]
    pub bond_mode: String,
    #[serde(rename = "SlaveInterfaceSpecification")]
    pub slave_interface_specification: SpecificationSlaveInterfaceSpecification,
}

impl crate::FlatSerialize for BondInterfaceSpecification {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.bond_mode,
            &format!("{}.BondMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.slave_interface_specification,
            &format!("{}.SlaveInterfaceSpecification", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseSlaveInterfaceSpecification {
    #[serde(rename = "SlaveNetworkInterfaceId")]
    pub slave_network_interface_id: String,
    #[serde(rename = "WorkState")]
    pub work_state: String,
    #[serde(rename = "BondNetworkInterfaceId")]
    pub bond_network_interface_id: String,
}

impl crate::FlatSerialize for ResponseSlaveInterfaceSpecification {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.slave_network_interface_id,
            &format!("{}.SlaveNetworkInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.work_state,
            &format!("{}.WorkState", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bond_network_interface_id,
            &format!("{}.BondNetworkInterfaceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseNetworkInterfaceTrafficConfig {
    #[serde(rename = "NetworkInterfaceTrafficMode")]
    pub network_interface_traffic_mode: String,
    #[serde(rename = "QueueNumber")]
    pub queue_number: i32,
    #[serde(rename = "QueuePairNumber")]
    pub queue_pair_number: i32,
}

impl crate::FlatSerialize for ResponseNetworkInterfaceTrafficConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_traffic_mode,
            &format!("{}.NetworkInterfaceTrafficMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.queue_number,
            &format!("{}.QueueNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.queue_pair_number,
            &format!("{}.QueuePairNumber", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseConnectionTrackingConfiguration {
    #[serde(rename = "TcpEstablishedTimeout")]
    pub tcp_established_timeout: i32,
    #[serde(rename = "TcpClosedAndTimeWaitTimeout")]
    pub tcp_closed_and_time_wait_timeout: i32,
    #[serde(rename = "UdpTimeout")]
    pub udp_timeout: i32,
}

impl crate::FlatSerialize for ResponseConnectionTrackingConfiguration {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tcp_established_timeout,
            &format!("{}.TcpEstablishedTimeout", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.tcp_closed_and_time_wait_timeout,
            &format!("{}.TcpClosedAndTimeWaitTimeout", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.udp_timeout,
            &format!("{}.UdpTimeout", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseEnhancedNetwork {
    #[serde(rename = "EnableSriov")]
    pub enable_sriov: bool,
    #[serde(rename = "EnableRss")]
    pub enable_rss: bool,
    #[serde(rename = "VirtualFunctionTotalQueueNumber")]
    pub virtual_function_total_queue_number: i32,
    #[serde(rename = "VirtualFunctionQuantity")]
    pub virtual_function_quantity: i32,
}

impl crate::FlatSerialize for ResponseEnhancedNetwork {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.enable_sriov,
            &format!("{}.EnableSriov", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_rss,
            &format!("{}.EnableRss", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.virtual_function_total_queue_number,
            &format!("{}.VirtualFunctionTotalQueueNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.virtual_function_quantity,
            &format!("{}.VirtualFunctionQuantity", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConfigQoS {
    #[serde(rename = "BandwidthTx")]
    pub bandwidth_tx: i64,
    #[serde(rename = "BandwidthRx")]
    pub bandwidth_rx: i64,
    #[serde(rename = "PpsTx")]
    pub pps_tx: i64,
    #[serde(rename = "PpsRx")]
    pub pps_rx: i64,
    #[serde(rename = "ConcurrentConnections")]
    pub concurrent_connections: i64,
}

impl crate::FlatSerialize for ConfigQoS {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_tx,
            &format!("{}.BandwidthTx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_rx,
            &format!("{}.BandwidthRx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.pps_tx, &format!("{}.PpsTx", name), params);
        crate::FlatSerialize::flat_serialize(&self.pps_rx, &format!("{}.PpsRx", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.concurrent_connections,
            &format!("{}.ConcurrentConnections", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SConfig {
    #[serde(rename = "EnableQoS")]
    pub enable_qo_s: bool,
    #[serde(rename = "QoS")]
    pub qo_s: ConfigQoS,
}

impl crate::FlatSerialize for SConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.enable_qo_s,
            &format!("{}.EnableQoS", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.qo_s, &format!("{}.QoS", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeNetworkInterfaceTrafficConfig {
    #[serde(rename = "NetworkInterfaceTrafficMode")]
    pub network_interface_traffic_mode: String,
    #[serde(rename = "QueueNumber")]
    pub queue_number: i32,
    #[serde(rename = "QueuePairNumber")]
    pub queue_pair_number: i32,
    #[serde(rename = "RxQueueSize")]
    pub rx_queue_size: i32,
    #[serde(rename = "TxQueueSize")]
    pub tx_queue_size: i32,
}

impl crate::FlatSerialize for AttributeNetworkInterfaceTrafficConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_traffic_mode,
            &format!("{}.NetworkInterfaceTrafficMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.queue_number,
            &format!("{}.QueueNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.queue_pair_number,
            &format!("{}.QueuePairNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.rx_queue_size,
            &format!("{}.RxQueueSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.tx_queue_size,
            &format!("{}.TxQueueSize", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeConnectionTrackingConfiguration {
    #[serde(rename = "TcpEstablishedTimeout")]
    pub tcp_established_timeout: i32,
    #[serde(rename = "TcpClosedAndTimeWaitTimeout")]
    pub tcp_closed_and_time_wait_timeout: i32,
    #[serde(rename = "UdpTimeout")]
    pub udp_timeout: i32,
}

impl crate::FlatSerialize for AttributeConnectionTrackingConfiguration {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tcp_established_timeout,
            &format!("{}.TcpEstablishedTimeout", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.tcp_closed_and_time_wait_timeout,
            &format!("{}.TcpClosedAndTimeWaitTimeout", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.udp_timeout,
            &format!("{}.UdpTimeout", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeEnhancedNetwork {
    #[serde(rename = "EnableSriov")]
    pub enable_sriov: bool,
    #[serde(rename = "EnableRss")]
    pub enable_rss: bool,
    #[serde(rename = "VirtualFunctionTotalQueueNumber")]
    pub virtual_function_total_queue_number: i32,
    #[serde(rename = "VirtualFunctionQuantity")]
    pub virtual_function_quantity: i32,
}

impl crate::FlatSerialize for AttributeEnhancedNetwork {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.enable_sriov,
            &format!("{}.EnableSriov", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_rss,
            &format!("{}.EnableRss", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.virtual_function_total_queue_number,
            &format!("{}.VirtualFunctionTotalQueueNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.virtual_function_quantity,
            &format!("{}.VirtualFunctionQuantity", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetPrivateIpSet {
    #[serde(rename = "PrivateIpAddress")]
    pub private_ip_address: Vec<String>,
}

impl crate::FlatSerialize for SetPrivateIpSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_address,
            &format!("{}.PrivateIpAddress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetIpv4PrefixSet {
    #[serde(rename = "Ipv4Prefixes")]
    pub ipv4_prefixes: Vec<String>,
}

impl crate::FlatSerialize for SetIpv4PrefixSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefixes,
            &format!("{}.Ipv4Prefixes", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AddressesSet {
    #[serde(rename = "NetworkInterfaceId")]
    pub network_interface_id: String,
    #[serde(rename = "PrivateIpSet")]
    pub private_ip_set: SetPrivateIpSet,
    #[serde(rename = "Ipv4PrefixSet")]
    pub ipv4_prefix_set: SetIpv4PrefixSet,
}

impl crate::FlatSerialize for AddressesSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_id,
            &format!("{}.NetworkInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_set,
            &format!("{}.PrivateIpSet", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv4_prefix_set,
            &format!("{}.Ipv4PrefixSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AddressesResponseIpv6Sets {
    #[serde(rename = "Ipv6Address")]
    pub ipv6_address: Vec<String>,
}

impl crate::FlatSerialize for AddressesResponseIpv6Sets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_address,
            &format!("{}.Ipv6Address", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AddressesResponseIpv6PrefixSets {
    #[serde(rename = "Ipv6Prefix")]
    pub ipv6_prefix: Vec<String>,
}

impl crate::FlatSerialize for AddressesResponseIpv6PrefixSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_prefix,
            &format!("{}.Ipv6Prefix", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseNetworkInterfacePermission {
    #[serde(rename = "Permission")]
    pub permission: String,
    #[serde(rename = "NetworkInterfaceId")]
    pub network_interface_id: String,
    #[serde(rename = "AccountId")]
    pub account_id: i64,
    #[serde(rename = "NetworkInterfacePermissionId")]
    pub network_interface_permission_id: String,
    #[serde(rename = "ServiceName")]
    pub service_name: String,
    #[serde(rename = "PermissionState")]
    pub permission_state: String,
}

impl crate::FlatSerialize for ResponseNetworkInterfacePermission {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.permission,
            &format!("{}.Permission", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_id,
            &format!("{}.NetworkInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.account_id,
            &format!("{}.AccountId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_permission_id,
            &format!("{}.NetworkInterfacePermissionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.service_name,
            &format!("{}.ServiceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.permission_state,
            &format!("{}.PermissionState", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PermissionsNetworkInterfacePermission {
    #[serde(rename = "Permission")]
    pub permission: String,
    #[serde(rename = "NetworkInterfaceId")]
    pub network_interface_id: String,
    #[serde(rename = "AccountId")]
    pub account_id: i64,
    #[serde(rename = "NetworkInterfacePermissionId")]
    pub network_interface_permission_id: String,
    #[serde(rename = "ServiceName")]
    pub service_name: String,
    #[serde(rename = "PermissionState")]
    pub permission_state: String,
}

impl crate::FlatSerialize for PermissionsNetworkInterfacePermission {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.permission,
            &format!("{}.Permission", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_id,
            &format!("{}.NetworkInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.account_id,
            &format!("{}.AccountId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_permission_id,
            &format!("{}.NetworkInterfacePermissionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.service_name,
            &format!("{}.ServiceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.permission_state,
            &format!("{}.PermissionState", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfacePermissions {
    #[serde(rename = "NetworkInterfacePermission")]
    pub network_interface_permission: Vec<PermissionsNetworkInterfacePermission>,
}

impl crate::FlatSerialize for InterfacePermissions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_permission,
            &format!("{}.NetworkInterfacePermission", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PrefixListEntry {
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Cidr")]
    pub cidr: String,
}

impl crate::FlatSerialize for PrefixListEntry {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.cidr, &format!("{}.Cidr", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PrefixListTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for PrefixListTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PrefixListsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for PrefixListsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ListItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for ListItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ListItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ListItemTagsTag>,
}

impl crate::FlatSerialize for ListItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PrefixList {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "AssociationCount")]
    pub association_count: i32,
    #[serde(rename = "MaxEntries")]
    pub max_entries: i32,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "AddressFamily")]
    pub address_family: String,
    #[serde(rename = "PrefixListName")]
    pub prefix_list_name: String,
    #[serde(rename = "PrefixListId")]
    pub prefix_list_id: String,
    #[serde(rename = "Tags")]
    pub tags: ListItemTags,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
}

impl crate::FlatSerialize for PrefixList {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.association_count,
            &format!("{}.AssociationCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.max_entries,
            &format!("{}.MaxEntries", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.address_family,
            &format!("{}.AddressFamily", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.prefix_list_name,
            &format!("{}.PrefixListName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.prefix_list_id,
            &format!("{}.PrefixListId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PrefixLists {
    #[serde(rename = "PrefixList")]
    pub prefix_list: Vec<PrefixList>,
}

impl crate::FlatSerialize for PrefixLists {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.prefix_list,
            &format!("{}.PrefixList", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct EntriesEntry {
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Cidr")]
    pub cidr: String,
}

impl crate::FlatSerialize for EntriesEntry {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.cidr, &format!("{}.Cidr", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseEntries {
    #[serde(rename = "Entry")]
    pub entry: Vec<EntriesEntry>,
}

impl crate::FlatSerialize for ResponseEntries {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.entry, &format!("{}.Entry", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PrefixListAssociation {
    #[serde(rename = "ResourceId")]
    pub resource_id: String,
    #[serde(rename = "ResourceType")]
    pub resource_type: String,
}

impl crate::FlatSerialize for PrefixListAssociation {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.resource_id,
            &format!("{}.ResourceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_type,
            &format!("{}.ResourceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ListAssociations {
    #[serde(rename = "PrefixListAssociation")]
    pub prefix_list_association: Vec<PrefixListAssociation>,
}

impl crate::FlatSerialize for ListAssociations {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.prefix_list_association,
            &format!("{}.PrefixListAssociation", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PrefixListAddEntry {
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Cidr")]
    pub cidr: String,
}

impl crate::FlatSerialize for PrefixListAddEntry {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.cidr, &format!("{}.Cidr", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PrefixListRemoveEntry {
    #[serde(rename = "Cidr")]
    pub cidr: String,
}

impl crate::FlatSerialize for PrefixListRemoveEntry {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.cidr, &format!("{}.Cidr", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RangeListEntry {
    #[serde(rename = "PortRange")]
    pub port_range: String,
    #[serde(rename = "Description")]
    pub description: String,
}

impl crate::FlatSerialize for RangeListEntry {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.port_range,
            &format!("{}.PortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RangeListTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for RangeListTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RangeListsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for RangeListsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ListsItemTag {
    #[serde(rename = "TagKey")]
    pub tag_key: String,
    #[serde(rename = "TagValue")]
    pub tag_value: String,
}

impl crate::FlatSerialize for ListsItemTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RangeList {
    #[serde(rename = "PortRangeListId")]
    pub port_range_list_id: String,
    #[serde(rename = "PortRangeListName")]
    pub port_range_list_name: String,
    #[serde(rename = "MaxEntries")]
    pub max_entries: i32,
    #[serde(rename = "AssociationCount")]
    pub association_count: i32,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "Tags")]
    pub tags: Vec<ListsItemTag>,
}

impl crate::FlatSerialize for RangeList {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.port_range_list_id,
            &format!("{}.PortRangeListId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range_list_name,
            &format!("{}.PortRangeListName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.max_entries,
            &format!("{}.MaxEntries", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.association_count,
            &format!("{}.AssociationCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseEntry {
    #[serde(rename = "PortRange")]
    pub port_range: String,
    #[serde(rename = "Description")]
    pub description: String,
}

impl crate::FlatSerialize for ResponseEntry {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.port_range,
            &format!("{}.PortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RangeListAssociation {
    #[serde(rename = "ResourceId")]
    pub resource_id: String,
    #[serde(rename = "ResourceType")]
    pub resource_type: String,
}

impl crate::FlatSerialize for RangeListAssociation {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.resource_id,
            &format!("{}.ResourceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_type,
            &format!("{}.ResourceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RangeListAddEntry {
    #[serde(rename = "PortRange")]
    pub port_range: String,
    #[serde(rename = "Description")]
    pub description: String,
}

impl crate::FlatSerialize for RangeListAddEntry {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.port_range,
            &format!("{}.PortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RangeListRemoveEntry {
    #[serde(rename = "PortRange")]
    pub port_range: String,
}

impl crate::FlatSerialize for RangeListRemoveEntry {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.port_range,
            &format!("{}.PortRange", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SecurityGroupTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for SecurityGroupTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SecurityGroupsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for SecurityGroupsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SecurityGroupItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for SecurityGroupItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SecurityGroupItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<SecurityGroupItemTagsTag>,
}

impl crate::FlatSerialize for SecurityGroupItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GroupsSecurityGroup {
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: String,
    #[serde(rename = "SecurityGroupName")]
    pub security_group_name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SecurityGroupType")]
    pub security_group_type: String,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "EcsCount")]
    pub ecs_count: i32,
    #[serde(rename = "AvailableInstanceAmount")]
    pub available_instance_amount: i32,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "ServiceManaged")]
    pub service_managed: bool,
    #[serde(rename = "ServiceID")]
    pub service_id: i64,
    #[serde(rename = "Tags")]
    pub tags: SecurityGroupItemTags,
    #[serde(rename = "RuleCount")]
    pub rule_count: i32,
    #[serde(rename = "GroupToGroupRuleCount")]
    pub group_to_group_rule_count: i32,
}

impl crate::FlatSerialize for GroupsSecurityGroup {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_name,
            &format!("{}.SecurityGroupName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_type,
            &format!("{}.SecurityGroupType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.vpc_id, &format!("{}.VpcId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ecs_count,
            &format!("{}.EcsCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_instance_amount,
            &format!("{}.AvailableInstanceAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.service_managed,
            &format!("{}.ServiceManaged", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.service_id,
            &format!("{}.ServiceID", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.rule_count,
            &format!("{}.RuleCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.group_to_group_rule_count,
            &format!("{}.GroupToGroupRuleCount", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseSecurityGroups {
    #[serde(rename = "SecurityGroup")]
    pub security_group: Vec<GroupsSecurityGroup>,
}

impl crate::FlatSerialize for ResponseSecurityGroups {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group,
            &format!("{}.SecurityGroup", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PermissionsPermission {
    #[serde(rename = "SecurityGroupRuleId")]
    pub security_group_rule_id: String,
    #[serde(rename = "Direction")]
    pub direction: String,
    #[serde(rename = "SourceGroupId")]
    pub source_group_id: String,
    #[serde(rename = "DestGroupOwnerAccount")]
    pub dest_group_owner_account: String,
    #[serde(rename = "DestPrefixListId")]
    pub dest_prefix_list_id: String,
    #[serde(rename = "DestPrefixListName")]
    pub dest_prefix_list_name: String,
    #[serde(rename = "SourceCidrIp")]
    pub source_cidr_ip: String,
    #[serde(rename = "Ipv6DestCidrIp")]
    pub ipv6_dest_cidr_ip: String,
    #[serde(rename = "CreateTime")]
    pub create_time: String,
    #[serde(rename = "Ipv6SourceCidrIp")]
    pub ipv6_source_cidr_ip: String,
    #[serde(rename = "DestGroupId")]
    pub dest_group_id: String,
    #[serde(rename = "DestCidrIp")]
    pub dest_cidr_ip: String,
    #[serde(rename = "IpProtocol")]
    pub ip_protocol: String,
    #[serde(rename = "Priority")]
    pub priority: String,
    #[serde(rename = "DestGroupName")]
    pub dest_group_name: String,
    #[serde(rename = "NicType")]
    pub nic_type: String,
    #[serde(rename = "Policy")]
    pub policy: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "PortRange")]
    pub port_range: String,
    #[serde(rename = "SourcePrefixListName")]
    pub source_prefix_list_name: String,
    #[serde(rename = "SourcePrefixListId")]
    pub source_prefix_list_id: String,
    #[serde(rename = "SourceGroupOwnerAccount")]
    pub source_group_owner_account: String,
    #[serde(rename = "SourceGroupName")]
    pub source_group_name: String,
    #[serde(rename = "SourcePortRange")]
    pub source_port_range: String,
    #[serde(rename = "PortRangeListId")]
    pub port_range_list_id: String,
    #[serde(rename = "PortRangeListName")]
    pub port_range_list_name: String,
}

impl crate::FlatSerialize for PermissionsPermission {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_rule_id,
            &format!("{}.SecurityGroupRuleId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.direction,
            &format!("{}.Direction", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_group_id,
            &format!("{}.SourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_group_owner_account,
            &format!("{}.DestGroupOwnerAccount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_prefix_list_id,
            &format!("{}.DestPrefixListId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_prefix_list_name,
            &format!("{}.DestPrefixListName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_cidr_ip,
            &format!("{}.SourceCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_dest_cidr_ip,
            &format!("{}.Ipv6DestCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.create_time,
            &format!("{}.CreateTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_source_cidr_ip,
            &format!("{}.Ipv6SourceCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_group_id,
            &format!("{}.DestGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_cidr_ip,
            &format!("{}.DestCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ip_protocol,
            &format!("{}.IpProtocol", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.priority, &format!("{}.Priority", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.dest_group_name,
            &format!("{}.DestGroupName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.nic_type, &format!("{}.NicType", name), params);
        crate::FlatSerialize::flat_serialize(&self.policy, &format!("{}.Policy", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range,
            &format!("{}.PortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_prefix_list_name,
            &format!("{}.SourcePrefixListName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_prefix_list_id,
            &format!("{}.SourcePrefixListId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_group_owner_account,
            &format!("{}.SourceGroupOwnerAccount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_group_name,
            &format!("{}.SourceGroupName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_port_range,
            &format!("{}.SourcePortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range_list_id,
            &format!("{}.PortRangeListId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range_list_name,
            &format!("{}.PortRangeListName", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponsePermissions {
    #[serde(rename = "Permission")]
    pub permission: Vec<PermissionsPermission>,
}

impl crate::FlatSerialize for ResponsePermissions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.permission,
            &format!("{}.Permission", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PolicyIds {
    #[serde(rename = "SnapshotPolicyId")]
    pub snapshot_policy_id: Vec<String>,
}

impl crate::FlatSerialize for PolicyIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_policy_id,
            &format!("{}.SnapshotPolicyId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AuthorizeSecurityGroupPermission {
    #[serde(rename = "Policy")]
    pub policy: String,
    #[serde(rename = "Priority")]
    pub priority: String,
    #[serde(rename = "IpProtocol")]
    pub ip_protocol: String,
    #[serde(rename = "SourceCidrIp")]
    pub source_cidr_ip: String,
    #[serde(rename = "Ipv6SourceCidrIp")]
    pub ipv6_source_cidr_ip: String,
    #[serde(rename = "SourceGroupId")]
    pub source_group_id: String,
    #[serde(rename = "SourcePrefixListId")]
    pub source_prefix_list_id: String,
    #[serde(rename = "PortRange")]
    pub port_range: String,
    #[serde(rename = "DestCidrIp")]
    pub dest_cidr_ip: String,
    #[serde(rename = "Ipv6DestCidrIp")]
    pub ipv6_dest_cidr_ip: String,
    #[serde(rename = "SourcePortRange")]
    pub source_port_range: String,
    #[serde(rename = "SourceGroupOwnerAccount")]
    pub source_group_owner_account: String,
    #[serde(rename = "SourceGroupOwnerId")]
    pub source_group_owner_id: i64,
    #[serde(rename = "NicType")]
    pub nic_type: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "PortRangeListId")]
    pub port_range_list_id: String,
}

impl crate::FlatSerialize for AuthorizeSecurityGroupPermission {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.policy, &format!("{}.Policy", name), params);
        crate::FlatSerialize::flat_serialize(&self.priority, &format!("{}.Priority", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.ip_protocol,
            &format!("{}.IpProtocol", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_cidr_ip,
            &format!("{}.SourceCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_source_cidr_ip,
            &format!("{}.Ipv6SourceCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_group_id,
            &format!("{}.SourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_prefix_list_id,
            &format!("{}.SourcePrefixListId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range,
            &format!("{}.PortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_cidr_ip,
            &format!("{}.DestCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_dest_cidr_ip,
            &format!("{}.Ipv6DestCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_port_range,
            &format!("{}.SourcePortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_group_owner_account,
            &format!("{}.SourceGroupOwnerAccount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_group_owner_id,
            &format!("{}.SourceGroupOwnerId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.nic_type, &format!("{}.NicType", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range_list_id,
            &format!("{}.PortRangeListId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RevokeSecurityGroupPermission {
    #[serde(rename = "Policy")]
    pub policy: String,
    #[serde(rename = "Priority")]
    pub priority: String,
    #[serde(rename = "IpProtocol")]
    pub ip_protocol: String,
    #[serde(rename = "SourceCidrIp")]
    pub source_cidr_ip: String,
    #[serde(rename = "Ipv6SourceCidrIp")]
    pub ipv6_source_cidr_ip: String,
    #[serde(rename = "SourceGroupId")]
    pub source_group_id: String,
    #[serde(rename = "SourcePrefixListId")]
    pub source_prefix_list_id: String,
    #[serde(rename = "PortRange")]
    pub port_range: String,
    #[serde(rename = "DestCidrIp")]
    pub dest_cidr_ip: String,
    #[serde(rename = "Ipv6DestCidrIp")]
    pub ipv6_dest_cidr_ip: String,
    #[serde(rename = "SourcePortRange")]
    pub source_port_range: String,
    #[serde(rename = "SourceGroupOwnerAccount")]
    pub source_group_owner_account: String,
    #[serde(rename = "SourceGroupOwnerId")]
    pub source_group_owner_id: i64,
    #[serde(rename = "NicType")]
    pub nic_type: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "PortRangeListId")]
    pub port_range_list_id: String,
}

impl crate::FlatSerialize for RevokeSecurityGroupPermission {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.policy, &format!("{}.Policy", name), params);
        crate::FlatSerialize::flat_serialize(&self.priority, &format!("{}.Priority", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.ip_protocol,
            &format!("{}.IpProtocol", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_cidr_ip,
            &format!("{}.SourceCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_source_cidr_ip,
            &format!("{}.Ipv6SourceCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_group_id,
            &format!("{}.SourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_prefix_list_id,
            &format!("{}.SourcePrefixListId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range,
            &format!("{}.PortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_cidr_ip,
            &format!("{}.DestCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_dest_cidr_ip,
            &format!("{}.Ipv6DestCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_port_range,
            &format!("{}.SourcePortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_group_owner_account,
            &format!("{}.SourceGroupOwnerAccount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_group_owner_id,
            &format!("{}.SourceGroupOwnerId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.nic_type, &format!("{}.NicType", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range_list_id,
            &format!("{}.PortRangeListId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AuthorizeSecurityGroupEgressPermission {
    #[serde(rename = "Policy")]
    pub policy: String,
    #[serde(rename = "Priority")]
    pub priority: String,
    #[serde(rename = "IpProtocol")]
    pub ip_protocol: String,
    #[serde(rename = "DestCidrIp")]
    pub dest_cidr_ip: String,
    #[serde(rename = "Ipv6DestCidrIp")]
    pub ipv6_dest_cidr_ip: String,
    #[serde(rename = "DestGroupId")]
    pub dest_group_id: String,
    #[serde(rename = "DestPrefixListId")]
    pub dest_prefix_list_id: String,
    #[serde(rename = "PortRange")]
    pub port_range: String,
    #[serde(rename = "SourceCidrIp")]
    pub source_cidr_ip: String,
    #[serde(rename = "Ipv6SourceCidrIp")]
    pub ipv6_source_cidr_ip: String,
    #[serde(rename = "SourcePortRange")]
    pub source_port_range: String,
    #[serde(rename = "DestGroupOwnerAccount")]
    pub dest_group_owner_account: String,
    #[serde(rename = "DestGroupOwnerId")]
    pub dest_group_owner_id: i64,
    #[serde(rename = "NicType")]
    pub nic_type: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "PortRangeListId")]
    pub port_range_list_id: String,
}

impl crate::FlatSerialize for AuthorizeSecurityGroupEgressPermission {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.policy, &format!("{}.Policy", name), params);
        crate::FlatSerialize::flat_serialize(&self.priority, &format!("{}.Priority", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.ip_protocol,
            &format!("{}.IpProtocol", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_cidr_ip,
            &format!("{}.DestCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_dest_cidr_ip,
            &format!("{}.Ipv6DestCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_group_id,
            &format!("{}.DestGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_prefix_list_id,
            &format!("{}.DestPrefixListId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range,
            &format!("{}.PortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_cidr_ip,
            &format!("{}.SourceCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_source_cidr_ip,
            &format!("{}.Ipv6SourceCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_port_range,
            &format!("{}.SourcePortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_group_owner_account,
            &format!("{}.DestGroupOwnerAccount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_group_owner_id,
            &format!("{}.DestGroupOwnerId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.nic_type, &format!("{}.NicType", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range_list_id,
            &format!("{}.PortRangeListId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RevokeSecurityGroupEgressPermission {
    #[serde(rename = "Policy")]
    pub policy: String,
    #[serde(rename = "Priority")]
    pub priority: String,
    #[serde(rename = "IpProtocol")]
    pub ip_protocol: String,
    #[serde(rename = "DestCidrIp")]
    pub dest_cidr_ip: String,
    #[serde(rename = "Ipv6DestCidrIp")]
    pub ipv6_dest_cidr_ip: String,
    #[serde(rename = "DestGroupId")]
    pub dest_group_id: String,
    #[serde(rename = "DestPrefixListId")]
    pub dest_prefix_list_id: String,
    #[serde(rename = "PortRange")]
    pub port_range: String,
    #[serde(rename = "SourceCidrIp")]
    pub source_cidr_ip: String,
    #[serde(rename = "Ipv6SourceCidrIp")]
    pub ipv6_source_cidr_ip: String,
    #[serde(rename = "SourcePortRange")]
    pub source_port_range: String,
    #[serde(rename = "DestGroupOwnerAccount")]
    pub dest_group_owner_account: String,
    #[serde(rename = "DestGroupOwnerId")]
    pub dest_group_owner_id: String,
    #[serde(rename = "NicType")]
    pub nic_type: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "PortRangeListId")]
    pub port_range_list_id: String,
}

impl crate::FlatSerialize for RevokeSecurityGroupEgressPermission {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.policy, &format!("{}.Policy", name), params);
        crate::FlatSerialize::flat_serialize(&self.priority, &format!("{}.Priority", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.ip_protocol,
            &format!("{}.IpProtocol", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_cidr_ip,
            &format!("{}.DestCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_dest_cidr_ip,
            &format!("{}.Ipv6DestCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_group_id,
            &format!("{}.DestGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_prefix_list_id,
            &format!("{}.DestPrefixListId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range,
            &format!("{}.PortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_cidr_ip,
            &format!("{}.SourceCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_source_cidr_ip,
            &format!("{}.Ipv6SourceCidrIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.source_port_range,
            &format!("{}.SourcePortRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_group_owner_account,
            &format!("{}.DestGroupOwnerAccount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dest_group_owner_id,
            &format!("{}.DestGroupOwnerId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.nic_type, &format!("{}.NicType", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_range_list_id,
            &format!("{}.PortRangeListId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReferencingSecurityGroup {
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: String,
    #[serde(rename = "AliUid")]
    pub ali_uid: String,
}

impl crate::FlatSerialize for ReferencingSecurityGroup {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.ali_uid, &format!("{}.AliUid", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReferencingSecurityGroups {
    #[serde(rename = "ReferencingSecurityGroup")]
    pub referencing_security_group: Vec<ReferencingSecurityGroup>,
}

impl crate::FlatSerialize for ReferencingSecurityGroups {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.referencing_security_group,
            &format!("{}.ReferencingSecurityGroup", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GroupReference {
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: String,
    #[serde(rename = "ReferencingSecurityGroups")]
    pub referencing_security_groups: ReferencingSecurityGroups,
}

impl crate::FlatSerialize for GroupReference {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.referencing_security_groups,
            &format!("{}.ReferencingSecurityGroups", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GroupReferences {
    #[serde(rename = "SecurityGroupReference")]
    pub security_group_reference: Vec<GroupReference>,
}

impl crate::FlatSerialize for GroupReferences {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_reference,
            &format!("{}.SecurityGroupReference", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CreateKeyPairTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for CreateKeyPairTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ImportKeyPairTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ImportKeyPairTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PairsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for PairsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PairItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for PairItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PairItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<PairItemTagsTag>,
}

impl crate::FlatSerialize for PairItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct KeyPair {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "KeyPairName")]
    pub key_pair_name: String,
    #[serde(rename = "KeyPairFingerPrint")]
    pub key_pair_finger_print: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "PublicKey")]
    pub public_key: String,
    #[serde(rename = "Tags")]
    pub tags: PairItemTags,
}

impl crate::FlatSerialize for KeyPair {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.key_pair_name,
            &format!("{}.KeyPairName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.key_pair_finger_print,
            &format!("{}.KeyPairFingerPrint", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.public_key,
            &format!("{}.PublicKey", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct KeyPairs {
    #[serde(rename = "KeyPair")]
    pub key_pair: Vec<KeyPair>,
}

impl crate::FlatSerialize for KeyPairs {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key_pair, &format!("{}.KeyPair", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttachKeyPairResponseResultsResult {
    #[serde(rename = "Code")]
    pub code: String,
    #[serde(rename = "Message")]
    pub message: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Success")]
    pub success: String,
}

impl crate::FlatSerialize for AttachKeyPairResponseResultsResult {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
        crate::FlatSerialize::flat_serialize(&self.message, &format!("{}.Message", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.success, &format!("{}.Success", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttachKeyPairResponseResults {
    #[serde(rename = "Result")]
    pub result: Vec<AttachKeyPairResponseResultsResult>,
}

impl crate::FlatSerialize for AttachKeyPairResponseResults {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.result, &format!("{}.Result", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DetachKeyPairResponseResultsResult {
    #[serde(rename = "Code")]
    pub code: String,
    #[serde(rename = "Message")]
    pub message: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Success")]
    pub success: String,
}

impl crate::FlatSerialize for DetachKeyPairResponseResultsResult {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
        crate::FlatSerialize::flat_serialize(&self.message, &format!("{}.Message", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.success, &format!("{}.Success", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DetachKeyPairResponseResults {
    #[serde(rename = "Result")]
    pub result: Vec<DetachKeyPairResponseResultsResult>,
}

impl crate::FlatSerialize for DetachKeyPairResponseResults {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.result, &format!("{}.Result", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateTemplateTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for TemplateTemplateTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateDataDisk {
    #[serde(rename = "PerformanceLevel")]
    pub performance_level: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "Size")]
    pub size: i32,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "DiskName")]
    pub disk_name: String,
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "DeleteWithInstance")]
    pub delete_with_instance: bool,
    #[serde(rename = "Encrypted")]
    pub encrypted: String,
    #[serde(rename = "AutoSnapshotPolicyId")]
    pub auto_snapshot_policy_id: String,
    #[serde(rename = "ProvisionedIops")]
    pub provisioned_iops: i64,
    #[serde(rename = "BurstingEnabled")]
    pub bursting_enabled: bool,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
}

impl crate::FlatSerialize for TemplateDataDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.performance_level,
            &format!("{}.PerformanceLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.disk_name,
            &format!("{}.DiskName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.delete_with_instance,
            &format!("{}.DeleteWithInstance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy_id,
            &format!("{}.AutoSnapshotPolicyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.provisioned_iops,
            &format!("{}.ProvisionedIops", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bursting_enabled,
            &format!("{}.BurstingEnabled", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateNetworkInterface {
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "NetworkInterfaceName")]
    pub network_interface_name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: String,
    #[serde(rename = "PrimaryIpAddress")]
    pub primary_ip_address: String,
    #[serde(rename = "SecurityGroupIds")]
    pub security_group_ids: Vec<String>,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "NetworkInterfaceTrafficMode")]
    pub network_interface_traffic_mode: String,
    #[serde(rename = "DeleteOnRelease")]
    pub delete_on_release: bool,
}

impl crate::FlatSerialize for TemplateNetworkInterface {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_name,
            &format!("{}.NetworkInterfaceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.primary_ip_address,
            &format!("{}.PrimaryIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_ids,
            &format!("{}.SecurityGroupIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_traffic_mode,
            &format!("{}.NetworkInterfaceTrafficMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.delete_on_release,
            &format!("{}.DeleteOnRelease", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct LaunchTemplateTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for LaunchTemplateTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateImageOptions {
    #[serde(rename = "LoginAsNonRoot")]
    pub login_as_non_root: bool,
}

impl crate::FlatSerialize for TemplateImageOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.login_as_non_root,
            &format!("{}.LoginAsNonRoot", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateSecurityOptions {
    #[serde(rename = "TrustedSystemMode")]
    pub trusted_system_mode: String,
}

impl crate::FlatSerialize for TemplateSecurityOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.trusted_system_mode,
            &format!("{}.TrustedSystemMode", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplatesTemplateTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for TemplatesTemplateTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateSetItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for TemplateSetItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateSetItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<TemplateSetItemTagsTag>,
}

impl crate::FlatSerialize for TemplateSetItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateSet {
    #[serde(rename = "LaunchTemplateName")]
    pub launch_template_name: String,
    #[serde(rename = "DefaultVersionNumber")]
    pub default_version_number: i64,
    #[serde(rename = "ModifiedTime")]
    pub modified_time: String,
    #[serde(rename = "LaunchTemplateId")]
    pub launch_template_id: String,
    #[serde(rename = "CreateTime")]
    pub create_time: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "CreatedBy")]
    pub created_by: String,
    #[serde(rename = "LatestVersionNumber")]
    pub latest_version_number: i64,
    #[serde(rename = "Tags")]
    pub tags: TemplateSetItemTags,
}

impl crate::FlatSerialize for TemplateSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_name,
            &format!("{}.LaunchTemplateName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.default_version_number,
            &format!("{}.DefaultVersionNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.modified_time,
            &format!("{}.ModifiedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_id,
            &format!("{}.LaunchTemplateId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.create_time,
            &format!("{}.CreateTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.created_by,
            &format!("{}.CreatedBy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.latest_version_number,
            &format!("{}.LatestVersionNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateSets {
    #[serde(rename = "LaunchTemplateSet")]
    pub launch_template_set: Vec<TemplateSet>,
}

impl crate::FlatSerialize for TemplateSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_set,
            &format!("{}.LaunchTemplateSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VersionNumbers {
    #[serde(rename = "versionNumbers")]
    pub version_numbers: Vec<i64>,
}

impl crate::FlatSerialize for VersionNumbers {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.version_numbers,
            &format!("{}.versionNumbers", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VersionDataDisk {
    #[serde(rename = "PerformanceLevel")]
    pub performance_level: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "Size")]
    pub size: i32,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "DiskName")]
    pub disk_name: String,
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "DeleteWithInstance")]
    pub delete_with_instance: bool,
    #[serde(rename = "Encrypted")]
    pub encrypted: String,
    #[serde(rename = "ProvisionedIops")]
    pub provisioned_iops: i64,
    #[serde(rename = "BurstingEnabled")]
    pub bursting_enabled: bool,
    #[serde(rename = "AutoSnapshotPolicyId")]
    pub auto_snapshot_policy_id: String,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
}

impl crate::FlatSerialize for VersionDataDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.performance_level,
            &format!("{}.PerformanceLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.disk_name,
            &format!("{}.DiskName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.delete_with_instance,
            &format!("{}.DeleteWithInstance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.provisioned_iops,
            &format!("{}.ProvisionedIops", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bursting_enabled,
            &format!("{}.BurstingEnabled", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy_id,
            &format!("{}.AutoSnapshotPolicyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VersionNetworkInterface {
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "NetworkInterfaceName")]
    pub network_interface_name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: String,
    #[serde(rename = "PrimaryIpAddress")]
    pub primary_ip_address: String,
    #[serde(rename = "SecurityGroupIds")]
    pub security_group_ids: Vec<String>,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "NetworkInterfaceTrafficMode")]
    pub network_interface_traffic_mode: String,
    #[serde(rename = "DeleteOnRelease")]
    pub delete_on_release: bool,
}

impl crate::FlatSerialize for VersionNetworkInterface {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_name,
            &format!("{}.NetworkInterfaceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.primary_ip_address,
            &format!("{}.PrimaryIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_ids,
            &format!("{}.SecurityGroupIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_traffic_mode,
            &format!("{}.NetworkInterfaceTrafficMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.delete_on_release,
            &format!("{}.DeleteOnRelease", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VersionTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for VersionTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VersionImageOptions {
    #[serde(rename = "LoginAsNonRoot")]
    pub login_as_non_root: bool,
}

impl crate::FlatSerialize for VersionImageOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.login_as_non_root,
            &format!("{}.LoginAsNonRoot", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VersionSecurityOptions {
    #[serde(rename = "TrustedSystemMode")]
    pub trusted_system_mode: String,
}

impl crate::FlatSerialize for VersionSecurityOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.trusted_system_mode,
            &format!("{}.TrustedSystemMode", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DisksDataDisk {
    #[serde(rename = "PerformanceLevel")]
    pub performance_level: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "Size")]
    pub size: i32,
    #[serde(rename = "DiskName")]
    pub disk_name: String,
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "DeleteWithInstance")]
    pub delete_with_instance: bool,
    #[serde(rename = "Encrypted")]
    pub encrypted: String,
    #[serde(rename = "ProvisionedIops")]
    pub provisioned_iops: i64,
    #[serde(rename = "BurstingEnabled")]
    pub bursting_enabled: bool,
    #[serde(rename = "AutoSnapshotPolicyId")]
    pub auto_snapshot_policy_id: String,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
}

impl crate::FlatSerialize for DisksDataDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.performance_level,
            &format!("{}.PerformanceLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.disk_name,
            &format!("{}.DiskName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.delete_with_instance,
            &format!("{}.DeleteWithInstance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.provisioned_iops,
            &format!("{}.ProvisionedIops", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bursting_enabled,
            &format!("{}.BurstingEnabled", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy_id,
            &format!("{}.AutoSnapshotPolicyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DataDisks {
    #[serde(rename = "DataDisk")]
    pub data_disk: Vec<DisksDataDisk>,
}

impl crate::FlatSerialize for DataDisks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.data_disk,
            &format!("{}.DataDisk", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceItemSecurityGroupIds {
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: Vec<String>,
}

impl crate::FlatSerialize for InterfaceItemSecurityGroupIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DataNetworkInterfacesNetworkInterface {
    #[serde(rename = "NetworkInterfaceName")]
    pub network_interface_name: String,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "PrimaryIpAddress")]
    pub primary_ip_address: String,
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: String,
    #[serde(rename = "SecurityGroupIds")]
    pub security_group_ids: InterfaceItemSecurityGroupIds,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "NetworkInterfaceTrafficMode")]
    pub network_interface_traffic_mode: String,
    #[serde(rename = "DeleteOnRelease")]
    pub delete_on_release: bool,
}

impl crate::FlatSerialize for DataNetworkInterfacesNetworkInterface {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_name,
            &format!("{}.NetworkInterfaceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.primary_ip_address,
            &format!("{}.PrimaryIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_ids,
            &format!("{}.SecurityGroupIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interface_traffic_mode,
            &format!("{}.NetworkInterfaceTrafficMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.delete_on_release,
            &format!("{}.DeleteOnRelease", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DataNetworkInterfaces {
    #[serde(rename = "NetworkInterface")]
    pub network_interface: Vec<DataNetworkInterfacesNetworkInterface>,
}

impl crate::FlatSerialize for DataNetworkInterfaces {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.network_interface,
            &format!("{}.NetworkInterface", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TagsInstanceTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for TagsInstanceTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DataTags {
    #[serde(rename = "InstanceTag")]
    pub instance_tag: Vec<TagsInstanceTag>,
}

impl crate::FlatSerialize for DataTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_tag,
            &format!("{}.InstanceTag", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DataSecurityGroupIds {
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: Vec<String>,
}

impl crate::FlatSerialize for DataSecurityGroupIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DataImageOptions {
    #[serde(rename = "LoginAsNonRoot")]
    pub login_as_non_root: bool,
}

impl crate::FlatSerialize for DataImageOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.login_as_non_root,
            &format!("{}.LoginAsNonRoot", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DataSecurityOptions {
    #[serde(rename = "TrustedSystemMode")]
    pub trusted_system_mode: String,
}

impl crate::FlatSerialize for DataSecurityOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.trusted_system_mode,
            &format!("{}.TrustedSystemMode", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateData {
    #[serde(rename = "DeploymentSetId")]
    pub deployment_set_id: String,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "SystemDisk.PerformanceLevel")]
    pub system_disk_performance_level: String,
    #[serde(rename = "KeyPairName")]
    pub key_pair_name: String,
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: String,
    #[serde(rename = "NetworkType")]
    pub network_type: String,
    #[serde(rename = "SpotStrategy")]
    pub spot_strategy: String,
    #[serde(rename = "EnableVmOsConfig")]
    pub enable_vm_os_config: bool,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SpotDuration")]
    pub spot_duration: i32,
    #[serde(rename = "InstanceName")]
    pub instance_name: String,
    #[serde(rename = "SecurityEnhancementStrategy")]
    pub security_enhancement_strategy: String,
    #[serde(rename = "UserData")]
    pub user_data: String,
    #[serde(rename = "SystemDisk.DiskName")]
    pub system_disk_disk_name: String,
    #[serde(rename = "SystemDisk.Size")]
    pub system_disk_size: i32,
    #[serde(rename = "SpotPriceLimit")]
    pub spot_price_limit: f32,
    #[serde(rename = "PasswordInherit")]
    pub password_inherit: bool,
    #[serde(rename = "PrivateIpAddress")]
    pub private_ip_address: String,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "SystemDisk.DeleteWithInstance")]
    pub system_disk_delete_with_instance: bool,
    #[serde(rename = "SystemDisk.Category")]
    pub system_disk_category: String,
    #[serde(rename = "AutoReleaseTime")]
    pub auto_release_time: String,
    #[serde(rename = "SystemDisk.Description")]
    pub system_disk_description: String,
    #[serde(rename = "ImageOwnerAlias")]
    pub image_owner_alias: String,
    #[serde(rename = "HostName")]
    pub host_name: String,
    #[serde(rename = "SystemDisk.Iops")]
    pub system_disk_iops: i32,
    #[serde(rename = "SystemDisk.AutoSnapshotPolicyId")]
    pub system_disk_auto_snapshot_policy_id: String,
    #[serde(rename = "InternetMaxBandwidthOut")]
    pub internet_max_bandwidth_out: i32,
    #[serde(rename = "InternetMaxBandwidthIn")]
    pub internet_max_bandwidth_in: i32,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "Period")]
    pub period: i32,
    #[serde(rename = "InstanceChargeType")]
    pub instance_charge_type: String,
    #[serde(rename = "IoOptimized")]
    pub io_optimized: String,
    #[serde(rename = "RamRoleName")]
    pub ram_role_name: String,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "InternetChargeType")]
    pub internet_charge_type: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "Ipv6AddressCount")]
    pub ipv6_address_count: i32,
    #[serde(rename = "DataDisks")]
    pub data_disks: DataDisks,
    #[serde(rename = "NetworkInterfaces")]
    pub network_interfaces: DataNetworkInterfaces,
    #[serde(rename = "Tags")]
    pub tags: DataTags,
    #[serde(rename = "SecurityGroupIds")]
    pub security_group_ids: DataSecurityGroupIds,
    #[serde(rename = "SystemDisk.ProvisionedIops")]
    pub system_disk_provisioned_iops: i64,
    #[serde(rename = "SystemDisk.BurstingEnabled")]
    pub system_disk_bursting_enabled: bool,
    #[serde(rename = "SystemDisk.Encrypted")]
    pub system_disk_encrypted: String,
    #[serde(rename = "DeletionProtection")]
    pub deletion_protection: bool,
    #[serde(rename = "CreditSpecification")]
    pub credit_specification: String,
    #[serde(rename = "AutoRenew")]
    pub auto_renew: bool,
    #[serde(rename = "AutoRenewPeriod")]
    pub auto_renew_period: i32,
    #[serde(rename = "PeriodUnit")]
    pub period_unit: String,
    #[serde(rename = "HttpEndpoint")]
    pub http_endpoint: String,
    #[serde(rename = "HttpTokens")]
    pub http_tokens: String,
    #[serde(rename = "HttpPutResponseHopLimit")]
    pub http_put_response_hop_limit: i32,
    #[serde(rename = "SystemDisk.KMSKeyId")]
    pub system_disk_kms_key_id: String,
    #[serde(rename = "ImageOptions")]
    pub image_options: DataImageOptions,
    #[serde(rename = "SecurityOptions")]
    pub security_options: DataSecurityOptions,
}

impl crate::FlatSerialize for TemplateData {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.deployment_set_id,
            &format!("{}.DeploymentSetId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.vpc_id, &format!("{}.VpcId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_performance_level,
            &format!("{}.SystemDisk.PerformanceLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.key_pair_name,
            &format!("{}.KeyPairName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_group_id,
            &format!("{}.SecurityGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_type,
            &format!("{}.NetworkType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.spot_strategy,
            &format!("{}.SpotStrategy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enable_vm_os_config,
            &format!("{}.EnableVmOsConfig", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.spot_duration,
            &format!("{}.SpotDuration", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_name,
            &format!("{}.InstanceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_enhancement_strategy,
            &format!("{}.SecurityEnhancementStrategy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.user_data,
            &format!("{}.UserData", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_disk_name,
            &format!("{}.SystemDisk.DiskName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_size,
            &format!("{}.SystemDisk.Size", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.spot_price_limit,
            &format!("{}.SpotPriceLimit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.password_inherit,
            &format!("{}.PasswordInherit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_ip_address,
            &format!("{}.PrivateIpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.image_id, &format!("{}.ImageId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_delete_with_instance,
            &format!("{}.SystemDisk.DeleteWithInstance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_category,
            &format!("{}.SystemDisk.Category", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_release_time,
            &format!("{}.AutoReleaseTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_description,
            &format!("{}.SystemDisk.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_owner_alias,
            &format!("{}.ImageOwnerAlias", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.host_name,
            &format!("{}.HostName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_iops,
            &format!("{}.SystemDisk.Iops", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_auto_snapshot_policy_id,
            &format!("{}.SystemDisk.AutoSnapshotPolicyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_max_bandwidth_out,
            &format!("{}.InternetMaxBandwidthOut", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_max_bandwidth_in,
            &format!("{}.InternetMaxBandwidthIn", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.period, &format!("{}.Period", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_charge_type,
            &format!("{}.InstanceChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.io_optimized,
            &format!("{}.IoOptimized", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ram_role_name,
            &format!("{}.RamRoleName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_charge_type,
            &format!("{}.InternetChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.ipv6_address_count,
            &format!("{}.Ipv6AddressCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.data_disks,
            &format!("{}.DataDisks", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_interfaces,
            &format!("{}.NetworkInterfaces", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.security_group_ids,
            &format!("{}.SecurityGroupIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_provisioned_iops,
            &format!("{}.SystemDisk.ProvisionedIops", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_bursting_enabled,
            &format!("{}.SystemDisk.BurstingEnabled", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_encrypted,
            &format!("{}.SystemDisk.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.deletion_protection,
            &format!("{}.DeletionProtection", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.credit_specification,
            &format!("{}.CreditSpecification", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_renew,
            &format!("{}.AutoRenew", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_renew_period,
            &format!("{}.AutoRenewPeriod", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.period_unit,
            &format!("{}.PeriodUnit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.http_endpoint,
            &format!("{}.HttpEndpoint", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.http_tokens,
            &format!("{}.HttpTokens", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.http_put_response_hop_limit,
            &format!("{}.HttpPutResponseHopLimit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.system_disk_kms_key_id,
            &format!("{}.SystemDisk.KMSKeyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_options,
            &format!("{}.ImageOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_options,
            &format!("{}.SecurityOptions", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VersionSet {
    #[serde(rename = "LaunchTemplateName")]
    pub launch_template_name: String,
    #[serde(rename = "DefaultVersion")]
    pub default_version: bool,
    #[serde(rename = "VersionNumber")]
    pub version_number: i64,
    #[serde(rename = "ModifiedTime")]
    pub modified_time: String,
    #[serde(rename = "LaunchTemplateId")]
    pub launch_template_id: String,
    #[serde(rename = "CreateTime")]
    pub create_time: String,
    #[serde(rename = "CreatedBy")]
    pub created_by: String,
    #[serde(rename = "VersionDescription")]
    pub version_description: String,
    #[serde(rename = "LaunchTemplateData")]
    pub launch_template_data: TemplateData,
}

impl crate::FlatSerialize for VersionSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_name,
            &format!("{}.LaunchTemplateName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.default_version,
            &format!("{}.DefaultVersion", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.version_number,
            &format!("{}.VersionNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.modified_time,
            &format!("{}.ModifiedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_id,
            &format!("{}.LaunchTemplateId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.create_time,
            &format!("{}.CreateTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.created_by,
            &format!("{}.CreatedBy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.version_description,
            &format!("{}.VersionDescription", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_data,
            &format!("{}.LaunchTemplateData", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VersionSets {
    #[serde(rename = "LaunchTemplateVersionSet")]
    pub launch_template_version_set: Vec<VersionSet>,
}

impl crate::FlatSerialize for VersionSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_version_set,
            &format!("{}.LaunchTemplateVersionSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateVersion {
    #[serde(rename = "LaunchTemplateId")]
    pub launch_template_id: String,
    #[serde(rename = "LaunchTemplateVersionNumber")]
    pub launch_template_version_number: i64,
}

impl crate::FlatSerialize for TemplateVersion {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_id,
            &format!("{}.LaunchTemplateId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_version_number,
            &format!("{}.LaunchTemplateVersionNumber", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateVersions {
    #[serde(rename = "LaunchTemplateVersion")]
    pub launch_template_version: Vec<TemplateVersion>,
}

impl crate::FlatSerialize for TemplateVersions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_version,
            &format!("{}.LaunchTemplateVersion", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CreateAutoProvisioningGroupLaunchTemplateConfig {
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "MaxPrice")]
    pub max_price: f64,
    #[serde(rename = "Priority")]
    pub priority: i32,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "WeightedCapacity")]
    pub weighted_capacity: f64,
    #[serde(rename = "MaxQuantity")]
    pub max_quantity: i32,
    #[serde(rename = "Cores")]
    pub cores: Vec<i32>,
    #[serde(rename = "Memories")]
    pub memories: Vec<f32>,
    #[serde(rename = "InstanceFamilyLevel")]
    pub instance_family_level: String,
    #[serde(rename = "ExcludedInstanceTypes")]
    pub excluded_instance_types: Vec<String>,
    #[serde(rename = "Architectures")]
    pub architectures: Vec<String>,
    #[serde(rename = "BurstablePerformance")]
    pub burstable_performance: String,
    #[serde(rename = "ImageId")]
    pub image_id: String,
}

impl crate::FlatSerialize for CreateAutoProvisioningGroupLaunchTemplateConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.max_price,
            &format!("{}.MaxPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.priority, &format!("{}.Priority", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.weighted_capacity,
            &format!("{}.WeightedCapacity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.max_quantity,
            &format!("{}.MaxQuantity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.cores, &format!("{}.Cores", name), params);
        crate::FlatSerialize::flat_serialize(&self.memories, &format!("{}.Memories", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_family_level,
            &format!("{}.InstanceFamilyLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.excluded_instance_types,
            &format!("{}.ExcludedInstanceTypes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.architectures,
            &format!("{}.Architectures", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.burstable_performance,
            &format!("{}.BurstablePerformance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.image_id, &format!("{}.ImageId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConfigurationDataDisk {
    #[serde(rename = "PerformanceLevel")]
    pub performance_level: String,
    #[serde(rename = "KmsKeyId")]
    pub kms_key_id: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "Size")]
    pub size: i32,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "DiskName")]
    pub disk_name: String,
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "DeleteWithInstance")]
    pub delete_with_instance: bool,
    #[serde(rename = "Encrypted")]
    pub encrypted: bool,
    #[serde(rename = "EncryptAlgorithm")]
    pub encrypt_algorithm: String,
    #[serde(rename = "ProvisionedIops")]
    pub provisioned_iops: i64,
    #[serde(rename = "BurstingEnabled")]
    pub bursting_enabled: bool,
    #[serde(rename = "AutoSnapshotPolicyId")]
    pub auto_snapshot_policy_id: String,
}

impl crate::FlatSerialize for ConfigurationDataDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.performance_level,
            &format!("{}.PerformanceLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KmsKeyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_id,
            &format!("{}.SnapshotId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.disk_name,
            &format!("{}.DiskName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.delete_with_instance,
            &format!("{}.DeleteWithInstance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypt_algorithm,
            &format!("{}.EncryptAlgorithm", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.provisioned_iops,
            &format!("{}.ProvisionedIops", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bursting_enabled,
            &format!("{}.BurstingEnabled", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy_id,
            &format!("{}.AutoSnapshotPolicyId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConfigurationTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ConfigurationTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SystemDiskConfig {
    #[serde(rename = "DiskCategory")]
    pub disk_category: String,
}

impl crate::FlatSerialize for SystemDiskConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.disk_category,
            &format!("{}.DiskCategory", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DataDiskConfig {
    #[serde(rename = "DiskCategory")]
    pub disk_category: String,
}

impl crate::FlatSerialize for DataDiskConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.disk_category,
            &format!("{}.DiskCategory", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConfigurationSystemDisk {
    #[serde(rename = "Encrypted")]
    pub encrypted: String,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
    #[serde(rename = "EncryptAlgorithm")]
    pub encrypt_algorithm: String,
    #[serde(rename = "ProvisionedIops")]
    pub provisioned_iops: i64,
    #[serde(rename = "BurstingEnabled")]
    pub bursting_enabled: bool,
    #[serde(rename = "AutoSnapshotPolicyId")]
    pub auto_snapshot_policy_id: String,
}

impl crate::FlatSerialize for ConfigurationSystemDisk {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.encrypted,
            &format!("{}.Encrypted", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encrypt_algorithm,
            &format!("{}.EncryptAlgorithm", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.provisioned_iops,
            &format!("{}.ProvisionedIops", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bursting_enabled,
            &format!("{}.BurstingEnabled", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_snapshot_policy_id,
            &format!("{}.AutoSnapshotPolicyId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct LaunchConfigurationArn {
    #[serde(rename = "Rolearn")]
    pub rolearn: String,
    #[serde(rename = "RoleType")]
    pub role_type: String,
    #[serde(rename = "AssumeRoleFor")]
    pub assume_role_for: i64,
}

impl crate::FlatSerialize for LaunchConfigurationArn {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.rolearn, &format!("{}.Rolearn", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.role_type,
            &format!("{}.RoleType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.assume_role_for,
            &format!("{}.AssumeRoleFor", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ProvisioningGroupTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ProvisioningGroupTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PoolOptions {
    #[serde(rename = "Strategy")]
    pub strategy: String,
    #[serde(rename = "PrivatePoolIds")]
    pub private_pool_ids: Vec<String>,
}

impl crate::FlatSerialize for PoolOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.strategy, &format!("{}.Strategy", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.private_pool_ids,
            &format!("{}.PrivatePoolIds", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConfigurationImageOptions {
    #[serde(rename = "LoginAsNonRoot")]
    pub login_as_non_root: bool,
}

impl crate::FlatSerialize for ConfigurationImageOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.login_as_non_root,
            &format!("{}.LoginAsNonRoot", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SchedulerOptions {
    #[serde(rename = "DedicatedHostId")]
    pub dedicated_host_id: String,
    #[serde(rename = "DedicatedHostClusterId")]
    pub dedicated_host_cluster_id: String,
}

impl crate::FlatSerialize for SchedulerOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_id,
            &format!("{}.DedicatedHostId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_cluster_id,
            &format!("{}.DedicatedHostClusterId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConfigurationSecurityOptions {
    #[serde(rename = "TrustedSystemMode")]
    pub trusted_system_mode: String,
}

impl crate::FlatSerialize for ConfigurationSecurityOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.trusted_system_mode,
            &format!("{}.TrustedSystemMode", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConfigurationCpuOptions {
    #[serde(rename = "Core")]
    pub core: i32,
    #[serde(rename = "ThreadsPerCore")]
    pub threads_per_core: i32,
}

impl crate::FlatSerialize for ConfigurationCpuOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.core, &format!("{}.Core", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.threads_per_core,
            &format!("{}.ThreadsPerCore", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct LaunchConfiguration {
    #[serde(rename = "Period")]
    pub period: i32,
    #[serde(rename = "PeriodUnit")]
    pub period_unit: String,
    #[serde(rename = "AutoRenew")]
    pub auto_renew: bool,
    #[serde(rename = "AutoRenewPeriod")]
    pub auto_renew_period: i32,
    #[serde(rename = "SpotDuration")]
    pub spot_duration: i32,
    #[serde(rename = "SpotInterruptionBehavior")]
    pub spot_interruption_behavior: String,
    #[serde(rename = "ImageOptions")]
    pub image_options: ConfigurationImageOptions,
    #[serde(rename = "SchedulerOptions")]
    pub scheduler_options: SchedulerOptions,
    #[serde(rename = "SecurityOptions")]
    pub security_options: ConfigurationSecurityOptions,
    #[serde(rename = "CpuOptions")]
    pub cpu_options: ConfigurationCpuOptions,
}

impl crate::FlatSerialize for LaunchConfiguration {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.period, &format!("{}.Period", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.period_unit,
            &format!("{}.PeriodUnit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_renew,
            &format!("{}.AutoRenew", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_renew_period,
            &format!("{}.AutoRenewPeriod", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.spot_duration,
            &format!("{}.SpotDuration", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.spot_interruption_behavior,
            &format!("{}.SpotInterruptionBehavior", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.image_options,
            &format!("{}.ImageOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.scheduler_options,
            &format!("{}.SchedulerOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.security_options,
            &format!("{}.SecurityOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_options,
            &format!("{}.CpuOptions", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CapacityDistribution {
    #[serde(rename = "InstanceTypes")]
    pub instance_types: Vec<String>,
    #[serde(rename = "MinTargetCapacity")]
    pub min_target_capacity: i32,
}

impl crate::FlatSerialize for CapacityDistribution {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_types,
            &format!("{}.InstanceTypes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.min_target_capacity,
            &format!("{}.MinTargetCapacity", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PaidOptions {
    #[serde(rename = "SpecifyCapacityDistribution")]
    pub specify_capacity_distribution: Vec<CapacityDistribution>,
}

impl crate::FlatSerialize for PaidOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.specify_capacity_distribution,
            &format!("{}.SpecifyCapacityDistribution", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResultItemInstanceIds {
    #[serde(rename = "InstanceId")]
    pub instance_id: Vec<String>,
}

impl crate::FlatSerialize for ResultItemInstanceIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct LaunchResult {
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "ErrorMsg")]
    pub error_msg: String,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "ErrorCode")]
    pub error_code: String,
    #[serde(rename = "SpotStrategy")]
    pub spot_strategy: String,
    #[serde(rename = "Amount")]
    pub amount: i32,
    #[serde(rename = "InstanceIds")]
    pub instance_ids: ResultItemInstanceIds,
}

impl crate::FlatSerialize for LaunchResult {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.error_msg,
            &format!("{}.ErrorMsg", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.error_code,
            &format!("{}.ErrorCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.spot_strategy,
            &format!("{}.SpotStrategy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.amount, &format!("{}.Amount", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_ids,
            &format!("{}.InstanceIds", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct LaunchResults {
    #[serde(rename = "LaunchResult")]
    pub launch_result: Vec<LaunchResult>,
}

impl crate::FlatSerialize for LaunchResults {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.launch_result,
            &format!("{}.LaunchResult", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ProvisioningGroupsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ProvisioningGroupsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConfigsLaunchTemplateConfig {
    #[serde(rename = "MaxPrice")]
    pub max_price: f32,
    #[serde(rename = "Priority")]
    pub priority: f32,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "WeightedCapacity")]
    pub weighted_capacity: f32,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
}

impl crate::FlatSerialize for ConfigsLaunchTemplateConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.max_price,
            &format!("{}.MaxPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.priority, &format!("{}.Priority", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.weighted_capacity,
            &format!("{}.WeightedCapacity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TemplateConfigs {
    #[serde(rename = "LaunchTemplateConfig")]
    pub launch_template_config: Vec<ConfigsLaunchTemplateConfig>,
}

impl crate::FlatSerialize for TemplateConfigs {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_config,
            &format!("{}.LaunchTemplateConfig", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SpotOptions {
    #[serde(rename = "InstancePoolsToUseCount")]
    pub instance_pools_to_use_count: i32,
    #[serde(rename = "AllocationStrategy")]
    pub allocation_strategy: String,
    #[serde(rename = "InstanceInterruptionBehavior")]
    pub instance_interruption_behavior: String,
}

impl crate::FlatSerialize for SpotOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_pools_to_use_count,
            &format!("{}.InstancePoolsToUseCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocation_strategy,
            &format!("{}.AllocationStrategy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_interruption_behavior,
            &format!("{}.InstanceInterruptionBehavior", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GoOptions {
    #[serde(rename = "AllocationStrategy")]
    pub allocation_strategy: String,
}

impl crate::FlatSerialize for GoOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.allocation_strategy,
            &format!("{}.AllocationStrategy", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CapacitySpecification {
    #[serde(rename = "SpotTargetCapacity")]
    pub spot_target_capacity: f32,
    #[serde(rename = "PayAsYouGoTargetCapacity")]
    pub pay_as_you_go_target_capacity: f32,
    #[serde(rename = "DefaultTargetCapacityType")]
    pub default_target_capacity_type: String,
    #[serde(rename = "TotalTargetCapacity")]
    pub total_target_capacity: f32,
}

impl crate::FlatSerialize for CapacitySpecification {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.spot_target_capacity,
            &format!("{}.SpotTargetCapacity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.pay_as_you_go_target_capacity,
            &format!("{}.PayAsYouGoTargetCapacity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.default_target_capacity_type,
            &format!("{}.DefaultTargetCapacityType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_target_capacity,
            &format!("{}.TotalTargetCapacity", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ProvisioningGroupItemTagsTag {
    #[serde(rename = "TagKey")]
    pub tag_key: String,
    #[serde(rename = "TagValue")]
    pub tag_value: String,
}

impl crate::FlatSerialize for ProvisioningGroupItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ProvisioningGroupItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ProvisioningGroupItemTagsTag>,
}

impl crate::FlatSerialize for ProvisioningGroupItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ProvisioningGroup {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "AutoProvisioningGroupName")]
    pub auto_provisioning_group_name: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "TerminateInstances")]
    pub terminate_instances: bool,
    #[serde(rename = "MaxSpotPrice")]
    pub max_spot_price: f32,
    #[serde(rename = "State")]
    pub state: String,
    #[serde(rename = "LaunchTemplateId")]
    pub launch_template_id: String,
    #[serde(rename = "ValidFrom")]
    pub valid_from: String,
    #[serde(rename = "LaunchTemplateVersion")]
    pub launch_template_version: String,
    #[serde(rename = "TerminateInstancesWithExpiration")]
    pub terminate_instances_with_expiration: bool,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "ValidUntil")]
    pub valid_until: String,
    #[serde(rename = "AutoProvisioningGroupType")]
    pub auto_provisioning_group_type: String,
    #[serde(rename = "AutoProvisioningGroupId")]
    pub auto_provisioning_group_id: String,
    #[serde(rename = "ExcessCapacityTerminationPolicy")]
    pub excess_capacity_termination_policy: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "LaunchTemplateConfigs")]
    pub launch_template_configs: TemplateConfigs,
    #[serde(rename = "SpotOptions")]
    pub spot_options: SpotOptions,
    #[serde(rename = "PayAsYouGoOptions")]
    pub pay_as_you_go_options: GoOptions,
    #[serde(rename = "TargetCapacitySpecification")]
    pub target_capacity_specification: CapacitySpecification,
    #[serde(rename = "Tags")]
    pub tags: ProvisioningGroupItemTags,
}

impl crate::FlatSerialize for ProvisioningGroup {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_provisioning_group_name,
            &format!("{}.AutoProvisioningGroupName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.terminate_instances,
            &format!("{}.TerminateInstances", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.max_spot_price,
            &format!("{}.MaxSpotPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.state, &format!("{}.State", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_id,
            &format!("{}.LaunchTemplateId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.valid_from,
            &format!("{}.ValidFrom", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_version,
            &format!("{}.LaunchTemplateVersion", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.terminate_instances_with_expiration,
            &format!("{}.TerminateInstancesWithExpiration", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.valid_until,
            &format!("{}.ValidUntil", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_provisioning_group_type,
            &format!("{}.AutoProvisioningGroupType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_provisioning_group_id,
            &format!("{}.AutoProvisioningGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.excess_capacity_termination_policy,
            &format!("{}.ExcessCapacityTerminationPolicy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.launch_template_configs,
            &format!("{}.LaunchTemplateConfigs", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.spot_options,
            &format!("{}.SpotOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.pay_as_you_go_options,
            &format!("{}.PayAsYouGoOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.target_capacity_specification,
            &format!("{}.TargetCapacitySpecification", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ProvisioningGroups {
    #[serde(rename = "AutoProvisioningGroup")]
    pub auto_provisioning_group: Vec<ProvisioningGroup>,
}

impl crate::FlatSerialize for ProvisioningGroups {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.auto_provisioning_group,
            &format!("{}.AutoProvisioningGroup", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GroupInstancesResponseInstancesInstance {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "IsSpot")]
    pub is_spot: bool,
    #[serde(rename = "CPU")]
    pub cpu: i32,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "NetworkType")]
    pub network_type: String,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "IoOptimized")]
    pub io_optimized: bool,
    #[serde(rename = "OsType")]
    pub os_type: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "Memory")]
    pub memory: i32,
}

impl crate::FlatSerialize for GroupInstancesResponseInstancesInstance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.is_spot, &format!("{}.IsSpot", name), params);
        crate::FlatSerialize::flat_serialize(&self.cpu, &format!("{}.CPU", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.network_type,
            &format!("{}.NetworkType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.io_optimized,
            &format!("{}.IoOptimized", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.os_type, &format!("{}.OsType", name), params);
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(&self.memory, &format!("{}.Memory", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GroupInstancesResponseInstances {
    #[serde(rename = "Instance")]
    pub instance: Vec<GroupInstancesResponseInstancesInstance>,
}

impl crate::FlatSerialize for GroupInstancesResponseInstances {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.instance, &format!("{}.Instance", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModifyAutoProvisioningGroupLaunchTemplateConfig {
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "MaxPrice")]
    pub max_price: f64,
    #[serde(rename = "Priority")]
    pub priority: i32,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "WeightedCapacity")]
    pub weighted_capacity: f64,
}

impl crate::FlatSerialize for ModifyAutoProvisioningGroupLaunchTemplateConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.max_price,
            &format!("{}.MaxPrice", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.priority, &format!("{}.Priority", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.weighted_capacity,
            &format!("{}.WeightedCapacity", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ActivityDetail {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Detail")]
    pub detail: String,
}

impl crate::FlatSerialize for ActivityDetail {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.detail, &format!("{}.Detail", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ActivityDetails {
    #[serde(rename = "ActivityDetail")]
    pub activity_detail: Vec<ActivityDetail>,
}

impl crate::FlatSerialize for ActivityDetails {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.activity_detail,
            &format!("{}.ActivityDetail", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GroupHistory {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "TaskId")]
    pub task_id: String,
    #[serde(rename = "LastEventTime")]
    pub last_event_time: String,
    #[serde(rename = "ActivityDetails")]
    pub activity_details: ActivityDetails,
}

impl crate::FlatSerialize for GroupHistory {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.task_id, &format!("{}.TaskId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.last_event_time,
            &format!("{}.LastEventTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.activity_details,
            &format!("{}.ActivityDetails", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GroupHistories {
    #[serde(rename = "AutoProvisioningGroupHistory")]
    pub auto_provisioning_group_history: Vec<GroupHistory>,
}

impl crate::FlatSerialize for GroupHistories {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.auto_provisioning_group_history,
            &format!("{}.AutoProvisioningGroupHistory", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetItemInstanceIds {
    #[serde(rename = "InstanceId")]
    pub instance_id: Vec<String>,
}

impl crate::FlatSerialize for SetItemInstanceIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CapacitiesCapacity {
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "UsedAmount")]
    pub used_amount: i32,
    #[serde(rename = "AvailableAmount")]
    pub available_amount: i32,
}

impl crate::FlatSerialize for CapacitiesCapacity {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.used_amount,
            &format!("{}.UsedAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_amount,
            &format!("{}.AvailableAmount", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemCapacities {
    #[serde(rename = "Capacity")]
    pub capacity: Vec<CapacitiesCapacity>,
}

impl crate::FlatSerialize for ItemCapacities {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.capacity, &format!("{}.Capacity", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DeploymentSet {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Strategy")]
    pub strategy: String,
    #[serde(rename = "DeploymentSetId")]
    pub deployment_set_id: String,
    #[serde(rename = "AccountId")]
    pub account_id: i64,
    #[serde(rename = "DeploymentStrategy")]
    pub deployment_strategy: String,
    #[serde(rename = "DeploymentSetDescription")]
    pub deployment_set_description: String,
    #[serde(rename = "Domain")]
    pub domain: String,
    #[serde(rename = "GroupCount")]
    pub group_count: i32,
    #[serde(rename = "Granularity")]
    pub granularity: String,
    #[serde(rename = "DeploymentSetName")]
    pub deployment_set_name: String,
    #[serde(rename = "InstanceAmount")]
    pub instance_amount: i32,
    #[serde(rename = "InstanceIds")]
    pub instance_ids: SetItemInstanceIds,
    #[serde(rename = "Capacities")]
    pub capacities: ItemCapacities,
}

impl crate::FlatSerialize for DeploymentSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.strategy, &format!("{}.Strategy", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.deployment_set_id,
            &format!("{}.DeploymentSetId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.account_id,
            &format!("{}.AccountId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.deployment_strategy,
            &format!("{}.DeploymentStrategy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.deployment_set_description,
            &format!("{}.DeploymentSetDescription", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.domain, &format!("{}.Domain", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.group_count,
            &format!("{}.GroupCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.granularity,
            &format!("{}.Granularity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.deployment_set_name,
            &format!("{}.DeploymentSetName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_amount,
            &format!("{}.InstanceAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_ids,
            &format!("{}.InstanceIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.capacities,
            &format!("{}.Capacities", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DeploymentSets {
    #[serde(rename = "DeploymentSet")]
    pub deployment_set: Vec<DeploymentSet>,
}

impl crate::FlatSerialize for DeploymentSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.deployment_set,
            &format!("{}.DeploymentSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceTag {
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for AssuranceTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CreateElasticityAssuranceRecurrenceRule {
    #[serde(rename = "StartHour")]
    pub start_hour: i32,
    #[serde(rename = "RecurrenceType")]
    pub recurrence_type: String,
    #[serde(rename = "EndHour")]
    pub end_hour: i32,
    #[serde(rename = "RecurrenceValue")]
    pub recurrence_value: String,
}

impl crate::FlatSerialize for CreateElasticityAssuranceRecurrenceRule {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.start_hour,
            &format!("{}.StartHour", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.recurrence_type,
            &format!("{}.RecurrenceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.end_hour, &format!("{}.EndHour", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.recurrence_value,
            &format!("{}.RecurrenceValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssurancesTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for AssurancesTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceUsage {
    #[serde(rename = "AccountId")]
    pub account_id: String,
    #[serde(rename = "ServiceName")]
    pub service_name: String,
    #[serde(rename = "UsedAmount")]
    pub used_amount: i32,
}

impl crate::FlatSerialize for AssuranceUsage {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.account_id,
            &format!("{}.AccountId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.service_name,
            &format!("{}.ServiceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.used_amount,
            &format!("{}.UsedAmount", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceUsages {
    #[serde(rename = "ElasticityAssuranceUsage")]
    pub elasticity_assurance_usage: Vec<AssuranceUsage>,
}

impl crate::FlatSerialize for AssuranceUsages {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.elasticity_assurance_usage,
            &format!("{}.ElasticityAssuranceUsage", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceItemItemAllocatedResourcesAllocatedResource {
    #[serde(rename = "UsedAmount")]
    pub used_amount: i32,
    #[serde(rename = "TotalAmount")]
    pub total_amount: i32,
    #[serde(rename = "AvailableAmount")]
    pub available_amount: i32,
    #[serde(rename = "zoneId")]
    pub zone_id: String,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "ElasticityAssuranceUsages")]
    pub elasticity_assurance_usages: AssuranceUsages,
}

impl crate::FlatSerialize for AssuranceItemItemAllocatedResourcesAllocatedResource {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.used_amount,
            &format!("{}.UsedAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_amount,
            &format!("{}.TotalAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_amount,
            &format!("{}.AvailableAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.zoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.elasticity_assurance_usages,
            &format!("{}.ElasticityAssuranceUsages", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceItemItemAllocatedResources {
    #[serde(rename = "AllocatedResource")]
    pub allocated_resource: Vec<AssuranceItemItemAllocatedResourcesAllocatedResource>,
}

impl crate::FlatSerialize for AssuranceItemItemAllocatedResources {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.allocated_resource,
            &format!("{}.AllocatedResource", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceItemItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for AssuranceItemItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceItemItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<AssuranceItemItemTagsTag>,
}

impl crate::FlatSerialize for AssuranceItemItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RulesRecurrenceRule {
    #[serde(rename = "RecurrenceType")]
    pub recurrence_type: String,
    #[serde(rename = "RecurrenceValue")]
    pub recurrence_value: String,
    #[serde(rename = "StartHour")]
    pub start_hour: i32,
    #[serde(rename = "EndHour")]
    pub end_hour: i32,
}

impl crate::FlatSerialize for RulesRecurrenceRule {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.recurrence_type,
            &format!("{}.RecurrenceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.recurrence_value,
            &format!("{}.RecurrenceValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.start_hour,
            &format!("{}.StartHour", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.end_hour, &format!("{}.EndHour", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RecurrenceRules {
    #[serde(rename = "RecurrenceRule")]
    pub recurrence_rule: Vec<RulesRecurrenceRule>,
}

impl crate::FlatSerialize for RecurrenceRules {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.recurrence_rule,
            &format!("{}.RecurrenceRule", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceItem {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "PrivatePoolOptionsMatchCriteria")]
    pub private_pool_options_match_criteria: String,
    #[serde(rename = "PrivatePoolOptionsId")]
    pub private_pool_options_id: String,
    #[serde(rename = "UsedAssuranceTimes")]
    pub used_assurance_times: i32,
    #[serde(rename = "LatestStartTime")]
    pub latest_start_time: String,
    #[serde(rename = "PrivatePoolOptionsName")]
    pub private_pool_options_name: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "EndTime")]
    pub end_time: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "TotalAssuranceTimes")]
    pub total_assurance_times: String,
    #[serde(rename = "AllocatedResources")]
    pub allocated_resources: AssuranceItemItemAllocatedResources,
    #[serde(rename = "Tags")]
    pub tags: AssuranceItemItemTags,
    #[serde(rename = "InstanceChargeType")]
    pub instance_charge_type: String,
    #[serde(rename = "StartTimeType")]
    pub start_time_type: String,
    #[serde(rename = "ElasticityAssuranceOwnerId")]
    pub elasticity_assurance_owner_id: String,
    #[serde(rename = "RecurrenceRules")]
    pub recurrence_rules: RecurrenceRules,
    #[serde(rename = "PackageType")]
    pub package_type: String,
}

impl crate::FlatSerialize for AssuranceItem {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.private_pool_options_match_criteria,
            &format!("{}.PrivatePoolOptionsMatchCriteria", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_pool_options_id,
            &format!("{}.PrivatePoolOptionsId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.used_assurance_times,
            &format!("{}.UsedAssuranceTimes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.latest_start_time,
            &format!("{}.LatestStartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_pool_options_name,
            &format!("{}.PrivatePoolOptionsName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.end_time, &format!("{}.EndTime", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_assurance_times,
            &format!("{}.TotalAssuranceTimes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocated_resources,
            &format!("{}.AllocatedResources", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_charge_type,
            &format!("{}.InstanceChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.start_time_type,
            &format!("{}.StartTimeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.elasticity_assurance_owner_id,
            &format!("{}.ElasticityAssuranceOwnerId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.recurrence_rules,
            &format!("{}.RecurrenceRules", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.package_type,
            &format!("{}.PackageType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceSet {
    #[serde(rename = "ElasticityAssuranceItem")]
    pub elasticity_assurance_item: Vec<AssuranceItem>,
}

impl crate::FlatSerialize for AssuranceSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.elasticity_assurance_item,
            &format!("{}.ElasticityAssuranceItem", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceItemInstanceIdSet {
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
}

impl crate::FlatSerialize for AssuranceItemInstanceIdSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ElasticityAssurance {
    #[serde(rename = "InstanceIdSet")]
    pub instance_id_set: Vec<AssuranceItemInstanceIdSet>,
}

impl crate::FlatSerialize for ElasticityAssurance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id_set,
            &format!("{}.InstanceIdSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModifyElasticityAssuranceRecurrenceRule {
    #[serde(rename = "RecurrenceType")]
    pub recurrence_type: String,
    #[serde(rename = "RecurrenceValue")]
    pub recurrence_value: String,
    #[serde(rename = "StartHour")]
    pub start_hour: i32,
    #[serde(rename = "EndHour")]
    pub end_hour: i32,
}

impl crate::FlatSerialize for ModifyElasticityAssuranceRecurrenceRule {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.recurrence_type,
            &format!("{}.RecurrenceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.recurrence_value,
            &format!("{}.RecurrenceValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.start_hour,
            &format!("{}.StartHour", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.end_hour, &format!("{}.EndHour", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OptionsIdSet {
    #[serde(rename = "PrivatePoolOptionsId")]
    pub private_pool_options_id: Vec<String>,
}

impl crate::FlatSerialize for OptionsIdSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.private_pool_options_id,
            &format!("{}.PrivatePoolOptionsId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceRenewAttribute {
    #[serde(rename = "PeriodUnit")]
    pub period_unit: String,
    #[serde(rename = "Period")]
    pub period: i32,
    #[serde(rename = "PrivatePoolOptionsId")]
    pub private_pool_options_id: String,
    #[serde(rename = "RenewalStatus")]
    pub renewal_status: String,
}

impl crate::FlatSerialize for AssuranceRenewAttribute {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.period_unit,
            &format!("{}.PeriodUnit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.period, &format!("{}.Period", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.private_pool_options_id,
            &format!("{}.PrivatePoolOptionsId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.renewal_status,
            &format!("{}.RenewalStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssuranceRenewAttributes {
    #[serde(rename = "ElasticityAssuranceRenewAttribute")]
    pub elasticity_assurance_renew_attribute: Vec<AssuranceRenewAttribute>,
}

impl crate::FlatSerialize for AssuranceRenewAttributes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.elasticity_assurance_renew_attribute,
            &format!("{}.ElasticityAssuranceRenewAttribute", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationTag {
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for ReservationTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ReservationsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationUsage {
    #[serde(rename = "AccountId")]
    pub account_id: String,
    #[serde(rename = "ServiceName")]
    pub service_name: String,
    #[serde(rename = "UsedAmount")]
    pub used_amount: i32,
}

impl crate::FlatSerialize for ReservationUsage {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.account_id,
            &format!("{}.AccountId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.service_name,
            &format!("{}.ServiceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.used_amount,
            &format!("{}.UsedAmount", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationUsages {
    #[serde(rename = "CapacityReservationUsage")]
    pub capacity_reservation_usage: Vec<ReservationUsage>,
}

impl crate::FlatSerialize for ReservationUsages {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.capacity_reservation_usage,
            &format!("{}.CapacityReservationUsage", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationItemItemAllocatedResourcesAllocatedResource {
    #[serde(rename = "UsedAmount")]
    pub used_amount: i32,
    #[serde(rename = "TotalAmount")]
    pub total_amount: i32,
    #[serde(rename = "AvailableAmount")]
    pub available_amount: i32,
    #[serde(rename = "zoneId")]
    pub zone_id: String,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "CapacityReservationUsages")]
    pub capacity_reservation_usages: ReservationUsages,
}

impl crate::FlatSerialize for ReservationItemItemAllocatedResourcesAllocatedResource {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.used_amount,
            &format!("{}.UsedAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_amount,
            &format!("{}.TotalAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_amount,
            &format!("{}.AvailableAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.zoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.capacity_reservation_usages,
            &format!("{}.CapacityReservationUsages", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationItemItemAllocatedResources {
    #[serde(rename = "AllocatedResource")]
    pub allocated_resource: Vec<ReservationItemItemAllocatedResourcesAllocatedResource>,
}

impl crate::FlatSerialize for ReservationItemItemAllocatedResources {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.allocated_resource,
            &format!("{}.AllocatedResource", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationItemItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for ReservationItemItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationItemItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ReservationItemItemTagsTag>,
}

impl crate::FlatSerialize for ReservationItemItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationItem {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "TimeSlot")]
    pub time_slot: String,
    #[serde(rename = "PrivatePoolOptionsMatchCriteria")]
    pub private_pool_options_match_criteria: String,
    #[serde(rename = "PrivatePoolOptionsId")]
    pub private_pool_options_id: String,
    #[serde(rename = "PrivatePoolOptionsName")]
    pub private_pool_options_name: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "InstanceChargeType")]
    pub instance_charge_type: String,
    #[serde(rename = "EndTime")]
    pub end_time: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "EndTimeType")]
    pub end_time_type: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "Platform")]
    pub platform: String,
    #[serde(rename = "AllocatedResources")]
    pub allocated_resources: ReservationItemItemAllocatedResources,
    #[serde(rename = "Tags")]
    pub tags: ReservationItemItemTags,
    #[serde(rename = "StartTimeType")]
    pub start_time_type: String,
    #[serde(rename = "SavingPlanId")]
    pub saving_plan_id: String,
    #[serde(rename = "ReservedInstanceId")]
    pub reserved_instance_id: String,
    #[serde(rename = "CapacityReservationOwnerId")]
    pub capacity_reservation_owner_id: String,
}

impl crate::FlatSerialize for ReservationItem {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.time_slot,
            &format!("{}.TimeSlot", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_pool_options_match_criteria,
            &format!("{}.PrivatePoolOptionsMatchCriteria", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_pool_options_id,
            &format!("{}.PrivatePoolOptionsId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_pool_options_name,
            &format!("{}.PrivatePoolOptionsName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_charge_type,
            &format!("{}.InstanceChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.end_time, &format!("{}.EndTime", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.end_time_type,
            &format!("{}.EndTimeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.platform, &format!("{}.Platform", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.allocated_resources,
            &format!("{}.AllocatedResources", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.start_time_type,
            &format!("{}.StartTimeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.saving_plan_id,
            &format!("{}.SavingPlanId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance_id,
            &format!("{}.ReservedInstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.capacity_reservation_owner_id,
            &format!("{}.CapacityReservationOwnerId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationSet {
    #[serde(rename = "CapacityReservationItem")]
    pub capacity_reservation_item: Vec<ReservationItem>,
}

impl crate::FlatSerialize for ReservationSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.capacity_reservation_item,
            &format!("{}.CapacityReservationItem", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservationItemInstanceIdSet {
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
}

impl crate::FlatSerialize for ReservationItemInstanceIdSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CapacityReservation {
    #[serde(rename = "InstanceIdSet")]
    pub instance_id_set: Vec<ReservationItemInstanceIdSet>,
}

impl crate::FlatSerialize for CapacityReservation {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id_set,
            &format!("{}.InstanceIdSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributesResponseInstancesInstance {
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "PrivatePoolOptionsMatchCriteria")]
    pub private_pool_options_match_criteria: String,
    #[serde(rename = "PrivatePoolOptionsId")]
    pub private_pool_options_id: String,
}

impl crate::FlatSerialize for AttributesResponseInstancesInstance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_pool_options_match_criteria,
            &format!("{}.PrivatePoolOptionsMatchCriteria", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.private_pool_options_id,
            &format!("{}.PrivatePoolOptionsId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributesResponseInstances {
    #[serde(rename = "Instance")]
    pub instance: Vec<AttributesResponseInstancesInstance>,
}

impl crate::FlatSerialize for AttributesResponseInstances {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.instance, &format!("{}.Instance", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OfferingTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for OfferingTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OfferingResponseReservedInstanceIdSets {
    #[serde(rename = "ReservedInstanceId")]
    pub reserved_instance_id: Vec<String>,
}

impl crate::FlatSerialize for OfferingResponseReservedInstanceIdSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance_id,
            &format!("{}.ReservedInstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservedInstancesTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ReservedInstancesTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceItemOperationLocksOperationLock {
    #[serde(rename = "LockReason")]
    pub lock_reason: String,
}

impl crate::FlatSerialize for InstanceItemOperationLocksOperationLock {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.lock_reason,
            &format!("{}.LockReason", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservedInstanceItemOperationLocks {
    #[serde(rename = "OperationLock")]
    pub operation_lock: Vec<InstanceItemOperationLocksOperationLock>,
}

impl crate::FlatSerialize for ReservedInstanceItemOperationLocks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.operation_lock,
            &format!("{}.OperationLock", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservedInstanceItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for ReservedInstanceItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservedInstanceItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ReservedInstanceItemTagsTag>,
}

impl crate::FlatSerialize for ReservedInstanceItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservedInstance {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "ReservedInstanceName")]
    pub reserved_instance_name: String,
    #[serde(rename = "ReservedInstanceId")]
    pub reserved_instance_id: String,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "InstanceAmount")]
    pub instance_amount: i32,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "OfferingType")]
    pub offering_type: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "AllocationStatus")]
    pub allocation_status: String,
    #[serde(rename = "ExpiredTime")]
    pub expired_time: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "Platform")]
    pub platform: String,
    #[serde(rename = "Scope")]
    pub scope: String,
    #[serde(rename = "OperationLocks")]
    pub operation_locks: ReservedInstanceItemOperationLocks,
    #[serde(rename = "Tags")]
    pub tags: ReservedInstanceItemTags,
}

impl crate::FlatSerialize for ReservedInstance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance_name,
            &format!("{}.ReservedInstanceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance_id,
            &format!("{}.ReservedInstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_amount,
            &format!("{}.InstanceAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.offering_type,
            &format!("{}.OfferingType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocation_status,
            &format!("{}.AllocationStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.expired_time,
            &format!("{}.ExpiredTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(&self.platform, &format!("{}.Platform", name), params);
        crate::FlatSerialize::flat_serialize(&self.scope, &format!("{}.Scope", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.operation_locks,
            &format!("{}.OperationLocks", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservedInstances {
    #[serde(rename = "ReservedInstance")]
    pub reserved_instance: Vec<ReservedInstance>,
}

impl crate::FlatSerialize for ReservedInstances {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance,
            &format!("{}.ReservedInstance", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesConfiguration {
    #[serde(rename = "ReservedInstanceName")]
    pub reserved_instance_name: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "Scope")]
    pub scope: String,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "InstanceAmount")]
    pub instance_amount: i32,
}

impl crate::FlatSerialize for InstancesConfiguration {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance_name,
            &format!("{}.ReservedInstanceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(&self.scope, &format!("{}.Scope", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_amount,
            &format!("{}.InstanceAmount", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModifyReservedInstancesResponseReservedInstanceIdSets {
    #[serde(rename = "ReservedInstanceId")]
    pub reserved_instance_id: Vec<String>,
}

impl crate::FlatSerialize for ModifyReservedInstancesResponseReservedInstanceIdSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance_id,
            &format!("{}.ReservedInstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RenewReservedInstancesResponseReservedInstanceIdSets {
    #[serde(rename = "ReservedInstanceId")]
    pub reserved_instance_id: Vec<String>,
}

impl crate::FlatSerialize for RenewReservedInstancesResponseReservedInstanceIdSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance_id,
            &format!("{}.ReservedInstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservedInstanceRenewAttribute {
    #[serde(rename = "PeriodUnit")]
    pub period_unit: String,
    #[serde(rename = "Duration")]
    pub duration: i32,
    #[serde(rename = "ReservedInstanceId")]
    pub reserved_instance_id: String,
    #[serde(rename = "RenewalStatus")]
    pub renewal_status: String,
}

impl crate::FlatSerialize for ReservedInstanceRenewAttribute {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.period_unit,
            &format!("{}.PeriodUnit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.duration, &format!("{}.Duration", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance_id,
            &format!("{}.ReservedInstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.renewal_status,
            &format!("{}.RenewalStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReservedInstanceRenewAttributes {
    #[serde(rename = "ReservedInstanceRenewAttribute")]
    pub reserved_instance_renew_attribute: Vec<ReservedInstanceRenewAttribute>,
}

impl crate::FlatSerialize for ReservedInstanceRenewAttributes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance_renew_attribute,
            &format!("{}.ReservedInstanceRenewAttribute", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct UnitTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for UnitTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct UnitIds {
    #[serde(rename = "StorageCapacityUnitId")]
    pub storage_capacity_unit_id: Vec<String>,
}

impl crate::FlatSerialize for UnitIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.storage_capacity_unit_id,
            &format!("{}.StorageCapacityUnitId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct UnitsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for UnitsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct UnitItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for UnitItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct UnitItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<UnitItemTagsTag>,
}

impl crate::FlatSerialize for UnitItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CapacityUnit {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "Capacity")]
    pub capacity: i32,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "AllocationStatus")]
    pub allocation_status: String,
    #[serde(rename = "ExpiredTime")]
    pub expired_time: String,
    #[serde(rename = "StorageCapacityUnitId")]
    pub storage_capacity_unit_id: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "Tags")]
    pub tags: UnitItemTags,
}

impl crate::FlatSerialize for CapacityUnit {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.capacity, &format!("{}.Capacity", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocation_status,
            &format!("{}.AllocationStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.expired_time,
            &format!("{}.ExpiredTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.storage_capacity_unit_id,
            &format!("{}.StorageCapacityUnitId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CapacityUnits {
    #[serde(rename = "StorageCapacityUnit")]
    pub storage_capacity_unit: Vec<CapacityUnit>,
}

impl crate::FlatSerialize for CapacityUnits {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.storage_capacity_unit,
            &format!("{}.StorageCapacityUnit", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RunCommandTag {
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for RunCommandTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RunCommandResourceTag {
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for RunCommandResourceTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CreateCommandTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for CreateCommandTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvokeCommandTag {
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for InvokeCommandTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvokeCommandResourceTag {
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for InvokeCommandResourceTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvocationsTag {
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for InvocationsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvocationsResponseInvocationsInvocationItemInvokeInstancesInvokeInstance {
    #[serde(rename = "Dropped")]
    pub dropped: i32,
    #[serde(rename = "InvocationStatus")]
    pub invocation_status: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Timed")]
    pub timed: bool,
    #[serde(rename = "InstanceInvokeStatus")]
    pub instance_invoke_status: String,
    #[serde(rename = "ExitCode")]
    pub exit_code: i64,
    #[serde(rename = "ErrorInfo")]
    pub error_info: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "Repeats")]
    pub repeats: i32,
    #[serde(rename = "OssOutputUri")]
    pub oss_output_uri: String,
    #[serde(rename = "OssOutputStatus")]
    pub oss_output_status: String,
    #[serde(rename = "FinishTime")]
    pub finish_time: String,
    #[serde(rename = "Output")]
    pub output: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "UpdateTime")]
    pub update_time: String,
    #[serde(rename = "ErrorCode")]
    pub error_code: String,
    #[serde(rename = "StopTime")]
    pub stop_time: String,
}

impl crate::FlatSerialize
    for InvocationsResponseInvocationsInvocationItemInvokeInstancesInvokeInstance
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.dropped, &format!("{}.Dropped", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.invocation_status,
            &format!("{}.InvocationStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.timed, &format!("{}.Timed", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_invoke_status,
            &format!("{}.InstanceInvokeStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.exit_code,
            &format!("{}.ExitCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.error_info,
            &format!("{}.ErrorInfo", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.repeats, &format!("{}.Repeats", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.oss_output_uri,
            &format!("{}.OssOutputUri", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.oss_output_status,
            &format!("{}.OssOutputStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.finish_time,
            &format!("{}.FinishTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.output, &format!("{}.Output", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.update_time,
            &format!("{}.UpdateTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.error_code,
            &format!("{}.ErrorCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.stop_time,
            &format!("{}.StopTime", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvocationsResponseInvocationsInvocationItemInvokeInstances {
    #[serde(rename = "InvokeInstance")]
    pub invoke_instance:
        Vec<InvocationsResponseInvocationsInvocationItemInvokeInstancesInvokeInstance>,
}

impl crate::FlatSerialize for InvocationsResponseInvocationsInvocationItemInvokeInstances {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.invoke_instance,
            &format!("{}.InvokeInstance", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvocationsResponseInvocationsInvocationItemTagsTag {
    #[serde(rename = "TagKey")]
    pub tag_key: String,
    #[serde(rename = "TagValue")]
    pub tag_value: String,
}

impl crate::FlatSerialize for InvocationsResponseInvocationsInvocationItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvocationsResponseInvocationsInvocationItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<InvocationsResponseInvocationsInvocationItemTagsTag>,
}

impl crate::FlatSerialize for InvocationsResponseInvocationsInvocationItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvocationsResponseInvocationsInvocation {
    #[serde(rename = "OssOutputDelivery")]
    pub oss_output_delivery: String,
    #[serde(rename = "InvocationStatus")]
    pub invocation_status: String,
    #[serde(rename = "Parameters")]
    pub parameters: String,
    #[serde(rename = "Timed")]
    pub timed: bool,
    #[serde(rename = "CommandDescription")]
    pub command_description: String,
    #[serde(rename = "Timeout")]
    pub timeout: i64,
    #[serde(rename = "InvokeInstances")]
    pub invoke_instances: InvocationsResponseInvocationsInvocationItemInvokeInstances,
    #[serde(rename = "CommandContent")]
    pub command_content: String,
    #[serde(rename = "WorkingDir")]
    pub working_dir: String,
    #[serde(rename = "RepeatMode")]
    pub repeat_mode: String,
    #[serde(rename = "InvokeStatus")]
    pub invoke_status: String,
    #[serde(rename = "CommandType")]
    pub command_type: String,
    #[serde(rename = "Username")]
    pub username: String,
    #[serde(rename = "ContainerId")]
    pub container_id: String,
    #[serde(rename = "ContainerName")]
    pub container_name: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Frequency")]
    pub frequency: String,
    #[serde(rename = "Launcher")]
    pub launcher: String,
    #[serde(rename = "CommandId")]
    pub command_id: String,
    #[serde(rename = "CommandName")]
    pub command_name: String,
    #[serde(rename = "InvokeId")]
    pub invoke_id: String,
    #[serde(rename = "TerminationMode")]
    pub termination_mode: String,
    #[serde(rename = "Tags")]
    pub tags: InvocationsResponseInvocationsInvocationItemTags,
}

impl crate::FlatSerialize for InvocationsResponseInvocationsInvocation {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.oss_output_delivery,
            &format!("{}.OssOutputDelivery", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invocation_status,
            &format!("{}.InvocationStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.parameters,
            &format!("{}.Parameters", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.timed, &format!("{}.Timed", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.command_description,
            &format!("{}.CommandDescription", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.timeout, &format!("{}.Timeout", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.invoke_instances,
            &format!("{}.InvokeInstances", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.command_content,
            &format!("{}.CommandContent", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.working_dir,
            &format!("{}.WorkingDir", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.repeat_mode,
            &format!("{}.RepeatMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invoke_status,
            &format!("{}.InvokeStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.command_type,
            &format!("{}.CommandType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.username, &format!("{}.Username", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.container_id,
            &format!("{}.ContainerId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.container_name,
            &format!("{}.ContainerName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.frequency,
            &format!("{}.Frequency", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.launcher, &format!("{}.Launcher", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.command_id,
            &format!("{}.CommandId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.command_name,
            &format!("{}.CommandName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invoke_id,
            &format!("{}.InvokeId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.termination_mode,
            &format!("{}.TerminationMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvocationsResponseInvocations {
    #[serde(rename = "Invocation")]
    pub invocation: Vec<InvocationsResponseInvocationsInvocation>,
}

impl crate::FlatSerialize for InvocationsResponseInvocations {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.invocation,
            &format!("{}.Invocation", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvocationResultsTag {
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for InvocationResultsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResultItemTagsTag {
    #[serde(rename = "TagKey")]
    pub tag_key: String,
    #[serde(rename = "TagValue")]
    pub tag_value: String,
}

impl crate::FlatSerialize for ResultItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResultItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ResultItemTagsTag>,
}

impl crate::FlatSerialize for ResultItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvocationResult {
    #[serde(rename = "Dropped")]
    pub dropped: i32,
    #[serde(rename = "OssOutputDelivery")]
    pub oss_output_delivery: String,
    #[serde(rename = "InvocationStatus")]
    pub invocation_status: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "ExitCode")]
    pub exit_code: i64,
    #[serde(rename = "ErrorInfo")]
    pub error_info: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "Repeats")]
    pub repeats: i32,
    #[serde(rename = "InvokeRecordStatus")]
    pub invoke_record_status: String,
    #[serde(rename = "FinishedTime")]
    pub finished_time: String,
    #[serde(rename = "OssOutputUri")]
    pub oss_output_uri: String,
    #[serde(rename = "OssOutputStatus")]
    pub oss_output_status: String,
    #[serde(rename = "Username")]
    pub username: String,
    #[serde(rename = "ContainerId")]
    pub container_id: String,
    #[serde(rename = "ContainerName")]
    pub container_name: String,
    #[serde(rename = "Output")]
    pub output: String,
    #[serde(rename = "Launcher")]
    pub launcher: String,
    #[serde(rename = "CommandId")]
    pub command_id: String,
    #[serde(rename = "ErrorCode")]
    pub error_code: String,
    #[serde(rename = "InvokeId")]
    pub invoke_id: String,
    #[serde(rename = "TerminationMode")]
    pub termination_mode: String,
    #[serde(rename = "Tags")]
    pub tags: ResultItemTags,
    #[serde(rename = "StopTime")]
    pub stop_time: String,
}

impl crate::FlatSerialize for InvocationResult {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.dropped, &format!("{}.Dropped", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.oss_output_delivery,
            &format!("{}.OssOutputDelivery", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invocation_status,
            &format!("{}.InvocationStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.exit_code,
            &format!("{}.ExitCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.error_info,
            &format!("{}.ErrorInfo", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.repeats, &format!("{}.Repeats", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.invoke_record_status,
            &format!("{}.InvokeRecordStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.finished_time,
            &format!("{}.FinishedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.oss_output_uri,
            &format!("{}.OssOutputUri", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.oss_output_status,
            &format!("{}.OssOutputStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.username, &format!("{}.Username", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.container_id,
            &format!("{}.ContainerId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.container_name,
            &format!("{}.ContainerName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.output, &format!("{}.Output", name), params);
        crate::FlatSerialize::flat_serialize(&self.launcher, &format!("{}.Launcher", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.command_id,
            &format!("{}.CommandId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.error_code,
            &format!("{}.ErrorCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invoke_id,
            &format!("{}.InvokeId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.termination_mode,
            &format!("{}.TerminationMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.stop_time,
            &format!("{}.StopTime", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InvocationResults {
    #[serde(rename = "InvocationResult")]
    pub invocation_result: Vec<InvocationResult>,
}

impl crate::FlatSerialize for InvocationResults {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.invocation_result,
            &format!("{}.InvocationResult", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseInvocation {
    #[serde(rename = "PageSize")]
    pub page_size: i64,
    #[serde(rename = "PageNumber")]
    pub page_number: i64,
    #[serde(rename = "TotalCount")]
    pub total_count: i64,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "InvocationResults")]
    pub invocation_results: InvocationResults,
}

impl crate::FlatSerialize for ResponseInvocation {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.page_size,
            &format!("{}.PageSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.page_number,
            &format!("{}.PageNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_count,
            &format!("{}.TotalCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.next_token,
            &format!("{}.NextToken", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invocation_results,
            &format!("{}.InvocationResults", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CommandsTag {
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "Key")]
    pub key: String,
}

impl crate::FlatSerialize for CommandsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PossibleValues {
    #[serde(rename = "PossibleValue")]
    pub possible_value: Vec<String>,
}

impl crate::FlatSerialize for PossibleValues {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.possible_value,
            &format!("{}.PossibleValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ParameterDefinition {
    #[serde(rename = "DefaultValue")]
    pub default_value: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Required")]
    pub required: bool,
    #[serde(rename = "ParameterName")]
    pub parameter_name: String,
    #[serde(rename = "PossibleValues")]
    pub possible_values: PossibleValues,
    #[serde(rename = "PatternRegex")]
    pub pattern_regex: String,
}

impl crate::FlatSerialize for ParameterDefinition {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.default_value,
            &format!("{}.DefaultValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.required, &format!("{}.Required", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.parameter_name,
            &format!("{}.ParameterName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.possible_values,
            &format!("{}.PossibleValues", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.pattern_regex,
            &format!("{}.PatternRegex", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ParameterDefinitions {
    #[serde(rename = "ParameterDefinition")]
    pub parameter_definition: Vec<ParameterDefinition>,
}

impl crate::FlatSerialize for ParameterDefinitions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.parameter_definition,
            &format!("{}.ParameterDefinition", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ParameterNames {
    #[serde(rename = "ParameterName")]
    pub parameter_name: Vec<String>,
}

impl crate::FlatSerialize for ParameterNames {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.parameter_name,
            &format!("{}.ParameterName", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CommandItemTagsTag {
    #[serde(rename = "TagKey")]
    pub tag_key: String,
    #[serde(rename = "TagValue")]
    pub tag_value: String,
}

impl crate::FlatSerialize for CommandItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CommandItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<CommandItemTagsTag>,
}

impl crate::FlatSerialize for CommandItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CommandsCommand {
    #[serde(rename = "ParameterDefinitions")]
    pub parameter_definitions: ParameterDefinitions,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Category")]
    pub category: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "ParameterNames")]
    pub parameter_names: ParameterNames,
    #[serde(rename = "Timeout")]
    pub timeout: i64,
    #[serde(rename = "Provider")]
    pub provider: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "WorkingDir")]
    pub working_dir: String,
    #[serde(rename = "CommandContent")]
    pub command_content: String,
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "Version")]
    pub version: i32,
    #[serde(rename = "InvokeTimes")]
    pub invoke_times: i32,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Launcher")]
    pub launcher: String,
    #[serde(rename = "Latest")]
    pub latest: bool,
    #[serde(rename = "EnableParameter")]
    pub enable_parameter: bool,
    #[serde(rename = "CommandId")]
    pub command_id: String,
    #[serde(rename = "Tags")]
    pub tags: CommandItemTags,
}

impl crate::FlatSerialize for CommandsCommand {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.parameter_definitions,
            &format!("{}.ParameterDefinitions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.category, &format!("{}.Category", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.parameter_names,
            &format!("{}.ParameterNames", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.timeout, &format!("{}.Timeout", name), params);
        crate::FlatSerialize::flat_serialize(&self.provider, &format!("{}.Provider", name), params);
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.working_dir,
            &format!("{}.WorkingDir", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.command_content,
            &format!("{}.CommandContent", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(&self.version, &format!("{}.Version", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.invoke_times,
            &format!("{}.InvokeTimes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.launcher, &format!("{}.Launcher", name), params);
        crate::FlatSerialize::flat_serialize(&self.latest, &format!("{}.Latest", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.enable_parameter,
            &format!("{}.EnableParameter", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.command_id,
            &format!("{}.CommandId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseCommands {
    #[serde(rename = "Command")]
    pub command: Vec<CommandsCommand>,
}

impl crate::FlatSerialize for ResponseCommands {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.command, &format!("{}.Command", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct FileTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for FileTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct FileResultsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for FileResultsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResultsResponseInvocationsInvocationItemInvokeInstancesInvokeInstance {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "InvocationStatus")]
    pub invocation_status: String,
    #[serde(rename = "FinishTime")]
    pub finish_time: String,
    #[serde(rename = "UpdateTime")]
    pub update_time: String,
    #[serde(rename = "ErrorInfo")]
    pub error_info: String,
    #[serde(rename = "ErrorCode")]
    pub error_code: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
}

impl crate::FlatSerialize
    for ResultsResponseInvocationsInvocationItemInvokeInstancesInvokeInstance
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invocation_status,
            &format!("{}.InvocationStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.finish_time,
            &format!("{}.FinishTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.update_time,
            &format!("{}.UpdateTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.error_info,
            &format!("{}.ErrorInfo", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.error_code,
            &format!("{}.ErrorCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResultsResponseInvocationsInvocationItemInvokeInstances {
    #[serde(rename = "InvokeInstance")]
    pub invoke_instance: Vec<ResultsResponseInvocationsInvocationItemInvokeInstancesInvokeInstance>,
}

impl crate::FlatSerialize for ResultsResponseInvocationsInvocationItemInvokeInstances {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.invoke_instance,
            &format!("{}.InvokeInstance", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResultsResponseInvocationsInvocationItemTagsTag {
    #[serde(rename = "TagKey")]
    pub tag_key: String,
    #[serde(rename = "TagValue")]
    pub tag_value: String,
}

impl crate::FlatSerialize for ResultsResponseInvocationsInvocationItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResultsResponseInvocationsInvocationItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ResultsResponseInvocationsInvocationItemTagsTag>,
}

impl crate::FlatSerialize for ResultsResponseInvocationsInvocationItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResultsResponseInvocationsInvocation {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "InvocationStatus")]
    pub invocation_status: String,
    #[serde(rename = "ContentType")]
    pub content_type: String,
    #[serde(rename = "TargetDir")]
    pub target_dir: String,
    #[serde(rename = "FileOwner")]
    pub file_owner: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "VmCount")]
    pub vm_count: i32,
    #[serde(rename = "FileMode")]
    pub file_mode: String,
    #[serde(rename = "FileGroup")]
    pub file_group: String,
    #[serde(rename = "InvokeId")]
    pub invoke_id: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Content")]
    pub content: String,
    #[serde(rename = "Overwrite")]
    pub overwrite: String,
    #[serde(rename = "InvokeInstances")]
    pub invoke_instances: ResultsResponseInvocationsInvocationItemInvokeInstances,
    #[serde(rename = "Tags")]
    pub tags: ResultsResponseInvocationsInvocationItemTags,
}

impl crate::FlatSerialize for ResultsResponseInvocationsInvocation {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invocation_status,
            &format!("{}.InvocationStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.content_type,
            &format!("{}.ContentType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.target_dir,
            &format!("{}.TargetDir", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.file_owner,
            &format!("{}.FileOwner", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.vm_count, &format!("{}.VmCount", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.file_mode,
            &format!("{}.FileMode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.file_group,
            &format!("{}.FileGroup", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invoke_id,
            &format!("{}.InvokeId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.content, &format!("{}.Content", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.overwrite,
            &format!("{}.Overwrite", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invoke_instances,
            &format!("{}.InvokeInstances", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResultsResponseInvocations {
    #[serde(rename = "Invocation")]
    pub invocation: Vec<ResultsResponseInvocationsInvocation>,
}

impl crate::FlatSerialize for ResultsResponseInvocations {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.invocation,
            &format!("{}.Invocation", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssistantStatus {
    #[serde(rename = "CloudAssistantStatus")]
    pub cloud_assistant_status: String,
    #[serde(rename = "LastInvokedTime")]
    pub last_invoked_time: String,
    #[serde(rename = "CloudAssistantVersion")]
    pub cloud_assistant_version: String,
    #[serde(rename = "ActiveTaskCount")]
    pub active_task_count: i64,
    #[serde(rename = "InvocationCount")]
    pub invocation_count: i64,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "LastHeartbeatTime")]
    pub last_heartbeat_time: String,
    #[serde(rename = "OSType")]
    pub os_type: String,
    #[serde(rename = "SupportSessionManager")]
    pub support_session_manager: bool,
}

impl crate::FlatSerialize for AssistantStatus {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.cloud_assistant_status,
            &format!("{}.CloudAssistantStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.last_invoked_time,
            &format!("{}.LastInvokedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cloud_assistant_version,
            &format!("{}.CloudAssistantVersion", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.active_task_count,
            &format!("{}.ActiveTaskCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invocation_count,
            &format!("{}.InvocationCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.last_heartbeat_time,
            &format!("{}.LastHeartbeatTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.os_type, &format!("{}.OSType", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.support_session_manager,
            &format!("{}.SupportSessionManager", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssistantStatusSet {
    #[serde(rename = "InstanceCloudAssistantStatus")]
    pub instance_cloud_assistant_status: Vec<AssistantStatus>,
}

impl crate::FlatSerialize for AssistantStatusSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_cloud_assistant_status,
            &format!("{}.InstanceCloudAssistantStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct EncryptionOptions {
    #[serde(rename = "Enabled")]
    pub enabled: bool,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
    #[serde(rename = "Mode")]
    pub mode: String,
}

impl crate::FlatSerialize for EncryptionOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.enabled, &format!("{}.Enabled", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.kms_key_id,
            &format!("{}.KMSKeyId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.mode, &format!("{}.Mode", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConnectionsConnection {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "FailedDetail")]
    pub failed_detail: String,
    #[serde(rename = "EndTime")]
    pub end_time: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "ClosedReason")]
    pub closed_reason: String,
}

impl crate::FlatSerialize for ConnectionsConnection {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.failed_detail,
            &format!("{}.FailedDetail", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.end_time, &format!("{}.EndTime", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.closed_reason,
            &format!("{}.ClosedReason", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemConnections {
    #[serde(rename = "Connection")]
    pub connection: Vec<ConnectionsConnection>,
}

impl crate::FlatSerialize for ItemConnections {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.connection,
            &format!("{}.Connection", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SessionsSession {
    #[serde(rename = "Connections")]
    pub connections: ItemConnections,
    #[serde(rename = "IdentityType")]
    pub identity_type: String,
    #[serde(rename = "PrincipalId")]
    pub principal_id: String,
    #[serde(rename = "Username")]
    pub username: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "TargetServer")]
    pub target_server: String,
    #[serde(rename = "PortNumber")]
    pub port_number: i32,
    #[serde(rename = "ClientIP")]
    pub client_ip: String,
    #[serde(rename = "SessionId")]
    pub session_id: String,
}

impl crate::FlatSerialize for SessionsSession {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.connections,
            &format!("{}.Connections", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.identity_type,
            &format!("{}.IdentityType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.principal_id,
            &format!("{}.PrincipalId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.username, &format!("{}.Username", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.target_server,
            &format!("{}.TargetServer", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_number,
            &format!("{}.PortNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.client_ip,
            &format!("{}.ClientIP", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.session_id,
            &format!("{}.SessionId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseSessions {
    #[serde(rename = "Session")]
    pub session: Vec<SessionsSession>,
}

impl crate::FlatSerialize for ResponseSessions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.session, &format!("{}.Session", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SettingsOssDeliveryConfig {
    #[serde(rename = "Enabled")]
    pub enabled: bool,
    #[serde(rename = "BucketName")]
    pub bucket_name: String,
    #[serde(rename = "Prefix")]
    pub prefix: String,
    #[serde(rename = "EncryptionType")]
    pub encryption_type: String,
    #[serde(rename = "EncryptionAlgorithm")]
    pub encryption_algorithm: String,
    #[serde(rename = "EncryptionKeyId")]
    pub encryption_key_id: String,
}

impl crate::FlatSerialize for SettingsOssDeliveryConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.enabled, &format!("{}.Enabled", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.bucket_name,
            &format!("{}.BucketName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.prefix, &format!("{}.Prefix", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.encryption_type,
            &format!("{}.EncryptionType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encryption_algorithm,
            &format!("{}.EncryptionAlgorithm", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encryption_key_id,
            &format!("{}.EncryptionKeyId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SettingsSlsDeliveryConfig {
    #[serde(rename = "Enabled")]
    pub enabled: bool,
    #[serde(rename = "ProjectName")]
    pub project_name: String,
    #[serde(rename = "LogstoreName")]
    pub logstore_name: String,
}

impl crate::FlatSerialize for SettingsSlsDeliveryConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.enabled, &format!("{}.Enabled", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.project_name,
            &format!("{}.ProjectName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.logstore_name,
            &format!("{}.LogstoreName", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SettingsAgentUpgradeConfig {
    #[serde(rename = "Enabled")]
    pub enabled: bool,
    #[serde(rename = "AllowedUpgradeWindow")]
    pub allowed_upgrade_window: Vec<String>,
    #[serde(rename = "TimeZone")]
    pub time_zone: String,
}

impl crate::FlatSerialize for SettingsAgentUpgradeConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.enabled, &format!("{}.Enabled", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.allowed_upgrade_window,
            &format!("{}.AllowedUpgradeWindow", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.time_zone,
            &format!("{}.TimeZone", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SettingsSessionManagerConfig {
    #[serde(rename = "SessionManagerEnabled")]
    pub session_manager_enabled: bool,
}

impl crate::FlatSerialize for SettingsSessionManagerConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.session_manager_enabled,
            &format!("{}.SessionManagerEnabled", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConfigsOssDeliveryConfig {
    #[serde(rename = "EncryptionType")]
    pub encryption_type: String,
    #[serde(rename = "EncryptionAlgorithm")]
    pub encryption_algorithm: String,
    #[serde(rename = "DeliveryType")]
    pub delivery_type: String,
    #[serde(rename = "Enabled")]
    pub enabled: bool,
    #[serde(rename = "BucketName")]
    pub bucket_name: String,
    #[serde(rename = "Prefix")]
    pub prefix: String,
    #[serde(rename = "EncryptionKeyId")]
    pub encryption_key_id: String,
}

impl crate::FlatSerialize for ConfigsOssDeliveryConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.encryption_type,
            &format!("{}.EncryptionType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.encryption_algorithm,
            &format!("{}.EncryptionAlgorithm", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.delivery_type,
            &format!("{}.DeliveryType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.enabled, &format!("{}.Enabled", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.bucket_name,
            &format!("{}.BucketName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.prefix, &format!("{}.Prefix", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.encryption_key_id,
            &format!("{}.EncryptionKeyId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OssDeliveryConfigs {
    #[serde(rename = "OssDeliveryConfig")]
    pub oss_delivery_config: Vec<ConfigsOssDeliveryConfig>,
}

impl crate::FlatSerialize for OssDeliveryConfigs {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.oss_delivery_config,
            &format!("{}.OssDeliveryConfig", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConfigsSlsDeliveryConfig {
    #[serde(rename = "DeliveryType")]
    pub delivery_type: String,
    #[serde(rename = "LogstoreName")]
    pub logstore_name: String,
    #[serde(rename = "Enabled")]
    pub enabled: bool,
    #[serde(rename = "ProjectName")]
    pub project_name: String,
}

impl crate::FlatSerialize for ConfigsSlsDeliveryConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.delivery_type,
            &format!("{}.DeliveryType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.logstore_name,
            &format!("{}.LogstoreName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.enabled, &format!("{}.Enabled", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.project_name,
            &format!("{}.ProjectName", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SlsDeliveryConfigs {
    #[serde(rename = "SlsDeliveryConfig")]
    pub sls_delivery_config: Vec<ConfigsSlsDeliveryConfig>,
}

impl crate::FlatSerialize for SlsDeliveryConfigs {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.sls_delivery_config,
            &format!("{}.SlsDeliveryConfig", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct UpgradeWindows {
    #[serde(rename = "AllowedUpgradeWindow")]
    pub allowed_upgrade_window: Vec<String>,
}

impl crate::FlatSerialize for UpgradeWindows {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.allowed_upgrade_window,
            &format!("{}.AllowedUpgradeWindow", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseAgentUpgradeConfig {
    #[serde(rename = "Enabled")]
    pub enabled: bool,
    #[serde(rename = "AllowedUpgradeWindows")]
    pub allowed_upgrade_windows: UpgradeWindows,
    #[serde(rename = "TimeZone")]
    pub time_zone: String,
}

impl crate::FlatSerialize for ResponseAgentUpgradeConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.enabled, &format!("{}.Enabled", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.allowed_upgrade_windows,
            &format!("{}.AllowedUpgradeWindows", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.time_zone,
            &format!("{}.TimeZone", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseSessionManagerConfig {
    #[serde(rename = "SessionManagerEnabled")]
    pub session_manager_enabled: bool,
}

impl crate::FlatSerialize for ResponseSessionManagerConfig {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.session_manager_enabled,
            &format!("{}.SessionManagerEnabled", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ActivationTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ActivationTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ActivationsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ActivationsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ListItemTag {
    #[serde(rename = "TagKey")]
    pub tag_key: String,
    #[serde(rename = "TagValue")]
    pub tag_value: String,
}

impl crate::FlatSerialize for ListItemTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ActivationList {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "DeregisteredCount")]
    pub deregistered_count: i32,
    #[serde(rename = "InstanceCount")]
    pub instance_count: i32,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RegisteredCount")]
    pub registered_count: i32,
    #[serde(rename = "InstanceName")]
    pub instance_name: String,
    #[serde(rename = "Disabled")]
    pub disabled: bool,
    #[serde(rename = "IpAddressRange")]
    pub ip_address_range: String,
    #[serde(rename = "TimeToLiveInHours")]
    pub time_to_live_in_hours: i64,
    #[serde(rename = "ActivationId")]
    pub activation_id: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "Tags")]
    pub tags: Vec<ListItemTag>,
}

impl crate::FlatSerialize for ActivationList {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.deregistered_count,
            &format!("{}.DeregisteredCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_count,
            &format!("{}.InstanceCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.registered_count,
            &format!("{}.RegisteredCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_name,
            &format!("{}.InstanceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.disabled, &format!("{}.Disabled", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.ip_address_range,
            &format!("{}.IpAddressRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.time_to_live_in_hours,
            &format!("{}.TimeToLiveInHours", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.activation_id,
            &format!("{}.ActivationId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DisableActivationResponseActivation {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "DeregisteredCount")]
    pub deregistered_count: i32,
    #[serde(rename = "InstanceCount")]
    pub instance_count: i32,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RegisteredCount")]
    pub registered_count: i32,
    #[serde(rename = "InstanceName")]
    pub instance_name: String,
    #[serde(rename = "Disabled")]
    pub disabled: bool,
    #[serde(rename = "IpAddressRange")]
    pub ip_address_range: String,
    #[serde(rename = "TimeToLiveInHours")]
    pub time_to_live_in_hours: i64,
    #[serde(rename = "ActivationId")]
    pub activation_id: String,
}

impl crate::FlatSerialize for DisableActivationResponseActivation {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.deregistered_count,
            &format!("{}.DeregisteredCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_count,
            &format!("{}.InstanceCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.registered_count,
            &format!("{}.RegisteredCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_name,
            &format!("{}.InstanceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.disabled, &format!("{}.Disabled", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.ip_address_range,
            &format!("{}.IpAddressRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.time_to_live_in_hours,
            &format!("{}.TimeToLiveInHours", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.activation_id,
            &format!("{}.ActivationId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DeleteActivationResponseActivation {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "DeregisteredCount")]
    pub deregistered_count: i32,
    #[serde(rename = "InstanceCount")]
    pub instance_count: i32,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RegisteredCount")]
    pub registered_count: i32,
    #[serde(rename = "InstanceName")]
    pub instance_name: String,
    #[serde(rename = "IpAddressRange")]
    pub ip_address_range: String,
    #[serde(rename = "TimeToLiveInHours")]
    pub time_to_live_in_hours: i64,
    #[serde(rename = "ActivationId")]
    pub activation_id: String,
}

impl crate::FlatSerialize for DeleteActivationResponseActivation {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.deregistered_count,
            &format!("{}.DeregisteredCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_count,
            &format!("{}.InstanceCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.registered_count,
            &format!("{}.RegisteredCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_name,
            &format!("{}.InstanceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ip_address_range,
            &format!("{}.IpAddressRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.time_to_live_in_hours,
            &format!("{}.TimeToLiveInHours", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.activation_id,
            &format!("{}.ActivationId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ManagedInstancesTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ManagedInstancesTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesItemTag {
    #[serde(rename = "TagKey")]
    pub tag_key: String,
    #[serde(rename = "TagValue")]
    pub tag_value: String,
}

impl crate::FlatSerialize for InstancesItemTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancesResponseInstance {
    #[serde(rename = "LastInvokedTime")]
    pub last_invoked_time: String,
    #[serde(rename = "Connected")]
    pub connected: bool,
    #[serde(rename = "InternetIp")]
    pub internet_ip: String,
    #[serde(rename = "Hostname")]
    pub hostname: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "ActivationId")]
    pub activation_id: String,
    #[serde(rename = "IntranetIp")]
    pub intranet_ip: String,
    #[serde(rename = "AgentVersion")]
    pub agent_version: String,
    #[serde(rename = "RegistrationTime")]
    pub registration_time: String,
    #[serde(rename = "InstanceName")]
    pub instance_name: String,
    #[serde(rename = "OsType")]
    pub os_type: String,
    #[serde(rename = "OsVersion")]
    pub os_version: String,
    #[serde(rename = "InvocationCount")]
    pub invocation_count: i64,
    #[serde(rename = "MachineId")]
    pub machine_id: String,
    #[serde(rename = "Tags")]
    pub tags: Vec<InstancesItemTag>,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
}

impl crate::FlatSerialize for InstancesResponseInstance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.last_invoked_time,
            &format!("{}.LastInvokedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.connected,
            &format!("{}.Connected", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_ip,
            &format!("{}.InternetIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.hostname, &format!("{}.Hostname", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.activation_id,
            &format!("{}.ActivationId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.intranet_ip,
            &format!("{}.IntranetIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.agent_version,
            &format!("{}.AgentVersion", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.registration_time,
            &format!("{}.RegistrationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_name,
            &format!("{}.InstanceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.os_type, &format!("{}.OsType", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.os_version,
            &format!("{}.OsVersion", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invocation_count,
            &format!("{}.InvocationCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.machine_id,
            &format!("{}.MachineId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ModifyManagedInstanceResponseInstance {
    #[serde(rename = "InstanceName")]
    pub instance_name: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
}

impl crate::FlatSerialize for ModifyManagedInstanceResponseInstance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_name,
            &format!("{}.InstanceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DeregisterManagedInstanceResponseInstance {
    #[serde(rename = "LastInvokedTime")]
    pub last_invoked_time: String,
    #[serde(rename = "InternetIp")]
    pub internet_ip: String,
    #[serde(rename = "Hostname")]
    pub hostname: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "ActivationId")]
    pub activation_id: String,
    #[serde(rename = "IntranetIp")]
    pub intranet_ip: String,
    #[serde(rename = "AgentVersion")]
    pub agent_version: String,
    #[serde(rename = "RegistrationTime")]
    pub registration_time: String,
    #[serde(rename = "InstanceName")]
    pub instance_name: String,
    #[serde(rename = "OsType")]
    pub os_type: String,
    #[serde(rename = "OsVersion")]
    pub os_version: String,
    #[serde(rename = "InvocationCount")]
    pub invocation_count: i64,
    #[serde(rename = "MachineId")]
    pub machine_id: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
}

impl crate::FlatSerialize for DeregisterManagedInstanceResponseInstance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.last_invoked_time,
            &format!("{}.LastInvokedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_ip,
            &format!("{}.InternetIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.hostname, &format!("{}.Hostname", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.activation_id,
            &format!("{}.ActivationId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.intranet_ip,
            &format!("{}.IntranetIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.agent_version,
            &format!("{}.AgentVersion", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.registration_time,
            &format!("{}.RegistrationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_name,
            &format!("{}.InstanceName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.os_type, &format!("{}.OsType", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.os_version,
            &format!("{}.OsVersion", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.invocation_count,
            &format!("{}.InvocationCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.machine_id,
            &format!("{}.MachineId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetPluginStatus {
    #[serde(rename = "PluginStatus")]
    pub plugin_status: String,
    #[serde(rename = "PluginVersion")]
    pub plugin_version: String,
    #[serde(rename = "PluginName")]
    pub plugin_name: String,
    #[serde(rename = "FirstHeartbeatTime")]
    pub first_heartbeat_time: String,
    #[serde(rename = "LastHeartbeatTime")]
    pub last_heartbeat_time: String,
}

impl crate::FlatSerialize for SetPluginStatus {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.plugin_status,
            &format!("{}.PluginStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.plugin_version,
            &format!("{}.PluginVersion", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.plugin_name,
            &format!("{}.PluginName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.first_heartbeat_time,
            &format!("{}.FirstHeartbeatTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.last_heartbeat_time,
            &format!("{}.LastHeartbeatTime", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemPluginStatusSet {
    #[serde(rename = "PluginStatus")]
    pub plugin_status: Vec<SetPluginStatus>,
}

impl crate::FlatSerialize for ItemPluginStatusSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.plugin_status,
            &format!("{}.PluginStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancePluginStatus {
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "PluginStatusSet")]
    pub plugin_status_set: ItemPluginStatusSet,
}

impl crate::FlatSerialize for InstancePluginStatus {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.plugin_status_set,
            &format!("{}.PluginStatusSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstancePluginStatusSet {
    #[serde(rename = "InstancePluginStatus")]
    pub instance_plugin_status: Vec<InstancePluginStatus>,
}

impl crate::FlatSerialize for InstancePluginStatusSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_plugin_status,
            &format!("{}.InstancePluginStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ScheduledSystemEventTypeItemEventCycleStatus {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Code")]
    pub code: i32,
}

impl crate::FlatSerialize for ScheduledSystemEventTypeItemEventCycleStatus {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ScheduledSystemEventTypeItemEventType {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Code")]
    pub code: i32,
}

impl crate::FlatSerialize for ScheduledSystemEventTypeItemEventType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ScheduledSystemEventTypeItemExtendedAttributeInactiveDisksInactiveDisk {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "DeviceSize")]
    pub device_size: String,
    #[serde(rename = "DeviceCategory")]
    pub device_category: String,
    #[serde(rename = "DeviceType")]
    pub device_type: String,
    #[serde(rename = "ReleaseTime")]
    pub release_time: String,
}

impl crate::FlatSerialize
    for ScheduledSystemEventTypeItemExtendedAttributeInactiveDisksInactiveDisk
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.device_size,
            &format!("{}.DeviceSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.device_category,
            &format!("{}.DeviceCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.device_type,
            &format!("{}.DeviceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.release_time,
            &format!("{}.ReleaseTime", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ScheduledSystemEventTypeItemExtendedAttributeInactiveDisks {
    #[serde(rename = "InactiveDisk")]
    pub inactive_disk: Vec<ScheduledSystemEventTypeItemExtendedAttributeInactiveDisksInactiveDisk>,
}

impl crate::FlatSerialize for ScheduledSystemEventTypeItemExtendedAttributeInactiveDisks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.inactive_disk,
            &format!("{}.InactiveDisk", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ScheduledSystemEventTypeItemExtendedAttribute {
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "DiskId")]
    pub disk_id: String,
    #[serde(rename = "InactiveDisks")]
    pub inactive_disks: ScheduledSystemEventTypeItemExtendedAttributeInactiveDisks,
}

impl crate::FlatSerialize for ScheduledSystemEventTypeItemExtendedAttribute {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(&self.disk_id, &format!("{}.DiskId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.inactive_disks,
            &format!("{}.InactiveDisks", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ScheduledSystemEventType {
    #[serde(rename = "EventPublishTime")]
    pub event_publish_time: String,
    #[serde(rename = "EventId")]
    pub event_id: String,
    #[serde(rename = "NotBefore")]
    pub not_before: String,
    #[serde(rename = "ImpactLevel")]
    pub impact_level: String,
    #[serde(rename = "Reason")]
    pub reason: String,
    #[serde(rename = "EventCycleStatus")]
    pub event_cycle_status: ScheduledSystemEventTypeItemEventCycleStatus,
    #[serde(rename = "EventType")]
    pub event_type: ScheduledSystemEventTypeItemEventType,
    #[serde(rename = "ExtendedAttribute")]
    pub extended_attribute: ScheduledSystemEventTypeItemExtendedAttribute,
}

impl crate::FlatSerialize for ScheduledSystemEventType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.event_publish_time,
            &format!("{}.EventPublishTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.event_id, &format!("{}.EventId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.not_before,
            &format!("{}.NotBefore", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.impact_level,
            &format!("{}.ImpactLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.reason, &format!("{}.Reason", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.event_cycle_status,
            &format!("{}.EventCycleStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.event_type,
            &format!("{}.EventType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.extended_attribute,
            &format!("{}.ExtendedAttribute", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ScheduledSystemEventSet {
    #[serde(rename = "ScheduledSystemEventType")]
    pub scheduled_system_event_type: Vec<ScheduledSystemEventType>,
}

impl crate::FlatSerialize for ScheduledSystemEventSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.scheduled_system_event_type,
            &format!("{}.ScheduledSystemEventType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceFullStatusTypeItemStatus {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Code")]
    pub code: i32,
}

impl crate::FlatSerialize for InstanceFullStatusTypeItemStatus {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceFullStatusTypeItemHealthStatus {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Code")]
    pub code: i32,
}

impl crate::FlatSerialize for InstanceFullStatusTypeItemHealthStatus {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceFullStatusType {
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "ScheduledSystemEventSet")]
    pub scheduled_system_event_set: ScheduledSystemEventSet,
    #[serde(rename = "Status")]
    pub status: InstanceFullStatusTypeItemStatus,
    #[serde(rename = "HealthStatus")]
    pub health_status: InstanceFullStatusTypeItemHealthStatus,
}

impl crate::FlatSerialize for InstanceFullStatusType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.scheduled_system_event_set,
            &format!("{}.ScheduledSystemEventSet", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.health_status,
            &format!("{}.HealthStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceFullStatusSet {
    #[serde(rename = "InstanceFullStatusType")]
    pub instance_full_status_type: Vec<InstanceFullStatusType>,
}

impl crate::FlatSerialize for InstanceFullStatusSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_full_status_type,
            &format!("{}.InstanceFullStatusType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct StatusTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for StatusTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskEventTypeItemEventType {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Code")]
    pub code: i32,
}

impl crate::FlatSerialize for DiskEventTypeItemEventType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskEventType {
    #[serde(rename = "EventId")]
    pub event_id: String,
    #[serde(rename = "EventEndTime")]
    pub event_end_time: String,
    #[serde(rename = "EventTime")]
    pub event_time: String,
    #[serde(rename = "ImpactLevel")]
    pub impact_level: String,
    #[serde(rename = "EventType")]
    pub event_type: DiskEventTypeItemEventType,
}

impl crate::FlatSerialize for DiskEventType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.event_id, &format!("{}.EventId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.event_end_time,
            &format!("{}.EventEndTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.event_time,
            &format!("{}.EventTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.impact_level,
            &format!("{}.ImpactLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.event_type,
            &format!("{}.EventType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskEventSet {
    #[serde(rename = "DiskEventType")]
    pub disk_event_type: Vec<DiskEventType>,
}

impl crate::FlatSerialize for DiskEventSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.disk_event_type,
            &format!("{}.DiskEventType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskFullStatusTypeItemStatus {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Code")]
    pub code: i32,
}

impl crate::FlatSerialize for DiskFullStatusTypeItemStatus {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskFullStatusTypeItemHealthStatus {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Code")]
    pub code: i32,
}

impl crate::FlatSerialize for DiskFullStatusTypeItemHealthStatus {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskFullStatusType {
    #[serde(rename = "DiskId")]
    pub disk_id: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "DiskEventSet")]
    pub disk_event_set: DiskEventSet,
    #[serde(rename = "Status")]
    pub status: DiskFullStatusTypeItemStatus,
    #[serde(rename = "HealthStatus")]
    pub health_status: DiskFullStatusTypeItemHealthStatus,
}

impl crate::FlatSerialize for DiskFullStatusType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.disk_id, &format!("{}.DiskId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.disk_event_set,
            &format!("{}.DiskEventSet", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.health_status,
            &format!("{}.HealthStatus", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskFullStatusSet {
    #[serde(rename = "DiskFullStatusType")]
    pub disk_full_status_type: Vec<DiskFullStatusType>,
}

impl crate::FlatSerialize for DiskFullStatusSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.disk_full_status_type,
            &format!("{}.DiskFullStatusType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct EventsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for EventsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceSystemEventTypeItemEventType {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Code")]
    pub code: i32,
}

impl crate::FlatSerialize for InstanceSystemEventTypeItemEventType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceSystemEventTypeItemEventCycleStatus {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Code")]
    pub code: i32,
}

impl crate::FlatSerialize for InstanceSystemEventTypeItemEventCycleStatus {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceSystemEventTypeItemExtendedAttributeInactiveDisksInactiveDisk {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "DeviceSize")]
    pub device_size: String,
    #[serde(rename = "DeviceCategory")]
    pub device_category: String,
    #[serde(rename = "DeviceType")]
    pub device_type: String,
    #[serde(rename = "ReleaseTime")]
    pub release_time: String,
}

impl crate::FlatSerialize
    for InstanceSystemEventTypeItemExtendedAttributeInactiveDisksInactiveDisk
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.device_size,
            &format!("{}.DeviceSize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.device_category,
            &format!("{}.DeviceCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.device_type,
            &format!("{}.DeviceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.release_time,
            &format!("{}.ReleaseTime", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceSystemEventTypeItemExtendedAttributeInactiveDisks {
    #[serde(rename = "InactiveDisk")]
    pub inactive_disk: Vec<InstanceSystemEventTypeItemExtendedAttributeInactiveDisksInactiveDisk>,
}

impl crate::FlatSerialize for InstanceSystemEventTypeItemExtendedAttributeInactiveDisks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.inactive_disk,
            &format!("{}.InactiveDisk", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct MigrationOptions {
    #[serde(rename = "MigrationOption")]
    pub migration_option: Vec<String>,
}

impl crate::FlatSerialize for MigrationOptions {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.migration_option,
            &format!("{}.MigrationOption", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceSystemEventTypeItemExtendedAttribute {
    #[serde(rename = "Device")]
    pub device: String,
    #[serde(rename = "DiskId")]
    pub disk_id: String,
    #[serde(rename = "InactiveDisks")]
    pub inactive_disks: InstanceSystemEventTypeItemExtendedAttributeInactiveDisks,
    #[serde(rename = "HostType")]
    pub host_type: String,
    #[serde(rename = "HostId")]
    pub host_id: String,
    #[serde(rename = "MigrationOptions")]
    pub migration_options: MigrationOptions,
    #[serde(rename = "OnlineRepairPolicy")]
    pub online_repair_policy: String,
    #[serde(rename = "Rack")]
    pub rack: String,
    #[serde(rename = "PunishType")]
    pub punish_type: String,
    #[serde(rename = "PunishDomain")]
    pub punish_domain: String,
    #[serde(rename = "PunishUrl")]
    pub punish_url: String,
    #[serde(rename = "Code")]
    pub code: String,
    #[serde(rename = "CanAccept")]
    pub can_accept: String,
    #[serde(rename = "ResponseResult")]
    pub response_result: String,
    #[serde(rename = "MetricValue")]
    pub metric_value: String,
    #[serde(rename = "MetricName")]
    pub metric_name: String,
}

impl crate::FlatSerialize for InstanceSystemEventTypeItemExtendedAttribute {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.device, &format!("{}.Device", name), params);
        crate::FlatSerialize::flat_serialize(&self.disk_id, &format!("{}.DiskId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.inactive_disks,
            &format!("{}.InactiveDisks", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.host_type,
            &format!("{}.HostType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.host_id, &format!("{}.HostId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.migration_options,
            &format!("{}.MigrationOptions", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.online_repair_policy,
            &format!("{}.OnlineRepairPolicy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.rack, &format!("{}.Rack", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.punish_type,
            &format!("{}.PunishType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.punish_domain,
            &format!("{}.PunishDomain", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.punish_url,
            &format!("{}.PunishUrl", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.code, &format!("{}.Code", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.can_accept,
            &format!("{}.CanAccept", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.response_result,
            &format!("{}.ResponseResult", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.metric_value,
            &format!("{}.MetricValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.metric_name,
            &format!("{}.MetricName", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceSystemEventType {
    #[serde(rename = "EventId")]
    pub event_id: String,
    #[serde(rename = "EventPublishTime")]
    pub event_publish_time: String,
    #[serde(rename = "EventFinishTime")]
    pub event_finish_time: String,
    #[serde(rename = "ResourceType")]
    pub resource_type: String,
    #[serde(rename = "ImpactLevel")]
    pub impact_level: String,
    #[serde(rename = "NotBefore")]
    pub not_before: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Reason")]
    pub reason: String,
    #[serde(rename = "EventType")]
    pub event_type: InstanceSystemEventTypeItemEventType,
    #[serde(rename = "EventCycleStatus")]
    pub event_cycle_status: InstanceSystemEventTypeItemEventCycleStatus,
    #[serde(rename = "ExtendedAttribute")]
    pub extended_attribute: InstanceSystemEventTypeItemExtendedAttribute,
    #[serde(rename = "ReasonCode")]
    pub reason_code: String,
}

impl crate::FlatSerialize for InstanceSystemEventType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.event_id, &format!("{}.EventId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.event_publish_time,
            &format!("{}.EventPublishTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.event_finish_time,
            &format!("{}.EventFinishTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_type,
            &format!("{}.ResourceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.impact_level,
            &format!("{}.ImpactLevel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.not_before,
            &format!("{}.NotBefore", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.reason, &format!("{}.Reason", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.event_type,
            &format!("{}.EventType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.event_cycle_status,
            &format!("{}.EventCycleStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.extended_attribute,
            &format!("{}.ExtendedAttribute", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.reason_code,
            &format!("{}.ReasonCode", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceSystemEventSet {
    #[serde(rename = "InstanceSystemEventType")]
    pub instance_system_event_type: Vec<InstanceSystemEventType>,
}

impl crate::FlatSerialize for InstanceSystemEventSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_system_event_type,
            &format!("{}.InstanceSystemEventType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct EventIdSet {
    #[serde(rename = "EventId")]
    pub event_id: Vec<String>,
}

impl crate::FlatSerialize for EventIdSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.event_id, &format!("{}.EventId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseMetric {
    #[serde(rename = "MetricId")]
    pub metric_id: String,
    #[serde(rename = "MetricName")]
    pub metric_name: String,
    #[serde(rename = "MetricCategory")]
    pub metric_category: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "ResourceType")]
    pub resource_type: String,
    #[serde(rename = "GuestMetric")]
    pub guest_metric: bool,
    #[serde(rename = "SupportedOperatingSystem")]
    pub supported_operating_system: String,
}

impl crate::FlatSerialize for ResponseMetric {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.metric_id,
            &format!("{}.MetricId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.metric_name,
            &format!("{}.MetricName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.metric_category,
            &format!("{}.MetricCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_type,
            &format!("{}.ResourceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.guest_metric,
            &format!("{}.GuestMetric", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.supported_operating_system,
            &format!("{}.SupportedOperatingSystem", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct MetricSet {
    #[serde(rename = "MetricSetId")]
    pub metric_set_id: String,
    #[serde(rename = "MetricSetName")]
    pub metric_set_name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "ResourceType")]
    pub resource_type: String,
    #[serde(rename = "MetricIds")]
    pub metric_ids: Vec<String>,
}

impl crate::FlatSerialize for MetricSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.metric_set_id,
            &format!("{}.MetricSetId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.metric_set_name,
            &format!("{}.MetricSetName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.resource_type,
            &format!("{}.ResourceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.metric_ids,
            &format!("{}.MetricIds", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReportItemIssuesIssue {
    #[serde(rename = "MetricId")]
    pub metric_id: String,
    #[serde(rename = "MetricCategory")]
    pub metric_category: String,
    #[serde(rename = "IssueId")]
    pub issue_id: String,
    #[serde(rename = "Severity")]
    pub severity: String,
}

impl crate::FlatSerialize for ReportItemIssuesIssue {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.metric_id,
            &format!("{}.MetricId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.metric_category,
            &format!("{}.MetricCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.issue_id, &format!("{}.IssueId", name), params);
        crate::FlatSerialize::flat_serialize(&self.severity, &format!("{}.Severity", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReportItemIssues {
    #[serde(rename = "Issue")]
    pub issue: Vec<ReportItemIssuesIssue>,
}

impl crate::FlatSerialize for ReportItemIssues {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.issue, &format!("{}.Issue", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ReportsReport {
    #[serde(rename = "ResourceId")]
    pub resource_id: String,
    #[serde(rename = "ResourceType")]
    pub resource_type: String,
    #[serde(rename = "MetricSetId")]
    pub metric_set_id: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "EndTime")]
    pub end_time: String,
    #[serde(rename = "ReportId")]
    pub report_id: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "FinishedTime")]
    pub finished_time: String,
    #[serde(rename = "Severity")]
    pub severity: String,
    #[serde(rename = "Issues")]
    pub issues: ReportItemIssues,
}

impl crate::FlatSerialize for ReportsReport {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.resource_id,
            &format!("{}.ResourceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_type,
            &format!("{}.ResourceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.metric_set_id,
            &format!("{}.MetricSetId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.end_time, &format!("{}.EndTime", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.report_id,
            &format!("{}.ReportId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.finished_time,
            &format!("{}.FinishedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.severity, &format!("{}.Severity", name), params);
        crate::FlatSerialize::flat_serialize(&self.issues, &format!("{}.Issues", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseReports {
    #[serde(rename = "Report")]
    pub report: Vec<ReportsReport>,
}

impl crate::FlatSerialize for ResponseReports {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.report, &format!("{}.Report", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResultItemIssuesIssue {
    #[serde(rename = "IssueId")]
    pub issue_id: String,
    #[serde(rename = "Severity")]
    pub severity: String,
    #[serde(rename = "Additional")]
    pub additional: String,
    #[serde(rename = "OccurrenceTime")]
    pub occurrence_time: String,
}

impl crate::FlatSerialize for ResultItemIssuesIssue {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.issue_id, &format!("{}.IssueId", name), params);
        crate::FlatSerialize::flat_serialize(&self.severity, &format!("{}.Severity", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.additional,
            &format!("{}.Additional", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.occurrence_time,
            &format!("{}.OccurrenceTime", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResultItemIssues {
    #[serde(rename = "Issue")]
    pub issue: Vec<ResultItemIssuesIssue>,
}

impl crate::FlatSerialize for ResultItemIssues {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.issue, &format!("{}.Issue", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct MetricResult {
    #[serde(rename = "MetricId")]
    pub metric_id: String,
    #[serde(rename = "MetricCategory")]
    pub metric_category: String,
    #[serde(rename = "Severity")]
    pub severity: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Issues")]
    pub issues: ResultItemIssues,
}

impl crate::FlatSerialize for MetricResult {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.metric_id,
            &format!("{}.MetricId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.metric_category,
            &format!("{}.MetricCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.severity, &format!("{}.Severity", name), params);
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.issues, &format!("{}.Issues", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct MetricResults {
    #[serde(rename = "MetricResult")]
    pub metric_result: Vec<MetricResult>,
}

impl crate::FlatSerialize for MetricResults {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.metric_result,
            &format!("{}.MetricResult", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskMonitorData {
    #[serde(rename = "BPSRead")]
    pub bps_read: i32,
    #[serde(rename = "IOPSRead")]
    pub iops_read: i32,
    #[serde(rename = "LatencyRead")]
    pub latency_read: i32,
    #[serde(rename = "BPSTotal")]
    pub bps_total: i32,
    #[serde(rename = "IOPSTotal")]
    pub iops_total: i32,
    #[serde(rename = "TimeStamp")]
    pub time_stamp: String,
    #[serde(rename = "LatencyWrite")]
    pub latency_write: i32,
    #[serde(rename = "IOPSWrite")]
    pub iops_write: i32,
    #[serde(rename = "DiskId")]
    pub disk_id: String,
    #[serde(rename = "BPSWrite")]
    pub bps_write: i32,
}

impl crate::FlatSerialize for DiskMonitorData {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.bps_read, &format!("{}.BPSRead", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.iops_read,
            &format!("{}.IOPSRead", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.latency_read,
            &format!("{}.LatencyRead", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bps_total,
            &format!("{}.BPSTotal", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.iops_total,
            &format!("{}.IOPSTotal", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.time_stamp,
            &format!("{}.TimeStamp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.latency_write,
            &format!("{}.LatencyWrite", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.iops_write,
            &format!("{}.IOPSWrite", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.disk_id, &format!("{}.DiskId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.bps_write,
            &format!("{}.BPSWrite", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DiskMonitorDataResponseMonitorData {
    #[serde(rename = "DiskMonitorData")]
    pub disk_monitor_data: Vec<DiskMonitorData>,
}

impl crate::FlatSerialize for DiskMonitorDataResponseMonitorData {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.disk_monitor_data,
            &format!("{}.DiskMonitorData", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceMonitorData {
    #[serde(rename = "CPUCreditBalance")]
    pub cpu_credit_balance: f32,
    #[serde(rename = "BPSRead")]
    pub bps_read: i32,
    #[serde(rename = "InternetTX")]
    pub internet_tx: i32,
    #[serde(rename = "CPU")]
    pub cpu: i32,
    #[serde(rename = "CPUCreditUsage")]
    pub cpu_credit_usage: f32,
    #[serde(rename = "IOPSWrite")]
    pub iops_write: i32,
    #[serde(rename = "IntranetTX")]
    pub intranet_tx: i32,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "BPSWrite")]
    pub bps_write: i32,
    #[serde(rename = "CPUNotpaidSurplusCreditUsage")]
    pub cpu_notpaid_surplus_credit_usage: f32,
    #[serde(rename = "CPUAdvanceCreditBalance")]
    pub cpu_advance_credit_balance: f32,
    #[serde(rename = "IOPSRead")]
    pub iops_read: i32,
    #[serde(rename = "InternetBandwidth")]
    pub internet_bandwidth: i32,
    #[serde(rename = "InternetRX")]
    pub internet_rx: i32,
    #[serde(rename = "TimeStamp")]
    pub time_stamp: String,
    #[serde(rename = "IntranetRX")]
    pub intranet_rx: i32,
    #[serde(rename = "IntranetBandwidth")]
    pub intranet_bandwidth: i32,
}

impl crate::FlatSerialize for InstanceMonitorData {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.cpu_credit_balance,
            &format!("{}.CPUCreditBalance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.bps_read, &format!("{}.BPSRead", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.internet_tx,
            &format!("{}.InternetTX", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.cpu, &format!("{}.CPU", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.cpu_credit_usage,
            &format!("{}.CPUCreditUsage", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.iops_write,
            &format!("{}.IOPSWrite", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.intranet_tx,
            &format!("{}.IntranetTX", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bps_write,
            &format!("{}.BPSWrite", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_notpaid_surplus_credit_usage,
            &format!("{}.CPUNotpaidSurplusCreditUsage", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_advance_credit_balance,
            &format!("{}.CPUAdvanceCreditBalance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.iops_read,
            &format!("{}.IOPSRead", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_bandwidth,
            &format!("{}.InternetBandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_rx,
            &format!("{}.InternetRX", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.time_stamp,
            &format!("{}.TimeStamp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.intranet_rx,
            &format!("{}.IntranetRX", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.intranet_bandwidth,
            &format!("{}.IntranetBandwidth", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InstanceMonitorDataResponseMonitorData {
    #[serde(rename = "InstanceMonitorData")]
    pub instance_monitor_data: Vec<InstanceMonitorData>,
}

impl crate::FlatSerialize for InstanceMonitorDataResponseMonitorData {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_monitor_data,
            &format!("{}.InstanceMonitorData", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct EniMonitorData {
    #[serde(rename = "PacketRx")]
    pub packet_rx: String,
    #[serde(rename = "TimeStamp")]
    pub time_stamp: String,
    #[serde(rename = "DropPacketRx")]
    pub drop_packet_rx: String,
    #[serde(rename = "EniId")]
    pub eni_id: String,
    #[serde(rename = "DropPacketTx")]
    pub drop_packet_tx: String,
    #[serde(rename = "PacketTx")]
    pub packet_tx: String,
    #[serde(rename = "IntranetTx")]
    pub intranet_tx: String,
    #[serde(rename = "IntranetRx")]
    pub intranet_rx: String,
}

impl crate::FlatSerialize for EniMonitorData {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.packet_rx,
            &format!("{}.PacketRx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.time_stamp,
            &format!("{}.TimeStamp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.drop_packet_rx,
            &format!("{}.DropPacketRx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.eni_id, &format!("{}.EniId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.drop_packet_tx,
            &format!("{}.DropPacketTx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.packet_tx,
            &format!("{}.PacketTx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.intranet_tx,
            &format!("{}.IntranetTx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.intranet_rx,
            &format!("{}.IntranetRx", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct EniMonitorDataResponseMonitorData {
    #[serde(rename = "EniMonitorData")]
    pub eni_monitor_data: Vec<EniMonitorData>,
}

impl crate::FlatSerialize for EniMonitorDataResponseMonitorData {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.eni_monitor_data,
            &format!("{}.EniMonitorData", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DataPoint {
    #[serde(rename = "Size")]
    pub size: i64,
    #[serde(rename = "TimeStamp")]
    pub time_stamp: String,
}

impl crate::FlatSerialize for DataPoint {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.size, &format!("{}.Size", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.time_stamp,
            &format!("{}.TimeStamp", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SnapshotMonitorDataResponseMonitorData {
    #[serde(rename = "DataPoint")]
    pub data_point: Vec<DataPoint>,
}

impl crate::FlatSerialize for SnapshotMonitorDataResponseMonitorData {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.data_point,
            &format!("{}.DataPoint", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct WindowsMaintenanceWindow {
    #[serde(rename = "EndTime")]
    pub end_time: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
}

impl crate::FlatSerialize for WindowsMaintenanceWindow {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.end_time, &format!("{}.EndTime", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct MaintenanceWindows {
    #[serde(rename = "MaintenanceWindow")]
    pub maintenance_window: Vec<WindowsMaintenanceWindow>,
}

impl crate::FlatSerialize for MaintenanceWindows {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.maintenance_window,
            &format!("{}.MaintenanceWindow", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SupportedValues {
    #[serde(rename = "SupportedValue")]
    pub supported_value: Vec<String>,
}

impl crate::FlatSerialize for SupportedValues {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_value,
            &format!("{}.SupportedValue", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct OnMaintenance {
    #[serde(rename = "DefaultValue")]
    pub default_value: String,
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "SupportedValues")]
    pub supported_values: SupportedValues,
}

impl crate::FlatSerialize for OnMaintenance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.default_value,
            &format!("{}.DefaultValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.supported_values,
            &format!("{}.SupportedValues", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct MaintenanceAttribute {
    #[serde(rename = "NotifyOnMaintenance")]
    pub notify_on_maintenance: bool,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "MaintenanceWindows")]
    pub maintenance_windows: MaintenanceWindows,
    #[serde(rename = "ActionOnMaintenance")]
    pub action_on_maintenance: OnMaintenance,
}

impl crate::FlatSerialize for MaintenanceAttribute {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.notify_on_maintenance,
            &format!("{}.NotifyOnMaintenance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.maintenance_windows,
            &format!("{}.MaintenanceWindows", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.action_on_maintenance,
            &format!("{}.ActionOnMaintenance", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct MaintenanceAttributes {
    #[serde(rename = "MaintenanceAttribute")]
    pub maintenance_attribute: Vec<MaintenanceAttribute>,
}

impl crate::FlatSerialize for MaintenanceAttributes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.maintenance_attribute,
            &format!("{}.MaintenanceAttribute", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributesMaintenanceWindow {
    #[serde(rename = "EndTime")]
    pub end_time: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
}

impl crate::FlatSerialize for AttributesMaintenanceWindow {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.end_time, &format!("{}.EndTime", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.start_time,
            &format!("{}.StartTime", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TagResourcesTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for TagResourcesTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ListTagResourcesTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ListTagResourcesTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TagFilter {
    #[serde(rename = "TagValues")]
    pub tag_values: Vec<String>,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for TagFilter {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_values,
            &format!("{}.TagValues", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TagResource {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "ResourceType")]
    pub resource_type: String,
    #[serde(rename = "ResourceId")]
    pub resource_id: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for TagResource {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_type,
            &format!("{}.ResourceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_id,
            &format!("{}.ResourceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseTagResources {
    #[serde(rename = "TagResource")]
    pub tag_resource: Vec<TagResource>,
}

impl crate::FlatSerialize for ResponseTagResources {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_resource,
            &format!("{}.TagResource", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AllocateDedicatedHostsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for AllocateDedicatedHostsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostIdSets {
    #[serde(rename = "DedicatedHostId")]
    pub dedicated_host_id: Vec<String>,
}

impl crate::FlatSerialize for HostIdSets {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_id,
            &format!("{}.DedicatedHostId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDedicatedHostsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for DescribeDedicatedHostsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemInstancesInstance {
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "SocketId")]
    pub socket_id: String,
    #[serde(rename = "InstanceOwnerId")]
    pub instance_owner_id: i64,
}

impl crate::FlatSerialize for ItemInstancesInstance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.socket_id,
            &format!("{}.SocketId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_owner_id,
            &format!("{}.InstanceOwnerId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemInstances {
    #[serde(rename = "Instance")]
    pub instance: Vec<ItemInstancesInstance>,
}

impl crate::FlatSerialize for ItemInstances {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.instance, &format!("{}.Instance", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostItemOperationLocksOperationLock {
    #[serde(rename = "LockReason")]
    pub lock_reason: String,
}

impl crate::FlatSerialize for HostItemOperationLocksOperationLock {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.lock_reason,
            &format!("{}.LockReason", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostItemOperationLocks {
    #[serde(rename = "OperationLock")]
    pub operation_lock: Vec<HostItemOperationLocksOperationLock>,
}

impl crate::FlatSerialize for HostItemOperationLocks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.operation_lock,
            &format!("{}.OperationLock", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for HostItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<HostItemTagsTag>,
}

impl crate::FlatSerialize for HostItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostItemSupportedInstanceTypeFamilies {
    #[serde(rename = "SupportedInstanceTypeFamily")]
    pub supported_instance_type_family: Vec<String>,
}

impl crate::FlatSerialize for HostItemSupportedInstanceTypeFamilies {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_instance_type_family,
            &format!("{}.SupportedInstanceTypeFamily", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CustomInstanceTypeFamilies {
    #[serde(rename = "SupportedCustomInstanceTypeFamily")]
    pub supported_custom_instance_type_family: Vec<String>,
}

impl crate::FlatSerialize for CustomInstanceTypeFamilies {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_custom_instance_type_family,
            &format!("{}.SupportedCustomInstanceTypeFamily", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostItemSupportedInstanceTypesList {
    #[serde(rename = "SupportedInstanceTypesList")]
    pub supported_instance_types_list: Vec<String>,
}

impl crate::FlatSerialize for HostItemSupportedInstanceTypesList {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_instance_types_list,
            &format!("{}.SupportedInstanceTypesList", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SocketCapacity {
    #[serde(rename = "SocketId")]
    pub socket_id: i32,
    #[serde(rename = "AvailableMemory")]
    pub available_memory: f32,
    #[serde(rename = "TotalMemory")]
    pub total_memory: f32,
    #[serde(rename = "AvailableVcpu")]
    pub available_vcpu: i32,
    #[serde(rename = "TotalVcpu")]
    pub total_vcpu: i32,
}

impl crate::FlatSerialize for SocketCapacity {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.socket_id,
            &format!("{}.SocketId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_memory,
            &format!("{}.AvailableMemory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_memory,
            &format!("{}.TotalMemory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_vcpu,
            &format!("{}.AvailableVcpu", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_vcpu,
            &format!("{}.TotalVcpu", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SocketCapacities {
    #[serde(rename = "SocketCapacity")]
    pub socket_capacity: Vec<SocketCapacity>,
}

impl crate::FlatSerialize for SocketCapacities {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.socket_capacity,
            &format!("{}.SocketCapacity", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemCapacityAvailableInstanceTypesAvailableInstanceType {
    #[serde(rename = "AvailableInstanceCapacity")]
    pub available_instance_capacity: i32,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
}

impl crate::FlatSerialize for ItemCapacityAvailableInstanceTypesAvailableInstanceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.available_instance_capacity,
            &format!("{}.AvailableInstanceCapacity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemCapacityAvailableInstanceTypes {
    #[serde(rename = "AvailableInstanceType")]
    pub available_instance_type: Vec<ItemCapacityAvailableInstanceTypesAvailableInstanceType>,
}

impl crate::FlatSerialize for ItemCapacityAvailableInstanceTypes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.available_instance_type,
            &format!("{}.AvailableInstanceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemCapacity {
    #[serde(rename = "AvailableMemory")]
    pub available_memory: f32,
    #[serde(rename = "LocalStorageCategory")]
    pub local_storage_category: String,
    #[serde(rename = "TotalMemory")]
    pub total_memory: f32,
    #[serde(rename = "TotalLocalStorage")]
    pub total_local_storage: i32,
    #[serde(rename = "TotalVcpus")]
    pub total_vcpus: i32,
    #[serde(rename = "TotalVgpus")]
    pub total_vgpus: i32,
    #[serde(rename = "AvailableLocalStorage")]
    pub available_local_storage: i32,
    #[serde(rename = "AvailableVcpus")]
    pub available_vcpus: i32,
    #[serde(rename = "AvailableVgpus")]
    pub available_vgpus: i32,
    #[serde(rename = "SocketCapacities")]
    pub socket_capacities: SocketCapacities,
    #[serde(rename = "AvailableInstanceTypes")]
    pub available_instance_types: ItemCapacityAvailableInstanceTypes,
}

impl crate::FlatSerialize for ItemCapacity {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.available_memory,
            &format!("{}.AvailableMemory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_storage_category,
            &format!("{}.LocalStorageCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_memory,
            &format!("{}.TotalMemory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_local_storage,
            &format!("{}.TotalLocalStorage", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_vcpus,
            &format!("{}.TotalVcpus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_vgpus,
            &format!("{}.TotalVgpus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_local_storage,
            &format!("{}.AvailableLocalStorage", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_vcpus,
            &format!("{}.AvailableVcpus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_vgpus,
            &format!("{}.AvailableVgpus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.socket_capacities,
            &format!("{}.SocketCapacities", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_instance_types,
            &format!("{}.AvailableInstanceTypes", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct NetworkAttributes {
    #[serde(rename = "UdpTimeout")]
    pub udp_timeout: i32,
    #[serde(rename = "SlbUdpTimeout")]
    pub slb_udp_timeout: i32,
}

impl crate::FlatSerialize for NetworkAttributes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.udp_timeout,
            &format!("{}.UdpTimeout", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.slb_udp_timeout,
            &format!("{}.SlbUdpTimeout", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostDetailInfo {
    #[serde(rename = "SerialNumber")]
    pub serial_number: String,
}

impl crate::FlatSerialize for HostDetailInfo {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.serial_number,
            &format!("{}.SerialNumber", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DedicatedHost {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "SchedulerOptions.ManagedPrivateSpaceId")]
    pub scheduler_options_managed_private_space_id: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Cores")]
    pub cores: i32,
    #[serde(rename = "AutoPlacement")]
    pub auto_placement: String,
    #[serde(rename = "GPUSpec")]
    pub gpu_spec: String,
    #[serde(rename = "AutoReleaseTime")]
    pub auto_release_time: String,
    #[serde(rename = "ChargeType")]
    pub charge_type: String,
    #[serde(rename = "CpuOverCommitRatio")]
    pub cpu_over_commit_ratio: f32,
    #[serde(rename = "ActionOnMaintenance")]
    pub action_on_maintenance: String,
    #[serde(rename = "SaleCycle")]
    pub sale_cycle: String,
    #[serde(rename = "PhysicalGpus")]
    pub physical_gpus: i32,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "DedicatedHostName")]
    pub dedicated_host_name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "DedicatedHostClusterId")]
    pub dedicated_host_cluster_id: String,
    #[serde(rename = "ExpiredTime")]
    pub expired_time: String,
    #[serde(rename = "DedicatedHostType")]
    pub dedicated_host_type: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "DedicatedHostId")]
    pub dedicated_host_id: String,
    #[serde(rename = "Sockets")]
    pub sockets: i32,
    #[serde(rename = "MachineId")]
    pub machine_id: String,
    #[serde(rename = "Instances")]
    pub instances: ItemInstances,
    #[serde(rename = "OperationLocks")]
    pub operation_locks: HostItemOperationLocks,
    #[serde(rename = "Tags")]
    pub tags: HostItemTags,
    #[serde(rename = "SupportedInstanceTypeFamilies")]
    pub supported_instance_type_families: HostItemSupportedInstanceTypeFamilies,
    #[serde(rename = "SupportedCustomInstanceTypeFamilies")]
    pub supported_custom_instance_type_families: CustomInstanceTypeFamilies,
    #[serde(rename = "SupportedInstanceTypesList")]
    pub supported_instance_types_list: HostItemSupportedInstanceTypesList,
    #[serde(rename = "Capacity")]
    pub capacity: ItemCapacity,
    #[serde(rename = "NetworkAttributes")]
    pub network_attributes: NetworkAttributes,
    #[serde(rename = "HostDetailInfo")]
    pub host_detail_info: HostDetailInfo,
    #[serde(rename = "DedicatedHostOwnerId")]
    pub dedicated_host_owner_id: i64,
}

impl crate::FlatSerialize for DedicatedHost {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.scheduler_options_managed_private_space_id,
            &format!("{}.SchedulerOptions.ManagedPrivateSpaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.cores, &format!("{}.Cores", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.auto_placement,
            &format!("{}.AutoPlacement", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.gpu_spec, &format!("{}.GPUSpec", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.auto_release_time,
            &format!("{}.AutoReleaseTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.charge_type,
            &format!("{}.ChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_over_commit_ratio,
            &format!("{}.CpuOverCommitRatio", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.action_on_maintenance,
            &format!("{}.ActionOnMaintenance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.sale_cycle,
            &format!("{}.SaleCycle", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.physical_gpus,
            &format!("{}.PhysicalGpus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_name,
            &format!("{}.DedicatedHostName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_cluster_id,
            &format!("{}.DedicatedHostClusterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.expired_time,
            &format!("{}.ExpiredTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_type,
            &format!("{}.DedicatedHostType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_id,
            &format!("{}.DedicatedHostId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.sockets, &format!("{}.Sockets", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.machine_id,
            &format!("{}.MachineId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instances,
            &format!("{}.Instances", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.operation_locks,
            &format!("{}.OperationLocks", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.supported_instance_type_families,
            &format!("{}.SupportedInstanceTypeFamilies", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.supported_custom_instance_type_families,
            &format!("{}.SupportedCustomInstanceTypeFamilies", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.supported_instance_types_list,
            &format!("{}.SupportedInstanceTypesList", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.capacity, &format!("{}.Capacity", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.network_attributes,
            &format!("{}.NetworkAttributes", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.host_detail_info,
            &format!("{}.HostDetailInfo", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_owner_id,
            &format!("{}.DedicatedHostOwnerId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DedicatedHosts {
    #[serde(rename = "DedicatedHost")]
    pub dedicated_host: Vec<DedicatedHost>,
}

impl crate::FlatSerialize for DedicatedHosts {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host,
            &format!("{}.DedicatedHost", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TypeItemSupportedInstanceTypeFamilies {
    #[serde(rename = "SupportedInstanceTypeFamily")]
    pub supported_instance_type_family: Vec<String>,
}

impl crate::FlatSerialize for TypeItemSupportedInstanceTypeFamilies {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_instance_type_family,
            &format!("{}.SupportedInstanceTypeFamily", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TypeItemSupportedInstanceTypesList {
    #[serde(rename = "SupportedInstanceTypesList")]
    pub supported_instance_types_list: Vec<String>,
}

impl crate::FlatSerialize for TypeItemSupportedInstanceTypesList {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.supported_instance_types_list,
            &format!("{}.SupportedInstanceTypesList", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostType {
    #[serde(rename = "Cores")]
    pub cores: i32,
    #[serde(rename = "LocalStorageCategory")]
    pub local_storage_category: String,
    #[serde(rename = "GPUSpec")]
    pub gpu_spec: String,
    #[serde(rename = "TotalVcpus")]
    pub total_vcpus: i32,
    #[serde(rename = "CpuOverCommitRatioRange")]
    pub cpu_over_commit_ratio_range: String,
    #[serde(rename = "PhysicalGpus")]
    pub physical_gpus: i32,
    #[serde(rename = "MemorySize")]
    pub memory_size: f32,
    #[serde(rename = "SupportCpuOverCommitRatio")]
    pub support_cpu_over_commit_ratio: bool,
    #[serde(rename = "LocalStorageCapacity")]
    pub local_storage_capacity: i64,
    #[serde(rename = "DedicatedHostType")]
    pub dedicated_host_type: String,
    #[serde(rename = "LocalStorageAmount")]
    pub local_storage_amount: i32,
    #[serde(rename = "TotalVgpus")]
    pub total_vgpus: i32,
    #[serde(rename = "Sockets")]
    pub sockets: i32,
    #[serde(rename = "SupportedInstanceTypeFamilies")]
    pub supported_instance_type_families: TypeItemSupportedInstanceTypeFamilies,
    #[serde(rename = "SupportedInstanceTypesList")]
    pub supported_instance_types_list: TypeItemSupportedInstanceTypesList,
}

impl crate::FlatSerialize for HostType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.cores, &format!("{}.Cores", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.local_storage_category,
            &format!("{}.LocalStorageCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.gpu_spec, &format!("{}.GPUSpec", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.total_vcpus,
            &format!("{}.TotalVcpus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cpu_over_commit_ratio_range,
            &format!("{}.CpuOverCommitRatioRange", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.physical_gpus,
            &format!("{}.PhysicalGpus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.memory_size,
            &format!("{}.MemorySize", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.support_cpu_over_commit_ratio,
            &format!("{}.SupportCpuOverCommitRatio", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_storage_capacity,
            &format!("{}.LocalStorageCapacity", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_type,
            &format!("{}.DedicatedHostType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_storage_amount,
            &format!("{}.LocalStorageAmount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_vgpus,
            &format!("{}.TotalVgpus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.sockets, &format!("{}.Sockets", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.supported_instance_type_families,
            &format!("{}.SupportedInstanceTypeFamilies", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.supported_instance_types_list,
            &format!("{}.SupportedInstanceTypesList", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseDedicatedHostTypes {
    #[serde(rename = "DedicatedHostType")]
    pub dedicated_host_type: Vec<HostType>,
}

impl crate::FlatSerialize for ResponseDedicatedHostTypes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_type,
            &format!("{}.DedicatedHostType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostsChargeTypeResponseFeeOfInstancesFeeOfInstance {
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Currency")]
    pub currency: String,
    #[serde(rename = "Fee")]
    pub fee: String,
}

impl crate::FlatSerialize for HostsChargeTypeResponseFeeOfInstancesFeeOfInstance {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.currency, &format!("{}.Currency", name), params);
        crate::FlatSerialize::flat_serialize(&self.fee, &format!("{}.Fee", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostsChargeTypeResponseFeeOfInstances {
    #[serde(rename = "FeeOfInstance")]
    pub fee_of_instance: Vec<HostsChargeTypeResponseFeeOfInstancesFeeOfInstance>,
}

impl crate::FlatSerialize for HostsChargeTypeResponseFeeOfInstances {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.fee_of_instance,
            &format!("{}.FeeOfInstance", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostRenewAttribute {
    #[serde(rename = "PeriodUnit")]
    pub period_unit: String,
    #[serde(rename = "Duration")]
    pub duration: i32,
    #[serde(rename = "DedicatedHostId")]
    pub dedicated_host_id: String,
    #[serde(rename = "RenewalStatus")]
    pub renewal_status: String,
    #[serde(rename = "AutoRenewEnabled")]
    pub auto_renew_enabled: bool,
    #[serde(rename = "AutoRenewWithEcs")]
    pub auto_renew_with_ecs: String,
}

impl crate::FlatSerialize for HostRenewAttribute {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.period_unit,
            &format!("{}.PeriodUnit", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.duration, &format!("{}.Duration", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_id,
            &format!("{}.DedicatedHostId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.renewal_status,
            &format!("{}.RenewalStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_renew_enabled,
            &format!("{}.AutoRenewEnabled", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.auto_renew_with_ecs,
            &format!("{}.AutoRenewWithEcs", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostRenewAttributes {
    #[serde(rename = "DedicatedHostRenewAttribute")]
    pub dedicated_host_renew_attribute: Vec<HostRenewAttribute>,
}

impl crate::FlatSerialize for HostRenewAttributes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_renew_attribute,
            &format!("{}.DedicatedHostRenewAttribute", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ClusterTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ClusterTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ClustersTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize for ClustersTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ClusterItemTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
}

impl crate::FlatSerialize for ClusterItemTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ClusterItemTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<ClusterItemTagsTag>,
}

impl crate::FlatSerialize for ClusterItemTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostIds {
    #[serde(rename = "DedicatedHostId")]
    pub dedicated_host_id: Vec<String>,
}

impl crate::FlatSerialize for HostIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_id,
            &format!("{}.DedicatedHostId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct StorageCapacity {
    #[serde(rename = "DataDiskCategory")]
    pub data_disk_category: String,
    #[serde(rename = "AvailableDisk")]
    pub available_disk: i32,
    #[serde(rename = "TotalDisk")]
    pub total_disk: i32,
}

impl crate::FlatSerialize for StorageCapacity {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.data_disk_category,
            &format!("{}.DataDiskCategory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_disk,
            &format!("{}.AvailableDisk", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_disk,
            &format!("{}.TotalDisk", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct StorageCapacities {
    #[serde(rename = "LocalStorageCapacity")]
    pub local_storage_capacity: Vec<StorageCapacity>,
}

impl crate::FlatSerialize for StorageCapacities {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.local_storage_capacity,
            &format!("{}.LocalStorageCapacity", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ClusterCapacityAvailableInstanceTypesAvailableInstanceType {
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "AvailableInstanceCapacity")]
    pub available_instance_capacity: i32,
}

impl crate::FlatSerialize for ClusterCapacityAvailableInstanceTypesAvailableInstanceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_instance_capacity,
            &format!("{}.AvailableInstanceCapacity", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ClusterCapacityAvailableInstanceTypes {
    #[serde(rename = "AvailableInstanceType")]
    pub available_instance_type: Vec<ClusterCapacityAvailableInstanceTypesAvailableInstanceType>,
}

impl crate::FlatSerialize for ClusterCapacityAvailableInstanceTypes {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.available_instance_type,
            &format!("{}.AvailableInstanceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ClusterCapacity {
    #[serde(rename = "AvailableVcpus")]
    pub available_vcpus: i32,
    #[serde(rename = "AvailableMemory")]
    pub available_memory: i32,
    #[serde(rename = "TotalMemory")]
    pub total_memory: i32,
    #[serde(rename = "TotalVcpus")]
    pub total_vcpus: i32,
    #[serde(rename = "LocalStorageCapacities")]
    pub local_storage_capacities: StorageCapacities,
    #[serde(rename = "AvailableInstanceTypes")]
    pub available_instance_types: ClusterCapacityAvailableInstanceTypes,
}

impl crate::FlatSerialize for ClusterCapacity {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.available_vcpus,
            &format!("{}.AvailableVcpus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_memory,
            &format!("{}.AvailableMemory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_memory,
            &format!("{}.TotalMemory", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.total_vcpus,
            &format!("{}.TotalVcpus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_storage_capacities,
            &format!("{}.LocalStorageCapacities", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_instance_types,
            &format!("{}.AvailableInstanceTypes", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostCluster {
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "DedicatedHostClusterId")]
    pub dedicated_host_cluster_id: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "DedicatedHostClusterName")]
    pub dedicated_host_cluster_name: String,
    #[serde(rename = "Tags")]
    pub tags: ClusterItemTags,
    #[serde(rename = "DedicatedHostIds")]
    pub dedicated_host_ids: HostIds,
    #[serde(rename = "DedicatedHostClusterCapacity")]
    pub dedicated_host_cluster_capacity: ClusterCapacity,
}

impl crate::FlatSerialize for HostCluster {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_cluster_id,
            &format!("{}.DedicatedHostClusterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_cluster_name,
            &format!("{}.DedicatedHostClusterName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tags, &format!("{}.Tags", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_ids,
            &format!("{}.DedicatedHostIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_cluster_capacity,
            &format!("{}.DedicatedHostClusterCapacity", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HostClusters {
    #[serde(rename = "DedicatedHostCluster")]
    pub dedicated_host_cluster: Vec<HostCluster>,
}

impl crate::FlatSerialize for HostClusters {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.dedicated_host_cluster,
            &format!("{}.DedicatedHostCluster", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HpcCluster {
    #[serde(rename = "HpcClusterId")]
    pub hpc_cluster_id: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Description")]
    pub description: String,
}

impl crate::FlatSerialize for HpcCluster {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.hpc_cluster_id,
            &format!("{}.HpcClusterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HpcClusters {
    #[serde(rename = "HpcCluster")]
    pub hpc_cluster: Vec<HpcCluster>,
}

impl crate::FlatSerialize for HpcClusters {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.hpc_cluster,
            &format!("{}.HpcCluster", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetTask {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "TaskStatus")]
    pub task_status: String,
    #[serde(rename = "FinishedTime")]
    pub finished_time: String,
    #[serde(rename = "SupportCancel")]
    pub support_cancel: String,
    #[serde(rename = "TaskId")]
    pub task_id: String,
    #[serde(rename = "TaskAction")]
    pub task_action: String,
    #[serde(rename = "ResourceId")]
    pub resource_id: String,
}

impl crate::FlatSerialize for SetTask {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.task_status,
            &format!("{}.TaskStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.finished_time,
            &format!("{}.FinishedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.support_cancel,
            &format!("{}.SupportCancel", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.task_id, &format!("{}.TaskId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.task_action,
            &format!("{}.TaskAction", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_id,
            &format!("{}.ResourceId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TaskSet {
    #[serde(rename = "Task")]
    pub task: Vec<SetTask>,
}

impl crate::FlatSerialize for TaskSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.task, &format!("{}.Task", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseOperationProgressSetOperationProgressItemRelatedItemSetRelatedItem {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Value")]
    pub value: String,
}

impl crate::FlatSerialize
    for AttributeResponseOperationProgressSetOperationProgressItemRelatedItemSetRelatedItem
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseOperationProgressSetOperationProgressItemRelatedItemSet {
    #[serde(rename = "RelatedItem")]
    pub related_item:
        Vec<AttributeResponseOperationProgressSetOperationProgressItemRelatedItemSetRelatedItem>,
}

impl crate::FlatSerialize
    for AttributeResponseOperationProgressSetOperationProgressItemRelatedItemSet
{
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.related_item,
            &format!("{}.RelatedItem", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseOperationProgressSetOperationProgress {
    #[serde(rename = "ErrorMsg")]
    pub error_msg: String,
    #[serde(rename = "ErrorCode")]
    pub error_code: String,
    #[serde(rename = "OperationStatus")]
    pub operation_status: String,
    #[serde(rename = "RelatedItemSet")]
    pub related_item_set: AttributeResponseOperationProgressSetOperationProgressItemRelatedItemSet,
}

impl crate::FlatSerialize for AttributeResponseOperationProgressSetOperationProgress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.error_msg,
            &format!("{}.ErrorMsg", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.error_code,
            &format!("{}.ErrorCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.operation_status,
            &format!("{}.OperationStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.related_item_set,
            &format!("{}.RelatedItemSet", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AttributeResponseOperationProgressSet {
    #[serde(rename = "OperationProgress")]
    pub operation_progress: Vec<AttributeResponseOperationProgressSetOperationProgress>,
}

impl crate::FlatSerialize for AttributeResponseOperationProgressSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.operation_progress,
            &format!("{}.OperationProgress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ClustersCluster {
    #[serde(rename = "ClusterId")]
    pub cluster_id: String,
}

impl crate::FlatSerialize for ClustersCluster {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.cluster_id,
            &format!("{}.ClusterId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseClusters {
    #[serde(rename = "Cluster")]
    pub cluster: Vec<ClustersCluster>,
}

impl crate::FlatSerialize for ResponseClusters {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.cluster, &format!("{}.Cluster", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct IpAddresse {
    #[serde(rename = "IpAddress")]
    pub ip_address: String,
    #[serde(rename = "AllocationId")]
    pub allocation_id: String,
}

impl crate::FlatSerialize for IpAddresse {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocation_id,
            &format!("{}.AllocationId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct IpAddresses {
    #[serde(rename = "PublicIpAddresse")]
    pub public_ip_addresse: Vec<IpAddresse>,
}

impl crate::FlatSerialize for IpAddresses {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.public_ip_addresse,
            &format!("{}.PublicIpAddresse", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PackagesBandwidthPackage {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "IpCount")]
    pub ip_count: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "InstanceChargeType")]
    pub instance_charge_type: String,
    #[serde(rename = "BandwidthPackageId")]
    pub bandwidth_package_id: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Bandwidth")]
    pub bandwidth: String,
    #[serde(rename = "NatGatewayId")]
    pub nat_gateway_id: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "InternetChargeType")]
    pub internet_charge_type: String,
    #[serde(rename = "BusinessStatus")]
    pub business_status: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "ISP")]
    pub isp: String,
    #[serde(rename = "PublicIpAddresses")]
    pub public_ip_addresses: IpAddresses,
}

impl crate::FlatSerialize for PackagesBandwidthPackage {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.ip_count, &format!("{}.IpCount", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_charge_type,
            &format!("{}.InstanceChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_package_id,
            &format!("{}.BandwidthPackageId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth,
            &format!("{}.Bandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.nat_gateway_id,
            &format!("{}.NatGatewayId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.internet_charge_type,
            &format!("{}.InternetChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.business_status,
            &format!("{}.BusinessStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(&self.isp, &format!("{}.ISP", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.public_ip_addresses,
            &format!("{}.PublicIpAddresses", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct BandwidthPackages {
    #[serde(rename = "BandwidthPackage")]
    pub bandwidth_package: Vec<PackagesBandwidthPackage>,
}

impl crate::FlatSerialize for BandwidthPackages {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_package,
            &format!("{}.BandwidthPackage", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VSwitch {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "IsDefault")]
    pub is_default: bool,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "CidrBlock")]
    pub cidr_block: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "AvailableIpAddressCount")]
    pub available_ip_address_count: i64,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "VSwitchName")]
    pub v_switch_name: String,
}

impl crate::FlatSerialize for VSwitch {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.vpc_id, &format!("{}.VpcId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.is_default,
            &format!("{}.IsDefault", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cidr_block,
            &format!("{}.CidrBlock", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.available_ip_address_count,
            &format!("{}.AvailableIpAddressCount", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone_id, &format!("{}.ZoneId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_name,
            &format!("{}.VSwitchName", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VSwitches {
    #[serde(rename = "VSwitch")]
    pub v_switch: Vec<VSwitch>,
}

impl crate::FlatSerialize for VSwitches {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.v_switch, &format!("{}.VSwitch", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConnectionsFilter {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: Vec<String>,
}

impl crate::FlatSerialize for ConnectionsFilter {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SetPhysicalConnectionType {
    #[serde(rename = "AdLocation")]
    pub ad_location: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "PortNumber")]
    pub port_number: String,
    #[serde(rename = "CircuitCode")]
    pub circuit_code: String,
    #[serde(rename = "Spec")]
    pub spec: String,
    #[serde(rename = "Bandwidth")]
    pub bandwidth: i64,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "PortType")]
    pub port_type: String,
    #[serde(rename = "EnabledTime")]
    pub enabled_time: String,
    #[serde(rename = "BusinessStatus")]
    pub business_status: String,
    #[serde(rename = "LineOperator")]
    pub line_operator: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "RedundantPhysicalConnectionId")]
    pub redundant_physical_connection_id: String,
    #[serde(rename = "PeerLocation")]
    pub peer_location: String,
    #[serde(rename = "AccessPointId")]
    pub access_point_id: String,
    #[serde(rename = "PhysicalConnectionId")]
    pub physical_connection_id: String,
}

impl crate::FlatSerialize for SetPhysicalConnectionType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.ad_location,
            &format!("{}.AdLocation", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.port_number,
            &format!("{}.PortNumber", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.circuit_code,
            &format!("{}.CircuitCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.spec, &format!("{}.Spec", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth,
            &format!("{}.Bandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.port_type,
            &format!("{}.PortType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.enabled_time,
            &format!("{}.EnabledTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.business_status,
            &format!("{}.BusinessStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.line_operator,
            &format!("{}.LineOperator", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.redundant_physical_connection_id,
            &format!("{}.RedundantPhysicalConnectionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.peer_location,
            &format!("{}.PeerLocation", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.access_point_id,
            &format!("{}.AccessPointId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.physical_connection_id,
            &format!("{}.PhysicalConnectionId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponsePhysicalConnectionSet {
    #[serde(rename = "PhysicalConnectionType")]
    pub physical_connection_type: Vec<SetPhysicalConnectionType>,
}

impl crate::FlatSerialize for ResponsePhysicalConnectionSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.physical_connection_type,
            &format!("{}.PhysicalConnectionType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SwitchIds {
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: Vec<String>,
}

impl crate::FlatSerialize for SwitchIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct UserCidrs {
    #[serde(rename = "UserCidr")]
    pub user_cidr: Vec<String>,
}

impl crate::FlatSerialize for UserCidrs {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.user_cidr,
            &format!("{}.UserCidr", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VpcsVpc {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "VpcName")]
    pub vpc_name: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "VRouterId")]
    pub v_router_id: String,
    #[serde(rename = "IsDefault")]
    pub is_default: bool,
    #[serde(rename = "CidrBlock")]
    pub cidr_block: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "VSwitchIds")]
    pub v_switch_ids: SwitchIds,
    #[serde(rename = "UserCidrs")]
    pub user_cidrs: UserCidrs,
}

impl crate::FlatSerialize for VpcsVpc {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.vpc_name, &format!("{}.VpcName", name), params);
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.vpc_id, &format!("{}.VpcId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.v_router_id,
            &format!("{}.VRouterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.is_default,
            &format!("{}.IsDefault", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.cidr_block,
            &format!("{}.CidrBlock", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_ids,
            &format!("{}.VSwitchIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.user_cidrs,
            &format!("{}.UserCidrs", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseVpcs {
    #[serde(rename = "Vpc")]
    pub vpc: Vec<VpcsVpc>,
}

impl crate::FlatSerialize for ResponseVpcs {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.vpc, &format!("{}.Vpc", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VipsFilter {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: Vec<String>,
}

impl crate::FlatSerialize for VipsFilter {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssociatedEipAddresses {
    #[serde(rename = "associatedEipAddresse")]
    pub associated_eip_addresse: Vec<String>,
}

impl crate::FlatSerialize for AssociatedEipAddresses {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.associated_eip_addresse,
            &format!("{}.associatedEipAddresse", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AssociatedInstances {
    #[serde(rename = "associatedInstance")]
    pub associated_instance: Vec<String>,
}

impl crate::FlatSerialize for AssociatedInstances {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.associated_instance,
            &format!("{}.associatedInstance", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HaVip {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "IpAddress")]
    pub ip_address: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "HaVipId")]
    pub ha_vip_id: String,
    #[serde(rename = "CreateTime")]
    pub create_time: String,
    #[serde(rename = "MasterInstanceId")]
    pub master_instance_id: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "AssociatedEipAddresses")]
    pub associated_eip_addresses: AssociatedEipAddresses,
    #[serde(rename = "AssociatedInstances")]
    pub associated_instances: AssociatedInstances,
}

impl crate::FlatSerialize for HaVip {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.vpc_id, &format!("{}.VpcId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.v_switch_id,
            &format!("{}.VSwitchId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.ha_vip_id, &format!("{}.HaVipId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.create_time,
            &format!("{}.CreateTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.master_instance_id,
            &format!("{}.MasterInstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.associated_eip_addresses,
            &format!("{}.AssociatedEipAddresses", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.associated_instances,
            &format!("{}.AssociatedInstances", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct HaVips {
    #[serde(rename = "HaVip")]
    pub ha_vip: Vec<HaVip>,
}

impl crate::FlatSerialize for HaVips {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.ha_vip, &format!("{}.HaVip", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RoutersFilter {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: Vec<String>,
}

impl crate::FlatSerialize for RoutersFilter {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RouterType {
    #[serde(rename = "VlanInterfaceId")]
    pub vlan_interface_id: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "CircuitCode")]
    pub circuit_code: String,
    #[serde(rename = "PhysicalConnectionOwnerUid")]
    pub physical_connection_owner_uid: String,
    #[serde(rename = "LocalGatewayIp")]
    pub local_gateway_ip: String,
    #[serde(rename = "ActivationTime")]
    pub activation_time: String,
    #[serde(rename = "PhysicalConnectionBusinessStatus")]
    pub physical_connection_business_status: String,
    #[serde(rename = "PeeringSubnetMask")]
    pub peering_subnet_mask: String,
    #[serde(rename = "RouteTableId")]
    pub route_table_id: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "PhysicalConnectionStatus")]
    pub physical_connection_status: String,
    #[serde(rename = "RecoveryTime")]
    pub recovery_time: String,
    #[serde(rename = "TerminationTime")]
    pub termination_time: String,
    #[serde(rename = "PeerGatewayIp")]
    pub peer_gateway_ip: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "AccessPointId")]
    pub access_point_id: String,
    #[serde(rename = "VbrId")]
    pub vbr_id: String,
    #[serde(rename = "PhysicalConnectionId")]
    pub physical_connection_id: String,
    #[serde(rename = "VlanId")]
    pub vlan_id: i32,
}

impl crate::FlatSerialize for RouterType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.vlan_interface_id,
            &format!("{}.VlanInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.circuit_code,
            &format!("{}.CircuitCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.physical_connection_owner_uid,
            &format!("{}.PhysicalConnectionOwnerUid", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.local_gateway_ip,
            &format!("{}.LocalGatewayIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.activation_time,
            &format!("{}.ActivationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.physical_connection_business_status,
            &format!("{}.PhysicalConnectionBusinessStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.peering_subnet_mask,
            &format!("{}.PeeringSubnetMask", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.route_table_id,
            &format!("{}.RouteTableId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.physical_connection_status,
            &format!("{}.PhysicalConnectionStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.recovery_time,
            &format!("{}.RecoveryTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.termination_time,
            &format!("{}.TerminationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.peer_gateway_ip,
            &format!("{}.PeerGatewayIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.access_point_id,
            &format!("{}.AccessPointId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.vbr_id, &format!("{}.VbrId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.physical_connection_id,
            &format!("{}.PhysicalConnectionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.vlan_id, &format!("{}.VlanId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RouterSet {
    #[serde(rename = "VirtualBorderRouterType")]
    pub virtual_border_router_type: Vec<RouterType>,
}

impl crate::FlatSerialize for RouterSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.virtual_border_router_type,
            &format!("{}.VirtualBorderRouterType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ConnectionFilter {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: Vec<String>,
}

impl crate::FlatSerialize for ConnectionFilter {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ForPhysicalConnectionType {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "CircuitCode")]
    pub circuit_code: String,
    #[serde(rename = "RecoveryTime")]
    pub recovery_time: String,
    #[serde(rename = "TerminationTime")]
    pub termination_time: String,
    #[serde(rename = "ActivationTime")]
    pub activation_time: String,
    #[serde(rename = "VbrOwnerUid")]
    pub vbr_owner_uid: i64,
    #[serde(rename = "VbrId")]
    pub vbr_id: String,
    #[serde(rename = "VlanId")]
    pub vlan_id: i32,
}

impl crate::FlatSerialize for ForPhysicalConnectionType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.circuit_code,
            &format!("{}.CircuitCode", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.recovery_time,
            &format!("{}.RecoveryTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.termination_time,
            &format!("{}.TerminationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.activation_time,
            &format!("{}.ActivationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.vbr_owner_uid,
            &format!("{}.VbrOwnerUid", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.vbr_id, &format!("{}.VbrId", name), params);
        crate::FlatSerialize::flat_serialize(&self.vlan_id, &format!("{}.VlanId", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ForPhysicalConnectionSet {
    #[serde(rename = "VirtualBorderRouterForPhysicalConnectionType")]
    pub virtual_border_router_for_physical_connection_type: Vec<ForPhysicalConnectionType>,
}

impl crate::FlatSerialize for ForPhysicalConnectionSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.virtual_border_router_for_physical_connection_type,
            &format!("{}.VirtualBorderRouterForPhysicalConnectionType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfacesFilter {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: Vec<String>,
}

impl crate::FlatSerialize for InterfacesFilter {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct InterfaceType {
    #[serde(rename = "HealthCheckTargetIp")]
    pub health_check_target_ip: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Spec")]
    pub spec: String,
    #[serde(rename = "OppositeInterfaceId")]
    pub opposite_interface_id: String,
    #[serde(rename = "RouterInterfaceId")]
    pub router_interface_id: String,
    #[serde(rename = "ChargeType")]
    pub charge_type: String,
    #[serde(rename = "OppositeRouterType")]
    pub opposite_router_type: String,
    #[serde(rename = "OppositeInterfaceOwnerId")]
    pub opposite_interface_owner_id: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "OppositeRouterId")]
    pub opposite_router_id: String,
    #[serde(rename = "OppositeInterfaceSpec")]
    pub opposite_interface_spec: String,
    #[serde(rename = "RouterId")]
    pub router_id: String,
    #[serde(rename = "OppositeInterfaceBusinessStatus")]
    pub opposite_interface_business_status: String,
    #[serde(rename = "ConnectedTime")]
    pub connected_time: String,
    #[serde(rename = "OppositeInterfaceStatus")]
    pub opposite_interface_status: String,
    #[serde(rename = "HealthCheckSourceIp")]
    pub health_check_source_ip: String,
    #[serde(rename = "EndTime")]
    pub end_time: String,
    #[serde(rename = "OppositeRegionId")]
    pub opposite_region_id: String,
    #[serde(rename = "OppositeAccessPointId")]
    pub opposite_access_point_id: String,
    #[serde(rename = "BusinessStatus")]
    pub business_status: String,
    #[serde(rename = "Role")]
    pub role: String,
    #[serde(rename = "RouterType")]
    pub router_type: String,
    #[serde(rename = "AccessPointId")]
    pub access_point_id: String,
}

impl crate::FlatSerialize for InterfaceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.health_check_target_ip,
            &format!("{}.HealthCheckTargetIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.spec, &format!("{}.Spec", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.opposite_interface_id,
            &format!("{}.OppositeInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.router_interface_id,
            &format!("{}.RouterInterfaceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.charge_type,
            &format!("{}.ChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.opposite_router_type,
            &format!("{}.OppositeRouterType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.opposite_interface_owner_id,
            &format!("{}.OppositeInterfaceOwnerId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.opposite_router_id,
            &format!("{}.OppositeRouterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.opposite_interface_spec,
            &format!("{}.OppositeInterfaceSpec", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.router_id,
            &format!("{}.RouterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.opposite_interface_business_status,
            &format!("{}.OppositeInterfaceBusinessStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.connected_time,
            &format!("{}.ConnectedTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.opposite_interface_status,
            &format!("{}.OppositeInterfaceStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.health_check_source_ip,
            &format!("{}.HealthCheckSourceIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.end_time, &format!("{}.EndTime", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.opposite_region_id,
            &format!("{}.OppositeRegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.opposite_access_point_id,
            &format!("{}.OppositeAccessPointId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.business_status,
            &format!("{}.BusinessStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.role, &format!("{}.Role", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.router_type,
            &format!("{}.RouterType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.access_point_id,
            &format!("{}.AccessPointId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RouterInterfaceSet {
    #[serde(rename = "RouterInterfaceType")]
    pub router_interface_type: Vec<InterfaceType>,
}

impl crate::FlatSerialize for RouterInterfaceSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.router_interface_type,
            &format!("{}.RouterInterfaceType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AddressItemOperationLocksLockReason {
    #[serde(rename = "LockReason")]
    pub lock_reason: String,
}

impl crate::FlatSerialize for AddressItemOperationLocksLockReason {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.lock_reason,
            &format!("{}.LockReason", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AddressItemOperationLocks {
    #[serde(rename = "LockReason")]
    pub lock_reason: Vec<AddressItemOperationLocksLockReason>,
}

impl crate::FlatSerialize for AddressItemOperationLocks {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.lock_reason,
            &format!("{}.LockReason", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AddressesEipAddress {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "AllocationTime")]
    pub allocation_time: String,
    #[serde(rename = "ChargeType")]
    pub charge_type: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "IpAddress")]
    pub ip_address: String,
    #[serde(rename = "Bandwidth")]
    pub bandwidth: String,
    #[serde(rename = "ExpiredTime")]
    pub expired_time: String,
    #[serde(rename = "AllocationId")]
    pub allocation_id: String,
    #[serde(rename = "InternetChargeType")]
    pub internet_charge_type: String,
    #[serde(rename = "EipBandwidth")]
    pub eip_bandwidth: String,
    #[serde(rename = "OperationLocks")]
    pub operation_locks: AddressItemOperationLocks,
}

impl crate::FlatSerialize for AddressesEipAddress {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.allocation_time,
            &format!("{}.AllocationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.charge_type,
            &format!("{}.ChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_type,
            &format!("{}.InstanceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ip_address,
            &format!("{}.IpAddress", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth,
            &format!("{}.Bandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.expired_time,
            &format!("{}.ExpiredTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.allocation_id,
            &format!("{}.AllocationId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internet_charge_type,
            &format!("{}.InternetChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.eip_bandwidth,
            &format!("{}.EipBandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.operation_locks,
            &format!("{}.OperationLocks", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseEipAddresses {
    #[serde(rename = "EipAddress")]
    pub eip_address: Vec<AddressesEipAddress>,
}

impl crate::FlatSerialize for ResponseEipAddresses {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.eip_address,
            &format!("{}.EipAddress", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribeEipMonitorDataResponseEipMonitorDatasEipMonitorData {
    #[serde(rename = "EipTX")]
    pub eip_tx: i32,
    #[serde(rename = "EipPackets")]
    pub eip_packets: i32,
    #[serde(rename = "EipBandwidth")]
    pub eip_bandwidth: i32,
    #[serde(rename = "TimeStamp")]
    pub time_stamp: String,
    #[serde(rename = "EipFlow")]
    pub eip_flow: i32,
    #[serde(rename = "EipRX")]
    pub eip_rx: i32,
}

impl crate::FlatSerialize for DescribeEipMonitorDataResponseEipMonitorDatasEipMonitorData {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.eip_tx, &format!("{}.EipTX", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.eip_packets,
            &format!("{}.EipPackets", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.eip_bandwidth,
            &format!("{}.EipBandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.time_stamp,
            &format!("{}.TimeStamp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.eip_flow, &format!("{}.EipFlow", name), params);
        crate::FlatSerialize::flat_serialize(&self.eip_rx, &format!("{}.EipRX", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribeEipMonitorDataResponseEipMonitorDatas {
    #[serde(rename = "EipMonitorData")]
    pub eip_monitor_data: Vec<DescribeEipMonitorDataResponseEipMonitorDatasEipMonitorData>,
}

impl crate::FlatSerialize for DescribeEipMonitorDataResponseEipMonitorDatas {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.eip_monitor_data,
            &format!("{}.EipMonitorData", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct GatewayBandwidthPackage {
    #[serde(rename = "Bandwidth")]
    pub bandwidth: i32,
    #[serde(rename = "Zone")]
    pub zone: String,
    #[serde(rename = "IpCount")]
    pub ip_count: i32,
}

impl crate::FlatSerialize for GatewayBandwidthPackage {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth,
            &format!("{}.Bandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.zone, &format!("{}.Zone", name), params);
        crate::FlatSerialize::flat_serialize(&self.ip_count, &format!("{}.IpCount", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseForwardTableIds {
    #[serde(rename = "ForwardTableId")]
    pub forward_table_id: Vec<String>,
}

impl crate::FlatSerialize for ResponseForwardTableIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.forward_table_id,
            &format!("{}.ForwardTableId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseBandwidthPackageIds {
    #[serde(rename = "BandwidthPackageId")]
    pub bandwidth_package_id: Vec<String>,
}

impl crate::FlatSerialize for ResponseBandwidthPackageIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_package_id,
            &format!("{}.BandwidthPackageId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemForwardTableIds {
    #[serde(rename = "ForwardTableId")]
    pub forward_table_id: Vec<String>,
}

impl crate::FlatSerialize for ItemForwardTableIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.forward_table_id,
            &format!("{}.ForwardTableId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ItemBandwidthPackageIds {
    #[serde(rename = "BandwidthPackageId")]
    pub bandwidth_package_id: Vec<String>,
}

impl crate::FlatSerialize for ItemBandwidthPackageIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_package_id,
            &format!("{}.BandwidthPackageId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct NatGateway {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "Spec")]
    pub spec: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "NatGatewayId")]
    pub nat_gateway_id: String,
    #[serde(rename = "BusinessStatus")]
    pub business_status: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "InstanceChargeType")]
    pub instance_charge_type: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "ForwardTableIds")]
    pub forward_table_ids: ItemForwardTableIds,
    #[serde(rename = "BandwidthPackageIds")]
    pub bandwidth_package_ids: ItemBandwidthPackageIds,
}

impl crate::FlatSerialize for NatGateway {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.vpc_id, &format!("{}.VpcId", name), params);
        crate::FlatSerialize::flat_serialize(&self.spec, &format!("{}.Spec", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.nat_gateway_id,
            &format!("{}.NatGatewayId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.business_status,
            &format!("{}.BusinessStatus", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.instance_charge_type,
            &format!("{}.InstanceChargeType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.forward_table_ids,
            &format!("{}.ForwardTableIds", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_package_ids,
            &format!("{}.BandwidthPackageIds", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct NatGateways {
    #[serde(rename = "NatGateway")]
    pub nat_gateway: Vec<NatGateway>,
}

impl crate::FlatSerialize for NatGateways {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.nat_gateway,
            &format!("{}.NatGateway", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ProjectEipMonitorDataResponseEipMonitorDatasEipMonitorData {
    #[serde(rename = "EipTX")]
    pub eip_tx: i32,
    #[serde(rename = "EipPackets")]
    pub eip_packets: i32,
    #[serde(rename = "EipBandwidth")]
    pub eip_bandwidth: i32,
    #[serde(rename = "TimeStamp")]
    pub time_stamp: String,
    #[serde(rename = "EipFlow")]
    pub eip_flow: i32,
    #[serde(rename = "EipRX")]
    pub eip_rx: i32,
}

impl crate::FlatSerialize for ProjectEipMonitorDataResponseEipMonitorDatasEipMonitorData {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.eip_tx, &format!("{}.EipTX", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.eip_packets,
            &format!("{}.EipPackets", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.eip_bandwidth,
            &format!("{}.EipBandwidth", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.time_stamp,
            &format!("{}.TimeStamp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.eip_flow, &format!("{}.EipFlow", name), params);
        crate::FlatSerialize::flat_serialize(&self.eip_rx, &format!("{}.EipRX", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ProjectEipMonitorDataResponseEipMonitorDatas {
    #[serde(rename = "EipMonitorData")]
    pub eip_monitor_data: Vec<ProjectEipMonitorDataResponseEipMonitorDatasEipMonitorData>,
}

impl crate::FlatSerialize for ProjectEipMonitorDataResponseEipMonitorDatas {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.eip_monitor_data,
            &format!("{}.EipMonitorData", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DeleteRouteEntryNextHopList {
    #[serde(rename = "NextHopId")]
    pub next_hop_id: String,
    #[serde(rename = "NextHopType")]
    pub next_hop_type: String,
}

impl crate::FlatSerialize for DeleteRouteEntryNextHopList {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.next_hop_id,
            &format!("{}.NextHopId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.next_hop_type,
            &format!("{}.NextHopType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RouteTableIds {
    #[serde(rename = "RouteTableId")]
    pub route_table_id: Vec<String>,
}

impl crate::FlatSerialize for RouteTableIds {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.route_table_id,
            &format!("{}.RouteTableId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VRouter {
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "VRouterId")]
    pub v_router_id: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "VRouterName")]
    pub v_router_name: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "RouteTableIds")]
    pub route_table_ids: RouteTableIds,
}

impl crate::FlatSerialize for VRouter {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.vpc_id, &format!("{}.VpcId", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.v_router_id,
            &format!("{}.VRouterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.v_router_name,
            &format!("{}.VRouterName", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.route_table_ids,
            &format!("{}.RouteTableIds", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct VRouters {
    #[serde(rename = "VRouter")]
    pub v_router: Vec<VRouter>,
}

impl crate::FlatSerialize for VRouters {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.v_router, &format!("{}.VRouter", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct CreateRouteEntryNextHopList {
    #[serde(rename = "NextHopId")]
    pub next_hop_id: String,
    #[serde(rename = "NextHopType")]
    pub next_hop_type: String,
}

impl crate::FlatSerialize for CreateRouteEntryNextHopList {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.next_hop_id,
            &format!("{}.NextHopId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.next_hop_type,
            &format!("{}.NextHopType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TableEntry {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "ForwardEntryId")]
    pub forward_entry_id: String,
    #[serde(rename = "InternalIp")]
    pub internal_ip: String,
    #[serde(rename = "InternalPort")]
    pub internal_port: String,
    #[serde(rename = "ForwardTableId")]
    pub forward_table_id: String,
    #[serde(rename = "ExternalPort")]
    pub external_port: String,
    #[serde(rename = "IpProtocol")]
    pub ip_protocol: String,
    #[serde(rename = "ExternalIp")]
    pub external_ip: String,
}

impl crate::FlatSerialize for TableEntry {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.forward_entry_id,
            &format!("{}.ForwardEntryId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internal_ip,
            &format!("{}.InternalIp", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.internal_port,
            &format!("{}.InternalPort", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.forward_table_id,
            &format!("{}.ForwardTableId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.external_port,
            &format!("{}.ExternalPort", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.ip_protocol,
            &format!("{}.IpProtocol", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.external_ip,
            &format!("{}.ExternalIp", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TableEntries {
    #[serde(rename = "ForwardTableEntry")]
    pub forward_table_entry: Vec<TableEntry>,
}

impl crate::FlatSerialize for TableEntries {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.forward_table_entry,
            &format!("{}.ForwardTableEntry", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PointsFilter {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "Value")]
    pub value: Vec<String>,
}

impl crate::FlatSerialize for PointsFilter {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.Value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PointType {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "HostOperator")]
    pub host_operator: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "AttachedRegionNo")]
    pub attached_region_no: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "AccessPointId")]
    pub access_point_id: String,
    #[serde(rename = "Location")]
    pub location: String,
}

impl crate::FlatSerialize for PointType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.host_operator,
            &format!("{}.HostOperator", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.description,
            &format!("{}.Description", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.attached_region_no,
            &format!("{}.AttachedRegionNo", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.name, &format!("{}.Name", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.access_point_id,
            &format!("{}.AccessPointId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.location, &format!("{}.Location", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct PointSet {
    #[serde(rename = "AccessPointType")]
    pub access_point_type: Vec<PointType>,
}

impl crate::FlatSerialize for PointSet {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.access_point_type,
            &format!("{}.AccessPointType", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct NextHop {
    #[serde(rename = "Weight")]
    pub weight: i32,
    #[serde(rename = "NextHopId")]
    pub next_hop_id: String,
    #[serde(rename = "NextHopType")]
    pub next_hop_type: String,
    #[serde(rename = "Enabled")]
    pub enabled: i32,
}

impl crate::FlatSerialize for NextHop {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.weight, &format!("{}.Weight", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.next_hop_id,
            &format!("{}.NextHopId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.next_hop_type,
            &format!("{}.NextHopType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.enabled, &format!("{}.Enabled", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct NextHops {
    #[serde(rename = "NextHop")]
    pub next_hop: Vec<NextHop>,
}

impl crate::FlatSerialize for NextHops {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.next_hop, &format!("{}.NextHop", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RouteEntry {
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "NextHopType")]
    pub next_hop_type: String,
    #[serde(rename = "DestinationCidrBlock")]
    pub destination_cidr_block: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "RouteTableId")]
    pub route_table_id: String,
    #[serde(rename = "NextHops")]
    pub next_hops: NextHops,
}

impl crate::FlatSerialize for RouteEntry {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.r#type, &format!("{}.Type", name), params);
        crate::FlatSerialize::flat_serialize(&self.status, &format!("{}.Status", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.next_hop_type,
            &format!("{}.NextHopType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.destination_cidr_block,
            &format!("{}.DestinationCidrBlock", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.instance_id,
            &format!("{}.InstanceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.route_table_id,
            &format!("{}.RouteTableId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.next_hops,
            &format!("{}.NextHops", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RouteEntrys {
    #[serde(rename = "RouteEntry")]
    pub route_entry: Vec<RouteEntry>,
}

impl crate::FlatSerialize for RouteEntrys {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.route_entry,
            &format!("{}.RouteEntry", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RouteTable {
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "VRouterId")]
    pub v_router_id: String,
    #[serde(rename = "RouteTableId")]
    pub route_table_id: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "RouteTableType")]
    pub route_table_type: String,
    #[serde(rename = "RouteEntrys")]
    pub route_entrys: RouteEntrys,
}

impl crate::FlatSerialize for RouteTable {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.creation_time,
            &format!("{}.CreationTime", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.v_router_id,
            &format!("{}.VRouterId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.route_table_id,
            &format!("{}.RouteTableId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_group_id,
            &format!("{}.ResourceGroupId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.route_table_type,
            &format!("{}.RouteTableType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.route_entrys,
            &format!("{}.RouteEntrys", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RouteTables {
    #[serde(rename = "RouteTable")]
    pub route_table: Vec<RouteTable>,
}

impl crate::FlatSerialize for RouteTables {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.route_table,
            &format!("{}.RouteTable", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct AddTagsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for AddTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ByTagsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for ByTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResourcesResource {
    #[serde(rename = "ResourceType")]
    pub resource_type: String,
    #[serde(rename = "ResourceId")]
    pub resource_id: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
}

impl crate::FlatSerialize for ResourcesResource {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.resource_type,
            &format!("{}.ResourceType", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.resource_id,
            &format!("{}.ResourceId", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.region_id,
            &format!("{}.RegionId", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct ResponseResources {
    #[serde(rename = "Resource")]
    pub resource: Vec<ResourcesResource>,
}

impl crate::FlatSerialize for ResponseResources {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.resource, &format!("{}.Resource", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct DescribeTagsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for DescribeTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TypeCount {
    #[serde(rename = "Instance")]
    pub instance: i32,
    #[serde(rename = "Image")]
    pub image: i32,
    #[serde(rename = "Ddh")]
    pub ddh: i32,
    #[serde(rename = "SnapshotPolicy")]
    pub snapshot_policy: i32,
    #[serde(rename = "Securitygroup")]
    pub securitygroup: i32,
    #[serde(rename = "Snapshot")]
    pub snapshot: i32,
    #[serde(rename = "ReservedInstance")]
    pub reserved_instance: i32,
    #[serde(rename = "LaunchTemplate")]
    pub launch_template: i32,
    #[serde(rename = "Eni")]
    pub eni: i32,
    #[serde(rename = "Disk")]
    pub disk: i32,
    #[serde(rename = "KeyPair")]
    pub key_pair: i32,
    #[serde(rename = "Volume")]
    pub volume: i32,
}

impl crate::FlatSerialize for TypeCount {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.instance, &format!("{}.Instance", name), params);
        crate::FlatSerialize::flat_serialize(&self.image, &format!("{}.Image", name), params);
        crate::FlatSerialize::flat_serialize(&self.ddh, &format!("{}.Ddh", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.snapshot_policy,
            &format!("{}.SnapshotPolicy", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.securitygroup,
            &format!("{}.Securitygroup", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.snapshot, &format!("{}.Snapshot", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.reserved_instance,
            &format!("{}.ReservedInstance", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.launch_template,
            &format!("{}.LaunchTemplate", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.eni, &format!("{}.Eni", name), params);
        crate::FlatSerialize::flat_serialize(&self.disk, &format!("{}.Disk", name), params);
        crate::FlatSerialize::flat_serialize(&self.key_pair, &format!("{}.KeyPair", name), params);
        crate::FlatSerialize::flat_serialize(&self.volume, &format!("{}.Volume", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TagsResponseTagsTag {
    #[serde(rename = "TagValue")]
    pub tag_value: String,
    #[serde(rename = "TagKey")]
    pub tag_key: String,
    #[serde(rename = "ResourceTypeCount")]
    pub resource_type_count: TypeCount,
}

impl crate::FlatSerialize for TagsResponseTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.tag_value,
            &format!("{}.TagValue", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.tag_key, &format!("{}.TagKey", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.resource_type_count,
            &format!("{}.ResourceTypeCount", name),
            params,
        );
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct TagsResponseTags {
    #[serde(rename = "Tag")]
    pub tag: Vec<TagsResponseTagsTag>,
}

impl crate::FlatSerialize for TagsResponseTags {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.tag, &format!("{}.Tag", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct RemoveTagsTag {
    #[serde(rename = "Key")]
    pub key: String,
    #[serde(rename = "value")]
    pub value: String,
}

impl crate::FlatSerialize for RemoveTagsTag {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(&self.key, &format!("{}.Key", name), params);
        crate::FlatSerialize::flat_serialize(&self.value, &format!("{}.value", name), params);
    }
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default)]
pub struct SQoS {
    #[serde(rename = "BandwidthTx")]
    pub bandwidth_tx: i64,
    #[serde(rename = "BandwidthRx")]
    pub bandwidth_rx: i64,
    #[serde(rename = "PpsTx")]
    pub pps_tx: i64,
    #[serde(rename = "PpsRx")]
    pub pps_rx: i64,
    #[serde(rename = "ConcurrentConnections")]
    pub concurrent_connections: i64,
}

impl crate::FlatSerialize for SQoS {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_tx,
            &format!("{}.BandwidthTx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(
            &self.bandwidth_rx,
            &format!("{}.BandwidthRx", name),
            params,
        );
        crate::FlatSerialize::flat_serialize(&self.pps_tx, &format!("{}.PpsTx", name), params);
        crate::FlatSerialize::flat_serialize(&self.pps_rx, &format!("{}.PpsRx", name), params);
        crate::FlatSerialize::flat_serialize(
            &self.concurrent_connections,
            &format!("{}.ConcurrentConnections", name),
            params,
        );
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum SpotStrategy {
    #[serde(rename = "NoSpot")]
    NoSpot,
    #[serde(rename = "SpotWithPriceLimit")]
    SpotWithPriceLimit,
    #[serde(rename = "SpotAsPriceGo")]
    SpotAsPriceGo,
}

impl Default for SpotStrategy {
    fn default() -> Self {
        Self::NoSpot
    }
}

impl SpotStrategy {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::NoSpot => "NoSpot",
            Self::SpotWithPriceLimit => "SpotWithPriceLimit",
            Self::SpotAsPriceGo => "SpotAsPriceGo",
        }
    }
}

impl std::fmt::Display for SpotStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a SpotStrategy> for crate::QueryValue<'a> {
    fn from(value: &'a SpotStrategy) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for SpotStrategy {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum DescribeInstanceTypesInstanceCategory {
    #[serde(rename = "General-purpose")]
    GeneralPurpose,
    #[serde(rename = "Compute-optimized")]
    ComputeOptimized,
    #[serde(rename = "Memory-optimized")]
    MemoryOptimized,
    #[serde(rename = "Big data")]
    BigData,
    #[serde(rename = "Local SSDs")]
    LocalSSDs,
    #[serde(rename = "High Clock Speed")]
    HighClockSpeed,
    #[serde(rename = "Enhanced")]
    Enhanced,
    #[serde(rename = "Shared")]
    Shared,
    #[serde(rename = "Compute-optimized with GPU")]
    ComputeOptimizedWithGPU,
    #[serde(rename = "Visual Compute-optimized")]
    VisualComputeOptimized,
    #[serde(rename = "Heterogeneous Service")]
    HeterogeneousService,
    #[serde(rename = "Compute-optimized with FPGA")]
    ComputeOptimizedWithFPGA,
    #[serde(rename = "Compute-optimized with NPU")]
    ComputeOptimizedWithNPU,
    #[serde(rename = "ECS Bare Metal")]
    ECSBareMetal,
    #[serde(rename = "Super Computing Cluster")]
    SuperComputingCluster,
    #[serde(rename = "High Performance Compute")]
    HighPerformanceCompute,
}

impl Default for DescribeInstanceTypesInstanceCategory {
    fn default() -> Self {
        Self::GeneralPurpose
    }
}

impl DescribeInstanceTypesInstanceCategory {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::GeneralPurpose => "General-purpose",
            Self::ComputeOptimized => "Compute-optimized",
            Self::MemoryOptimized => "Memory-optimized",
            Self::BigData => "Big data",
            Self::LocalSSDs => "Local SSDs",
            Self::HighClockSpeed => "High Clock Speed",
            Self::Enhanced => "Enhanced",
            Self::Shared => "Shared",
            Self::ComputeOptimizedWithGPU => "Compute-optimized with GPU",
            Self::VisualComputeOptimized => "Visual Compute-optimized",
            Self::HeterogeneousService => "Heterogeneous Service",
            Self::ComputeOptimizedWithFPGA => "Compute-optimized with FPGA",
            Self::ComputeOptimizedWithNPU => "Compute-optimized with NPU",
            Self::ECSBareMetal => "ECS Bare Metal",
            Self::SuperComputingCluster => "Super Computing Cluster",
            Self::HighPerformanceCompute => "High Performance Compute",
        }
    }
}

impl std::fmt::Display for DescribeInstanceTypesInstanceCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a DescribeInstanceTypesInstanceCategory> for crate::QueryValue<'a> {
    fn from(value: &'a DescribeInstanceTypesInstanceCategory) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for DescribeInstanceTypesInstanceCategory {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum DescribeInstanceTypesCpuArchitecture {
    #[serde(rename = "X86")]
    X86,
    #[serde(rename = "ARM")]
    ARM,
}

impl Default for DescribeInstanceTypesCpuArchitecture {
    fn default() -> Self {
        Self::X86
    }
}

impl DescribeInstanceTypesCpuArchitecture {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::X86 => "X86",
            Self::ARM => "ARM",
        }
    }
}

impl std::fmt::Display for DescribeInstanceTypesCpuArchitecture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a DescribeInstanceTypesCpuArchitecture> for crate::QueryValue<'a> {
    fn from(value: &'a DescribeInstanceTypesCpuArchitecture) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for DescribeInstanceTypesCpuArchitecture {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum FamilyLevel {
    #[serde(rename = "EntryLevel")]
    EntryLevel,
    #[serde(rename = "EnterpriseLevel")]
    EnterpriseLevel,
    #[serde(rename = "CreditEntryLevel")]
    CreditEntryLevel,
}

impl Default for FamilyLevel {
    fn default() -> Self {
        Self::EntryLevel
    }
}

impl FamilyLevel {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::EntryLevel => "EntryLevel",
            Self::EnterpriseLevel => "EnterpriseLevel",
            Self::CreditEntryLevel => "CreditEntryLevel",
        }
    }
}

impl std::fmt::Display for FamilyLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a FamilyLevel> for crate::QueryValue<'a> {
    fn from(value: &'a FamilyLevel) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for FamilyLevel {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum DescribeInstanceTypesLocalStorageCategory {
    #[serde(rename = "local_hdd_pro")]
    LocalHddPro,
    #[serde(rename = "local_ssd_pro")]
    LocalSsdPro,
}

impl Default for DescribeInstanceTypesLocalStorageCategory {
    fn default() -> Self {
        Self::LocalHddPro
    }
}

impl DescribeInstanceTypesLocalStorageCategory {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::LocalHddPro => "local_hdd_pro",
            Self::LocalSsdPro => "local_ssd_pro",
        }
    }
}

impl std::fmt::Display for DescribeInstanceTypesLocalStorageCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a DescribeInstanceTypesLocalStorageCategory> for crate::QueryValue<'a> {
    fn from(value: &'a DescribeInstanceTypesLocalStorageCategory) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for DescribeInstanceTypesLocalStorageCategory {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum NvmeSupport {
    #[serde(rename = "required")]
    Required,
    #[serde(rename = "unsupported")]
    Unsupported,
}

impl Default for NvmeSupport {
    fn default() -> Self {
        Self::Required
    }
}

impl NvmeSupport {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Required => "required",
            Self::Unsupported => "unsupported",
        }
    }
}

impl std::fmt::Display for NvmeSupport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a NvmeSupport> for crate::QueryValue<'a> {
    fn from(value: &'a NvmeSupport) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for NvmeSupport {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum DescribeInstanceTypesInstanceCategoriesItem {
    #[serde(rename = "General-purpose")]
    GeneralPurpose,
    #[serde(rename = "Compute-optimized")]
    ComputeOptimized,
    #[serde(rename = "Memory-optimized")]
    MemoryOptimized,
    #[serde(rename = "Big data")]
    BigData,
    #[serde(rename = "Local SSDs")]
    LocalSSDs,
    #[serde(rename = "High Clock Speed")]
    HighClockSpeed,
    #[serde(rename = "Enhanced")]
    Enhanced,
    #[serde(rename = "Shared")]
    Shared,
    #[serde(rename = "Compute-optimized with GPU")]
    ComputeOptimizedWithGPU,
    #[serde(rename = "Visual Compute-optimized")]
    VisualComputeOptimized,
    #[serde(rename = "Heterogeneous Service")]
    HeterogeneousService,
    #[serde(rename = "Compute-optimized with FPGA")]
    ComputeOptimizedWithFPGA,
    #[serde(rename = "Compute-optimized with NPU")]
    ComputeOptimizedWithNPU,
    #[serde(rename = "ECS Bare Metal")]
    ECSBareMetal,
    #[serde(rename = "Super Computing Cluster")]
    SuperComputingCluster,
    #[serde(rename = "High Performance Compute")]
    HighPerformanceCompute,
}

impl Default for DescribeInstanceTypesInstanceCategoriesItem {
    fn default() -> Self {
        Self::GeneralPurpose
    }
}

impl DescribeInstanceTypesInstanceCategoriesItem {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::GeneralPurpose => "General-purpose",
            Self::ComputeOptimized => "Compute-optimized",
            Self::MemoryOptimized => "Memory-optimized",
            Self::BigData => "Big data",
            Self::LocalSSDs => "Local SSDs",
            Self::HighClockSpeed => "High Clock Speed",
            Self::Enhanced => "Enhanced",
            Self::Shared => "Shared",
            Self::ComputeOptimizedWithGPU => "Compute-optimized with GPU",
            Self::VisualComputeOptimized => "Visual Compute-optimized",
            Self::HeterogeneousService => "Heterogeneous Service",
            Self::ComputeOptimizedWithFPGA => "Compute-optimized with FPGA",
            Self::ComputeOptimizedWithNPU => "Compute-optimized with NPU",
            Self::ECSBareMetal => "ECS Bare Metal",
            Self::SuperComputingCluster => "Super Computing Cluster",
            Self::HighPerformanceCompute => "High Performance Compute",
        }
    }
}

impl std::fmt::Display for DescribeInstanceTypesInstanceCategoriesItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a DescribeInstanceTypesInstanceCategoriesItem> for crate::QueryValue<'a> {
    fn from(value: &'a DescribeInstanceTypesInstanceCategoriesItem) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for DescribeInstanceTypesInstanceCategoriesItem {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum DescribeInstanceTypesCpuArchitecturesItem {
    #[serde(rename = "X86")]
    X86,
    #[serde(rename = "ARM")]
    ARM,
}

impl Default for DescribeInstanceTypesCpuArchitecturesItem {
    fn default() -> Self {
        Self::X86
    }
}

impl DescribeInstanceTypesCpuArchitecturesItem {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::X86 => "X86",
            Self::ARM => "ARM",
        }
    }
}

impl std::fmt::Display for DescribeInstanceTypesCpuArchitecturesItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a DescribeInstanceTypesCpuArchitecturesItem> for crate::QueryValue<'a> {
    fn from(value: &'a DescribeInstanceTypesCpuArchitecturesItem) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for DescribeInstanceTypesCpuArchitecturesItem {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum DescribeInstanceTypesLocalStorageCategoriesItem {
    #[serde(rename = "local_hdd_pro")]
    LocalHddPro,
    #[serde(rename = "local_ssd_pro")]
    LocalSsdPro,
}

impl Default for DescribeInstanceTypesLocalStorageCategoriesItem {
    fn default() -> Self {
        Self::LocalHddPro
    }
}

impl DescribeInstanceTypesLocalStorageCategoriesItem {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::LocalHddPro => "local_hdd_pro",
            Self::LocalSsdPro => "local_ssd_pro",
        }
    }
}

impl std::fmt::Display for DescribeInstanceTypesLocalStorageCategoriesItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a DescribeInstanceTypesLocalStorageCategoriesItem> for crate::QueryValue<'a> {
    fn from(value: &'a DescribeInstanceTypesLocalStorageCategoriesItem) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for DescribeInstanceTypesLocalStorageCategoriesItem {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum ModifyInstanceSpecModifyMode {
    #[serde(rename = "Online")]
    Online,
    #[serde(rename = "Offline")]
    Offline,
}

impl Default for ModifyInstanceSpecModifyMode {
    fn default() -> Self {
        Self::Online
    }
}

impl ModifyInstanceSpecModifyMode {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Online => "Online",
            Self::Offline => "Offline",
        }
    }
}

impl std::fmt::Display for ModifyInstanceSpecModifyMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a ModifyInstanceSpecModifyMode> for crate::QueryValue<'a> {
    fn from(value: &'a ModifyInstanceSpecModifyMode) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for ModifyInstanceSpecModifyMode {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum PrepayInstanceSpecModifyMode {
    #[serde(rename = "Online")]
    Online,
    #[serde(rename = "Offline")]
    Offline,
}

impl Default for PrepayInstanceSpecModifyMode {
    fn default() -> Self {
        Self::Online
    }
}

impl PrepayInstanceSpecModifyMode {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Online => "Online",
            Self::Offline => "Offline",
        }
    }
}

impl std::fmt::Display for PrepayInstanceSpecModifyMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a PrepayInstanceSpecModifyMode> for crate::QueryValue<'a> {
    fn from(value: &'a PrepayInstanceSpecModifyMode) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for PrepayInstanceSpecModifyMode {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum OptionsRecover {
    #[serde(rename = "All")]
    All,
}

impl Default for OptionsRecover {
    fn default() -> Self {
        Self::All
    }
}

impl OptionsRecover {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::All => "All",
        }
    }
}

impl std::fmt::Display for OptionsRecover {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a OptionsRecover> for crate::QueryValue<'a> {
    fn from(value: &'a OptionsRecover) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for OptionsRecover {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum CategoryCategory {
    #[serde(rename = "Archive")]
    Archive,
}

impl Default for CategoryCategory {
    fn default() -> Self {
        Self::Archive
    }
}

impl CategoryCategory {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Archive => "Archive",
        }
    }
}

impl std::fmt::Display for CategoryCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a CategoryCategory> for crate::QueryValue<'a> {
    fn from(value: &'a CategoryCategory) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for CategoryCategory {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum MetricsResourceType {
    #[serde(rename = "instance")]
    Instance,
}

impl Default for MetricsResourceType {
    fn default() -> Self {
        Self::Instance
    }
}

impl MetricsResourceType {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Instance => "instance",
        }
    }
}

impl std::fmt::Display for MetricsResourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a MetricsResourceType> for crate::QueryValue<'a> {
    fn from(value: &'a MetricsResourceType) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for MetricsResourceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum CreateDiagnosticMetricSetResourceType {
    #[serde(rename = "instance")]
    Instance,
    #[serde(rename = "account")]
    Account,
}

impl Default for CreateDiagnosticMetricSetResourceType {
    fn default() -> Self {
        Self::Instance
    }
}

impl CreateDiagnosticMetricSetResourceType {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Instance => "instance",
            Self::Account => "account",
        }
    }
}

impl std::fmt::Display for CreateDiagnosticMetricSetResourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a CreateDiagnosticMetricSetResourceType> for crate::QueryValue<'a> {
    fn from(value: &'a CreateDiagnosticMetricSetResourceType) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for CreateDiagnosticMetricSetResourceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum SetsType {
    #[serde(rename = "User")]
    User,
    #[serde(rename = "Common")]
    Common,
}

impl Default for SetsType {
    fn default() -> Self {
        Self::User
    }
}

impl SetsType {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::User => "User",
            Self::Common => "Common",
        }
    }
}

impl std::fmt::Display for SetsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a SetsType> for crate::QueryValue<'a> {
    fn from(value: &'a SetsType) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for SetsType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum SetsResourceType {
    #[serde(rename = "instance")]
    Instance,
}

impl Default for SetsResourceType {
    fn default() -> Self {
        Self::Instance
    }
}

impl SetsResourceType {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Instance => "instance",
        }
    }
}

impl std::fmt::Display for SetsResourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a SetsResourceType> for crate::QueryValue<'a> {
    fn from(value: &'a SetsResourceType) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for SetsResourceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum ModifyDiagnosticMetricSetResourceType {
    #[serde(rename = "instance")]
    Instance,
}

impl Default for ModifyDiagnosticMetricSetResourceType {
    fn default() -> Self {
        Self::Instance
    }
}

impl ModifyDiagnosticMetricSetResourceType {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Instance => "instance",
        }
    }
}

impl std::fmt::Display for ModifyDiagnosticMetricSetResourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a ModifyDiagnosticMetricSetResourceType> for crate::QueryValue<'a> {
    fn from(value: &'a ModifyDiagnosticMetricSetResourceType) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for ModifyDiagnosticMetricSetResourceType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum ReportsStatus {
    #[serde(rename = "InProgress")]
    InProgress,
    #[serde(rename = "Finished")]
    Finished,
    #[serde(rename = "Failed")]
    Failed,
    #[serde(rename = "inprogress")]
    Inprogress,
}

impl Default for ReportsStatus {
    fn default() -> Self {
        Self::InProgress
    }
}

impl ReportsStatus {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::InProgress => "InProgress",
            Self::Finished => "Finished",
            Self::Failed => "Failed",
            Self::Inprogress => "inprogress",
        }
    }
}

impl std::fmt::Display for ReportsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a ReportsStatus> for crate::QueryValue<'a> {
    fn from(value: &'a ReportsStatus) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for ReportsStatus {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum ReportsSeverity {
    #[serde(rename = "normal")]
    Normal,
    #[serde(rename = "info")]
    Info,
    #[serde(rename = "warn")]
    Warn,
    #[serde(rename = "critical")]
    Critical,
    #[serde(rename = "unknown")]
    Unknown,
}

impl Default for ReportsSeverity {
    fn default() -> Self {
        Self::Normal
    }
}

impl ReportsSeverity {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Normal => "normal",
            Self::Info => "info",
            Self::Warn => "warn",
            Self::Critical => "critical",
            Self::Unknown => "unknown",
        }
    }
}

impl std::fmt::Display for ReportsSeverity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a ReportsSeverity> for crate::QueryValue<'a> {
    fn from(value: &'a ReportsSeverity) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for ReportsSeverity {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

/// Enum type marshalled as String
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum MigrationType {
    #[serde(rename = "Reboot")]
    Reboot,
    #[serde(rename = "LiveMigrationFirst")]
    LiveMigrationFirst,
}

impl Default for MigrationType {
    fn default() -> Self {
        Self::Reboot
    }
}

impl MigrationType {
    /// Returns the string value of this enum variant as used in the API.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Reboot => "Reboot",
            Self::LiveMigrationFirst => "LiveMigrationFirst",
        }
    }
}

impl std::fmt::Display for MigrationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a MigrationType> for crate::QueryValue<'a> {
    fn from(value: &'a MigrationType) -> Self {
        crate::QueryValue::from(value.as_str())
    }
}

impl crate::FlatSerialize for MigrationType {
    fn flat_serialize<'a>(
        &'a self,
        name: &str,
        params: &mut Vec<(std::borrow::Cow<'static, str>, crate::QueryValue<'a>)>,
    ) {
        params.push((name.to_string().into(), self.into()));
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeRegionsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Regions")]
    pub regions: ResponseRegions,
}

impl crate::ToCodeMessage for DescribeRegionsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeZonesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Zones")]
    pub zones: ResponseZones,
}

impl crate::ToCodeMessage for DescribeZonesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeAvailableResourceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "AvailableZones")]
    pub available_zones: ResourceResponseAvailableZones,
}

impl crate::ToCodeMessage for DescribeAvailableResourceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeAccountAttributesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "AccountAttributeItems")]
    pub account_attribute_items: AttributeItems,
}

impl crate::ToCodeMessage for DescribeAccountAttributesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeResourcesModificationResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "AvailableZones")]
    pub available_zones: ModificationResponseAvailableZones,
}

impl crate::ToCodeMessage for DescribeResourcesModificationResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeRecommendInstanceTypeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Data")]
    pub data: ResponseData,
}

impl crate::ToCodeMessage for DescribeRecommendInstanceTypeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribePriceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PriceInfo")]
    pub price_info: DescribePriceResponsePriceInfo,
}

impl crate::ToCodeMessage for DescribePriceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeRenewalPriceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PriceInfo")]
    pub price_info: RenewalPriceResponsePriceInfo,
}

impl crate::ToCodeMessage for DescribeRenewalPriceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceModificationPriceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PriceInfo")]
    pub price_info: ModificationPriceResponsePriceInfo,
}

impl crate::ToCodeMessage for DescribeInstanceModificationPriceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RunInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "OrderId")]
    pub order_id: String,
    #[serde(rename = "TradePrice")]
    pub trade_price: f32,
    #[serde(rename = "InstanceIdSets")]
    pub instance_id_sets: ResponseInstanceIdSets,
}

impl crate::ToCodeMessage for RunInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateInstanceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "OrderId")]
    pub order_id: String,
    #[serde(rename = "TradePrice")]
    pub trade_price: f32,
}

impl crate::ToCodeMessage for CreateInstanceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct StartInstanceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for StartInstanceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct StartInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "InstanceResponses")]
    pub instance_responses: StartInstancesResponseInstanceResponses,
}

impl crate::ToCodeMessage for StartInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct StopInstanceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for StopInstanceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct StopInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "InstanceResponses")]
    pub instance_responses: StopInstancesResponseInstanceResponses,
}

impl crate::ToCodeMessage for StopInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RebootInstanceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for RebootInstanceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RebootInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "InstanceResponses")]
    pub instance_responses: RebootInstancesResponseInstanceResponses,
}

impl crate::ToCodeMessage for RebootInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteInstanceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteInstanceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceStatusResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "InstanceStatuses")]
    pub instance_statuses: InstanceStatuses,
}

impl crate::ToCodeMessage for DescribeInstanceStatusResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "Instances")]
    pub instances: DescribeInstancesResponseInstances,
}

impl crate::ToCodeMessage for DescribeInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceTypeFamiliesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "InstanceTypeFamilies")]
    pub instance_type_families: ResponseInstanceTypeFamilies,
}

impl crate::ToCodeMessage for DescribeInstanceTypeFamiliesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceTypesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "InstanceTypes")]
    pub instance_types: DescribeInstanceTypesResponseInstanceTypes,
    #[serde(rename = "NextToken")]
    pub next_token: String,
}

impl crate::ToCodeMessage for DescribeInstanceTypesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "SerialNumber")]
    pub serial_number: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "InstanceName")]
    pub instance_name: String,
    #[serde(rename = "InstanceNetworkType")]
    pub instance_network_type: String,
    #[serde(rename = "Memory")]
    pub memory: i32,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "ClusterId")]
    pub cluster_id: String,
    #[serde(rename = "VlanId")]
    pub vlan_id: String,
    #[serde(rename = "StoppedMode")]
    pub stopped_mode: String,
    #[serde(rename = "HostName")]
    pub host_name: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "InstanceType")]
    pub instance_type: String,
    #[serde(rename = "InternetMaxBandwidthIn")]
    pub internet_max_bandwidth_in: i32,
    #[serde(rename = "InternetMaxBandwidthOut")]
    pub internet_max_bandwidth_out: i32,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "InstanceChargeType")]
    pub instance_charge_type: String,
    #[serde(rename = "IoOptimized")]
    pub io_optimized: String,
    #[serde(rename = "Cpu")]
    pub cpu: i32,
    #[serde(rename = "ExpiredTime")]
    pub expired_time: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "InternetChargeType")]
    pub internet_charge_type: String,
    #[serde(rename = "CreditSpecification")]
    pub credit_specification: String,
    #[serde(rename = "SecurityGroupIds")]
    pub security_group_ids: InstanceAttributeResponseSecurityGroupIds,
    #[serde(rename = "PublicIpAddress")]
    pub public_ip_address: ResponsePublicIpAddress,
    #[serde(rename = "InnerIpAddress")]
    pub inner_ip_address: ResponseInnerIpAddress,
    #[serde(rename = "VpcAttributes")]
    pub vpc_attributes: ResponseVpcAttributes,
    #[serde(rename = "EipAddress")]
    pub eip_address: ResponseEipAddress,
    #[serde(rename = "DedicatedHostAttribute")]
    pub dedicated_host_attribute: ResponseDedicatedHostAttribute,
    #[serde(rename = "OperationLocks")]
    pub operation_locks: ResponseOperationLocks,
    #[serde(rename = "EnableJumboFrame")]
    pub enable_jumbo_frame: bool,
    #[serde(rename = "EnableNetworkEncryption")]
    pub enable_network_encryption: bool,
    #[serde(rename = "NetworkOptions")]
    pub network_options: ResponseNetworkOptions,
}

impl crate::ToCodeMessage for DescribeInstanceAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceClockOptionsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TaskId")]
    pub task_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceClockOptionsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceNetworkOptionsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TaskId")]
    pub task_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceNetworkOptionsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceChargeTypeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "OrderId")]
    pub order_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "FeeOfInstances")]
    pub fee_of_instances: InstanceChargeTypeResponseFeeOfInstances,
}

impl crate::ToCodeMessage for ModifyInstanceChargeTypeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceSpecResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceSpecResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyPrepayInstanceSpecResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "OrderId")]
    pub order_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyPrepayInstanceSpecResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceAutoReleaseTimeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceAutoReleaseTimeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AttachInstanceRamRoleResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RamRoleName")]
    pub ram_role_name: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "FailCount")]
    pub fail_count: i32,
    #[serde(rename = "AttachInstanceRamRoleResults")]
    pub attach_instance_ram_role_results: AttachInstanceRamRoleResults,
}

impl crate::ToCodeMessage for AttachInstanceRamRoleResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceRamRoleResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "InstanceRamRoleSets")]
    pub instance_ram_role_sets: ResponseInstanceRamRoleSets,
}

impl crate::ToCodeMessage for DescribeInstanceRamRoleResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DetachInstanceRamRoleResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RamRoleName")]
    pub ram_role_name: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "FailCount")]
    pub fail_count: i32,
    #[serde(rename = "DetachInstanceRamRoleResults")]
    pub detach_instance_ram_role_results: DetachInstanceRamRoleResults,
}

impl crate::ToCodeMessage for DetachInstanceRamRoleResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceVncUrlResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "VncUrl")]
    pub vnc_url: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DescribeInstanceVncUrlResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceVncPasswdResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceVncPasswdResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceMetadataOptionsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceMetadataOptionsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeUserDataResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "UserData")]
    pub user_data: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
}

impl crate::ToCodeMessage for DescribeUserDataResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RenewInstanceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "OrderId")]
    pub order_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for RenewInstanceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceAutoRenewAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "InstanceRenewAttributes")]
    pub instance_renew_attributes: ResponseInstanceRenewAttributes,
}

impl crate::ToCodeMessage for DescribeInstanceAutoRenewAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceAutoRenewAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceAutoRenewAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ReActivateInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ReActivateInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSpotPriceHistoryResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Currency")]
    pub currency: String,
    #[serde(rename = "NextOffset")]
    pub next_offset: i32,
    #[serde(rename = "SpotPrices")]
    pub spot_prices: SpotPrices,
}

impl crate::ToCodeMessage for DescribeSpotPriceHistoryResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSpotAdviceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "AvailableSpotZones")]
    pub available_spot_zones: SpotZones,
}

impl crate::ToCodeMessage for DescribeSpotAdviceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateImageResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateImageResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeImagesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "Images")]
    pub images: ResponseImages,
}

impl crate::ToCodeMessage for DescribeImagesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyImageAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyImageAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteImageResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteImageResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeImageFromFamilyResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Image")]
    pub image: ResponseImage,
}

impl crate::ToCodeMessage for DescribeImageFromFamilyResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeImageSupportInstanceTypesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "InstanceTypes")]
    pub instance_types: SupportInstanceTypesResponseInstanceTypes,
}

impl crate::ToCodeMessage for DescribeImageSupportInstanceTypesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeImageSharePermissionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "ShareGroups")]
    pub share_groups: ShareGroups,
    #[serde(rename = "Accounts")]
    pub accounts: ResponseAccounts,
}

impl crate::ToCodeMessage for DescribeImageSharePermissionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyImageSharePermissionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyImageSharePermissionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyImageShareGroupPermissionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyImageShareGroupPermissionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ImportImageResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "TaskId")]
    pub task_id: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
}

impl crate::ToCodeMessage for ImportImageResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ExportImageResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TaskId")]
    pub task_id: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
}

impl crate::ToCodeMessage for ExportImageResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CopyImageResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "ImageId")]
    pub image_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CopyImageResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CancelCopyImageResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CancelCopyImageResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateImageComponentResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "ImageComponentId")]
    pub image_component_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateImageComponentResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeImageComponentsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "MaxResults")]
    pub max_results: i32,
    #[serde(rename = "ImageComponent")]
    pub image_component: ImageComponent,
}

impl crate::ToCodeMessage for DescribeImageComponentsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteImageComponentResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteImageComponentResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateImagePipelineResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "ImagePipelineId")]
    pub image_pipeline_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateImagePipelineResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeImagePipelinesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "MaxResults")]
    pub max_results: i32,
    #[serde(rename = "ImagePipeline")]
    pub image_pipeline: ImagePipeline,
}

impl crate::ToCodeMessage for DescribeImagePipelinesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteImagePipelineResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteImagePipelineResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct StartImagePipelineExecutionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "ExecutionId")]
    pub execution_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for StartImagePipelineExecutionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeImagePipelineExecutionsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "MaxResults")]
    pub max_results: i32,
    #[serde(rename = "ImagePipelineExecution")]
    pub image_pipeline_execution: PipelineExecution,
}

impl crate::ToCodeMessage for DescribeImagePipelineExecutionsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CancelImagePipelineExecutionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CancelImagePipelineExecutionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateDiskResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "DiskId")]
    pub disk_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "OrderId")]
    pub order_id: String,
}

impl crate::ToCodeMessage for CreateDiskResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDisksResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "Disks")]
    pub disks: ResponseDisks,
}

impl crate::ToCodeMessage for DescribeDisksResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AttachDiskResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for AttachDiskResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DetachDiskResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DetachDiskResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ResizeDiskResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "OrderId")]
    pub order_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ResizeDiskResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDiskAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyDiskAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDiskChargeTypeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "OrderId")]
    pub order_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyDiskChargeTypeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDiskSpecResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TaskId")]
    pub task_id: String,
    #[serde(rename = "OrderId")]
    pub order_id: String,
}

impl crate::ToCodeMessage for ModifyDiskSpecResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ReplaceSystemDiskResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "DiskId")]
    pub disk_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ReplaceSystemDiskResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ResetDiskResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ResetDiskResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ResetDisksResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "OperationProgressSet")]
    pub operation_progress_set: DisksResponseOperationProgressSet,
}

impl crate::ToCodeMessage for ResetDisksResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ReInitDiskResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ReInitDiskResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDiskDeploymentResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TaskId")]
    pub task_id: String,
}

impl crate::ToCodeMessage for ModifyDiskDeploymentResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteDiskResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteDiskResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct EnableDiskEncryptionByDefaultResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for EnableDiskEncryptionByDefaultResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDiskEncryptionByDefaultStatusResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Encrypted")]
    pub encrypted: bool,
}

impl crate::ToCodeMessage for DescribeDiskEncryptionByDefaultStatusResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDiskDefaultKMSKeyIdResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "KMSKeyId")]
    pub kms_key_id: String,
}

impl crate::ToCodeMessage for DescribeDiskDefaultKMSKeyIdResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDiskDefaultKMSKeyIdResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyDiskDefaultKMSKeyIdResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ResetDiskDefaultKMSKeyIdResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ResetDiskDefaultKMSKeyIdResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DisableDiskEncryptionByDefaultResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DisableDiskEncryptionByDefaultResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct OpenSnapshotServiceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for OpenSnapshotServiceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateSnapshotResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateSnapshotResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSnapshotsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "Snapshots")]
    pub snapshots: ResponseSnapshots,
}

impl crate::ToCodeMessage for DescribeSnapshotsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSnapshotsUsageResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "SnapshotSize")]
    pub snapshot_size: i64,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "SnapshotCount")]
    pub snapshot_count: i32,
}

impl crate::ToCodeMessage for DescribeSnapshotsUsageResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifySnapshotAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifySnapshotAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifySnapshotCategoryResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TaskId")]
    pub task_id: String,
}

impl crate::ToCodeMessage for ModifySnapshotCategoryResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CopySnapshotResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "SnapshotId")]
    pub snapshot_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CopySnapshotResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteSnapshotResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteSnapshotResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSnapshotLinksResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "SnapshotLinks")]
    pub snapshot_links: SnapshotLinks,
}

impl crate::ToCodeMessage for DescribeSnapshotLinksResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateSnapshotGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "SnapshotGroupId")]
    pub snapshot_group_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateSnapshotGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSnapshotGroupsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "SnapshotGroups")]
    pub snapshot_groups: SnapshotGroups,
}

impl crate::ToCodeMessage for DescribeSnapshotGroupsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifySnapshotGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifySnapshotGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteSnapshotGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "OperationProgressSet")]
    pub operation_progress_set: GroupResponseOperationProgressSet,
}

impl crate::ToCodeMessage for DeleteSnapshotGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateAutoSnapshotPolicyResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "AutoSnapshotPolicyId")]
    pub auto_snapshot_policy_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateAutoSnapshotPolicyResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeAutoSnapshotPolicyExResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "AutoSnapshotPolicies")]
    pub auto_snapshot_policies: SnapshotPolicies,
}

impl crate::ToCodeMessage for DescribeAutoSnapshotPolicyExResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeAutoSnapshotPolicyAssociationsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "AutoSnapshotPolicyAssociations")]
    pub auto_snapshot_policy_associations: PolicyAssociations,
}

impl crate::ToCodeMessage for DescribeAutoSnapshotPolicyAssociationsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyAutoSnapshotPolicyExResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyAutoSnapshotPolicyExResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ApplyAutoSnapshotPolicyResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ApplyAutoSnapshotPolicyResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CancelAutoSnapshotPolicyResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CancelAutoSnapshotPolicyResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteAutoSnapshotPolicyResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteAutoSnapshotPolicyResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSnapshotPackageResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "SnapshotPackages")]
    pub snapshot_packages: SnapshotPackages,
}

impl crate::ToCodeMessage for DescribeSnapshotPackageResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeBandwidthLimitationResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Bandwidths")]
    pub bandwidths: ResponseBandwidths,
}

impl crate::ToCodeMessage for DescribeBandwidthLimitationResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceNetworkSpecResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "OrderId")]
    pub order_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceNetworkSpecResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AllocatePublicIpAddressResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "IpAddress")]
    pub ip_address: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for AllocatePublicIpAddressResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ConvertNatPublicIpToEipResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ConvertNatPublicIpToEipResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceVpcAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceVpcAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeClassicLinkInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "Links")]
    pub links: ResponseLinks,
}

impl crate::ToCodeMessage for DescribeClassicLinkInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AttachClassicLinkVpcResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for AttachClassicLinkVpcResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DetachClassicLinkVpcResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DetachClassicLinkVpcResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateNetworkInterfaceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "NetworkInterfaceName")]
    pub network_interface_name: String,
    #[serde(rename = "MacAddress")]
    pub mac_address: String,
    #[serde(rename = "NetworkInterfaceId")]
    pub network_interface_id: String,
    #[serde(rename = "ServiceID")]
    pub service_id: i64,
    #[serde(rename = "OwnerId")]
    pub owner_id: String,
    #[serde(rename = "ServiceManaged")]
    pub service_managed: bool,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "PrivateIpAddress")]
    pub private_ip_address: String,
    #[serde(rename = "SecurityGroupIds")]
    pub security_group_ids: InterfaceResponseSecurityGroupIds,
    #[serde(rename = "PrivateIpSets")]
    pub private_ip_sets: InterfaceResponsePrivateIpSets,
    #[serde(rename = "Tags")]
    pub tags: InterfaceResponseTags,
    #[serde(rename = "Ipv6Sets")]
    pub ipv6_sets: InterfaceResponseIpv6Sets,
    #[serde(rename = "Ipv4PrefixSets")]
    pub ipv4_prefix_sets: InterfaceResponseIpv4PrefixSets,
    #[serde(rename = "Ipv6PrefixSets")]
    pub ipv6_prefix_sets: InterfaceResponseIpv6PrefixSets,
    #[serde(rename = "SourceDestCheck")]
    pub source_dest_check: bool,
}

impl crate::ToCodeMessage for CreateNetworkInterfaceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeNetworkInterfacesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "NetworkInterfaceSets")]
    pub network_interface_sets: InterfaceSets,
}

impl crate::ToCodeMessage for DescribeNetworkInterfacesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeNetworkInterfaceAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "Type")]
    pub r#type: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "NetworkInterfaceTrafficMode")]
    pub network_interface_traffic_mode: String,
    #[serde(rename = "NetworkInterfaceName")]
    pub network_interface_name: String,
    #[serde(rename = "MacAddress")]
    pub mac_address: String,
    #[serde(rename = "QueuePairNumber")]
    pub queue_pair_number: i32,
    #[serde(rename = "NetworkInterfaceId")]
    pub network_interface_id: String,
    #[serde(rename = "ServiceID")]
    pub service_id: i64,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "OwnerId")]
    pub owner_id: String,
    #[serde(rename = "ServiceManaged")]
    pub service_managed: bool,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "ResourceGroupId")]
    pub resource_group_id: String,
    #[serde(rename = "ZoneId")]
    pub zone_id: String,
    #[serde(rename = "PrivateIpAddress")]
    pub private_ip_address: String,
    #[serde(rename = "QueueNumber")]
    pub queue_number: i32,
    #[serde(rename = "SecurityGroupIds")]
    pub security_group_ids: InterfaceAttributeResponseSecurityGroupIds,
    #[serde(rename = "AssociatedPublicIp")]
    pub associated_public_ip: ResponseAssociatedPublicIp,
    #[serde(rename = "Attachment")]
    pub attachment: ResponseAttachment,
    #[serde(rename = "PrivateIpSets")]
    pub private_ip_sets: AttributeResponsePrivateIpSets,
    #[serde(rename = "Ipv6Sets")]
    pub ipv6_sets: AttributeResponseIpv6Sets,
    #[serde(rename = "Ipv4PrefixSets")]
    pub ipv4_prefix_sets: AttributeResponseIpv4PrefixSets,
    #[serde(rename = "Ipv6PrefixSets")]
    pub ipv6_prefix_sets: AttributeResponseIpv6PrefixSets,
    #[serde(rename = "Tags")]
    pub tags: AttributeResponseTags,
    #[serde(rename = "BondInterfaceSpecification")]
    pub bond_interface_specification: BondInterfaceSpecification,
    #[serde(rename = "SlaveInterfaceSpecification")]
    pub slave_interface_specification: ResponseSlaveInterfaceSpecification,
    #[serde(rename = "DeleteOnRelease")]
    pub delete_on_release: bool,
    #[serde(rename = "TcpOptionAddressEnabled")]
    pub tcp_option_address_enabled: String,
    #[serde(rename = "NetworkInterfaceTrafficConfig")]
    pub network_interface_traffic_config: ResponseNetworkInterfaceTrafficConfig,
    #[serde(rename = "ConnectionTrackingConfiguration")]
    pub connection_tracking_configuration: ResponseConnectionTrackingConfiguration,
    #[serde(rename = "SourceDestCheck")]
    pub source_dest_check: bool,
    #[serde(rename = "EnhancedNetwork")]
    pub enhanced_network: ResponseEnhancedNetwork,
    #[serde(rename = "QoSConfig")]
    pub qo_s_config: SConfig,
}

impl crate::ToCodeMessage for DescribeNetworkInterfaceAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyNetworkInterfaceAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyNetworkInterfaceAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteNetworkInterfaceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteNetworkInterfaceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AttachNetworkInterfaceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for AttachNetworkInterfaceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DetachNetworkInterfaceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DetachNetworkInterfaceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AssignPrivateIpAddressesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "AssignedPrivateIpAddressesSet")]
    pub assigned_private_ip_addresses_set: AddressesSet,
}

impl crate::ToCodeMessage for AssignPrivateIpAddressesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct UnassignPrivateIpAddressesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for UnassignPrivateIpAddressesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AssignIpv6AddressesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "NetworkInterfaceId")]
    pub network_interface_id: String,
    #[serde(rename = "Ipv6Sets")]
    pub ipv6_sets: AddressesResponseIpv6Sets,
    #[serde(rename = "Ipv6PrefixSets")]
    pub ipv6_prefix_sets: AddressesResponseIpv6PrefixSets,
}

impl crate::ToCodeMessage for AssignIpv6AddressesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct UnassignIpv6AddressesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for UnassignIpv6AddressesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateNetworkInterfacePermissionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "NetworkInterfacePermission")]
    pub network_interface_permission: ResponseNetworkInterfacePermission,
}

impl crate::ToCodeMessage for CreateNetworkInterfacePermissionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeNetworkInterfacePermissionsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "NetworkInterfacePermissions")]
    pub network_interface_permissions: InterfacePermissions,
}

impl crate::ToCodeMessage for DescribeNetworkInterfacePermissionsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreatePrefixListResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PrefixListId")]
    pub prefix_list_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreatePrefixListResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribePrefixListsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PrefixLists")]
    pub prefix_lists: PrefixLists,
}

impl crate::ToCodeMessage for DescribePrefixListsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribePrefixListAttributesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "MaxEntries")]
    pub max_entries: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "AddressFamily")]
    pub address_family: String,
    #[serde(rename = "PrefixListName")]
    pub prefix_list_name: String,
    #[serde(rename = "PrefixListId")]
    pub prefix_list_id: String,
    #[serde(rename = "Entries")]
    pub entries: ResponseEntries,
}

impl crate::ToCodeMessage for DescribePrefixListAttributesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribePrefixListAssociationsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PrefixListAssociations")]
    pub prefix_list_associations: ListAssociations,
}

impl crate::ToCodeMessage for DescribePrefixListAssociationsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyPrefixListResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyPrefixListResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeletePrefixListResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeletePrefixListResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreatePortRangeListResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PortRangeListId")]
    pub port_range_list_id: String,
}

impl crate::ToCodeMessage for CreatePortRangeListResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribePortRangeListsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PortRangeLists")]
    pub port_range_lists: Vec<RangeList>,
}

impl crate::ToCodeMessage for DescribePortRangeListsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribePortRangeListEntriesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Entries")]
    pub entries: Vec<ResponseEntry>,
}

impl crate::ToCodeMessage for DescribePortRangeListEntriesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribePortRangeListAssociationsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "PortRangeListAssociations")]
    pub port_range_list_associations: Vec<RangeListAssociation>,
}

impl crate::ToCodeMessage for DescribePortRangeListAssociationsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyPortRangeListResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyPortRangeListResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeletePortRangeListResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeletePortRangeListResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateSecurityGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateSecurityGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSecurityGroupsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "SecurityGroups")]
    pub security_groups: ResponseSecurityGroups,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
}

impl crate::ToCodeMessage for DescribeSecurityGroupsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSecurityGroupAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "InnerAccessPolicy")]
    pub inner_access_policy: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "SecurityGroupId")]
    pub security_group_id: String,
    #[serde(rename = "SecurityGroupName")]
    pub security_group_name: String,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "Permissions")]
    pub permissions: ResponsePermissions,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "SnapshotPolicyIds")]
    pub snapshot_policy_ids: PolicyIds,
}

impl crate::ToCodeMessage for DescribeSecurityGroupAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifySecurityGroupPolicyResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifySecurityGroupPolicyResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifySecurityGroupAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifySecurityGroupAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteSecurityGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteSecurityGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AuthorizeSecurityGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for AuthorizeSecurityGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifySecurityGroupRuleResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifySecurityGroupRuleResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RevokeSecurityGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for RevokeSecurityGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AuthorizeSecurityGroupEgressResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for AuthorizeSecurityGroupEgressResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifySecurityGroupEgressRuleResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifySecurityGroupEgressRuleResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RevokeSecurityGroupEgressResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for RevokeSecurityGroupEgressResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSecurityGroupReferencesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "SecurityGroupReferences")]
    pub security_group_references: GroupReferences,
}

impl crate::ToCodeMessage for DescribeSecurityGroupReferencesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct JoinSecurityGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for JoinSecurityGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct LeaveSecurityGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for LeaveSecurityGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateKeyPairResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PrivateKeyBody")]
    pub private_key_body: String,
    #[serde(rename = "KeyPairName")]
    pub key_pair_name: String,
    #[serde(rename = "KeyPairId")]
    pub key_pair_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "KeyPairFingerPrint")]
    pub key_pair_finger_print: String,
}

impl crate::ToCodeMessage for CreateKeyPairResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ImportKeyPairResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "KeyPairName")]
    pub key_pair_name: String,
    #[serde(rename = "KeyPairFingerPrint")]
    pub key_pair_finger_print: String,
}

impl crate::ToCodeMessage for ImportKeyPairResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeKeyPairsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "KeyPairs")]
    pub key_pairs: KeyPairs,
}

impl crate::ToCodeMessage for DescribeKeyPairsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AttachKeyPairResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "KeyPairName")]
    pub key_pair_name: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: String,
    #[serde(rename = "FailCount")]
    pub fail_count: String,
    #[serde(rename = "Results")]
    pub results: AttachKeyPairResponseResults,
}

impl crate::ToCodeMessage for AttachKeyPairResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DetachKeyPairResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "KeyPairName")]
    pub key_pair_name: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: String,
    #[serde(rename = "FailCount")]
    pub fail_count: String,
    #[serde(rename = "Results")]
    pub results: DetachKeyPairResponseResults,
}

impl crate::ToCodeMessage for DetachKeyPairResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteKeyPairsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteKeyPairsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateLaunchTemplateResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "LaunchTemplateId")]
    pub launch_template_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "LaunchTemplateVersionNumber")]
    pub launch_template_version_number: i64,
}

impl crate::ToCodeMessage for CreateLaunchTemplateResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeLaunchTemplatesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "LaunchTemplateSets")]
    pub launch_template_sets: TemplateSets,
}

impl crate::ToCodeMessage for DescribeLaunchTemplatesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteLaunchTemplateResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "LaunchTemplateId")]
    pub launch_template_id: String,
    #[serde(rename = "LaunchTemplateVersionNumbers")]
    pub launch_template_version_numbers: VersionNumbers,
}

impl crate::ToCodeMessage for DeleteLaunchTemplateResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateLaunchTemplateVersionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "LaunchTemplateVersionNumber")]
    pub launch_template_version_number: i64,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "LaunchTemplateId")]
    pub launch_template_id: String,
}

impl crate::ToCodeMessage for CreateLaunchTemplateVersionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeLaunchTemplateVersionsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "LaunchTemplateVersionSets")]
    pub launch_template_version_sets: VersionSets,
}

impl crate::ToCodeMessage for DescribeLaunchTemplateVersionsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyLaunchTemplateDefaultVersionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "LaunchTemplateId")]
    pub launch_template_id: String,
}

impl crate::ToCodeMessage for ModifyLaunchTemplateDefaultVersionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteLaunchTemplateVersionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "LaunchTemplateVersions")]
    pub launch_template_versions: TemplateVersions,
}

impl crate::ToCodeMessage for DeleteLaunchTemplateVersionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateAutoProvisioningGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "AutoProvisioningGroupId")]
    pub auto_provisioning_group_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "LaunchResults")]
    pub launch_results: LaunchResults,
}

impl crate::ToCodeMessage for CreateAutoProvisioningGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeAutoProvisioningGroupsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "AutoProvisioningGroups")]
    pub auto_provisioning_groups: ProvisioningGroups,
}

impl crate::ToCodeMessage for DescribeAutoProvisioningGroupsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeAutoProvisioningGroupInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "Instances")]
    pub instances: GroupInstancesResponseInstances,
}

impl crate::ToCodeMessage for DescribeAutoProvisioningGroupInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyAutoProvisioningGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyAutoProvisioningGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeAutoProvisioningGroupHistoryResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "AutoProvisioningGroupHistories")]
    pub auto_provisioning_group_histories: GroupHistories,
}

impl crate::ToCodeMessage for DescribeAutoProvisioningGroupHistoryResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteAutoProvisioningGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteAutoProvisioningGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateDeploymentSetResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "DeploymentSetId")]
    pub deployment_set_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateDeploymentSetResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDeploymentSetSupportedInstanceTypeFamilyResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "InstanceTypeFamilies")]
    pub instance_type_families: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DescribeDeploymentSetSupportedInstanceTypeFamilyResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDeploymentSetsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "DeploymentSets")]
    pub deployment_sets: DeploymentSets,
}

impl crate::ToCodeMessage for DescribeDeploymentSetsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceDeploymentResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceDeploymentResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDeploymentSetAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyDeploymentSetAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteDeploymentSetResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteDeploymentSetResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateElasticityAssuranceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PrivatePoolOptionsId")]
    pub private_pool_options_id: String,
    #[serde(rename = "OrderId")]
    pub order_id: String,
}

impl crate::ToCodeMessage for CreateElasticityAssuranceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeElasticityAssurancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "MaxResults")]
    pub max_results: i32,
    #[serde(rename = "ElasticityAssuranceSet")]
    pub elasticity_assurance_set: AssuranceSet,
}

impl crate::ToCodeMessage for DescribeElasticityAssurancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeElasticityAssuranceInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "MaxResults")]
    pub max_results: i32,
    #[serde(rename = "ElasticityAssuranceItem")]
    pub elasticity_assurance_item: ElasticityAssurance,
}

impl crate::ToCodeMessage for DescribeElasticityAssuranceInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyElasticityAssuranceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyElasticityAssuranceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RenewElasticityAssurancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "OrderId")]
    pub order_id: String,
    #[serde(rename = "PrivatePoolOptionsIdSet")]
    pub private_pool_options_id_set: OptionsIdSet,
}

impl crate::ToCodeMessage for RenewElasticityAssurancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyElasticityAssuranceAutoRenewAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyElasticityAssuranceAutoRenewAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeElasticityAssuranceAutoRenewAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "ElasticityAssuranceRenewAttributes")]
    pub elasticity_assurance_renew_attributes: AssuranceRenewAttributes,
}

impl crate::ToCodeMessage for DescribeElasticityAssuranceAutoRenewAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct PurchaseElasticityAssuranceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for PurchaseElasticityAssuranceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateCapacityReservationResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PrivatePoolOptionsId")]
    pub private_pool_options_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateCapacityReservationResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeCapacityReservationsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "MaxResults")]
    pub max_results: i32,
    #[serde(rename = "CapacityReservationSet")]
    pub capacity_reservation_set: ReservationSet,
}

impl crate::ToCodeMessage for DescribeCapacityReservationsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeCapacityReservationInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "MaxResults")]
    pub max_results: i32,
    #[serde(rename = "CapacityReservationItem")]
    pub capacity_reservation_item: CapacityReservation,
}

impl crate::ToCodeMessage for DescribeCapacityReservationInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyCapacityReservationResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyCapacityReservationResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceAttachmentAttributesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "Instances")]
    pub instances: AttributesResponseInstances,
}

impl crate::ToCodeMessage for DescribeInstanceAttachmentAttributesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceAttachmentAttributesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceAttachmentAttributesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ReleaseCapacityReservationResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ReleaseCapacityReservationResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct PurchaseReservedInstancesOfferingResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "ReservedInstanceIdSets")]
    pub reserved_instance_id_sets: OfferingResponseReservedInstanceIdSets,
    #[serde(rename = "OrderId")]
    pub order_id: String,
}

impl crate::ToCodeMessage for PurchaseReservedInstancesOfferingResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeReservedInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "ReservedInstances")]
    pub reserved_instances: ReservedInstances,
}

impl crate::ToCodeMessage for DescribeReservedInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyReservedInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "ReservedInstanceIdSets")]
    pub reserved_instance_id_sets: ModifyReservedInstancesResponseReservedInstanceIdSets,
}

impl crate::ToCodeMessage for ModifyReservedInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyReservedInstanceAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "HttpStatusCode")]
    pub http_status_code: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyReservedInstanceAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RenewReservedInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "ReservedInstanceIdSets")]
    pub reserved_instance_id_sets: RenewReservedInstancesResponseReservedInstanceIdSets,
    #[serde(rename = "OrderId")]
    pub order_id: String,
}

impl crate::ToCodeMessage for RenewReservedInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeReservedInstanceAutoRenewAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "ReservedInstanceRenewAttributes")]
    pub reserved_instance_renew_attributes: ReservedInstanceRenewAttributes,
}

impl crate::ToCodeMessage for DescribeReservedInstanceAutoRenewAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyReservedInstanceAutoRenewAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyReservedInstanceAutoRenewAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct PurchaseStorageCapacityUnitResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "OrderId")]
    pub order_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "StorageCapacityUnitIds")]
    pub storage_capacity_unit_ids: UnitIds,
}

impl crate::ToCodeMessage for PurchaseStorageCapacityUnitResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeStorageCapacityUnitsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "StorageCapacityUnits")]
    pub storage_capacity_units: CapacityUnits,
}

impl crate::ToCodeMessage for DescribeStorageCapacityUnitsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyStorageCapacityUnitAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyStorageCapacityUnitAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RunCommandResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "CommandId")]
    pub command_id: String,
    #[serde(rename = "InvokeId")]
    pub invoke_id: String,
}

impl crate::ToCodeMessage for RunCommandResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateCommandResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "CommandId")]
    pub command_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateCommandResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct InvokeCommandResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "InvokeId")]
    pub invoke_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for InvokeCommandResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInvocationsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i64,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i64,
    #[serde(rename = "TotalCount")]
    pub total_count: i64,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "Invocations")]
    pub invocations: InvocationsResponseInvocations,
}

impl crate::ToCodeMessage for DescribeInvocationsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInvocationResultsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Invocation")]
    pub invocation: ResponseInvocation,
}

impl crate::ToCodeMessage for DescribeInvocationResultsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInvocationAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "CommandId")]
    pub command_id: String,
}

impl crate::ToCodeMessage for ModifyInvocationAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct StopInvocationResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for StopInvocationResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeCommandsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i64,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i64,
    #[serde(rename = "TotalCount")]
    pub total_count: i64,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "Commands")]
    pub commands: ResponseCommands,
}

impl crate::ToCodeMessage for DescribeCommandsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyCommandResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyCommandResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteCommandResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteCommandResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct SendFileResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "InvokeId")]
    pub invoke_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for SendFileResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSendFileResultsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i64,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i64,
    #[serde(rename = "TotalCount")]
    pub total_count: i64,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "Invocations")]
    pub invocations: ResultsResponseInvocations,
}

impl crate::ToCodeMessage for DescribeSendFileResultsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeCloudAssistantStatusResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i64,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i64,
    #[serde(rename = "TotalCount")]
    pub total_count: i64,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "InstanceCloudAssistantStatusSet")]
    pub instance_cloud_assistant_status_set: AssistantStatusSet,
}

impl crate::ToCodeMessage for DescribeCloudAssistantStatusResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct InstallCloudAssistantResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for InstallCloudAssistantResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct StartTerminalSessionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "SessionId")]
    pub session_id: String,
    #[serde(rename = "SecurityToken")]
    pub security_token: String,
    #[serde(rename = "WebSocketUrl")]
    pub web_socket_url: String,
}

impl crate::ToCodeMessage for StartTerminalSessionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct EndTerminalSessionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for EndTerminalSessionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeTerminalSessionsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "Sessions")]
    pub sessions: ResponseSessions,
}

impl crate::ToCodeMessage for DescribeTerminalSessionsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyCloudAssistantSettingsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyCloudAssistantSettingsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeCloudAssistantSettingsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "OssDeliveryConfigs")]
    pub oss_delivery_configs: OssDeliveryConfigs,
    #[serde(rename = "SlsDeliveryConfigs")]
    pub sls_delivery_configs: SlsDeliveryConfigs,
    #[serde(rename = "AgentUpgradeConfig")]
    pub agent_upgrade_config: ResponseAgentUpgradeConfig,
    #[serde(rename = "SessionManagerConfig")]
    pub session_manager_config: ResponseSessionManagerConfig,
}

impl crate::ToCodeMessage for DescribeCloudAssistantSettingsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateActivationResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "ActivationCode")]
    pub activation_code: String,
    #[serde(rename = "ActivationId")]
    pub activation_id: String,
}

impl crate::ToCodeMessage for CreateActivationResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeActivationsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i64,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i64,
    #[serde(rename = "TotalCount")]
    pub total_count: i64,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "ActivationList")]
    pub activation_list: Vec<ActivationList>,
}

impl crate::ToCodeMessage for DescribeActivationsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DisableActivationResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Activation")]
    pub activation: DisableActivationResponseActivation,
}

impl crate::ToCodeMessage for DisableActivationResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteActivationResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Activation")]
    pub activation: DeleteActivationResponseActivation,
}

impl crate::ToCodeMessage for DeleteActivationResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeManagedInstancesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i64,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i64,
    #[serde(rename = "TotalCount")]
    pub total_count: i64,
    #[serde(rename = "Instances")]
    pub instances: Vec<InstancesResponseInstance>,
    #[serde(rename = "NextToken")]
    pub next_token: String,
}

impl crate::ToCodeMessage for DescribeManagedInstancesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyManagedInstanceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Instance")]
    pub instance: ModifyManagedInstanceResponseInstance,
}

impl crate::ToCodeMessage for ModifyManagedInstanceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeregisterManagedInstanceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Instance")]
    pub instance: DeregisterManagedInstanceResponseInstance,
}

impl crate::ToCodeMessage for DeregisterManagedInstanceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ListPluginStatusResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i64,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i64,
    #[serde(rename = "TotalCount")]
    pub total_count: i64,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "InstancePluginStatusSet")]
    pub instance_plugin_status_set: InstancePluginStatusSet,
}

impl crate::ToCodeMessage for ListPluginStatusResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstancesFullStatusResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "InstanceFullStatusSet")]
    pub instance_full_status_set: InstanceFullStatusSet,
}

impl crate::ToCodeMessage for DescribeInstancesFullStatusResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDisksFullStatusResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "DiskFullStatusSet")]
    pub disk_full_status_set: DiskFullStatusSet,
}

impl crate::ToCodeMessage for DescribeDisksFullStatusResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceHistoryEventsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "InstanceSystemEventSet")]
    pub instance_system_event_set: InstanceSystemEventSet,
    #[serde(rename = "NextToken")]
    pub next_token: String,
}

impl crate::ToCodeMessage for DescribeInstanceHistoryEventsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateSimulatedSystemEventsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "EventIdSet")]
    pub event_id_set: EventIdSet,
}

impl crate::ToCodeMessage for CreateSimulatedSystemEventsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CancelSimulatedSystemEventsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CancelSimulatedSystemEventsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AcceptInquiredSystemEventResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for AcceptInquiredSystemEventResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDiagnosticMetricsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "Metrics")]
    pub metrics: Vec<ResponseMetric>,
}

impl crate::ToCodeMessage for DescribeDiagnosticMetricsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateDiagnosticMetricSetResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "MetricSetId")]
    pub metric_set_id: String,
}

impl crate::ToCodeMessage for CreateDiagnosticMetricSetResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDiagnosticMetricSetsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "MetricSets")]
    pub metric_sets: Vec<MetricSet>,
}

impl crate::ToCodeMessage for DescribeDiagnosticMetricSetsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDiagnosticMetricSetResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyDiagnosticMetricSetResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteDiagnosticMetricSetsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteDiagnosticMetricSetsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateDiagnosticReportResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "ReportId")]
    pub report_id: String,
}

impl crate::ToCodeMessage for CreateDiagnosticReportResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDiagnosticReportsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "Reports")]
    pub reports: ResponseReports,
}

impl crate::ToCodeMessage for DescribeDiagnosticReportsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDiagnosticReportAttributesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "ResourceId")]
    pub resource_id: String,
    #[serde(rename = "ResourceType")]
    pub resource_type: String,
    #[serde(rename = "ReportId")]
    pub report_id: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "FinishedTime")]
    pub finished_time: String,
    #[serde(rename = "StartTime")]
    pub start_time: String,
    #[serde(rename = "EndTime")]
    pub end_time: String,
    #[serde(rename = "Severity")]
    pub severity: String,
    #[serde(rename = "MetricSetId")]
    pub metric_set_id: String,
    #[serde(rename = "MetricResults")]
    pub metric_results: MetricResults,
    #[serde(rename = "Attributes")]
    pub attributes: String,
}

impl crate::ToCodeMessage for DescribeDiagnosticReportAttributesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteDiagnosticReportsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteDiagnosticReportsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct GetInstanceScreenshotResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "Screenshot")]
    pub screenshot: String,
}

impl crate::ToCodeMessage for GetInstanceScreenshotResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct GetInstanceConsoleOutputResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "LastUpdateTime")]
    pub last_update_time: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "InstanceId")]
    pub instance_id: String,
    #[serde(rename = "ConsoleOutput")]
    pub console_output: String,
}

impl crate::ToCodeMessage for GetInstanceConsoleOutputResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDiskMonitorDataResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "MonitorData")]
    pub monitor_data: DiskMonitorDataResponseMonitorData,
}

impl crate::ToCodeMessage for DescribeDiskMonitorDataResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceMonitorDataResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "MonitorData")]
    pub monitor_data: InstanceMonitorDataResponseMonitorData,
}

impl crate::ToCodeMessage for DescribeInstanceMonitorDataResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeEniMonitorDataResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "MonitorData")]
    pub monitor_data: EniMonitorDataResponseMonitorData,
}

impl crate::ToCodeMessage for DescribeEniMonitorDataResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeSnapshotMonitorDataResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "MonitorData")]
    pub monitor_data: SnapshotMonitorDataResponseMonitorData,
}

impl crate::ToCodeMessage for DescribeSnapshotMonitorDataResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeInstanceMaintenanceAttributesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "MaintenanceAttributes")]
    pub maintenance_attributes: MaintenanceAttributes,
}

impl crate::ToCodeMessage for DescribeInstanceMaintenanceAttributesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyInstanceMaintenanceAttributesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyInstanceMaintenanceAttributesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RedeployInstanceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "TaskId")]
    pub task_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for RedeployInstanceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ReportInstancesStatusResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ReportInstancesStatusResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct TagResourcesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for TagResourcesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ListTagResourcesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TagResources")]
    pub tag_resources: ResponseTagResources,
}

impl crate::ToCodeMessage for ListTagResourcesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct UntagResourcesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for UntagResourcesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct JoinResourceGroupResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for JoinResourceGroupResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AllocateDedicatedHostsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "DedicatedHostIdSets")]
    pub dedicated_host_id_sets: HostIdSets,
    #[serde(rename = "OrderId")]
    pub order_id: String,
}

impl crate::ToCodeMessage for AllocateDedicatedHostsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDedicatedHostsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "NextToken")]
    pub next_token: String,
    #[serde(rename = "DedicatedHosts")]
    pub dedicated_hosts: DedicatedHosts,
}

impl crate::ToCodeMessage for DescribeDedicatedHostsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDedicatedHostTypesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "DedicatedHostTypes")]
    pub dedicated_host_types: ResponseDedicatedHostTypes,
}

impl crate::ToCodeMessage for DescribeDedicatedHostTypesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDedicatedHostAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyDedicatedHostAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDedicatedHostsChargeTypeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "OrderId")]
    pub order_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "FeeOfInstances")]
    pub fee_of_instances: HostsChargeTypeResponseFeeOfInstances,
}

impl crate::ToCodeMessage for ModifyDedicatedHostsChargeTypeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDedicatedHostAutoRenewResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "DedicatedHostRenewAttributes")]
    pub dedicated_host_renew_attributes: HostRenewAttributes,
}

impl crate::ToCodeMessage for DescribeDedicatedHostAutoRenewResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDedicatedHostAutoRenewAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyDedicatedHostAutoRenewAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RenewDedicatedHostsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "OrderId")]
    pub order_id: String,
}

impl crate::ToCodeMessage for RenewDedicatedHostsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDedicatedHostAutoReleaseTimeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyDedicatedHostAutoReleaseTimeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RedeployDedicatedHostResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for RedeployDedicatedHostResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ReleaseDedicatedHostResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ReleaseDedicatedHostResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateDedicatedHostClusterResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "DedicatedHostClusterId")]
    pub dedicated_host_cluster_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateDedicatedHostClusterResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyDedicatedHostClusterAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyDedicatedHostClusterAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeDedicatedHostClustersResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "DedicatedHostClusters")]
    pub dedicated_host_clusters: HostClusters,
}

impl crate::ToCodeMessage for DescribeDedicatedHostClustersResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteDedicatedHostClusterResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteDedicatedHostClusterResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateHpcClusterResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "HpcClusterId")]
    pub hpc_cluster_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateHpcClusterResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeHpcClustersResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "HpcClusters")]
    pub hpc_clusters: HpcClusters,
}

impl crate::ToCodeMessage for DescribeHpcClustersResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyHpcClusterAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyHpcClusterAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteHpcClusterResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteHpcClusterResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeTasksResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "TaskSet")]
    pub task_set: TaskSet,
}

impl crate::ToCodeMessage for DescribeTasksResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeTaskAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "CreationTime")]
    pub creation_time: String,
    #[serde(rename = "SupportCancel")]
    pub support_cancel: String,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "SuccessCount")]
    pub success_count: i32,
    #[serde(rename = "RegionId")]
    pub region_id: String,
    #[serde(rename = "TaskAction")]
    pub task_action: String,
    #[serde(rename = "FailedCount")]
    pub failed_count: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "TaskStatus")]
    pub task_status: String,
    #[serde(rename = "TaskProcess")]
    pub task_process: String,
    #[serde(rename = "FinishedTime")]
    pub finished_time: String,
    #[serde(rename = "TaskId")]
    pub task_id: String,
    #[serde(rename = "OperationProgressSet")]
    pub operation_progress_set: AttributeResponseOperationProgressSet,
}

impl crate::ToCodeMessage for DescribeTaskAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CancelTaskResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CancelTaskResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeUserBusinessBehaviorResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "StatusValue")]
    pub status_value: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DescribeUserBusinessBehaviorResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyUserBusinessBehaviorResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyUserBusinessBehaviorResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeLimitationResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "Limitation")]
    pub limitation: String,
    #[serde(rename = "Value")]
    pub value: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DescribeLimitationResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeClustersResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "Clusters")]
    pub clusters: ResponseClusters,
}

impl crate::ToCodeMessage for DescribeClustersResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteNetworkInterfacePermissionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteNetworkInterfacePermissionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteBandwidthPackageResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteBandwidthPackageResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyBandwidthPackageSpecResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyBandwidthPackageSpecResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeBandwidthPackagesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "BandwidthPackages")]
    pub bandwidth_packages: BandwidthPackages,
}

impl crate::ToCodeMessage for DescribeBandwidthPackagesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateVSwitchResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "VSwitchId")]
    pub v_switch_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateVSwitchResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteVSwitchResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteVSwitchResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyVSwitchAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyVSwitchAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeVSwitchesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "VSwitches")]
    pub v_switches: VSwitches,
}

impl crate::ToCodeMessage for DescribeVSwitchesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreatePhysicalConnectionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PhysicalConnectionId")]
    pub physical_connection_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreatePhysicalConnectionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeletePhysicalConnectionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeletePhysicalConnectionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyPhysicalConnectionAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyPhysicalConnectionAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct EnablePhysicalConnectionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for EnablePhysicalConnectionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribePhysicalConnectionsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "PhysicalConnectionSet")]
    pub physical_connection_set: ResponsePhysicalConnectionSet,
}

impl crate::ToCodeMessage for DescribePhysicalConnectionsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CancelPhysicalConnectionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CancelPhysicalConnectionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct TerminatePhysicalConnectionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for TerminatePhysicalConnectionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateVpcResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "VpcId")]
    pub vpc_id: String,
    #[serde(rename = "VRouterId")]
    pub v_router_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "RouteTableId")]
    pub route_table_id: String,
}

impl crate::ToCodeMessage for CreateVpcResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteVpcResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteVpcResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeVpcsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "Vpcs")]
    pub vpcs: ResponseVpcs,
}

impl crate::ToCodeMessage for DescribeVpcsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyVpcAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyVpcAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RemoveBandwidthPackageIpsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for RemoveBandwidthPackageIpsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateHaVipResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "HaVipId")]
    pub ha_vip_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateHaVipResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteHaVipResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteHaVipResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AssociateHaVipResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for AssociateHaVipResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyHaVipAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyHaVipAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeHaVipsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "HaVips")]
    pub ha_vips: HaVips,
}

impl crate::ToCodeMessage for DescribeHaVipsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct UnassociateHaVipResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for UnassociateHaVipResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateVirtualBorderRouterResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "VbrId")]
    pub vbr_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateVirtualBorderRouterResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteVirtualBorderRouterResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteVirtualBorderRouterResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyVirtualBorderRouterAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyVirtualBorderRouterAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RecoverVirtualBorderRouterResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for RecoverVirtualBorderRouterResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct TerminateVirtualBorderRouterResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for TerminateVirtualBorderRouterResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeVirtualBorderRoutersResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "VirtualBorderRouterSet")]
    pub virtual_border_router_set: RouterSet,
}

impl crate::ToCodeMessage for DescribeVirtualBorderRoutersResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "VirtualBorderRouterForPhysicalConnectionSet")]
    pub virtual_border_router_for_physical_connection_set: ForPhysicalConnectionSet,
}

impl crate::ToCodeMessage for DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateRouterInterfaceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "OrderId")]
    pub order_id: i64,
    #[serde(rename = "RouterInterfaceId")]
    pub router_interface_id: String,
}

impl crate::ToCodeMessage for CreateRouterInterfaceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteRouterInterfaceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteRouterInterfaceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ActivateRouterInterfaceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ActivateRouterInterfaceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeactivateRouterInterfaceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeactivateRouterInterfaceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyRouterInterfaceAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyRouterInterfaceAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyRouterInterfaceSpecResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "Spec")]
    pub spec: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyRouterInterfaceSpecResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyVRouterAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyVRouterAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeRouterInterfacesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "RouterInterfaceSet")]
    pub router_interface_set: RouterInterfaceSet,
}

impl crate::ToCodeMessage for DescribeRouterInterfacesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct UnassociateEipAddressResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for UnassociateEipAddressResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AllocateEipAddressResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "AllocationId")]
    pub allocation_id: String,
    #[serde(rename = "EipAddress")]
    pub eip_address: String,
}

impl crate::ToCodeMessage for AllocateEipAddressResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyEipAddressAttributeResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyEipAddressAttributeResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ReleaseEipAddressResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ReleaseEipAddressResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AssociateEipAddressResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for AssociateEipAddressResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeEipAddressesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "EipAddresses")]
    pub eip_addresses: ResponseEipAddresses,
}

impl crate::ToCodeMessage for DescribeEipAddressesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeEipMonitorDataResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "EipMonitorDatas")]
    pub eip_monitor_datas: DescribeEipMonitorDataResponseEipMonitorDatas,
}

impl crate::ToCodeMessage for DescribeEipMonitorDataResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateNatGatewayResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "NatGatewayId")]
    pub nat_gateway_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "ForwardTableIds")]
    pub forward_table_ids: ResponseForwardTableIds,
    #[serde(rename = "BandwidthPackageIds")]
    pub bandwidth_package_ids: ResponseBandwidthPackageIds,
}

impl crate::ToCodeMessage for CreateNatGatewayResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteNatGatewayResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteNatGatewayResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeNatGatewaysResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "NatGateways")]
    pub nat_gateways: NatGateways,
}

impl crate::ToCodeMessage for DescribeNatGatewaysResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeNewProjectEipMonitorDataResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "EipMonitorDatas")]
    pub eip_monitor_datas: ProjectEipMonitorDataResponseEipMonitorDatas,
}

impl crate::ToCodeMessage for DescribeNewProjectEipMonitorDataResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteRouteEntryResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteRouteEntryResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DeleteForwardEntryResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DeleteForwardEntryResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateForwardEntryResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "ForwardEntryId")]
    pub forward_entry_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateForwardEntryResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AddBandwidthPackageIpsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for AddBandwidthPackageIpsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeVRoutersResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "VRouters")]
    pub v_routers: VRouters,
}

impl crate::ToCodeMessage for DescribeVRoutersResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct CreateRouteEntryResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for CreateRouteEntryResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeForwardTableEntriesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "ForwardTableEntries")]
    pub forward_table_entries: TableEntries,
}

impl crate::ToCodeMessage for DescribeForwardTableEntriesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ModifyForwardEntryResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ModifyForwardEntryResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeAccessPointsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "AccessPointSet")]
    pub access_point_set: PointSet,
}

impl crate::ToCodeMessage for DescribeAccessPointsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeRouteTablesResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "RouteTables")]
    pub route_tables: RouteTables,
}

impl crate::ToCodeMessage for DescribeRouteTablesResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ConnectRouterInterfaceResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ConnectRouterInterfaceResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ExportSnapshotResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "TaskId")]
    pub task_id: String,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for ExportSnapshotResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct ReleasePublicIpAddressResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "RemainTimes")]
    pub remain_times: String,
}

impl crate::ToCodeMessage for ReleasePublicIpAddressResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct AddTagsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for AddTagsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeResourceByTagsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "Resources")]
    pub resources: ResponseResources,
}

impl crate::ToCodeMessage for DescribeResourceByTagsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DescribeTagsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
    #[serde(rename = "PageSize")]
    pub page_size: i32,
    #[serde(rename = "PageNumber")]
    pub page_number: i32,
    #[serde(rename = "TotalCount")]
    pub total_count: i32,
    #[serde(rename = "Tags")]
    pub tags: TagsResponseTags,
}

impl crate::ToCodeMessage for DescribeTagsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct RemoveTagsResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for RemoveTagsResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct EnableNetworkInterfaceQoSResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for EnableNetworkInterfaceQoSResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}

#[derive(Debug, Default, serde::Deserialize)]
#[serde(default)]
pub struct DisableNetworkInterfaceQoSResponse {
    #[serde(flatten)]
    pub code_message: crate::CodeMessage,
    #[serde(rename = "RequestId")]
    pub request_id: String,
}

impl crate::ToCodeMessage for DisableNetworkInterfaceQoSResponse {
    fn to_code_message(&self) -> &crate::CodeMessage {
        &self.code_message
    }
}
